/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickAdd
});
module.exports = __toCommonJS(main_exports);
var import_obsidian37 = require("obsidian");

// src/quickAddSettingsTab.ts
var import_obsidian31 = require("obsidian");

// node_modules/.pnpm/svelte@3.59.1/node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function add_flush_callback(fn2) {
  flush_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block5, next3, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block5(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next3);
    lookup.set(block.key, block);
    next3 = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next3 = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance17, create_fragment17, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance17 ? instance17(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment17 ? create_fragment17($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/.pnpm/@fortawesome+free-solid-svg-icons@6.4.0/node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faBars = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"]
};
var faTrash = {
  prefix: "fas",
  iconName: "trash",
  icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"]
};
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
};
var faCog = faGear;
var faBolt = {
  prefix: "fas",
  iconName: "bolt",
  icon: [448, 512, [9889, "zap"], "f0e7", "M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"]
};
var faChevronDown = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
};
var faClone = {
  prefix: "fas",
  iconName: "clone",
  icon: [512, 512, [], "f24d", "M288 448H64V224h64V160H64c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H288c35.3 0 64-28.7 64-64V384H288v64zm-64-96H448c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64H224c-35.3 0-64 28.7-64 64V288c0 35.3 28.7 64 64 64z"]
};

// node_modules/.pnpm/svelte-awesome@3.2.0_svelte@3.59.1/node_modules/svelte-awesome/components/svg/Raw.svelte
function create_fragment(ctx) {
  let g;
  return {
    c() {
      g = svg_element("g");
    },
    m(target, anchor) {
      insert(target, g, anchor);
      g.innerHTML = /*raw*/
      ctx[0];
    },
    p(ctx2, [dirty]) {
      if (dirty & /*raw*/
      1)
        g.innerHTML = /*raw*/
        ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(g);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let cursor = 870711;
  function getId() {
    cursor += 1;
    return `fa-${cursor.toString(16)}`;
  }
  let raw = "";
  let { data } = $$props;
  function getRaw(data2) {
    if (!data2 || !data2.raw) {
      return "";
    }
    let rawData = data2.raw;
    const ids = {};
    rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
      const uniqueId = getId();
      ids[id] = uniqueId;
      return ` id="${uniqueId}"`;
    });
    rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
      const id = rawId || pointerId;
      if (!id || !ids[id]) {
        return match;
      }
      return `#${ids[id]}`;
    });
    return rawData;
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2) {
      $:
        $$invalidate(0, raw = getRaw(data));
    }
  };
  return [raw, data];
}
var Raw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { data: 1 });
  }
};
var Raw_default = Raw;

// node_modules/.pnpm/svelte-awesome@3.2.0_svelte@3.59.1/node_modules/svelte-awesome/components/svg/Svg.svelte
function add_css(target) {
  append_styles(target, "svelte-1mc5hvj", ".fa-icon.svelte-1mc5hvj{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1mc5hvj{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1mc5hvj{transform:scale(1, -1)}.fa-spin.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1mc5hvj{color:#fff}.fa-pulse.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s infinite steps(8)}@keyframes svelte-1mc5hvj-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function create_fragment2(ctx) {
  let svg;
  let svg_class_value;
  let svg_role_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let svg_levels = [
    { version: "1.1" },
    {
      class: svg_class_value = "fa-icon " + /*className*/
      ctx[0]
    },
    { width: (
      /*width*/
      ctx[1]
    ) },
    { height: (
      /*height*/
      ctx[2]
    ) },
    { "aria-label": (
      /*label*/
      ctx[9]
    ) },
    {
      role: svg_role_value = /*label*/
      ctx[9] ? "img" : "presentation"
    },
    { viewBox: (
      /*box*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
      toggle_class(
        svg,
        "fa-spin",
        /*spin*/
        ctx[4]
      );
      toggle_class(
        svg,
        "fa-pulse",
        /*pulse*/
        ctx[6]
      );
      toggle_class(
        svg,
        "fa-inverse",
        /*inverse*/
        ctx[5]
      );
      toggle_class(
        svg,
        "fa-flip-horizontal",
        /*flip*/
        ctx[7] === "horizontal"
      );
      toggle_class(
        svg,
        "fa-flip-vertical",
        /*flip*/
        ctx[7] === "vertical"
      );
      toggle_class(svg, "svelte-1mc5hvj", true);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { version: "1.1" },
        (!current || dirty & /*className*/
        1 && svg_class_value !== (svg_class_value = "fa-icon " + /*className*/
        ctx2[0])) && { class: svg_class_value },
        (!current || dirty & /*width*/
        2) && { width: (
          /*width*/
          ctx2[1]
        ) },
        (!current || dirty & /*height*/
        4) && { height: (
          /*height*/
          ctx2[2]
        ) },
        (!current || dirty & /*label*/
        512) && { "aria-label": (
          /*label*/
          ctx2[9]
        ) },
        (!current || dirty & /*label*/
        512 && svg_role_value !== (svg_role_value = /*label*/
        ctx2[9] ? "img" : "presentation")) && { role: svg_role_value },
        (!current || dirty & /*box*/
        8) && { viewBox: (
          /*box*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        256) && { style: (
          /*style*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(
        svg,
        "fa-spin",
        /*spin*/
        ctx2[4]
      );
      toggle_class(
        svg,
        "fa-pulse",
        /*pulse*/
        ctx2[6]
      );
      toggle_class(
        svg,
        "fa-inverse",
        /*inverse*/
        ctx2[5]
      );
      toggle_class(
        svg,
        "fa-flip-horizontal",
        /*flip*/
        ctx2[7] === "horizontal"
      );
      toggle_class(
        svg,
        "fa-flip-vertical",
        /*flip*/
        ctx2[7] === "vertical"
      );
      toggle_class(svg, "svelte-1mc5hvj", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svg);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "width", "height", "box", "spin", "inverse", "pulse", "flip", "style", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = "" } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { box = "0 0 0 0" } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip: flip2 = "none" } = $$props;
  let { style = "" } = $$props;
  let { label = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("width" in $$new_props)
      $$invalidate(1, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(2, height = $$new_props.height);
    if ("box" in $$new_props)
      $$invalidate(3, box = $$new_props.box);
    if ("spin" in $$new_props)
      $$invalidate(4, spin = $$new_props.spin);
    if ("inverse" in $$new_props)
      $$invalidate(5, inverse = $$new_props.inverse);
    if ("pulse" in $$new_props)
      $$invalidate(6, pulse = $$new_props.pulse);
    if ("flip" in $$new_props)
      $$invalidate(7, flip2 = $$new_props.flip);
    if ("style" in $$new_props)
      $$invalidate(8, style = $$new_props.style);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  return [
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip2,
    style,
    label,
    $$restProps,
    $$scope,
    slots
  ];
}
var Svg = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        class: 0,
        width: 1,
        height: 2,
        box: 3,
        spin: 4,
        inverse: 5,
        pulse: 6,
        flip: 7,
        style: 8,
        label: 9
      },
      add_css
    );
  }
};
var Svg_default = Svg;

// node_modules/.pnpm/svelte-awesome@3.2.0_svelte@3.59.1/node_modules/svelte-awesome/components/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*iconData*/
    ctx[6].paths && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*iconData*/
    ctx[6].polygons && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*iconData*/
    ctx[6].raw && create_if_block_1(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*iconData*/
        ctx2[6].paths
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*iconData*/
        ctx2[6].polygons
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*iconData*/
        ctx2[6].raw
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*iconData*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*iconData*/
    ctx[6].paths
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconData*/
      64) {
        each_value_1 = /*iconData*/
        ctx2[6].paths;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1(ctx) {
  let path;
  let path_levels = [
    /*path*/
    ctx[27]
  ];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  return {
    c() {
      path = svg_element("path");
      set_svg_attributes(path, path_data);
    },
    m(target, anchor) {
      insert(target, path, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [dirty & /*iconData*/
      64 && /*path*/
      ctx2[27]]));
    },
    d(detaching) {
      if (detaching)
        detach(path);
    }
  };
}
function create_if_block_2(ctx) {
  let each_1_anchor;
  let each_value = (
    /*iconData*/
    ctx[6].polygons
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconData*/
      64) {
        each_value = /*iconData*/
        ctx2[6].polygons;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let polygon;
  let polygon_levels = [
    /*polygon*/
    ctx[24]
  ];
  let polygon_data = {};
  for (let i = 0; i < polygon_levels.length; i += 1) {
    polygon_data = assign(polygon_data, polygon_levels[i]);
  }
  return {
    c() {
      polygon = svg_element("polygon");
      set_svg_attributes(polygon, polygon_data);
    },
    m(target, anchor) {
      insert(target, polygon, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [dirty & /*iconData*/
      64 && /*polygon*/
      ctx2[24]]));
    },
    d(detaching) {
      if (detaching)
        detach(polygon);
    }
  };
}
function create_if_block_1(ctx) {
  let raw;
  let updating_data;
  let current;
  function raw_data_binding(value) {
    ctx[16](value);
  }
  let raw_props = {};
  if (
    /*iconData*/
    ctx[6] !== void 0
  ) {
    raw_props.data = /*iconData*/
    ctx[6];
  }
  raw = new Raw_default({ props: raw_props });
  binding_callbacks.push(() => bind(raw, "data", raw_data_binding));
  return {
    c() {
      create_component(raw.$$.fragment);
    },
    m(target, anchor) {
      mount_component(raw, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const raw_changes = {};
      if (!updating_data && dirty & /*iconData*/
      64) {
        updating_data = true;
        raw_changes.data = /*iconData*/
        ctx2[6];
        add_flush_callback(() => updating_data = false);
      }
      raw.$set(raw_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(raw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(raw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(raw, detaching);
    }
  };
}
function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*iconData*/
    ctx[6] && create_if_block(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*iconData*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*iconData*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*iconData*/
        64)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let svg;
  let current;
  const svg_spread_levels = [
    { label: (
      /*label*/
      ctx[5]
    ) },
    { width: (
      /*width*/
      ctx[7]
    ) },
    { height: (
      /*height*/
      ctx[8]
    ) },
    { box: (
      /*box*/
      ctx[10]
    ) },
    { style: (
      /*combinedStyle*/
      ctx[9]
    ) },
    { spin: (
      /*spin*/
      ctx[1]
    ) },
    { flip: (
      /*flip*/
      ctx[4]
    ) },
    { inverse: (
      /*inverse*/
      ctx[2]
    ) },
    { pulse: (
      /*pulse*/
      ctx[3]
    ) },
    { class: (
      /*className*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[11]
  ];
  let svg_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < svg_spread_levels.length; i += 1) {
    svg_props = assign(svg_props, svg_spread_levels[i]);
  }
  svg = new Svg_default({ props: svg_props });
  return {
    c() {
      create_component(svg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const svg_changes = dirty & /*label, width, height, box, combinedStyle, spin, flip, inverse, pulse, className, $$restProps*/
      4031 ? get_spread_update(svg_spread_levels, [
        dirty & /*label*/
        32 && { label: (
          /*label*/
          ctx2[5]
        ) },
        dirty & /*width*/
        128 && { width: (
          /*width*/
          ctx2[7]
        ) },
        dirty & /*height*/
        256 && { height: (
          /*height*/
          ctx2[8]
        ) },
        dirty & /*box*/
        1024 && { box: (
          /*box*/
          ctx2[10]
        ) },
        dirty & /*combinedStyle*/
        512 && { style: (
          /*combinedStyle*/
          ctx2[9]
        ) },
        dirty & /*spin*/
        2 && { spin: (
          /*spin*/
          ctx2[1]
        ) },
        dirty & /*flip*/
        16 && { flip: (
          /*flip*/
          ctx2[4]
        ) },
        dirty & /*inverse*/
        4 && { inverse: (
          /*inverse*/
          ctx2[2]
        ) },
        dirty & /*pulse*/
        8 && { pulse: (
          /*pulse*/
          ctx2[3]
        ) },
        dirty & /*className*/
        1 && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx2[11]
        )
      ]) : {};
      if (dirty & /*$$scope, iconData*/
      131136) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(svg, detaching);
    }
  };
}
var childrenHeight = 0;
var childrenWidth = 0;
var outerScale = 1;
function normaliseData(data) {
  let name;
  let iconData;
  if (!data) {
    return void 0;
  } else if ("definition" in data) {
    console.error("`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead");
    return void 0;
  } else if ("iconName" in data && "icon" in data) {
    name = data.iconName;
    let paths = [];
    const [width, height, , , path] = data.icon;
    if (Array.isArray(path)) {
      paths = path;
    } else {
      paths = [path];
    }
    iconData = {
      width,
      height,
      paths: paths.map((path2) => {
        return { d: path2 };
      })
    };
  } else {
    name = Object.keys(data)[0];
    iconData = data[name];
  }
  return iconData;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "data", "scale", "spin", "inverse", "pulse", "flip", "label", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = "" } = $$props;
  let { data } = $$props;
  let iconData;
  let { scale = 1 } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip: flip2 = void 0 } = $$props;
  let { label = "" } = $$props;
  let { style = "" } = $$props;
  let width = 10;
  let height = 10;
  let combinedStyle;
  let box;
  function normalisedScale() {
    let numScale = 1;
    if (typeof scale !== "undefined") {
      numScale = Number(scale);
    }
    if (isNaN(numScale) || numScale <= 0) {
      console.warn('Invalid prop: prop "scale" should be a number over 0.');
      return outerScale;
    }
    return numScale * outerScale;
  }
  function calculateBox() {
    if (iconData) {
      return `0 0 ${iconData.width} ${iconData.height}`;
    }
    return `0 0 ${width} ${height}`;
  }
  function calculateRatio() {
    if (!iconData) {
      return 1;
    }
    return Math.max(iconData.width, iconData.height) / 16;
  }
  function calculateWidth() {
    if (childrenWidth) {
      return childrenWidth;
    }
    if (iconData) {
      return iconData.width / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateHeight() {
    if (childrenHeight) {
      return childrenHeight;
    }
    if (iconData) {
      return iconData.height / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateStyle() {
    let combined = "";
    if (style !== null) {
      combined += style;
    }
    let size = normalisedScale();
    if (size === 1) {
      if (combined.length === 0) {
        return "";
      }
      return combined;
    }
    if (combined !== "" && !combined.endsWith(";")) {
      combined += "; ";
    }
    return `${combined}font-size: ${size}em`;
  }
  function raw_data_binding(value) {
    iconData = value;
    $$invalidate(6, iconData), $$invalidate(12, data), $$invalidate(14, style), $$invalidate(13, scale);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("data" in $$new_props)
      $$invalidate(12, data = $$new_props.data);
    if ("scale" in $$new_props)
      $$invalidate(13, scale = $$new_props.scale);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("inverse" in $$new_props)
      $$invalidate(2, inverse = $$new_props.inverse);
    if ("pulse" in $$new_props)
      $$invalidate(3, pulse = $$new_props.pulse);
    if ("flip" in $$new_props)
      $$invalidate(4, flip2 = $$new_props.flip);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("style" in $$new_props)
      $$invalidate(14, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data, style, scale*/
    28672) {
      $: {
        $$invalidate(6, iconData = normaliseData(data));
        style;
        scale;
        $$invalidate(7, width = calculateWidth());
        $$invalidate(8, height = calculateHeight());
        $$invalidate(9, combinedStyle = calculateStyle());
        $$invalidate(10, box = calculateBox());
      }
    }
  };
  return [
    className,
    spin,
    inverse,
    pulse,
    flip2,
    label,
    iconData,
    width,
    height,
    combinedStyle,
    box,
    $$restProps,
    data,
    scale,
    style,
    slots,
    raw_data_binding,
    $$scope
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      class: 0,
      data: 12,
      scale: 13,
      spin: 1,
      inverse: 2,
      pulse: 3,
      flip: 4,
      label: 5,
      style: 14
    });
  }
};
var Icon_default = Icon;

// src/gui/choiceList/ChoiceItemRightButtons.svelte
function add_css2(target) {
  append_styles(target, "svelte-a47k80", ".rightButtonsContainer.svelte-a47k80{display:flex;align-items:center;gap:8px}.clickable.svelte-a47k80:hover{cursor:pointer}.alignIconInDivInMiddle.svelte-a47k80{display:flex;align-items:center}");
}
function create_if_block_12(ctx) {
  let div;
  let icon;
  let div_aria_label_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faCog } });
  return {
    c() {
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div, "aria-label", div_aria_label_value = `Configure${/*choiceName*/
      ctx[4] ? " " + /*choiceName*/
      ctx[4] : ""}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*emitConfigureChoice*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*choiceName*/
      16 && div_aria_label_value !== (div_aria_label_value = `Configure${/*choiceName*/
      ctx2[4] ? " " + /*choiceName*/
      ctx2[4] : ""}`)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let icon;
  let div_aria_label_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faClone } });
  return {
    c() {
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "aria-label", div_aria_label_value = `Duplicate ${/*choiceName*/
      ctx[4] ?? ""}`);
      attr(div, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*emitDuplicateChoice*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*choiceName*/
      16 && div_aria_label_value !== (div_aria_label_value = `Duplicate ${/*choiceName*/
      ctx2[4] ?? ""}`)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let div3;
  let div0;
  let icon0;
  let div0_aria_label_value;
  let div0_style_value;
  let t0;
  let t1;
  let t2;
  let div1;
  let icon1;
  let div1_aria_label_value;
  let t3;
  let div2;
  let icon2;
  let div2_tabindex_value;
  let div2_style_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faBolt } });
  let if_block0 = (
    /*showConfigureButton*/
    ctx[1] && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*showDuplicateButton*/
    ctx[2] && create_if_block2(ctx)
  );
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t3 = space();
      div2 = element("div");
      create_component(icon2.$$.fragment);
      attr(div0, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div0, "aria-label", div0_aria_label_value = `${/*commandEnabled*/
      ctx[3] ? "Remove" : "Add"} command${/*choiceName*/
      ctx[4] ? " for " + /*choiceName*/
      ctx[4] : ""}`);
      attr(div0, "style", div0_style_value = /*commandEnabled*/
      ctx[3] ? "color: #FDD023;" : "");
      attr(div1, "aria-label", div1_aria_label_value = `Delete${/*choiceName*/
      ctx[4] ? " " + /*choiceName*/
      ctx[4] : ""}`);
      attr(div1, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div2, "tabindex", div2_tabindex_value = /*dragDisabled*/
      ctx[0] ? 0 : -1);
      attr(div2, "aria-label", "Drag-handle");
      attr(div2, "style", div2_style_value = /*dragDisabled*/
      (ctx[0] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(div2, "class", "alignIconInDivInMiddle svelte-a47k80");
      attr(div3, "class", "rightButtonsContainer svelte-a47k80");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(icon0, div0, null);
      append(div3, t0);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t1);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t2);
      append(div3, div1);
      mount_component(icon1, div1, null);
      append(div3, t3);
      append(div3, div2);
      mount_component(icon2, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*emitToggleCommand*/
            ctx[7]
          ),
          listen(
            div1,
            "click",
            /*emitDeleteChoice*/
            ctx[5]
          ),
          listen(
            div2,
            "mousedown",
            /*mousedown_handler*/
            ctx[9]
          ),
          listen(
            div2,
            "touchstart",
            /*touchstart_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*commandEnabled, choiceName*/
      24 && div0_aria_label_value !== (div0_aria_label_value = `${/*commandEnabled*/
      ctx2[3] ? "Remove" : "Add"} command${/*choiceName*/
      ctx2[4] ? " for " + /*choiceName*/
      ctx2[4] : ""}`)) {
        attr(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty & /*commandEnabled*/
      8 && div0_style_value !== (div0_style_value = /*commandEnabled*/
      ctx2[3] ? "color: #FDD023;" : "")) {
        attr(div0, "style", div0_style_value);
      }
      if (
        /*showConfigureButton*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showConfigureButton*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showDuplicateButton*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showDuplicateButton*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*choiceName*/
      16 && div1_aria_label_value !== (div1_aria_label_value = `Delete${/*choiceName*/
      ctx2[4] ? " " + /*choiceName*/
      ctx2[4] : ""}`)) {
        attr(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty & /*dragDisabled*/
      1 && div2_tabindex_value !== (div2_tabindex_value = /*dragDisabled*/
      ctx2[0] ? 0 : -1)) {
        attr(div2, "tabindex", div2_tabindex_value);
      }
      if (!current || dirty & /*dragDisabled*/
      1 && div2_style_value !== (div2_style_value = /*dragDisabled*/
      (ctx2[0] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(div2, "style", div2_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(icon0);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { dragDisabled } = $$props;
  let { showConfigureButton = true } = $$props;
  let { showDuplicateButton = true } = $$props;
  let { commandEnabled = false } = $$props;
  let { choiceName = "" } = $$props;
  const dispatcher = createEventDispatcher();
  function emitDeleteChoice() {
    dispatcher("deleteChoice");
  }
  function emitConfigureChoice() {
    dispatcher("configureChoice");
  }
  function emitToggleCommand() {
    dispatcher("toggleCommand");
  }
  function emitDuplicateChoice() {
    dispatcher("duplicateChoice");
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dragDisabled" in $$props2)
      $$invalidate(0, dragDisabled = $$props2.dragDisabled);
    if ("showConfigureButton" in $$props2)
      $$invalidate(1, showConfigureButton = $$props2.showConfigureButton);
    if ("showDuplicateButton" in $$props2)
      $$invalidate(2, showDuplicateButton = $$props2.showDuplicateButton);
    if ("commandEnabled" in $$props2)
      $$invalidate(3, commandEnabled = $$props2.commandEnabled);
    if ("choiceName" in $$props2)
      $$invalidate(4, choiceName = $$props2.choiceName);
  };
  return [
    dragDisabled,
    showConfigureButton,
    showDuplicateButton,
    commandEnabled,
    choiceName,
    emitDeleteChoice,
    emitConfigureChoice,
    emitToggleCommand,
    emitDuplicateChoice,
    mousedown_handler,
    touchstart_handler
  ];
}
var ChoiceItemRightButtons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        dragDisabled: 0,
        showConfigureButton: 1,
        showDuplicateButton: 2,
        commandEnabled: 3,
        choiceName: 4
      },
      add_css2
    );
  }
};
var ChoiceItemRightButtons_default = ChoiceItemRightButtons;

// src/gui/choiceList/ChoiceListItem.svelte
var import_obsidian = require("obsidian");
function create_fragment5(ctx) {
  let div;
  let span;
  let t;
  let rightbuttons;
  let updating_choiceName;
  let updating_commandEnabled;
  let updating_showConfigureButton;
  let updating_dragDisabled;
  let current;
  function rightbuttons_choiceName_binding(value) {
    ctx[9](value);
  }
  function rightbuttons_commandEnabled_binding(value) {
    ctx[10](value);
  }
  function rightbuttons_showConfigureButton_binding(value) {
    ctx[11](value);
  }
  function rightbuttons_dragDisabled_binding(value) {
    ctx[12](value);
  }
  let rightbuttons_props = { showDuplicateButton: true };
  if (
    /*choice*/
    ctx[0].name !== void 0
  ) {
    rightbuttons_props.choiceName = /*choice*/
    ctx[0].name;
  }
  if (
    /*choice*/
    ctx[0].command !== void 0
  ) {
    rightbuttons_props.commandEnabled = /*choice*/
    ctx[0].command;
  }
  if (
    /*showConfigureButton*/
    ctx[3] !== void 0
  ) {
    rightbuttons_props.showConfigureButton = /*showConfigureButton*/
    ctx[3];
  }
  if (
    /*dragDisabled*/
    ctx[1] !== void 0
  ) {
    rightbuttons_props.dragDisabled = /*dragDisabled*/
    ctx[1];
  }
  rightbuttons = new ChoiceItemRightButtons_default({ props: rightbuttons_props });
  binding_callbacks.push(() => bind(rightbuttons, "choiceName", rightbuttons_choiceName_binding));
  binding_callbacks.push(() => bind(rightbuttons, "commandEnabled", rightbuttons_commandEnabled_binding));
  binding_callbacks.push(() => bind(rightbuttons, "showConfigureButton", rightbuttons_showConfigureButton_binding));
  binding_callbacks.push(() => bind(rightbuttons, "dragDisabled", rightbuttons_dragDisabled_binding));
  rightbuttons.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[13]
  );
  rightbuttons.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[14]
  );
  rightbuttons.$on(
    "deleteChoice",
    /*deleteChoice*/
    ctx[4]
  );
  rightbuttons.$on(
    "configureChoice",
    /*configureChoice*/
    ctx[5]
  );
  rightbuttons.$on(
    "toggleCommand",
    /*toggleCommandForChoice*/
    ctx[6]
  );
  rightbuttons.$on(
    "duplicateChoice",
    /*duplicateChoice*/
    ctx[7]
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      t = space();
      create_component(rightbuttons.$$.fragment);
      attr(span, "class", "choiceListItemName");
      attr(div, "class", "choiceListItem");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      ctx[8](span);
      append(div, t);
      mount_component(rightbuttons, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rightbuttons_changes = {};
      if (!updating_choiceName && dirty & /*choice*/
      1) {
        updating_choiceName = true;
        rightbuttons_changes.choiceName = /*choice*/
        ctx2[0].name;
        add_flush_callback(() => updating_choiceName = false);
      }
      if (!updating_commandEnabled && dirty & /*choice*/
      1) {
        updating_commandEnabled = true;
        rightbuttons_changes.commandEnabled = /*choice*/
        ctx2[0].command;
        add_flush_callback(() => updating_commandEnabled = false);
      }
      if (!updating_showConfigureButton && dirty & /*showConfigureButton*/
      8) {
        updating_showConfigureButton = true;
        rightbuttons_changes.showConfigureButton = /*showConfigureButton*/
        ctx2[3];
        add_flush_callback(() => updating_showConfigureButton = false);
      }
      if (!updating_dragDisabled && dirty & /*dragDisabled*/
      2) {
        updating_dragDisabled = true;
        rightbuttons_changes.dragDisabled = /*dragDisabled*/
        ctx2[1];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      rightbuttons.$set(rightbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rightbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rightbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[8](null);
      destroy_component(rightbuttons);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { choice } = $$props;
  let { dragDisabled } = $$props;
  let showConfigureButton = true;
  const dispatcher = createEventDispatcher();
  function deleteChoice() {
    dispatcher("deleteChoice", { choice });
  }
  function configureChoice() {
    dispatcher("configureChoice", { choice });
  }
  function toggleCommandForChoice() {
    dispatcher("toggleCommand", { choice });
  }
  function duplicateChoice() {
    dispatcher("duplicateChoice", { choice });
  }
  const cmp = new import_obsidian.Component();
  let nameElement;
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nameElement = $$value;
      $$invalidate(2, nameElement), $$invalidate(0, choice);
    });
  }
  function rightbuttons_choiceName_binding(value) {
    if ($$self.$$.not_equal(choice.name, value)) {
      choice.name = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_commandEnabled_binding(value) {
    if ($$self.$$.not_equal(choice.command, value)) {
      choice.command = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_showConfigureButton_binding(value) {
    showConfigureButton = value;
    $$invalidate(3, showConfigureButton);
  }
  function rightbuttons_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(1, dragDisabled);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choice" in $$props2)
      $$invalidate(0, choice = $$props2.choice);
    if ("dragDisabled" in $$props2)
      $$invalidate(1, dragDisabled = $$props2.dragDisabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*nameElement, choice*/
    5) {
      $: {
        if (nameElement) {
          $$invalidate(2, nameElement.innerHTML = "", nameElement);
          const nameHTML = (0, import_obsidian.htmlToMarkdown)(choice.name);
          import_obsidian.MarkdownRenderer.renderMarkdown(nameHTML, nameElement, "/", cmp);
        }
      }
    }
  };
  return [
    choice,
    dragDisabled,
    nameElement,
    showConfigureButton,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    duplicateChoice,
    span_binding,
    rightbuttons_choiceName_binding,
    rightbuttons_commandEnabled_binding,
    rightbuttons_showConfigureButton_binding,
    rightbuttons_dragDisabled_binding,
    mousedown_handler,
    touchstart_handler
  ];
}
var ChoiceListItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { choice: 0, dragDisabled: 1 });
  }
};
var ChoiceListItem_default = ChoiceListItem;

// src/gui/choiceList/MultiChoiceListItem.svelte
var import_obsidian2 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-na99np", ".multiChoiceListItem.svelte-na99np{display:flex;font-size:16px;align-items:center;margin:12px 0 0 0}.clickable.svelte-na99np:hover{cursor:pointer}.multiChoiceListItemName.svelte-na99np{flex:1 0 0;margin-left:5px}.nestedChoiceList.svelte-na99np{padding-left:25px}");
}
function create_if_block3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*choice*/
  ctx[0].collapsed && create_if_block_13(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*choice*/
      ctx2[0].collapsed) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*choice*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  let choicelist;
  let updating_multiChoice;
  let updating_choices;
  let current;
  function choicelist_multiChoice_binding(value) {
    ctx[17](value);
  }
  function choicelist_choices_binding(value) {
    ctx[18](value);
  }
  let choicelist_props = {};
  if (
    /*choice*/
    ctx[0] !== void 0
  ) {
    choicelist_props.multiChoice = /*choice*/
    ctx[0];
  }
  if (
    /*choice*/
    ctx[0].choices !== void 0
  ) {
    choicelist_props.choices = /*choice*/
    ctx[0].choices;
  }
  choicelist = new ChoiceList_default({ props: choicelist_props });
  binding_callbacks.push(() => bind(choicelist, "multiChoice", choicelist_multiChoice_binding));
  binding_callbacks.push(() => bind(choicelist, "choices", choicelist_choices_binding));
  choicelist.$on(
    "deleteChoice",
    /*deleteChoice_handler*/
    ctx[19]
  );
  choicelist.$on(
    "configureChoice",
    /*configureChoice_handler*/
    ctx[20]
  );
  choicelist.$on(
    "toggleCommand",
    /*toggleCommand_handler*/
    ctx[21]
  );
  choicelist.$on(
    "duplicateChoice",
    /*duplicateChoice_handler*/
    ctx[22]
  );
  return {
    c() {
      div = element("div");
      create_component(choicelist.$$.fragment);
      attr(div, "class", "nestedChoiceList svelte-na99np");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(choicelist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const choicelist_changes = {};
      if (!updating_multiChoice && dirty & /*choice*/
      1) {
        updating_multiChoice = true;
        choicelist_changes.multiChoice = /*choice*/
        ctx2[0];
        add_flush_callback(() => updating_multiChoice = false);
      }
      if (!updating_choices && dirty & /*choice*/
      1) {
        updating_choices = true;
        choicelist_changes.choices = /*choice*/
        ctx2[0].choices;
        add_flush_callback(() => updating_choices = false);
      }
      choicelist.$set(choicelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(choicelist);
    }
  };
}
function create_fragment6(ctx) {
  let div2;
  let div1;
  let div0;
  let icon;
  let t0;
  let span;
  let t1;
  let rightbuttons;
  let updating_showConfigureButton;
  let updating_dragDisabled;
  let updating_choiceName;
  let updating_commandEnabled;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      data: faChevronDown,
      style: `transform:rotate(${/*choice*/
      ctx[0].collapsed ? -180 : 0}deg)`
    }
  });
  function rightbuttons_showConfigureButton_binding(value) {
    ctx[11](value);
  }
  function rightbuttons_dragDisabled_binding(value) {
    ctx[12](value);
  }
  function rightbuttons_choiceName_binding(value) {
    ctx[13](value);
  }
  function rightbuttons_commandEnabled_binding(value) {
    ctx[14](value);
  }
  let rightbuttons_props = { showDuplicateButton: true };
  if (
    /*showConfigureButton*/
    ctx[4] !== void 0
  ) {
    rightbuttons_props.showConfigureButton = /*showConfigureButton*/
    ctx[4];
  }
  if (
    /*dragDisabled*/
    ctx[1] !== void 0
  ) {
    rightbuttons_props.dragDisabled = /*dragDisabled*/
    ctx[1];
  }
  if (
    /*choice*/
    ctx[0].name !== void 0
  ) {
    rightbuttons_props.choiceName = /*choice*/
    ctx[0].name;
  }
  if (
    /*choice*/
    ctx[0].command !== void 0
  ) {
    rightbuttons_props.commandEnabled = /*choice*/
    ctx[0].command;
  }
  rightbuttons = new ChoiceItemRightButtons_default({ props: rightbuttons_props });
  binding_callbacks.push(() => bind(rightbuttons, "showConfigureButton", rightbuttons_showConfigureButton_binding));
  binding_callbacks.push(() => bind(rightbuttons, "dragDisabled", rightbuttons_dragDisabled_binding));
  binding_callbacks.push(() => bind(rightbuttons, "choiceName", rightbuttons_choiceName_binding));
  binding_callbacks.push(() => bind(rightbuttons, "commandEnabled", rightbuttons_commandEnabled_binding));
  rightbuttons.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[15]
  );
  rightbuttons.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[16]
  );
  rightbuttons.$on(
    "deleteChoice",
    /*deleteChoice*/
    ctx[5]
  );
  rightbuttons.$on(
    "configureChoice",
    /*configureChoice*/
    ctx[6]
  );
  rightbuttons.$on(
    "toggleCommand",
    /*toggleCommandForChoice*/
    ctx[7]
  );
  rightbuttons.$on(
    "duplicateChoice",
    /*duplicateChoice*/
    ctx[8]
  );
  let if_block = (!/*collapseId*/
  ctx[2] || /*collapseId*/
  ctx[2] && /*choice*/
  ctx[0].id !== /*collapseId*/
  ctx[2]) && create_if_block3(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = space();
      create_component(rightbuttons.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "choiceListItemName");
      attr(div0, "class", "multiChoiceListItemName clickable svelte-na99np");
      attr(div1, "class", "multiChoiceListItem svelte-na99np");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(icon, div0, null);
      append(div0, t0);
      append(div0, span);
      ctx[9](span);
      append(div1, t1);
      mount_component(rightbuttons, div1, null);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*click_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const icon_changes = {};
      if (dirty & /*choice*/
      1)
        icon_changes.style = `transform:rotate(${/*choice*/
        ctx2[0].collapsed ? -180 : 0}deg)`;
      icon.$set(icon_changes);
      const rightbuttons_changes = {};
      if (!updating_showConfigureButton && dirty & /*showConfigureButton*/
      16) {
        updating_showConfigureButton = true;
        rightbuttons_changes.showConfigureButton = /*showConfigureButton*/
        ctx2[4];
        add_flush_callback(() => updating_showConfigureButton = false);
      }
      if (!updating_dragDisabled && dirty & /*dragDisabled*/
      2) {
        updating_dragDisabled = true;
        rightbuttons_changes.dragDisabled = /*dragDisabled*/
        ctx2[1];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_choiceName && dirty & /*choice*/
      1) {
        updating_choiceName = true;
        rightbuttons_changes.choiceName = /*choice*/
        ctx2[0].name;
        add_flush_callback(() => updating_choiceName = false);
      }
      if (!updating_commandEnabled && dirty & /*choice*/
      1) {
        updating_commandEnabled = true;
        rightbuttons_changes.commandEnabled = /*choice*/
        ctx2[0].command;
        add_flush_callback(() => updating_commandEnabled = false);
      }
      rightbuttons.$set(rightbuttons_changes);
      if (!/*collapseId*/
      ctx2[2] || /*collapseId*/
      ctx2[2] && /*choice*/
      ctx2[0].id !== /*collapseId*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*collapseId, choice*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(rightbuttons.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(rightbuttons.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(icon);
      ctx[9](null);
      destroy_component(rightbuttons);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { choice } = $$props;
  let { collapseId } = $$props;
  let { dragDisabled } = $$props;
  let showConfigureButton = true;
  const dispatcher = createEventDispatcher();
  function deleteChoice(e) {
    dispatcher("deleteChoice", { choice });
  }
  function configureChoice() {
    dispatcher("configureChoice", { choice });
  }
  function toggleCommandForChoice() {
    dispatcher("toggleCommand", { choice });
  }
  function duplicateChoice() {
    dispatcher("duplicateChoice", { choice });
  }
  const cmp = new import_obsidian2.Component();
  let nameElement;
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nameElement = $$value;
      $$invalidate(3, nameElement), $$invalidate(0, choice);
    });
  }
  const click_handler = () => $$invalidate(0, choice.collapsed = !choice.collapsed, choice);
  function rightbuttons_showConfigureButton_binding(value) {
    showConfigureButton = value;
    $$invalidate(4, showConfigureButton);
  }
  function rightbuttons_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(1, dragDisabled);
  }
  function rightbuttons_choiceName_binding(value) {
    if ($$self.$$.not_equal(choice.name, value)) {
      choice.name = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_commandEnabled_binding(value) {
    if ($$self.$$.not_equal(choice.command, value)) {
      choice.command = value;
      $$invalidate(0, choice);
    }
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function choicelist_multiChoice_binding(value) {
    choice = value;
    $$invalidate(0, choice);
  }
  function choicelist_choices_binding(value) {
    if ($$self.$$.not_equal(choice.choices, value)) {
      choice.choices = value;
      $$invalidate(0, choice);
    }
  }
  function deleteChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choice" in $$props2)
      $$invalidate(0, choice = $$props2.choice);
    if ("collapseId" in $$props2)
      $$invalidate(2, collapseId = $$props2.collapseId);
    if ("dragDisabled" in $$props2)
      $$invalidate(1, dragDisabled = $$props2.dragDisabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*nameElement, choice*/
    9) {
      $: {
        if (nameElement) {
          $$invalidate(3, nameElement.innerHTML = "", nameElement);
          const nameHTML = (0, import_obsidian2.htmlToMarkdown)(choice.name);
          import_obsidian2.MarkdownRenderer.renderMarkdown(nameHTML, nameElement, "/", cmp);
        }
      }
    }
  };
  return [
    choice,
    dragDisabled,
    collapseId,
    nameElement,
    showConfigureButton,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    duplicateChoice,
    span_binding,
    click_handler,
    rightbuttons_showConfigureButton_binding,
    rightbuttons_dragDisabled_binding,
    rightbuttons_choiceName_binding,
    rightbuttons_commandEnabled_binding,
    mousedown_handler,
    touchstart_handler,
    choicelist_multiChoice_binding,
    choicelist_choices_binding,
    deleteChoice_handler,
    configureChoice_handler,
    toggleCommand_handler,
    duplicateChoice_handler
  ];
}
var MultiChoiceListItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        choice: 0,
        collapseId: 2,
        dragDisabled: 1
      },
      add_css3
    );
  }
};
var MultiChoiceListItem_default = MultiChoiceListItem;

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/dispatcher.js
var FINALIZE_EVENT_NAME = "finalize";
var CONSIDER_EVENT_NAME = "consider";
function dispatchFinalizeEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(FINALIZE_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
function dispatchConsiderEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(CONSIDER_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
var DRAGGED_ENTERED_EVENT_NAME = "draggedEntered";
var DRAGGED_LEFT_EVENT_NAME = "draggedLeft";
var DRAGGED_OVER_INDEX_EVENT_NAME = "draggedOverIndex";
var DRAGGED_LEFT_DOCUMENT_EVENT_NAME = "draggedLeftDocument";
var DRAGGED_LEFT_TYPES = {
  LEFT_FOR_ANOTHER: "leftForAnother",
  OUTSIDE_OF_ANY: "outsideOfAny"
};
function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl2, theOtherDz) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz }
    })
  );
}
function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY }
    })
  );
}
function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
function dispatchDraggedLeftDocument(draggedEl2) {
  window.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2 }
    })
  );
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/constants.js
var TRIGGERS = {
  DRAG_STARTED: "dragStarted",
  DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,
  DRAGGED_ENTERED_ANOTHER: "dragEnteredAnother",
  DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,
  DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,
  DRAGGED_LEFT_ALL: "draggedLeftAll",
  DROPPED_INTO_ZONE: "droppedIntoZone",
  DROPPED_INTO_ANOTHER: "droppedIntoAnother",
  DROPPED_OUTSIDE_OF_ANY: "droppedOutsideOfAny",
  DRAG_STOPPED: "dragStopped"
};
var SOURCES = {
  POINTER: "pointer",
  KEYBOARD: "keyboard"
};
var SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
var SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
var DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
var ITEM_ID_KEY = "id";
var activeDndZoneCount = 0;
function incrementActiveDropZoneCount() {
  activeDndZoneCount++;
}
function decrementActiveDropZoneCount() {
  if (activeDndZoneCount === 0) {
    throw new Error("Bug! trying to decrement when there are no dropzones");
  }
  activeDndZoneCount--;
}
var isOnServer = typeof window === "undefined";
var printDebug = () => {
};

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/intersection.js
function getBoundingRectNoTransforms(el) {
  let ta;
  const rect = el.getBoundingClientRect();
  const style = getComputedStyle(el);
  const tx = style.transform;
  if (tx) {
    let sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return rect;
    }
    const to = style.transformOrigin;
    const x = rect.x - dx - (1 - sx) * parseFloat(to);
    const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w = sx ? rect.width / sx : el.offsetWidth;
    const h = sy ? rect.height / sy : el.offsetHeight;
    return {
      x,
      y,
      width: w,
      height: h,
      top: y,
      right: x + w,
      bottom: y + h,
      left: x
    };
  } else {
    return rect;
  }
}
function getAbsoluteRectNoTransforms(el) {
  const rect = getBoundingRectNoTransforms(el);
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function getAbsoluteRect(el) {
  const rect = el.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function findCenter(rect) {
  return {
    x: (rect.left + rect.right) / 2,
    y: (rect.top + rect.bottom) / 2
  };
}
function calcDistance(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
}
function isPointInsideRect(point, rect) {
  return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;
}
function findCenterOfElement(el) {
  return findCenter(getAbsoluteRect(el));
}
function isCenterOfAInsideB(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const rectOfB = getAbsoluteRectNoTransforms(elB);
  return isPointInsideRect(centerOfA, rectOfB);
}
function calcDistanceBetweenCenters(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const centerOfB = findCenterOfElement(elB);
  return calcDistance(centerOfA, centerOfB);
}
function isElementOffDocument(el) {
  const rect = getAbsoluteRect(el);
  return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
}
function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
  const rect = getAbsoluteRect(el);
  if (!isPointInsideRect(point, rect)) {
    return null;
  }
  return {
    top: point.y - rect.top,
    bottom: rect.bottom - point.y,
    left: point.x - rect.left,
    // TODO - figure out what is so special about right (why the rect is too big)
    right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/listUtil.js
var dzToShadowIndexToRect;
function resetIndexesCache() {
  printDebug(() => "resetting indexes cache");
  dzToShadowIndexToRect = /* @__PURE__ */ new Map();
}
resetIndexesCache();
function resetIndexesCacheForDz(dz) {
  printDebug(() => "resetting indexes cache for dz");
  dzToShadowIndexToRect.delete(dz);
}
function cacheShadowRect(dz) {
  const shadowElIndex = Array.from(dz.children).findIndex((child) => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));
  if (shadowElIndex >= 0) {
    if (!dzToShadowIndexToRect.has(dz)) {
      dzToShadowIndexToRect.set(dz, /* @__PURE__ */ new Map());
    }
    dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));
    return shadowElIndex;
  }
  return void 0;
}
function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
  if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {
    return null;
  }
  const children2 = collectionBelowEl.children;
  if (children2.length === 0) {
    return { index: 0, isProximityBased: true };
  }
  const shadowElIndex = cacheShadowRect(collectionBelowEl);
  for (let i = 0; i < children2.length; i++) {
    if (isCenterOfAInsideB(floatingAboveEl, children2[i])) {
      const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);
      if (cachedShadowRect) {
        if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {
          return { index: shadowElIndex, isProximityBased: false };
        }
      }
      return { index: i, isProximityBased: false };
    }
  }
  let minDistanceSoFar = Number.MAX_VALUE;
  let indexOfMin = void 0;
  for (let i = 0; i < children2.length; i++) {
    const distance = calcDistanceBetweenCenters(floatingAboveEl, children2[i]);
    if (distance < minDistanceSoFar) {
      minDistanceSoFar = distance;
      indexOfMin = i;
    }
  }
  return { index: indexOfMin, isProximityBased: true };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/scroller.js
var SCROLL_ZONE_PX = 25;
function makeScroller() {
  let scrollingInfo;
  function resetScrolling3() {
    scrollingInfo = { directionObj: void 0, stepPx: 0 };
  }
  resetScrolling3();
  function scrollContainer(containerEl) {
    const { directionObj, stepPx } = scrollingInfo;
    if (directionObj) {
      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
      window.requestAnimationFrame(() => scrollContainer(containerEl));
    }
  }
  function calcScrollStepPx(distancePx) {
    return SCROLL_ZONE_PX - distancePx;
  }
  function scrollIfNeeded3(pointer, elementToScroll) {
    if (!elementToScroll) {
      return false;
    }
    const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
    if (distances === null) {
      resetScrolling3();
      return false;
    }
    const isAlreadyScrolling = !!scrollingInfo.directionObj;
    let [scrollingVertically, scrollingHorizontally] = [false, false];
    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
      if (distances.bottom < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: 1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
      } else if (distances.top < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: -1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
      }
      if (!isAlreadyScrolling && scrollingVertically) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
      if (distances.right < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: 1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
      } else if (distances.left < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: -1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
      }
      if (!isAlreadyScrolling && scrollingHorizontally) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    resetScrolling3();
    return false;
  }
  return {
    scrollIfNeeded: scrollIfNeeded3,
    resetScrolling: resetScrolling3
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/util.js
function toString(object) {
  return JSON.stringify(object, null, 2);
}
function getDepth(node) {
  if (!node) {
    throw new Error("cannot get depth of a falsy node");
  }
  return _getDepth(node, 0);
}
function _getDepth(node, countSoFar = 0) {
  if (!node.parentElement) {
    return countSoFar - 1;
  }
  return _getDepth(node.parentElement, countSoFar + 1);
}
function areObjectsShallowEqual(objA, objB) {
  if (Object.keys(objA).length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA in objA) {
    if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {
      return false;
    }
  }
  return true;
}
function areArraysShallowEqualSameOrder(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/observer.js
var INTERVAL_MS = 200;
var TOLERANCE_PX = 10;
var { scrollIfNeeded, resetScrolling } = makeScroller();
var next;
function observe(draggedEl2, dropZones, intervalMs = INTERVAL_MS) {
  let lastDropZoneFound;
  let lastIndexFound;
  let lastIsDraggedInADropZone = false;
  let lastCentrePositionOfDragged;
  const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));
  function andNow() {
    const currentCenterOfDragged = findCenterOfElement(draggedEl2);
    const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);
    if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
      next = window.setTimeout(andNow, intervalMs);
      return;
    }
    if (isElementOffDocument(draggedEl2)) {
      printDebug(() => "off document");
      dispatchDraggedLeftDocument(draggedEl2);
      return;
    }
    lastCentrePositionOfDragged = currentCenterOfDragged;
    let isDraggedInADropZone = false;
    for (const dz of dropZonesFromDeepToShallow) {
      if (scrolled)
        resetIndexesCacheForDz(lastDropZoneFound);
      const indexObj = findWouldBeIndex(draggedEl2, dz);
      if (indexObj === null) {
        continue;
      }
      const { index } = indexObj;
      isDraggedInADropZone = true;
      if (dz !== lastDropZoneFound) {
        lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl2, dz);
        dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl2);
        lastDropZoneFound = dz;
      } else if (index !== lastIndexFound) {
        dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl2);
        lastIndexFound = index;
      }
      break;
    }
    if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {
      dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl2);
      lastDropZoneFound = void 0;
      lastIndexFound = void 0;
      lastIsDraggedInADropZone = false;
    } else {
      lastIsDraggedInADropZone = true;
    }
    next = window.setTimeout(andNow, intervalMs);
  }
  andNow();
}
function unobserve() {
  printDebug(() => "unobserving");
  clearTimeout(next);
  resetScrolling();
  resetIndexesCache();
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/windowScroller.js
var INTERVAL_MS2 = 300;
var mousePosition;
function updateMousePosition(e) {
  const c = e.touches ? e.touches[0] : e;
  mousePosition = { x: c.clientX, y: c.clientY };
}
var { scrollIfNeeded: scrollIfNeeded2, resetScrolling: resetScrolling2 } = makeScroller();
var next2;
function loop() {
  if (mousePosition) {
    const scrolled = scrollIfNeeded2(mousePosition, document.documentElement);
    if (scrolled)
      resetIndexesCache();
  }
  next2 = window.setTimeout(loop, INTERVAL_MS2);
}
function armWindowScroller() {
  printDebug(() => "arming window scroller");
  window.addEventListener("mousemove", updateMousePosition);
  window.addEventListener("touchmove", updateMousePosition);
  loop();
}
function disarmWindowScroller() {
  printDebug(() => "disarming window scroller");
  window.removeEventListener("mousemove", updateMousePosition);
  window.removeEventListener("touchmove", updateMousePosition);
  mousePosition = void 0;
  window.clearTimeout(next2);
  resetScrolling2();
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js
function svelteNodeClone(el) {
  const cloned = el.cloneNode(true);
  const values = [];
  const elIsSelect = el.tagName === "SELECT";
  const selects = elIsSelect ? [el] : [...el.querySelectorAll("select")];
  for (const select of selects) {
    values.push(select.value);
  }
  if (selects.length <= 0) {
    return cloned;
  }
  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll("select")];
  for (let i = 0; i < clonedSelects.length; i++) {
    const select = clonedSelects[i];
    const value = values[i];
    const optionEl = select.querySelector(`option[value="${value}"`);
    if (optionEl) {
      optionEl.setAttribute("selected", true);
    }
  }
  return cloned;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/styler.js
var TRANSITION_DURATION_SECONDS = 0.2;
function trs(property) {
  return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;
}
function createDraggedElementFrom(originalElement, positionCenterOnXY) {
  const rect = originalElement.getBoundingClientRect();
  const draggedEl2 = svelteNodeClone(originalElement);
  copyStylesFromTo(originalElement, draggedEl2);
  draggedEl2.id = DRAGGED_ELEMENT_ID;
  draggedEl2.style.position = "fixed";
  let elTopPx = rect.top;
  let elLeftPx = rect.left;
  draggedEl2.style.top = `${elTopPx}px`;
  draggedEl2.style.left = `${elLeftPx}px`;
  if (positionCenterOnXY) {
    const center = findCenter(rect);
    elTopPx -= center.y - positionCenterOnXY.y;
    elLeftPx -= center.x - positionCenterOnXY.x;
    window.setTimeout(() => {
      draggedEl2.style.top = `${elTopPx}px`;
      draggedEl2.style.left = `${elLeftPx}px`;
    }, 0);
  }
  draggedEl2.style.margin = "0";
  draggedEl2.style.boxSizing = "border-box";
  draggedEl2.style.height = `${rect.height}px`;
  draggedEl2.style.width = `${rect.width}px`;
  draggedEl2.style.transition = `${trs("top")}, ${trs("left")}, ${trs("background-color")}, ${trs("opacity")}, ${trs("color")} `;
  window.setTimeout(() => draggedEl2.style.transition += `, ${trs("width")}, ${trs("height")}`, 0);
  draggedEl2.style.zIndex = "9999";
  draggedEl2.style.cursor = "grabbing";
  return draggedEl2;
}
function moveDraggedElementToWasDroppedState(draggedEl2) {
  draggedEl2.style.cursor = "grab";
}
function morphDraggedElementToBeLike(draggedEl2, copyFromEl, currentMouseX, currentMouseY) {
  copyStylesFromTo(copyFromEl, draggedEl2);
  const newRect = copyFromEl.getBoundingClientRect();
  const draggedElRect = draggedEl2.getBoundingClientRect();
  const widthChange = newRect.width - draggedElRect.width;
  const heightChange = newRect.height - draggedElRect.height;
  if (widthChange || heightChange) {
    const relativeDistanceOfMousePointerFromDraggedSides = {
      left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
      top: (currentMouseY - draggedElRect.top) / draggedElRect.height
    };
    draggedEl2.style.height = `${newRect.height}px`;
    draggedEl2.style.width = `${newRect.width}px`;
    draggedEl2.style.left = `${parseFloat(draggedEl2.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;
    draggedEl2.style.top = `${parseFloat(draggedEl2.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;
  }
}
function copyStylesFromTo(copyFromEl, copyToEl) {
  const computedStyle = window.getComputedStyle(copyFromEl);
  Array.from(computedStyle).filter(
    (s) => s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type"
  ).forEach((s) => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));
}
function styleDraggable(draggableEl, dragDisabled) {
  draggableEl.draggable = false;
  draggableEl.ondragstart = () => false;
  if (!dragDisabled) {
    draggableEl.style.userSelect = "none";
    draggableEl.style.WebkitUserSelect = "none";
    draggableEl.style.cursor = "grab";
  } else {
    draggableEl.style.userSelect = "";
    draggableEl.style.WebkitUserSelect = "";
    draggableEl.style.cursor = "";
  }
}
function hideElement(dragTarget) {
  dragTarget.style.display = "none";
  dragTarget.style.position = "fixed";
  dragTarget.style.zIndex = "-5";
}
function decorateShadowEl(shadowEl) {
  shadowEl.style.visibility = "hidden";
  shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, "true");
}
function unDecorateShadowElement(shadowEl) {
  shadowEl.style.visibility = "";
  shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
}
function styleActiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles = getStyles(dz);
    Object.keys(styles).forEach((style) => {
      dz.style[style] = styles[style];
    });
    getClasses(dz).forEach((c) => dz.classList.add(c));
  });
}
function styleInactiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles = getStyles(dz);
    Object.keys(styles).forEach((style) => {
      dz.style[style] = "";
    });
    getClasses(dz).forEach((c) => dz.classList.contains(c) && dz.classList.remove(c));
  });
}
function preventShrinking(el) {
  const originalMinHeight = el.style.minHeight;
  el.style.minHeight = window.getComputedStyle(el).getPropertyValue("height");
  const originalMinWidth = el.style.minWidth;
  el.style.minWidth = window.getComputedStyle(el).getPropertyValue("width");
  return function undo() {
    el.style.minHeight = originalMinHeight;
    el.style.minWidth = originalMinWidth;
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/pointerAction.js
var DEFAULT_DROP_ZONE_TYPE = "--any--";
var MIN_OBSERVATION_INTERVAL_MS = 100;
var MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
var DEFAULT_DROP_TARGET_STYLE = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var originalDragTarget;
var draggedEl;
var draggedElData;
var draggedElType;
var originDropZone;
var originIndex;
var shadowElData;
var shadowElDropZone;
var dragStartMousePosition;
var currentMousePosition;
var isWorkingOnPreviousDrag = false;
var finalizingPreviousDrag = false;
var unlockOriginDzMinDimensions;
var isDraggedOutsideOfAnyDz = false;
var scheduledForRemovalAfterDrop = [];
var typeToDropZones = /* @__PURE__ */ new Map();
var dzToConfig = /* @__PURE__ */ new Map();
var elToMouseDownListener = /* @__PURE__ */ new WeakMap();
function registerDropZone(dropZoneEl, type) {
  printDebug(() => "registering drop-zone if absent");
  if (!typeToDropZones.has(type)) {
    typeToDropZones.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones.get(type).has(dropZoneEl)) {
    typeToDropZones.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone(dropZoneEl, type) {
  typeToDropZones.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones.get(type).size === 0) {
    typeToDropZones.delete(type);
  }
}
function watchDraggedElement() {
  printDebug(() => "watching dragged element");
  armWindowScroller();
  const dropZones = typeToDropZones.get(draggedElType);
  for (const dz of dropZones) {
    dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  const observationIntervalMs = Math.max(
    MIN_OBSERVATION_INTERVAL_MS,
    ...Array.from(dropZones.keys()).map((dz) => dzToConfig.get(dz).dropAnimationDurationMs)
  );
  observe(draggedEl, dropZones, observationIntervalMs * 1.07);
}
function unWatchDraggedElement() {
  printDebug(() => "unwatching dragged element");
  disarmWindowScroller();
  const dropZones = typeToDropZones.get(draggedElType);
  for (const dz of dropZones) {
    dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  unobserve();
}
function findShadowPlaceHolderIdx(items) {
  return items.findIndex((item) => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);
}
function findShadowElementIdx(items) {
  return items.findIndex((item) => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);
}
function handleDraggedEntered(e) {
  printDebug(() => ["dragged entered", e.currentTarget, e.detail]);
  let { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(() => "ignoring dragged entered because drop is currently disabled");
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  items = items.filter((item) => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);
  printDebug(() => `dragged entered items ${toString(items)}`);
  if (originDropZone !== e.currentTarget) {
    const originZoneItems = dzToConfig.get(originDropZone).items;
    const newOriginZoneItems = originZoneItems.filter((item) => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);
    dispatchConsiderEvent(originDropZone, newOriginZoneItems, {
      trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  } else {
    const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
    if (shadowPlaceHolderIdx !== -1) {
      printDebug(() => "removing placeholder item from origin dz");
      items.splice(shadowPlaceHolderIdx, 1);
    }
  }
  const { index, isProximityBased } = e.detail.indexObj;
  const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
  shadowElDropZone = e.currentTarget;
  items.splice(shadowElIdx, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
function handleDraggedLeft(e) {
  if (!isWorkingOnPreviousDrag)
    return;
  printDebug(() => ["dragged left", e.currentTarget, e.detail]);
  const { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
    printDebug(() => "drop is currently disabled");
    return;
  }
  const shadowElIdx = findShadowElementIdx(items);
  const shadowItem = items.splice(shadowElIdx, 1)[0];
  shadowElDropZone = void 0;
  const { type, theOtherDz } = e.detail;
  if (type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY || type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled) {
    printDebug(() => "dragged left all, putting shadow element back in the origin dz");
    isDraggedOutsideOfAnyDz = true;
    shadowElDropZone = originDropZone;
    const originZoneItems = dzToConfig.get(originDropZone).items;
    originZoneItems.splice(originIndex, 0, shadowItem);
    dispatchConsiderEvent(originDropZone, originZoneItems, {
      trigger: TRIGGERS.DRAGGED_LEFT_ALL,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  }
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_LEFT,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
function handleDraggedIsOverIndex(e) {
  printDebug(() => ["dragged is over index", e.currentTarget, e.detail]);
  const { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(() => "drop is currently disabled");
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  const { index } = e.detail.indexObj;
  const shadowElIdx = findShadowElementIdx(items);
  items.splice(shadowElIdx, 1);
  items.splice(index, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
function handleMouseMove(e) {
  e.preventDefault();
  const c = e.touches ? e.touches[0] : e;
  currentMousePosition = { x: c.clientX, y: c.clientY };
  draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${currentMousePosition.y - dragStartMousePosition.y}px, 0)`;
}
function handleDrop() {
  printDebug(() => "dropped");
  finalizingPreviousDrag = true;
  window.removeEventListener("mousemove", handleMouseMove);
  window.removeEventListener("touchmove", handleMouseMove);
  window.removeEventListener("mouseup", handleDrop);
  window.removeEventListener("touchend", handleDrop);
  unWatchDraggedElement();
  moveDraggedElementToWasDroppedState(draggedEl);
  if (!shadowElDropZone) {
    printDebug(() => "element was dropped right after it left origin but before entering somewhere else");
    shadowElDropZone = originDropZone;
  }
  printDebug(() => ["dropped in dz", shadowElDropZone]);
  let { items, type } = dzToConfig.get(shadowElDropZone);
  styleInactiveDropZones(
    typeToDropZones.get(type),
    (dz) => dzToConfig.get(dz).dropTargetStyle,
    (dz) => dzToConfig.get(dz).dropTargetClasses
  );
  let shadowElIdx = findShadowElementIdx(items);
  if (shadowElIdx === -1)
    shadowElIdx = originIndex;
  items = items.map((item) => item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item);
  function finalizeWithinZone() {
    unlockOriginDzMinDimensions();
    dispatchFinalizeEvent(shadowElDropZone, items, {
      trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
    if (shadowElDropZone !== originDropZone) {
      dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {
        trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
        id: draggedElData[ITEM_ID_KEY],
        source: SOURCES.POINTER
      });
    }
    unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
    cleanupPostDrop();
  }
  animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
}
function animateDraggedToFinalPosition(shadowElIdx, callback) {
  const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
  const newTransform = {
    x: shadowElRect.left - parseFloat(draggedEl.style.left),
    y: shadowElRect.top - parseFloat(draggedEl.style.top)
  };
  const { dropAnimationDurationMs } = dzToConfig.get(shadowElDropZone);
  const transition = `transform ${dropAnimationDurationMs}ms ease`;
  draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
  draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;
  window.setTimeout(callback, dropAnimationDurationMs);
}
function scheduleDZForRemovalAfterDrop(dz, destroy) {
  scheduledForRemovalAfterDrop.push({ dz, destroy });
  window.requestAnimationFrame(() => {
    hideElement(dz);
    document.body.appendChild(dz);
  });
}
function cleanupPostDrop() {
  draggedEl.remove();
  originalDragTarget.remove();
  if (scheduledForRemovalAfterDrop.length) {
    printDebug(() => ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop]);
    scheduledForRemovalAfterDrop.forEach(({ dz, destroy }) => {
      destroy();
      dz.remove();
    });
    scheduledForRemovalAfterDrop = [];
  }
  draggedEl = void 0;
  originalDragTarget = void 0;
  draggedElData = void 0;
  draggedElType = void 0;
  originDropZone = void 0;
  originIndex = void 0;
  shadowElData = void 0;
  shadowElDropZone = void 0;
  dragStartMousePosition = void 0;
  currentMousePosition = void 0;
  isWorkingOnPreviousDrag = false;
  finalizingPreviousDrag = false;
  unlockOriginDzMinDimensions = void 0;
  isDraggedOutsideOfAnyDz = false;
}
function dndzone(node, options) {
  let initialized = false;
  const config = {
    items: void 0,
    type: void 0,
    flipDurationMs: 0,
    dragDisabled: false,
    morphDisabled: false,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses: [],
    transformDraggedElement: () => {
    },
    centreDraggedOnCursor: false
  };
  printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, { node }]);
  let elToIdx = /* @__PURE__ */ new Map();
  function addMaybeListeners() {
    window.addEventListener("mousemove", handleMouseMoveMaybeDragStart, { passive: false });
    window.addEventListener("touchmove", handleMouseMoveMaybeDragStart, { passive: false, capture: false });
    window.addEventListener("mouseup", handleFalseAlarm, { passive: false });
    window.addEventListener("touchend", handleFalseAlarm, { passive: false });
  }
  function removeMaybeListeners() {
    window.removeEventListener("mousemove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("mouseup", handleFalseAlarm);
    window.removeEventListener("touchend", handleFalseAlarm);
  }
  function handleFalseAlarm() {
    removeMaybeListeners();
    originalDragTarget = void 0;
    dragStartMousePosition = void 0;
    currentMousePosition = void 0;
  }
  function handleMouseMoveMaybeDragStart(e) {
    e.preventDefault();
    const c = e.touches ? e.touches[0] : e;
    currentMousePosition = { x: c.clientX, y: c.clientY };
    if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
      removeMaybeListeners();
      handleDragStart();
    }
  }
  function handleMouseDown(e) {
    if (e.target !== e.currentTarget && (e.target.value !== void 0 || e.target.isContentEditable)) {
      printDebug(() => "won't initiate drag on a nested input element");
      return;
    }
    if (e.button) {
      printDebug(() => `ignoring none left click button: ${e.button}`);
      return;
    }
    if (isWorkingOnPreviousDrag) {
      printDebug(() => "cannot start a new drag before finalizing previous one");
      return;
    }
    e.stopPropagation();
    const c = e.touches ? e.touches[0] : e;
    dragStartMousePosition = { x: c.clientX, y: c.clientY };
    currentMousePosition = { ...dragStartMousePosition };
    originalDragTarget = e.currentTarget;
    addMaybeListeners();
  }
  function handleDragStart() {
    printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);
    isWorkingOnPreviousDrag = true;
    const currentIdx = elToIdx.get(originalDragTarget);
    originIndex = currentIdx;
    originDropZone = originalDragTarget.parentElement;
    const rootNode = originDropZone.getRootNode();
    const originDropZoneRoot = rootNode.body || rootNode;
    const { items, type, centreDraggedOnCursor } = config;
    draggedElData = { ...items[currentIdx] };
    draggedElType = type;
    shadowElData = { ...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true };
    const placeHolderElData = { ...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID };
    draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
    function keepOriginalElementInDom() {
      if (!draggedEl.parentElement) {
        originDropZoneRoot.appendChild(draggedEl);
        draggedEl.focus();
        watchDraggedElement();
        hideElement(originalDragTarget);
        originDropZoneRoot.appendChild(originalDragTarget);
      } else {
        window.requestAnimationFrame(keepOriginalElementInDom);
      }
    }
    window.requestAnimationFrame(keepOriginalElementInDom);
    styleActiveDropZones(
      Array.from(typeToDropZones.get(config.type)).filter((dz) => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),
      (dz) => dzToConfig.get(dz).dropTargetStyle,
      (dz) => dzToConfig.get(dz).dropTargetClasses
    );
    items.splice(currentIdx, 1, placeHolderElData);
    unlockOriginDzMinDimensions = preventShrinking(originDropZone);
    dispatchConsiderEvent(originDropZone, items, { trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
    window.addEventListener("mousemove", handleMouseMove, { passive: false });
    window.addEventListener("touchmove", handleMouseMove, { passive: false, capture: false });
    window.addEventListener("mouseup", handleDrop, { passive: false });
    window.addEventListener("touchend", handleDrop, { passive: false });
  }
  function configure({
    items = void 0,
    flipDurationMs: dropAnimationDurationMs = 0,
    type: newType = DEFAULT_DROP_ZONE_TYPE,
    dragDisabled = false,
    morphDisabled = false,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses = [],
    transformDraggedElement = () => {
    },
    centreDraggedOnCursor = false
  }) {
    config.dropAnimationDurationMs = dropAnimationDurationMs;
    if (config.type && newType !== config.type) {
      unregisterDropZone(node, config.type);
    }
    config.type = newType;
    registerDropZone(node, newType);
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.morphDisabled = morphDisabled;
    config.transformDraggedElement = transformDraggedElement;
    config.centreDraggedOnCursor = centreDraggedOnCursor;
    if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
      styleInactiveDropZones(
        [node],
        () => config.dropTargetStyle,
        () => dropTargetClasses
      );
      styleActiveDropZones(
        [node],
        () => dropTargetStyle,
        () => dropTargetClasses
      );
    }
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = [...dropTargetClasses];
    function getConfigProp(dz, propName) {
      return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];
    }
    if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {
      if (dropFromOthersDisabled) {
        styleInactiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      } else {
        styleActiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      }
    }
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    dzToConfig.set(node, config);
    const shadowElIdx = findShadowElementIdx(config.items);
    for (let idx = 0; idx < node.children.length; idx++) {
      const draggableEl = node.children[idx];
      styleDraggable(draggableEl, dragDisabled);
      if (idx === shadowElIdx) {
        config.transformDraggedElement(draggedEl, draggedElData, idx);
        if (!morphDisabled) {
          morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
        }
        decorateShadowEl(draggableEl);
        continue;
      }
      draggableEl.removeEventListener("mousedown", elToMouseDownListener.get(draggableEl));
      draggableEl.removeEventListener("touchstart", elToMouseDownListener.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("mousedown", handleMouseDown);
        draggableEl.addEventListener("touchstart", handleMouseDown);
        elToMouseDownListener.set(draggableEl, handleMouseDown);
      }
      elToIdx.set(draggableEl, idx);
      if (!initialized) {
        initialized = true;
      }
    }
  }
  configure(options);
  return {
    update: (newOptions) => {
      printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);
      configure(newOptions);
    },
    destroy: () => {
      function destroyDz() {
        printDebug(() => "pointer dndzone will destroy");
        unregisterDropZone(node, dzToConfig.get(node).type);
        dzToConfig.delete(node);
      }
      if (isWorkingOnPreviousDrag) {
        printDebug(() => "pointer dndzone will be scheduled for destruction");
        scheduleDZForRemovalAfterDrop(node, destroyDz);
      } else {
        destroyDz();
      }
    }
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/helpers/aria.js
var INSTRUCTION_IDs = {
  DND_ZONE_ACTIVE: "dnd-zone-active",
  DND_ZONE_DRAG_DISABLED: "dnd-zone-drag-disabled"
};
var ID_TO_INSTRUCTION = {
  [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: "Tab to one the items and press space-bar or enter to start dragging it",
  [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: "This is a disabled drag and drop list"
};
var ALERT_DIV_ID = "dnd-action-aria-alert";
var alertsDiv;
function initAriaOnBrowser() {
  if (alertsDiv) {
    return;
  }
  alertsDiv = document.createElement("div");
  (function initAlertsDiv() {
    alertsDiv.id = ALERT_DIV_ID;
    alertsDiv.style.position = "fixed";
    alertsDiv.style.bottom = "0";
    alertsDiv.style.left = "0";
    alertsDiv.style.zIndex = "-5";
    alertsDiv.style.opacity = "0";
    alertsDiv.style.height = "0";
    alertsDiv.style.width = "0";
    alertsDiv.setAttribute("role", "alert");
  })();
  document.body.prepend(alertsDiv);
  Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));
}
function initAria() {
  if (isOnServer)
    return null;
  if (document.readyState === "complete") {
    initAriaOnBrowser();
  } else {
    window.addEventListener("DOMContentLoaded", initAriaOnBrowser);
  }
  return { ...INSTRUCTION_IDs };
}
function destroyAria() {
  if (isOnServer || !alertsDiv)
    return;
  Object.keys(ID_TO_INSTRUCTION).forEach((id) => document.getElementById(id)?.remove());
  alertsDiv.remove();
  alertsDiv = void 0;
}
function instructionToHiddenDiv(id, txt) {
  const div = document.createElement("div");
  div.id = id;
  div.innerHTML = `<p>${txt}</p>`;
  div.style.display = "none";
  div.style.position = "fixed";
  div.style.zIndex = "-5";
  return div;
}
function alertToScreenReader(txt) {
  if (isOnServer)
    return;
  if (!alertsDiv) {
    initAriaOnBrowser();
  }
  alertsDiv.innerHTML = "";
  const alertText = document.createTextNode(txt);
  alertsDiv.appendChild(alertText);
  alertsDiv.style.display = "none";
  alertsDiv.style.display = "inline";
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/keyboardAction.js
var DEFAULT_DROP_ZONE_TYPE2 = "--any--";
var DEFAULT_DROP_TARGET_STYLE2 = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var isDragging = false;
var draggedItemType;
var focusedDz;
var focusedDzLabel = "";
var focusedItem;
var focusedItemId;
var focusedItemLabel = "";
var allDragTargets = /* @__PURE__ */ new WeakSet();
var elToKeyDownListeners = /* @__PURE__ */ new WeakMap();
var elToFocusListeners = /* @__PURE__ */ new WeakMap();
var dzToHandles = /* @__PURE__ */ new Map();
var dzToConfig2 = /* @__PURE__ */ new Map();
var typeToDropZones2 = /* @__PURE__ */ new Map();
var INSTRUCTION_IDs2;
function registerDropZone2(dropZoneEl, type) {
  printDebug(() => "registering drop-zone if absent");
  if (typeToDropZones2.size === 0) {
    printDebug(() => "adding global keydown and click handlers");
    INSTRUCTION_IDs2 = initAria();
    window.addEventListener("keydown", globalKeyDownHandler);
    window.addEventListener("click", globalClickHandler);
  }
  if (!typeToDropZones2.has(type)) {
    typeToDropZones2.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones2.get(type).has(dropZoneEl)) {
    typeToDropZones2.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone2(dropZoneEl, type) {
  printDebug(() => "unregistering drop-zone");
  if (focusedDz === dropZoneEl) {
    handleDrop2();
  }
  typeToDropZones2.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones2.get(type).size === 0) {
    typeToDropZones2.delete(type);
  }
  if (typeToDropZones2.size === 0) {
    printDebug(() => "removing global keydown and click handlers");
    window.removeEventListener("keydown", globalKeyDownHandler);
    window.removeEventListener("click", globalClickHandler);
    INSTRUCTION_IDs2 = void 0;
    destroyAria();
  }
}
function globalKeyDownHandler(e) {
  if (!isDragging)
    return;
  switch (e.key) {
    case "Escape": {
      handleDrop2();
      break;
    }
  }
}
function globalClickHandler() {
  if (!isDragging)
    return;
  if (!allDragTargets.has(document.activeElement)) {
    printDebug(() => "clicked outside of any draggable");
    handleDrop2();
  }
}
function handleZoneFocus(e) {
  printDebug(() => "zone focus");
  if (!isDragging)
    return;
  const newlyFocusedDz = e.currentTarget;
  if (newlyFocusedDz === focusedDz)
    return;
  focusedDzLabel = newlyFocusedDz.getAttribute("aria-label") || "";
  const { items: originItems } = dzToConfig2.get(focusedDz);
  const originItem = originItems.find((item) => item[ITEM_ID_KEY] === focusedItemId);
  const originIdx = originItems.indexOf(originItem);
  const itemToMove = originItems.splice(originIdx, 1)[0];
  const { items: targetItems, autoAriaDisabled } = dzToConfig2.get(newlyFocusedDz);
  if (newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top || newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left) {
    targetItems.push(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);
    }
  } else {
    targetItems.unshift(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);
    }
  }
  const dzFrom = focusedDz;
  dispatchFinalizeEvent(dzFrom, originItems, { trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD });
  dispatchFinalizeEvent(newlyFocusedDz, targetItems, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
  focusedDz = newlyFocusedDz;
}
function triggerAllDzsUpdate() {
  dzToHandles.forEach(({ update: update2 }, dz) => update2(dzToConfig2.get(dz)));
}
function handleDrop2(dispatchConsider = true) {
  printDebug(() => "drop");
  if (!dzToConfig2.get(focusedDz).autoAriaDisabled) {
    alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);
  }
  if (allDragTargets.has(document.activeElement)) {
    document.activeElement.blur();
  }
  if (dispatchConsider) {
    dispatchConsiderEvent(focusedDz, dzToConfig2.get(focusedDz).items, {
      trigger: TRIGGERS.DRAG_STOPPED,
      id: focusedItemId,
      source: SOURCES.KEYBOARD
    });
  }
  styleInactiveDropZones(
    typeToDropZones2.get(draggedItemType),
    (dz) => dzToConfig2.get(dz).dropTargetStyle,
    (dz) => dzToConfig2.get(dz).dropTargetClasses
  );
  focusedItem = null;
  focusedItemId = null;
  focusedItemLabel = "";
  draggedItemType = null;
  focusedDz = null;
  focusedDzLabel = "";
  isDragging = false;
  triggerAllDzsUpdate();
}
function dndzone2(node, options) {
  const config = {
    items: void 0,
    type: void 0,
    dragDisabled: false,
    zoneTabIndex: 0,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE2,
    dropTargetClasses: [],
    autoAriaDisabled: false
  };
  function swap(arr, i, j) {
    if (arr.length <= 1)
      return;
    arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);
  }
  function handleKeyDown(e) {
    printDebug(() => ["handling key down", e.key]);
    switch (e.key) {
      case "Enter":
      case " ": {
        if ((e.target.disabled !== void 0 || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (isDragging) {
          handleDrop2();
        } else {
          handleDragStart(e);
        }
        break;
      }
      case "ArrowDown":
      case "ArrowRight": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig2.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        printDebug(() => ["arrow down", idx]);
        if (idx < children2.length - 1) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx + 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
      case "ArrowUp":
      case "ArrowLeft": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig2.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        printDebug(() => ["arrow up", idx]);
        if (idx > 0) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx - 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
    }
  }
  function handleDragStart(e) {
    printDebug(() => "drag start");
    setCurrentFocusedItem(e.currentTarget);
    focusedDz = node;
    draggedItemType = config.type;
    isDragging = true;
    const dropTargets = Array.from(typeToDropZones2.get(config.type)).filter((dz) => dz === focusedDz || !dzToConfig2.get(dz).dropFromOthersDisabled);
    styleActiveDropZones(
      dropTargets,
      (dz) => dzToConfig2.get(dz).dropTargetStyle,
      (dz) => dzToConfig2.get(dz).dropTargetClasses
    );
    if (!config.autoAriaDisabled) {
      let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;
      if (dropTargets.length > 1) {
        msg += `, or tab to another list in order to move the item into it`;
      }
      alertToScreenReader(msg);
    }
    dispatchConsiderEvent(node, dzToConfig2.get(node).items, { trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD });
    triggerAllDzsUpdate();
  }
  function handleClick(e) {
    if (!isDragging)
      return;
    if (e.currentTarget === focusedItem)
      return;
    e.stopPropagation();
    handleDrop2(false);
    handleDragStart(e);
  }
  function setCurrentFocusedItem(draggableEl) {
    const { items } = dzToConfig2.get(node);
    const children2 = Array.from(node.children);
    const focusedItemIdx = children2.indexOf(draggableEl);
    focusedItem = draggableEl;
    focusedItem.tabIndex = 0;
    focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
    focusedItemLabel = children2[focusedItemIdx].getAttribute("aria-label") || "";
  }
  function configure({
    items = [],
    type: newType = DEFAULT_DROP_ZONE_TYPE2,
    dragDisabled = false,
    zoneTabIndex = 0,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE2,
    dropTargetClasses = [],
    autoAriaDisabled = false
  }) {
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    config.zoneTabIndex = zoneTabIndex;
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = dropTargetClasses;
    config.autoAriaDisabled = autoAriaDisabled;
    if (config.type && newType !== config.type) {
      unregisterDropZone2(node, config.type);
    }
    config.type = newType;
    registerDropZone2(node, newType);
    if (!autoAriaDisabled) {
      node.setAttribute("aria-disabled", dragDisabled);
      node.setAttribute("role", "list");
      node.setAttribute("aria-describedby", dragDisabled ? INSTRUCTION_IDs2.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs2.DND_ZONE_ACTIVE);
    }
    dzToConfig2.set(node, config);
    if (isDragging) {
      node.tabIndex = node === focusedDz || focusedItem.contains(node) || config.dropFromOthersDisabled || focusedDz && config.type !== dzToConfig2.get(focusedDz).type ? -1 : 0;
    } else {
      node.tabIndex = config.zoneTabIndex;
    }
    node.addEventListener("focus", handleZoneFocus);
    for (let i = 0; i < node.children.length; i++) {
      const draggableEl = node.children[i];
      allDragTargets.add(draggableEl);
      draggableEl.tabIndex = isDragging ? -1 : 0;
      if (!autoAriaDisabled) {
        draggableEl.setAttribute("role", "listitem");
      }
      draggableEl.removeEventListener("keydown", elToKeyDownListeners.get(draggableEl));
      draggableEl.removeEventListener("click", elToFocusListeners.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("keydown", handleKeyDown);
        elToKeyDownListeners.set(draggableEl, handleKeyDown);
        draggableEl.addEventListener("click", handleClick);
        elToFocusListeners.set(draggableEl, handleClick);
      }
      if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {
        printDebug(() => ["focusing on", { i, focusedItemId }]);
        focusedItem = draggableEl;
        focusedItem.tabIndex = 0;
        draggableEl.focus();
      }
    }
  }
  configure(options);
  const handles = {
    update: (newOptions) => {
      printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);
      configure(newOptions);
    },
    destroy: () => {
      printDebug(() => "keyboard dndzone will destroy");
      unregisterDropZone2(node, config.type);
      dzToConfig2.delete(node);
      dzToHandles.delete(node);
    }
  };
  dzToHandles.set(node, handles);
  return handles;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.59.1/node_modules/svelte-dnd-action/src/action.js
function dndzone3(node, options) {
  validateOptions(options);
  const pointerZone = dndzone(node, options);
  const keyboardZone = dndzone2(node, options);
  return {
    update: (newOptions) => {
      validateOptions(newOptions);
      pointerZone.update(newOptions);
      keyboardZone.update(newOptions);
    },
    destroy: () => {
      pointerZone.destroy();
      keyboardZone.destroy();
    }
  };
}
function validateOptions(options) {
  const {
    items,
    flipDurationMs,
    type,
    dragDisabled,
    morphDisabled,
    dropFromOthersDisabled,
    zoneTabIndex,
    dropTargetStyle,
    dropTargetClasses,
    transformDraggedElement,
    autoAriaDisabled,
    centreDraggedOnCursor,
    ...rest
  } = options;
  if (Object.keys(rest).length > 0) {
    console.warn(`dndzone will ignore unknown options`, rest);
  }
  if (!items) {
    throw new Error("no 'items' key provided to dndzone");
  }
  const itemWithMissingId = items.find((item) => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));
  if (itemWithMissingId) {
    throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);
  }
  if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {
    throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);
  }
  if (zoneTabIndex && !isInt(zoneTabIndex)) {
    throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);
  }
}
function isInt(value) {
  return !isNaN(value) && function(x) {
    return (x | 0) === x;
  }(parseFloat(value));
}

// src/gui/choiceList/ChoiceList.svelte
function add_css4(target) {
  append_styles(target, "svelte-jb273g", ".choiceList.svelte-jb273g{width:auto;border:0 solid black;overflow-y:auto;height:auto}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  let multichoicelistitem;
  let updating_dragDisabled;
  let updating_collapseId;
  let updating_choice;
  let current;
  function multichoicelistitem_dragDisabled_binding(value) {
    ctx[14](value);
  }
  function multichoicelistitem_collapseId_binding(value) {
    ctx[15](value);
  }
  function multichoicelistitem_choice_binding(value) {
    ctx[16](
      value,
      /*choice*/
      ctx[23],
      /*each_value*/
      ctx[24],
      /*choice_index*/
      ctx[25]
    );
  }
  let multichoicelistitem_props = {};
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    multichoicelistitem_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*collapseId*/
    ctx[2] !== void 0
  ) {
    multichoicelistitem_props.collapseId = /*collapseId*/
    ctx[2];
  }
  if (
    /*choice*/
    ctx[23] !== void 0
  ) {
    multichoicelistitem_props.choice = /*choice*/
    ctx[23];
  }
  multichoicelistitem = new MultiChoiceListItem_default({ props: multichoicelistitem_props });
  binding_callbacks.push(() => bind(multichoicelistitem, "dragDisabled", multichoicelistitem_dragDisabled_binding));
  binding_callbacks.push(() => bind(multichoicelistitem, "collapseId", multichoicelistitem_collapseId_binding));
  binding_callbacks.push(() => bind(multichoicelistitem, "choice", multichoicelistitem_choice_binding));
  multichoicelistitem.$on(
    "mousedown",
    /*startDrag*/
    ctx[6]
  );
  multichoicelistitem.$on(
    "touchstart",
    /*startDrag*/
    ctx[6]
  );
  multichoicelistitem.$on(
    "deleteChoice",
    /*deleteChoice_handler_1*/
    ctx[17]
  );
  multichoicelistitem.$on(
    "configureChoice",
    /*configureChoice_handler_1*/
    ctx[18]
  );
  multichoicelistitem.$on(
    "toggleCommand",
    /*toggleCommand_handler_1*/
    ctx[19]
  );
  multichoicelistitem.$on(
    "duplicateChoice",
    /*duplicateChoice_handler_1*/
    ctx[20]
  );
  return {
    c() {
      create_component(multichoicelistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multichoicelistitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const multichoicelistitem_changes = {};
      if (!updating_dragDisabled && dirty & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        multichoicelistitem_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_collapseId && dirty & /*collapseId*/
      4) {
        updating_collapseId = true;
        multichoicelistitem_changes.collapseId = /*collapseId*/
        ctx[2];
        add_flush_callback(() => updating_collapseId = false);
      }
      if (!updating_choice && dirty & /*choices, SHADOW_PLACEHOLDER_ITEM_ID*/
      3) {
        updating_choice = true;
        multichoicelistitem_changes.choice = /*choice*/
        ctx[23];
        add_flush_callback(() => updating_choice = false);
      }
      multichoicelistitem.$set(multichoicelistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multichoicelistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multichoicelistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multichoicelistitem, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let choicelistitem;
  let updating_dragDisabled;
  let updating_choice;
  let current;
  function choicelistitem_dragDisabled_binding(value) {
    ctx[8](value);
  }
  function choicelistitem_choice_binding(value) {
    ctx[9](
      value,
      /*choice*/
      ctx[23],
      /*each_value*/
      ctx[24],
      /*choice_index*/
      ctx[25]
    );
  }
  let choicelistitem_props = {};
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    choicelistitem_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*choice*/
    ctx[23] !== void 0
  ) {
    choicelistitem_props.choice = /*choice*/
    ctx[23];
  }
  choicelistitem = new ChoiceListItem_default({ props: choicelistitem_props });
  binding_callbacks.push(() => bind(choicelistitem, "dragDisabled", choicelistitem_dragDisabled_binding));
  binding_callbacks.push(() => bind(choicelistitem, "choice", choicelistitem_choice_binding));
  choicelistitem.$on(
    "mousedown",
    /*startDrag*/
    ctx[6]
  );
  choicelistitem.$on(
    "touchstart",
    /*startDrag*/
    ctx[6]
  );
  choicelistitem.$on(
    "deleteChoice",
    /*deleteChoice_handler*/
    ctx[10]
  );
  choicelistitem.$on(
    "configureChoice",
    /*configureChoice_handler*/
    ctx[11]
  );
  choicelistitem.$on(
    "toggleCommand",
    /*toggleCommand_handler*/
    ctx[12]
  );
  choicelistitem.$on(
    "duplicateChoice",
    /*duplicateChoice_handler*/
    ctx[13]
  );
  return {
    c() {
      create_component(choicelistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(choicelistitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const choicelistitem_changes = {};
      if (!updating_dragDisabled && dirty & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        choicelistitem_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_choice && dirty & /*choices, SHADOW_PLACEHOLDER_ITEM_ID*/
      3) {
        updating_choice = true;
        choicelistitem_changes.choice = /*choice*/
        ctx[23];
        add_flush_callback(() => updating_choice = false);
      }
      choicelistitem.$set(choicelistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(choicelistitem, detaching);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*choice*/
      ctx2[23].type !== "Multi"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment7(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_style_value;
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*choices*/
    ctx[0].filter(
      /*func*/
      ctx[7]
    )
  );
  const get_key = (ctx2) => (
    /*choice*/
    ctx2[23].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "choiceList svelte-jb273g");
      attr(div, "style", div_style_value = /*choices*/
      ctx[0].length === 0 ? "padding-bottom: 0.5rem" : "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone3.call(null, div, {
            items: (
              /*choices*/
              ctx[0]
            ),
            dragDisabled: (
              /*dragDisabled*/
              ctx[3]
            ),
            dropTargetStyle: {}
          })),
          listen(
            div,
            "consider",
            /*handleConsider*/
            ctx[4]
          ),
          listen(
            div,
            "finalize",
            /*handleSort*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dragDisabled, choices, SHADOW_PLACEHOLDER_ITEM_ID, startDrag, collapseId*/
      79) {
        each_value = /*choices*/
        ctx2[0].filter(
          /*func*/
          ctx2[7]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty & /*choices*/
      1 && div_style_value !== (div_style_value = /*choices*/
      ctx2[0].length === 0 ? "padding-bottom: 0.5rem" : "")) {
        attr(div, "style", div_style_value);
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & /*choices, dragDisabled*/
      9)
        dndzone_action.update.call(null, {
          items: (
            /*choices*/
            ctx2[0]
          ),
          dragDisabled: (
            /*dragDisabled*/
            ctx2[3]
          ),
          dropTargetStyle: {}
        });
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { choices = [] } = $$props;
  let collapseId;
  let dragDisabled = true;
  const dispatcher = createEventDispatcher();
  function emitChoicesReordered() {
    dispatcher("reorderChoices", { choices });
  }
  function handleConsider(e) {
    let { items: newItems, info: { id } } = e.detail;
    $$invalidate(2, collapseId = id);
    $$invalidate(0, choices = newItems);
  }
  function handleSort(e) {
    let { items: newItems, info: { source } } = e.detail;
    $$invalidate(2, collapseId = "");
    $$invalidate(0, choices = newItems);
    if (source === SOURCES.POINTER) {
      $$invalidate(3, dragDisabled = true);
    }
    emitChoicesReordered();
  }
  function startDrag(e) {
    e.preventDefault();
    $$invalidate(3, dragDisabled = false);
  }
  const func = (c) => c.id !== SHADOW_PLACEHOLDER_ITEM_ID;
  function choicelistitem_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function choicelistitem_choice_binding(value, choice, each_value, choice_index) {
    each_value[choice_index] = value;
    $$invalidate(0, choices);
  }
  function deleteChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function multichoicelistitem_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function multichoicelistitem_collapseId_binding(value) {
    collapseId = value;
    $$invalidate(2, collapseId);
  }
  function multichoicelistitem_choice_binding(value, choice, each_value, choice_index) {
    each_value[choice_index] = value;
    $$invalidate(0, choices);
  }
  function deleteChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choices" in $$props2)
      $$invalidate(0, choices = $$props2.choices);
  };
  return [
    choices,
    SHADOW_PLACEHOLDER_ITEM_ID,
    collapseId,
    dragDisabled,
    handleConsider,
    handleSort,
    startDrag,
    func,
    choicelistitem_dragDisabled_binding,
    choicelistitem_choice_binding,
    deleteChoice_handler,
    configureChoice_handler,
    toggleCommand_handler,
    duplicateChoice_handler,
    multichoicelistitem_dragDisabled_binding,
    multichoicelistitem_collapseId_binding,
    multichoicelistitem_choice_binding,
    deleteChoice_handler_1,
    configureChoice_handler_1,
    toggleCommand_handler_1,
    duplicateChoice_handler_1
  ];
}
var ChoiceList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { choices: 0 }, add_css4);
  }
};
var ChoiceList_default = ChoiceList;

// src/gui/choiceList/AddChoiceBox.svelte
var import_obsidian3 = require("obsidian");
function add_css5(target) {
  append_styles(target, "svelte-1newuee", ".addChoiceBox.svelte-1newuee{margin-top:1em;display:flex;flex-direction:row;align-items:center;gap:10px;justify-content:center}@media(max-width: 800px){.addChoiceBox.svelte-1newuee{flex-direction:column}}#addChoiceTypeSelector.svelte-1newuee{font-size:16px;padding:3px;border-radius:3px}");
}
function create_fragment8(ctx) {
  let div;
  let input;
  let t0;
  let select;
  let option0;
  let option0_value_value;
  let option1;
  let option1_value_value;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${"Template"}`;
      option1 = element("option");
      option1.textContent = `${"Capture"}`;
      option2 = element("option");
      option2.textContent = `${"Macro"}`;
      option3 = element("option");
      option3.textContent = `${"Multi"}`;
      t5 = space();
      button = element("button");
      button.textContent = "Add Choice";
      attr(input, "type", "text");
      attr(input, "placeholder", "Name");
      option0.__value = option0_value_value = "Template";
      option0.value = option0.__value;
      option1.__value = option1_value_value = "Capture";
      option1.value = option1.__value;
      option2.__value = option2_value_value = "Macro";
      option2.value = option2.__value;
      option3.__value = option3_value_value = "Multi";
      option3.value = option3.__value;
      attr(select, "id", "addChoiceTypeSelector");
      attr(select, "class", "svelte-1newuee");
      if (
        /*type*/
        ctx[1] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      attr(button, "class", "mod-cta");
      attr(div, "class", "addChoiceBox svelte-1newuee");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*name*/
        ctx[0]
      );
      append(div, t0);
      append(div, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*type*/
        ctx[1],
        true
      );
      append(div, t5);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*addChoice*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      1 && input.value !== /*name*/
      ctx2[0]) {
        set_input_value(
          input,
          /*name*/
          ctx2[0]
        );
      }
      if (dirty & /*type*/
      2) {
        select_option(
          select,
          /*type*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let name;
  let type;
  const dispatch = createEventDispatcher();
  function addChoice() {
    if (!name) {
      new import_obsidian3.Notice("Choice name is invalid.");
      return;
    }
    dispatch("addChoice", { name, type });
    $$invalidate(0, name = "");
  }
  function input_input_handler() {
    name = this.value;
    $$invalidate(0, name);
  }
  function select_change_handler() {
    type = select_value(this);
    $$invalidate(1, type);
  }
  return [name, type, addChoice, input_input_handler, select_change_handler];
}
var AddChoiceBox = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {}, add_css5);
  }
};
var AddChoiceBox_default = AddChoiceBox;

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/types/choices/Choice.ts
var Choice = class {
  constructor(name, type) {
    this.id = v4_default();
    this.name = name;
    this.type = type;
    this.command = false;
  }
};

// src/types/choices/TemplateChoice.ts
var TemplateChoice = class extends Choice {
  constructor(name) {
    super(name, "Template");
    this.templatePath = "";
    this.fileNameFormat = { enabled: false, format: "" };
    this.folder = {
      enabled: false,
      folders: [],
      chooseWhenCreatingNote: false,
      createInSameFolderAsActiveFile: false,
      chooseFromSubfolders: false
    };
    this.appendLink = false;
    this.openFileInNewTab = {
      enabled: false,
      direction: "vertical" /* vertical */,
      focus: true
    };
    this.openFile = false;
    this.openFileInMode = "default";
    this.fileExistsMode = "Increment the file name";
    this.setFileExistsBehavior = false;
  }
  static Load(choice) {
    return choice;
  }
};

// src/types/choices/MacroChoice.ts
var MacroChoice = class extends Choice {
  constructor(name) {
    super(name, "Macro");
    this.macroId = "";
  }
};

// src/types/choices/CaptureChoice.ts
var CaptureChoice = class extends Choice {
  constructor(name) {
    super(name, "Capture");
    this.appendLink = false;
    this.captureTo = "";
    this.captureToActiveFile = false;
    this.createFileIfItDoesntExist = {
      enabled: false,
      createWithTemplate: false,
      template: ""
    };
    this.format = { enabled: false, format: "" };
    this.insertAfter = {
      enabled: false,
      after: "",
      insertAtEnd: false,
      considerSubsections: false,
      createIfNotFound: false,
      createIfNotFoundLocation: "top"
    };
    this.prepend = false;
    this.task = false;
    this.openFileInNewTab = {
      enabled: false,
      direction: "vertical" /* vertical */,
      focus: true
    };
    this.openFile = false;
    this.openFileInMode = "default";
  }
  static Load(choice) {
    return choice;
  }
};

// src/types/choices/MultiChoice.ts
var MultiChoice = class extends Choice {
  constructor(name) {
    super(name, "Multi");
    this.choices = [];
  }
  addChoice(choice) {
    this.choices.push(choice);
    return this;
  }
  addChoices(choices) {
    this.choices.push(...choices);
    return this;
  }
};

// src/gui/GenericYesNoPrompt/GenericYesNoPrompt.ts
var import_obsidian4 = require("obsidian");
var GenericYesNoPrompt = class extends import_obsidian4.Modal {
  constructor(app2, header, text2) {
    super(app2);
    this.header = header;
    this.text = text2;
    this.didSubmit = false;
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.open();
    this.display();
  }
  static Prompt(app2, header, text2) {
    const newPromptModal = new GenericYesNoPrompt(app2, header, text2);
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaYesNoPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    this.contentEl.createEl("p", { text: this.text });
    const buttonsDiv = this.contentEl.createDiv({
      cls: "yesNoPromptButtonContainer"
    });
    const noButton = new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("No").onClick(() => this.submit(false));
    const yesButton = new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("Yes").onClick(() => this.submit(true)).setWarning();
    yesButton.buttonEl.focus();
    addArrowKeyNavigation([noButton.buttonEl, yesButton.buttonEl]);
  }
  submit(input) {
    this.input = input;
    this.didSubmit = true;
    this.close();
  }
  onClose() {
    super.onClose();
    if (!this.didSubmit)
      this.rejectPromise("No answer given.");
    else
      this.resolvePromise(this.input);
  }
};
function addArrowKeyNavigation(buttons) {
  buttons.forEach((button) => {
    button.addEventListener("keydown", (event) => {
      if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
        const currentIndex = buttons.indexOf(button);
        const nextIndex = (currentIndex + (event.key === "ArrowRight" ? 1 : -1) + buttons.length) % buttons.length;
        buttons[nextIndex].focus();
        event.preventDefault();
      }
    });
  });
}

// src/gui/ChoiceBuilder/choiceBuilder.ts
var import_obsidian7 = require("obsidian");

// src/gui/GenericInputPrompt/GenericInputPrompt.ts
var import_obsidian6 = require("obsidian");

// src/gui/suggesters/suggest.ts
var import_obsidian5 = require("obsidian");

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next3 = child;
    do {
      if (next3 && parent.isSameNode(next3)) {
        return true;
      }
      next3 = next3.parentNode || next3.host;
    } while (next3);
  }
  return false;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance17 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance17.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance17.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance17.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance17.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance17 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance17.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance17
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance17.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance17;
    }
    instance17.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance17,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance17;
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.7/node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/gui/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion?.removeClass("is-selected");
    selectedSuggestion?.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app2, inputEl) {
    this.app = app2;
    this.inputEl = inputEl;
    this.scope = new import_obsidian5.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance: instance17 }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            void instance17.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/constants.ts
var VALUE_SYNTAX = "{{value}}";
var DATE_SYNTAX = "{{date}}";
var TIME_SYNTAX = "{{time}}";
var NAME_SYNTAX = "{{name}}";
var VARIABLE_SYNTAX = "{{value:<variable name>}}";
var FIELD_VAR_SYNTAX = "{{field:<field name>}}";
var MATH_VALUE_SYNTAX = "{{mvalue}}";
var LINKCURRENT_SYNTAX = "{{linkcurrent}}";
var SELECTED_SYNTAX = "{{selected}}";
var FILE_NAME_FORMAT_SYNTAX = [
  DATE_SYNTAX,
  "{{date:<dateformat>}}",
  "{{vdate:<variable name>, <date format>}}",
  VALUE_SYNTAX,
  NAME_SYNTAX,
  VARIABLE_SYNTAX,
  FIELD_VAR_SYNTAX
];
var FILE_NUMBER_REGEX = new RegExp(/([0-9]*)\.md$/);
var NUMBER_REGEX = new RegExp(/^-?[0-9]*$/);
var CREATE_IF_NOT_FOUND_TOP = "top";
var CREATE_IF_NOT_FOUND_BOTTOM = "bottom";
var DATE_REGEX = new RegExp(/{{DATE(\+-?[0-9]+)?}}/i);
var DATE_REGEX_FORMATTED = new RegExp(
  /{{DATE:([^}\n\r+]*)(\+-?[0-9]+)?}}/i
);
var TIME_REGEX = new RegExp(/{{TIME}}/i);
var TIME_REGEX_FORMATTED = new RegExp(/{{TIME:([^}\n\r+]*)}}/i);
var NAME_VALUE_REGEX = new RegExp(/{{NAME}}|{{VALUE}}/i);
var VARIABLE_REGEX = new RegExp(/{{VALUE:([^\n\r}]*)}}/i);
var FIELD_VAR_REGEX = new RegExp(/{{FIELD:([^\n\r}]*)}}/i);
var DATE_VARIABLE_REGEX = new RegExp(
  /{{VDATE:([^\n\r},]*),\s*([^\n\r},]*)}}/i
);
var LINK_TO_CURRENT_FILE_REGEX = new RegExp(
  /{{LINKCURRENT}}/i
);
var MARKDOWN_FILE_EXTENSION_REGEX = new RegExp(/\.md$/);
var JAVASCRIPT_FILE_EXTENSION_REGEX = new RegExp(/\.js$/);
var MACRO_REGEX = new RegExp(/{{MACRO:([^\n\r}]*)}}/i);
var TEMPLATE_REGEX = new RegExp(
  /{{TEMPLATE:([^\n\r}]*.md)}}/i
);
var LINEBREAK_REGEX = new RegExp(/\\n/);
var INLINE_JAVASCRIPT_REGEX = new RegExp(
  /`{3,}js quickadd([\s\S]*?)`{3,}/
);
var MATH_VALUE_REGEX = new RegExp(/{{MVALUE}}/i);
var TITLE_REGEX = new RegExp(/{{TITLE}}/i);
var SELECTED_REGEX = new RegExp(/{{SELECTED}}/i);
var FILE_LINK_REGEX = new RegExp(/\[\[([^\]]*)$/);
var TAG_REGEX = new RegExp(/#([^ ]*)$/);
var DATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[D]?[A]?[T]?[E]?[}]?[}]?$/i
);
var DATE_FORMAT_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[D]?[A]?[T]?[E]?[:]?$|{{DATE:[^\n\r}]*}}$/i
);
var NAME_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[N]?[A]?[M]?[E]?[}]?[}]?$/i
);
var VALUE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[A]?[L]?[U]?[E]?[}]?[}]?$/i
);
var VARIABLE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[A]?[L]?[U]?[E]?[:]?$|{{VALUE:[^\n\r}]*}}$/i
);
var VARIABLE_DATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[D]?[A]?[T]?[E]?[:]?$|{{VDATE:[^\n\r}]*}}$/i
);
var LINKCURRENT_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[L]?[I]?[N]?[K]?[C]?[U]?[R]?[R]?[E]?[N]?[T]?[}]?[}]?$/i
);
var TEMPLATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[T]?[E]?[M]?[P]?[L]?[A]?[T]?[E]?[:]?$|{{TEMPLATE:[^\n\r}]*[}]?[}]?$/i
);
var MACRO_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[M]?[A]?[C]?[R]?[O]?[:]?$|{{MACRO:[^\n\r}]*}}$/i
);
var MATH_VALUE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[M]?[V]?[A]?[L]?[U]?[E]?[}]?[}]?/i
);
var TITLE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[T]?[I]?[T]?[L]?[E]?[}]?[}]?/i
);
var SELECTED_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[S]?[E]?[L]?[E]?[C]?[T]?[E]?[D]?[}]?[}]?/i
);
var TIME_SYNTAX_SUGGEST_REGEX = new RegExp(/{{[T]?[I]?[M]?[E]?[}]?[}]?/i);
var TIME_FORMAT_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[T]?[I]?[M]?[E]?[:]?$|{{TIME:[^\n\r}]*}}$/i
);
var fileExistsIncrement = "Increment the file name";
var fileExistsAppendToBottom = "Append to the bottom of the file";
var fileExistsAppendToTop = "Append to the top of the file";
var fileExistsOverwriteFile = "Overwrite the file";
var fileExistsDoNothing = "Nothing";
var fileExistsChoices = [
  fileExistsAppendToBottom,
  fileExistsAppendToTop,
  fileExistsOverwriteFile,
  fileExistsIncrement,
  fileExistsDoNothing
];
var WIKI_LINK_REGEX = new RegExp(/\[\[([^\]]*)\]\]/);

// node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString2(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end2 = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start2 === -1) {
      start2 = i;
    } else if (!match && start2 !== -1) {
      end2 = i - 1;
      if (end2 - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end2]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
    indices.push([start2, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end2 = len - remainder;
      while (i < end2) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto: auto2 = true } = {}) {
  const next3 = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next3(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next3(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next3(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/gui/suggesters/fileSuggester.ts
var SuggestionMap = class extends Map {
};
function buildFileMap(files, unresolvedLinkNames) {
  const fileMap = new SuggestionMap();
  for (const file of files) {
    fileMap.set(file.path, {
      file,
      type: 0 /* File */
    });
    for (const alias of file.alias) {
      fileMap.set(alias, {
        file,
        type: 1 /* Alias */
      });
    }
  }
  for (const unresolvedLinkName of unresolvedLinkNames) {
    fileMap.set(unresolvedLinkName, {
      type: 2 /* Unresolved */
    });
  }
  return fileMap;
}
function getAliasesForFile(file, app2) {
  const fileMetadata = app2.metadataCache.getFileCache(file);
  const fileMetaAlias = fileMetadata?.frontmatter?.alias ?? fileMetadata?.frontmatter?.aliases ?? "";
  const aliases = [];
  if (typeof fileMetaAlias === "string" && fileMetaAlias) {
    aliases.push(fileMetaAlias);
  } else if (Array.isArray(fileMetaAlias)) {
    const filteredAliases = fileMetaAlias.filter(
      (v) => v && typeof v === "string"
    );
    if (filteredAliases.length) {
      aliases.push(...filteredAliases);
    }
  }
  return { ...file, alias: aliases };
}
var SilentFileSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.lastInput = "";
    const filesAndAliases = app2.vault.getMarkdownFiles().map((file) => getAliasesForFile(file, app2));
    const unresolvedLinkNames = this.getUnresolvedLinkNames(app2);
    const fileAndAliasMap = buildFileMap(
      filesAndAliases,
      unresolvedLinkNames
    );
    this.fileNames = [...fileAndAliasMap.keys()];
    this.fileMap = fileAndAliasMap;
  }
  getSuggestions(inputStr) {
    if (this.inputEl.selectionStart === null)
      return [];
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const fileLinkMatch = FILE_LINK_REGEX.exec(inputBeforeCursor);
    if (!fileLinkMatch) {
      return [];
    }
    const fileNameInput = fileLinkMatch[1];
    this.lastInput = fileNameInput;
    const fuse = new Fuse(this.fileNames, {
      findAllMatches: true,
      shouldSort: true,
      isCaseSensitive: false,
      minMatchCharLength: 1,
      threshold: 0.3
    });
    const MAX_ITEMS = 50;
    const search2 = fuse.search(this.lastInput).slice(0, MAX_ITEMS).map((value) => value.item);
    return search2;
  }
  renderSuggestion(item, el) {
    const suggestionItem = this.fileMap.get(item);
    if (suggestionItem === void 0) {
      el.innerHTML = `
				<span class="suggestion-main-text">${item}</span>
				<span class="suggestion-sub-text">Unknown</span>
			`;
    } else {
      switch (suggestionItem.type) {
        case 0 /* File */:
          el.innerHTML = `
                    <span class="suggestion-main-text">${suggestionItem?.file?.basename}</span>
                    <span class="suggestion-sub-text">${suggestionItem?.file?.path}</span>
                `;
          break;
        case 1 /* Alias */:
          el.innerHTML = `
                    <span class="suggestion-main-text">${item}</span>
                    <span class="suggestion-sub-text">${suggestionItem?.file?.path}</span>
                `;
          break;
        case 2 /* Unresolved */:
          el.innerHTML = `
                    <span class="suggestion-main-text">${item}</span>
                    <span class="suggestion-sub-text">Unresolved link</span>
                `;
          break;
        default:
          break;
      }
    }
    el.classList.add("qaFileSuggestionItem");
  }
  selectSuggestion(item) {
    if (this.inputEl.selectionStart === null)
      return;
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const suggestionItem = this.fileMap.get(item);
    if (suggestionItem !== void 0 && suggestionItem.file !== void 0) {
      if (suggestionItem.type === 0 /* File */) {
        insertedEndPosition = this.makeLinkObsidianMethod(
          suggestionItem.file,
          currentInputValue,
          cursorPosition,
          lastInputLength
        );
      } else if (suggestionItem.type === 1 /* Alias */) {
        insertedEndPosition = this.makeLinkObsidianMethod(
          suggestionItem.file,
          currentInputValue,
          cursorPosition,
          lastInputLength,
          item
        );
      }
    } else {
      insertedEndPosition = this.makeLinkManually(
        currentInputValue,
        item.replace(/.md$/, ""),
        cursorPosition,
        lastInputLength
      );
    }
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  makeLinkObsidianMethod(linkFile, currentInputValue, cursorPosition, lastInputLength, alias) {
    const file = this.app.vault.getAbstractFileByPath(
      linkFile.path
    );
    const link = this.app.fileManager.generateMarkdownLink(
      file,
      "",
      "",
      alias ?? ""
    );
    this.inputEl.value = this.getNewInputValueForFileLink(
      currentInputValue,
      link,
      cursorPosition,
      lastInputLength
    );
    return cursorPosition - lastInputLength + link.length + 2;
  }
  makeLinkManually(currentInputValue, item, cursorPosition, lastInputLength) {
    this.inputEl.value = this.getNewInputValueForFileName(
      currentInputValue,
      item,
      cursorPosition,
      lastInputLength
    );
    return cursorPosition - lastInputLength + item.length + 2;
  }
  getNewInputValueForFileLink(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength - 2
    )}${selectedItem}${currentInputElValue.substr(cursorPosition)}`;
  }
  getNewInputValueForFileName(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength
    )}${selectedItem}]]${currentInputElValue.substr(cursorPosition)}`;
  }
  getUnresolvedLinkNames(app2) {
    const unresolvedLinks = app2.metadataCache.unresolvedLinks;
    const unresolvedLinkNames = /* @__PURE__ */ new Set();
    for (const sourceFileName in unresolvedLinks) {
      for (const unresolvedLink in unresolvedLinks[sourceFileName]) {
        unresolvedLinkNames.add(unresolvedLink);
      }
    }
    return Array.from(unresolvedLinkNames);
  }
};

// src/gui/suggesters/tagSuggester.ts
var SilentTagSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.lastInput = "";
    this.tags = Object.keys(app2.metadataCache.getTags());
  }
  getSuggestions(inputStr) {
    if (this.inputEl.selectionStart === null) {
      return [];
    }
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const tagMatch = TAG_REGEX.exec(inputBeforeCursor);
    if (!tagMatch) {
      return [];
    }
    const tagInput = tagMatch[1];
    this.lastInput = tagInput;
    const suggestions = this.tags.filter(
      (tag) => tag.toLowerCase().contains(tagInput.toLowerCase())
    );
    const fuse = new Fuse(suggestions, {
      findAllMatches: true,
      threshold: 0.8
    });
    const search2 = fuse.search(this.lastInput).map((value) => value.item);
    return search2;
  }
  renderSuggestion(item, el) {
    el.setText(item);
  }
  selectSuggestion(item) {
    if (!this.inputEl.selectionStart)
      return;
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    this.inputEl.value = this.getNewInputValueForTag(
      currentInputValue,
      item,
      cursorPosition,
      lastInputLength
    );
    insertedEndPosition = cursorPosition - lastInputLength + item.length - 1;
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  getNewInputValueForTag(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength - 1
    )}${selectedItem}${currentInputElValue.substr(cursorPosition)}`;
  }
};

// src/gui/GenericInputPrompt/GenericInputPrompt.ts
var GenericInputPrompt = class extends import_obsidian6.Modal {
  constructor(app2, header, placeholder, value) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.submitEnterCallback = (evt) => {
      if (!evt.isComposing && evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.placeholder = placeholder ?? "";
    this.input = value ?? "";
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
    this.fileSuggester = new SilentFileSuggester(
      app2,
      this.inputComponent.inputEl
    );
    this.tagSuggester = new SilentTagSuggester(
      app2,
      this.inputComponent.inputEl
    );
  }
  static Prompt(app2, header, placeholder, value) {
    const newPromptModal = new GenericInputPrompt(
      app2,
      header,
      placeholder,
      value
    );
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaInputPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    const mainContentContainer = this.contentEl.createDiv();
    this.inputComponent = this.createInputField(
      mainContentContainer,
      this.placeholder,
      this.input
    );
    this.createButtonBar(mainContentContainer);
  }
  createInputField(container, placeholder, value) {
    const textComponent = new import_obsidian6.TextComponent(container);
    textComponent.inputEl.style.width = "100%";
    textComponent.setPlaceholder(placeholder ?? "").setValue(value ?? "").onChange((value2) => this.input = value2).inputEl.addEventListener("keydown", this.submitEnterCallback);
    return textComponent;
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian6.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(this.input);
  }
  removeInputListener() {
    this.inputComponent.inputEl.removeEventListener(
      "keydown",
      this.submitEnterCallback
    );
  }
  onOpen() {
    super.onOpen();
    this.inputComponent.inputEl.focus();
    this.inputComponent.inputEl.select();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
};

// src/logger/logManager.ts
var _LogManager = class {
  register(logger) {
    _LogManager.loggers.push(logger);
    return this;
  }
  logError(message) {
    _LogManager.loggers.forEach((logger) => logger.logError(message));
  }
  logWarning(message) {
    _LogManager.loggers.forEach((logger) => logger.logError(message));
  }
  logMessage(message) {
    _LogManager.loggers.forEach((logger) => logger.logMessage(message));
  }
};
var LogManager = _LogManager;
LogManager.loggers = [];
var log = new LogManager();

// src/gui/suggesters/genericTextSuggester.ts
var GenericTextSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, items, maxSuggestions = Infinity) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.items = items;
    this.maxSuggestions = maxSuggestions;
  }
  getSuggestions(inputStr) {
    const inputLowerCase = inputStr.toLowerCase();
    const filtered = this.items.filter((item) => {
      if (item.toLowerCase().contains(inputLowerCase))
        return item;
    });
    if (!filtered)
      this.close();
    const limited = filtered.slice(0, this.maxSuggestions);
    return limited;
  }
  selectSuggestion(item) {
    this.inputEl.value = item;
    this.inputEl.trigger("input");
    this.close();
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
};

// src/gui/ChoiceBuilder/choiceBuilder.ts
var ChoiceBuilder = class extends import_obsidian7.Modal {
  constructor(app2) {
    super(app2);
    this.didSubmit = false;
    this.svelteElements = [];
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.containerEl.addClass("quickAddModal");
    this.open();
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addFileSearchInputToSetting(setting, value, onChangeCallback) {
    setting.addSearch((searchComponent) => {
      searchComponent.setValue(value);
      searchComponent.setPlaceholder("File path");
      const markdownFiles = this.app.vault.getMarkdownFiles().map((f) => f.path);
      new GenericTextSuggester(
        this.app,
        searchComponent.inputEl,
        markdownFiles
      );
      searchComponent.onChange(onChangeCallback);
    });
    return;
  }
  addCenteredChoiceNameHeader(choice) {
    const headerEl = this.contentEl.createEl("h2", {
      cls: "choiceNameHeader"
    });
    headerEl.setText(choice.name);
    headerEl.addEventListener("click", async (ev) => {
      try {
        const newName = await GenericInputPrompt.Prompt(
          this.app,
          choice.name,
          "Choice name",
          choice.name
        );
        if (newName !== choice.name) {
          choice.name = newName;
          headerEl.setText(newName);
        }
      } catch (e) {
        log.logMessage(`No new name given for ${choice.name}`);
      }
    });
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.choice);
    this.svelteElements.forEach((el) => {
      if (el && el.$destroy)
        el.$destroy();
    });
    if (!this.didSubmit)
      this.rejectPromise("No answer given.");
    else
      this.resolvePromise(this.input);
  }
};

// src/gui/ChoiceBuilder/templateChoiceBuilder.ts
var import_obsidian9 = require("obsidian");

// src/gui/ChoiceBuilder/FolderList.svelte
function add_css6(target) {
  append_styles(target, "svelte-tuapcq", ".quickAddCommandListItem.svelte-tuapcq{display:flex;align-items:center;justify-content:space-between}@media(min-width: 768px){.quickAddFolderListGrid.svelte-tuapcq{display:grid;grid-template-columns:repeat(2, 1fr);column-gap:20px}}.quickAddCommandList.svelte-tuapcq{max-width:50%;margin:12px auto}.clickable.svelte-tuapcq{cursor:pointer}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  child_ctx[6] = i;
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let span0;
  let t0_value = (
    /*folder*/
    ctx[4] + ""
  );
  let t0;
  let t1;
  let span1;
  let icon;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faTrash } });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*folder*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      create_component(icon.$$.fragment);
      t2 = space();
      attr(span1, "class", "clickable svelte-tuapcq");
      attr(div, "class", "quickAddCommandListItem svelte-tuapcq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      mount_component(icon, span1, null);
      append(div, t2);
      current = true;
      if (!mounted) {
        dispose = listen(span1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*folders*/
      1) && t0_value !== (t0_value = /*folder*/
      ctx[4] + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let current;
  let each_value = (
    /*folders*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "quickAddFolderListGrid quickAddCommandList svelte-tuapcq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*deleteFolder, folders, faTrash*/
      3) {
        each_value = /*folders*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { folders } = $$props;
  let { deleteFolder } = $$props;
  const updateFolders = (newFolders) => {
    $$invalidate(0, folders = newFolders);
  };
  const click_handler = (folder) => deleteFolder(folder);
  $$self.$$set = ($$props2) => {
    if ("folders" in $$props2)
      $$invalidate(0, folders = $$props2.folders);
    if ("deleteFolder" in $$props2)
      $$invalidate(1, deleteFolder = $$props2.deleteFolder);
  };
  return [folders, deleteFolder, updateFolders, click_handler];
}
var FolderList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        folders: 0,
        deleteFolder: 1,
        updateFolders: 2
      },
      add_css6
    );
  }
  get updateFolders() {
    return this.$$.ctx[2];
  }
};
var FolderList_default = FolderList;

// src/utilityObsidian.ts
var import_obsidian8 = require("obsidian");
function getTemplater(app2) {
  return app2.plugins.plugins["templater-obsidian"];
}
async function replaceTemplaterTemplatesInCreatedFile(app2, file, force = false) {
  const templater = getTemplater(app2);
  if (templater && (force || !templater.settings["trigger_on_file_creation"])) {
    const impl = templater?.templater;
    if (impl?.overwrite_file_commands) {
      await impl.overwrite_file_commands(file);
    }
  }
}
async function templaterParseTemplate(app2, templateContent, targetFile) {
  const templater = getTemplater(app2);
  if (!templater)
    return templateContent;
  return await templater.templater.parse_template({ target_file: targetFile, run_mode: 4 }, templateContent);
}
function getNaturalLanguageDates(app2) {
  return app2.plugins.plugins["nldates-obsidian"];
}
function getDate(input) {
  let duration;
  if (input?.offset !== null && input?.offset !== void 0 && typeof input.offset === "number") {
    duration = window.moment.duration(input.offset, "days");
  }
  return input?.format ? window.moment().add(duration).format(input.format) : window.moment().add(duration).format("YYYY-MM-DD");
}
function appendToCurrentLine(toAppend, app2) {
  try {
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView) {
      log.logError(`unable to append '${toAppend}' to current line.`);
      return;
    }
    activeView.editor.replaceSelection(toAppend);
  } catch {
    log.logError(`unable to append '${toAppend}' to current line.`);
  }
}
function findObsidianCommand(app2, commandId) {
  return app2.commands.findCommand(commandId);
}
function deleteObsidianCommand(app2, commandId) {
  if (findObsidianCommand(app2, commandId)) {
    delete app2.commands.commands[commandId];
    delete app2.commands.editorCommands[commandId];
  }
}
function getAllFolderPathsInVault(app2) {
  return app2.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian8.TFolder).map((folder) => folder.path);
}
function getUserScriptMemberAccess(fullMemberPath) {
  const fullMemberArray = fullMemberPath.split("::");
  return {
    basename: fullMemberArray[0],
    memberAccess: fullMemberArray.slice(1)
  };
}
async function openFile(app2, file, optional) {
  let leaf;
  if (optional.openInNewTab && optional.direction) {
    leaf = app2.workspace.getLeaf("split", optional.direction);
  } else {
    leaf = app2.workspace.getLeaf("tab");
  }
  await leaf.openFile(file);
  if (optional?.focus) {
    app2.workspace.setActiveLeaf(leaf, { focus: optional.focus });
  }
  if (optional?.mode) {
    const leafViewState = leaf.getViewState();
    await leaf.setViewState({
      ...leafViewState,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      state: {
        ...leafViewState.state,
        mode: optional.mode
      }
    });
  }
}
async function getUserScript(command, app2) {
  const file = app2.vault.getAbstractFileByPath(command.path);
  if (!file) {
    log.logError(`failed to load file ${command.path}.`);
    return;
  }
  if (file instanceof import_obsidian8.TFile) {
    const req = (s) => window.require && window.require(s);
    const exp = {};
    const mod = { exports: exp };
    const fileContent = await app2.vault.read(file);
    const fn2 = window.eval(
      `(function(require, module, exports) { ${fileContent} 
})`
    );
    fn2(req, mod, exp);
    const userScript = exp["default"] || mod.exports;
    if (!userScript)
      return;
    let script = userScript;
    const { memberAccess } = getUserScriptMemberAccess(command.name);
    if (memberAccess && memberAccess.length > 0) {
      let member;
      while (member = memberAccess.shift()) {
        script = script[member];
      }
    }
    return script;
  }
}
function excludeKeys(sourceObj, except) {
  const obj = structuredClone(sourceObj);
  for (const key of except) {
    delete obj[key];
  }
  return obj;
}
function getChoiceType(choice) {
  const isTemplate = (choice2) => choice2.type === "Template";
  const isMacro = (choice2) => choice2.type === "Macro";
  const isCapture = (choice2) => choice2.type === "Capture";
  const isMulti = (choice2) => choice2.type === "Multi";
  return isTemplate(choice) || isMacro(choice) || isCapture(choice) || isMulti(choice);
}
function isFolder(path) {
  const abstractItem = app.vault.getAbstractFileByPath(path);
  return !!abstractItem && abstractItem instanceof import_obsidian8.TFolder;
}
function getMarkdownFilesInFolder(folderPath) {
  return app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(folderPath));
}
function getFrontmatterTags(fileCache) {
  const frontmatter = fileCache.frontmatter;
  if (!frontmatter)
    return [];
  const frontMatterValues = Object.entries(frontmatter);
  if (!frontMatterValues.length)
    return [];
  const tagPairs = frontMatterValues.filter(([key, value]) => {
    const lowercaseKey = key.toLowerCase();
    return lowercaseKey === "tags" || lowercaseKey === "tag";
  });
  if (!tagPairs)
    return [];
  const tags = tagPairs.flatMap(([key, value]) => {
    if (typeof value === "string") {
      return value.split(/,|\s+/).map((v) => v.trim());
    } else if (Array.isArray(value)) {
      return value;
    }
  }).filter((v) => !!v);
  return tags;
}
function getFileTags(file) {
  const fileCache = app.metadataCache.getFileCache(file);
  if (!fileCache)
    return [];
  const tagsInFile = [];
  if (fileCache.frontmatter) {
    tagsInFile.push(...getFrontmatterTags(fileCache));
  }
  if (fileCache.tags && Array.isArray(fileCache.tags)) {
    tagsInFile.push(...fileCache.tags.map((v) => v.tag.replace(/^\#/, "")));
  }
  return tagsInFile;
}
function getMarkdownFilesWithTag(tag) {
  const targetTag = tag.replace(/^\#/, "");
  return app.vault.getMarkdownFiles().filter((f) => {
    const fileTags = getFileTags(f);
    return fileTags.includes(targetTag);
  });
}

// src/formatters/formatter.ts
var Formatter = class {
  constructor() {
    this.variables = /* @__PURE__ */ new Map();
  }
  replacer(str, reg, replaceValue) {
    return str.replace(reg, function() {
      return replaceValue;
    });
  }
  replaceDateInString(input) {
    let output = input;
    while (DATE_REGEX.test(output)) {
      const dateMatch = DATE_REGEX.exec(output);
      let offset2;
      if (dateMatch && dateMatch[1]) {
        const offsetString = dateMatch[1].replace("+", "").trim();
        const offsetIsInt = NUMBER_REGEX.test(offsetString);
        if (offsetIsInt)
          offset2 = parseInt(offsetString);
      }
      output = this.replacer(
        output,
        DATE_REGEX,
        getDate({ offset: offset2 })
      );
    }
    while (DATE_REGEX_FORMATTED.test(output)) {
      const dateMatch = DATE_REGEX_FORMATTED.exec(output);
      if (!dateMatch)
        throw new Error("unable to parse date");
      const format3 = dateMatch[1];
      let offset2;
      if (dateMatch[2]) {
        const offsetString = dateMatch[2].replace("+", "").trim();
        const offsetIsInt = NUMBER_REGEX.test(offsetString);
        if (offsetIsInt)
          offset2 = parseInt(offsetString);
      }
      output = this.replacer(
        output,
        DATE_REGEX_FORMATTED,
        getDate({ format: format3, offset: offset2 })
      );
    }
    return output;
  }
  replaceTimeInString(input) {
    let output = input;
    while (TIME_REGEX.test(output)) {
      const timeMatch = TIME_REGEX.exec(output);
      if (!timeMatch)
        throw new Error("unable to parse time");
      output = this.replacer(
        output,
        TIME_REGEX,
        getDate({ format: "HH:mm" })
      );
    }
    while (TIME_REGEX_FORMATTED.test(output)) {
      const timeMatch = TIME_REGEX_FORMATTED.exec(output);
      if (!timeMatch)
        throw new Error("unable to parse time");
      const format3 = timeMatch[1];
      output = this.replacer(
        output,
        TIME_REGEX_FORMATTED,
        getDate({ format: format3 })
      );
    }
    return output;
  }
  async replaceValueInString(input) {
    let output = input;
    while (NAME_VALUE_REGEX.test(output)) {
      if (!this.value)
        this.value = await this.promptForValue();
      output = this.replacer(output, NAME_VALUE_REGEX, this.value);
    }
    return output;
  }
  async replaceSelectedInString(input) {
    let output = input;
    const selectedText = await this.getSelectedText();
    while (SELECTED_REGEX.test(output)) {
      output = this.replacer(output, SELECTED_REGEX, selectedText);
    }
    return output;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async replaceLinkToCurrentFileInString(input) {
    const currentFilePathLink = this.getCurrentFileLink();
    let output = input;
    if (!currentFilePathLink && LINK_TO_CURRENT_FILE_REGEX.test(output)) {
      throw new Error("unable to get current file path");
    } else if (!currentFilePathLink)
      return output;
    while (LINK_TO_CURRENT_FILE_REGEX.test(output))
      output = this.replacer(
        output,
        LINK_TO_CURRENT_FILE_REGEX,
        currentFilePathLink
      );
    return output;
  }
  async replaceVariableInString(input) {
    let output = input;
    while (VARIABLE_REGEX.test(output)) {
      const match = VARIABLE_REGEX.exec(output);
      if (!match)
        throw new Error("unable to parse variable");
      const variableName = match[1];
      if (variableName) {
        if (!this.getVariableValue(variableName)) {
          const suggestedValues = variableName.split(",");
          if (suggestedValues.length === 1)
            this.variables.set(
              variableName,
              await this.promptForVariable(variableName)
            );
          else
            this.variables.set(
              variableName,
              await this.suggestForValue(suggestedValues)
            );
        }
        output = this.replacer(
          output,
          VARIABLE_REGEX,
          this.getVariableValue(variableName)
        );
      } else {
        break;
      }
    }
    return output;
  }
  async replaceFieldVarInString(input) {
    let output = input;
    while (FIELD_VAR_REGEX.test(output)) {
      const match = FIELD_VAR_REGEX.exec(output);
      if (!match)
        throw new Error("unable to parse variable");
      const variableName = match[1];
      if (variableName) {
        if (!this.getVariableValue(variableName)) {
          this.variables.set(
            variableName,
            await this.suggestForField(variableName)
          );
        }
        output = this.replacer(
          output,
          FIELD_VAR_REGEX,
          this.getVariableValue(variableName)
        );
      } else {
        break;
      }
    }
    return output;
  }
  async replaceMathValueInString(input) {
    let output = input;
    while (MATH_VALUE_REGEX.test(output)) {
      const mathstr = await this.promptForMathValue();
      output = this.replacer(output, MATH_VALUE_REGEX, mathstr);
    }
    return output;
  }
  async replaceMacrosInString(input) {
    let output = input;
    while (MACRO_REGEX.test(output)) {
      const exec = MACRO_REGEX.exec(output);
      if (!exec || !exec[1])
        continue;
      const macroName = exec[1];
      const macroOutput = await this.getMacroValue(macroName);
      output = this.replacer(
        output,
        MACRO_REGEX,
        macroOutput ? macroOutput.toString() : ""
      );
    }
    return output;
  }
  async replaceDateVariableInString(input) {
    let output = input;
    while (DATE_VARIABLE_REGEX.test(output)) {
      const match = DATE_VARIABLE_REGEX.exec(output);
      if (!match || !match[1] || !match[2])
        continue;
      const variableName = match[1];
      const dateFormat = match[2];
      if (variableName && dateFormat) {
        if (!this.variables.get(variableName)) {
          this.variables.set(
            variableName,
            await this.promptForVariable(variableName)
          );
          const nld = this.getNaturalLanguageDates();
          if (!nld || !nld.parseDate || typeof nld.parseDate !== "function")
            continue;
          const parseAttempt = nld.parseDate(this.variables.get(variableName));
          if (parseAttempt)
            this.variables.set(
              variableName,
              parseAttempt.moment.format(dateFormat)
            );
          else
            throw new Error(
              `unable to parse date variable ${this.variables.get(
                variableName
              )}`
            );
        }
        output = this.replacer(
          output,
          DATE_VARIABLE_REGEX,
          this.variables.get(variableName)
          // literally setting it above / throwing error if not set
        );
      } else {
        break;
      }
    }
    return output;
  }
  async replaceTemplateInString(input) {
    let output = input;
    while (TEMPLATE_REGEX.test(output)) {
      const exec = TEMPLATE_REGEX.exec(output);
      if (!exec || !exec[1])
        continue;
      const templatePath = exec[1];
      const templateContent = await this.getTemplateContent(templatePath);
      output = this.replacer(output, TEMPLATE_REGEX, templateContent);
    }
    return output;
  }
  replaceLinebreakInString(input) {
    let output = input;
    let match = LINEBREAK_REGEX.exec(output);
    while (match && input[match.index - 1] !== "\\") {
      output = this.replacer(output, LINEBREAK_REGEX, `
`);
      match = LINEBREAK_REGEX.exec(output);
    }
    const EscapedLinebreakRegex = /\\\\n/;
    while (EscapedLinebreakRegex.test(output)) {
      output = this.replacer(output, EscapedLinebreakRegex, `\\n`);
    }
    return output;
  }
};

// src/formatters/fileNameDisplayFormatter.ts
var FileNameDisplayFormatter = class extends Formatter {
  constructor(app2) {
    super();
    this.app = app2;
  }
  async format(input) {
    let output = input;
    output = await this.replaceMacrosInString(output);
    output = this.replaceDateInString(output);
    output = this.replaceTimeInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    output = await this.replaceFieldVarInString(output);
    return `File Name: ${output}`;
  }
  promptForValue(header) {
    return `FileName`;
  }
  getVariableValue(variableName) {
    return variableName;
  }
  getCurrentFileLink() {
    return this.app.workspace.getActiveFile()?.path ?? "";
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  suggestForValue(suggestedValues) {
    return "_suggest_";
  }
  promptForMathValue() {
    return Promise.resolve("_math_");
  }
  getMacroValue(macroName) {
    return `_macro: ${macroName}`;
  }
  async promptForVariable(variableName) {
    return `_${variableName}_`;
  }
  async getTemplateContent(templatePath) {
    return `/${templatePath}/`;
  }
  async getSelectedText() {
    return "_selected_";
  }
  suggestForField(variableName) {
    return `_field: ${variableName}_`;
  }
};

// src/gui/suggesters/formatSyntaxSuggester.ts
var FormatSyntaxSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, plugin, suggestForFileNames = false) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.suggestForFileNames = suggestForFileNames;
    this.lastInput = "";
    this.macroNames = this.plugin.settings.macros.map(
      (macro) => macro.name
    );
    this.templatePaths = this.plugin.getTemplateFiles().map((file) => file.path);
  }
  getSuggestions(inputStr) {
    if (this.inputEl.selectionStart === null)
      return [];
    const cursorPosition = this.inputEl.selectionStart;
    const lookbehind = 15;
    const inputBeforeCursor = inputStr.substr(
      cursorPosition - lookbehind,
      lookbehind
    );
    const suggestions = [];
    this.processToken(
      inputBeforeCursor,
      (match, type, suggestion) => {
        this.lastInput = match[0];
        this.lastInputType = type;
        suggestions.push(suggestion);
        if (this.lastInputType === 8 /* Template */) {
          suggestions.push(
            ...this.templatePaths.map(
              (templatePath) => `{{TEMPLATE:${templatePath}}}`
            )
          );
        }
        if (this.lastInputType === 7 /* Macro */) {
          suggestions.push(
            ...this.macroNames.map(
              (macroName) => `{{MACRO:${macroName}}}`
            )
          );
        }
      }
    );
    return suggestions;
  }
  selectSuggestion(item) {
    if (this.inputEl.selectionStart === null)
      return;
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const insert2 = (text2, offset2 = 0) => {
      return `${currentInputValue.substr(
        0,
        cursorPosition - lastInputLength + offset2
      )}${text2}${currentInputValue.substr(cursorPosition)}`;
    };
    this.processToken(item, (match, type, suggestion) => {
      if (item.contains(suggestion)) {
        this.inputEl.value = insert2(item);
        this.lastInputType = type;
        insertedEndPosition = cursorPosition - lastInputLength + item.length;
        if (this.lastInputType === 2 /* VariableDate */ || this.lastInputType === 5 /* Variable */ || this.lastInputType === 1 /* DateFormat */) {
          insertedEndPosition -= 2;
        }
      }
    });
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
  processToken(input, callback) {
    const dateFormatMatch = DATE_FORMAT_SYNTAX_SUGGEST_REGEX.exec(input);
    if (dateFormatMatch)
      callback(
        dateFormatMatch,
        1 /* DateFormat */,
        "{{DATE:}}"
      );
    const dateMatch = DATE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (dateMatch)
      callback(dateMatch, 0 /* Date */, DATE_SYNTAX);
    const timeMatch = TIME_SYNTAX_SUGGEST_REGEX.exec(input);
    if (timeMatch)
      callback(timeMatch, 10 /* Time */, TIME_SYNTAX);
    const nameMatch = NAME_SYNTAX_SUGGEST_REGEX.exec(input);
    if (nameMatch)
      callback(nameMatch, 4 /* Name */, NAME_SYNTAX);
    const valueMatch = VALUE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (valueMatch)
      callback(valueMatch, 3 /* Value */, VALUE_SYNTAX);
    const mathValueMatch = MATH_VALUE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (mathValueMatch)
      callback(
        mathValueMatch,
        9 /* MathValue */,
        MATH_VALUE_SYNTAX
      );
    const selectedMatch = SELECTED_SYNTAX_SUGGEST_REGEX.exec(input);
    if (selectedMatch)
      callback(selectedMatch, 11 /* Selected */, SELECTED_SYNTAX);
    const variableMatch = VARIABLE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (variableMatch)
      callback(variableMatch, 5 /* Variable */, "{{VALUE:}}");
    const variableDateMatch = VARIABLE_DATE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (variableDateMatch)
      callback(
        variableDateMatch,
        2 /* VariableDate */,
        "{{VDATE:}}"
      );
    if (!this.suggestForFileNames) {
      const linkCurrentMatch = LINKCURRENT_SYNTAX_SUGGEST_REGEX.exec(input);
      if (linkCurrentMatch)
        callback(
          linkCurrentMatch,
          6 /* LinkCurrent */,
          LINKCURRENT_SYNTAX
        );
      const templateMatch = TEMPLATE_SYNTAX_SUGGEST_REGEX.exec(input);
      if (templateMatch)
        callback(
          templateMatch,
          8 /* Template */,
          "{{TEMPLATE:"
        );
      const macroMatch = MACRO_SYNTAX_SUGGEST_REGEX.exec(input);
      if (macroMatch)
        callback(macroMatch, 7 /* Macro */, "{{MACRO:");
    }
  }
};

// src/gui/suggesters/exclusiveSuggester.ts
var ExclusiveSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, suggestItems, currentItems) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.suggestItems = suggestItems;
    this.currentItems = currentItems;
  }
  updateCurrentItems(currentItems) {
    this.currentItems = currentItems;
  }
  getSuggestions(inputStr) {
    return this.suggestItems.filter((item) => item.contains(inputStr));
  }
  selectSuggestion(item) {
    this.inputEl.value = item;
    this.inputEl.trigger("input");
    this.close();
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
};

// src/gui/ChoiceBuilder/templateChoiceBuilder.ts
var TemplateChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, plugin) {
    super(app2);
    this.plugin = plugin;
    this.choice = choice;
    this.display();
  }
  display() {
    this.containerEl.addClass("templateChoiceBuilder");
    this.addCenteredChoiceNameHeader(this.choice);
    this.addTemplatePathSetting();
    this.addFileNameFormatSetting();
    this.addFolderSetting();
    this.addAppendLinkSetting();
    this.addFileAlreadyExistsSetting();
    this.addOpenFileSetting();
    if (this.choice.openFile)
      this.addOpenFileInNewTabSetting();
  }
  addTemplatePathSetting() {
    new import_obsidian9.Setting(this.contentEl).setName("Template Path").setDesc("Path to the Template.").addSearch((search2) => {
      const templates = this.plugin.getTemplateFiles().map((f) => f.path);
      search2.setValue(this.choice.templatePath);
      search2.setPlaceholder("Template path");
      new GenericTextSuggester(this.app, search2.inputEl, templates, 50);
      search2.onChange((value) => {
        this.choice.templatePath = value;
      });
    });
  }
  addFileNameFormatSetting() {
    let textField;
    const enableSetting = new import_obsidian9.Setting(this.contentEl);
    enableSetting.setName("File Name Format").setDesc("Set the file name format.").addToggle((toggleComponent) => {
      toggleComponent.setValue(this.choice.fileNameFormat.enabled).onChange((value) => {
        this.choice.fileNameFormat.enabled = value;
        textField.setDisabled(!value);
      });
    });
    const formatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FileNameDisplayFormatter(this.app);
    void (async () => formatDisplay.textContent = await displayFormatter.format(
      this.choice.fileNameFormat.format
    ))();
    const formatInput = new import_obsidian9.TextComponent(this.contentEl);
    formatInput.setPlaceholder("File name format");
    textField = formatInput;
    formatInput.inputEl.style.width = "100%";
    formatInput.inputEl.style.marginBottom = "8px";
    formatInput.setValue(this.choice.fileNameFormat.format).setDisabled(!this.choice.fileNameFormat.enabled).onChange(async (value) => {
      this.choice.fileNameFormat.format = value;
      formatDisplay.textContent = await displayFormatter.format(
        value
      );
    });
    new FormatSyntaxSuggester(
      this.app,
      textField.inputEl,
      this.plugin,
      true
    );
  }
  addFolderSetting() {
    const folderSetting = new import_obsidian9.Setting(this.contentEl);
    folderSetting.setName("Create in folder").setDesc(
      "Create the file in the specified folder. If multiple folders are specified, you will be prompted for which folder to create the file in."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.folder.enabled);
      toggle.onChange((value) => {
        this.choice.folder.enabled = value;
        this.reload();
      });
    });
    if (!this.choice.folder.enabled) {
      return;
    }
    if (!this.choice.folder?.createInSameFolderAsActiveFile) {
      const chooseFolderWhenCreatingNoteContainer = this.contentEl.createDiv(
        "chooseFolderWhenCreatingNoteContainer"
      );
      chooseFolderWhenCreatingNoteContainer.createEl("span", {
        text: "Choose folder when creating a new note"
      });
      const chooseFolderWhenCreatingNote = new import_obsidian9.ToggleComponent(chooseFolderWhenCreatingNoteContainer);
      chooseFolderWhenCreatingNote.setValue(this.choice.folder?.chooseWhenCreatingNote).onChange((value) => {
        this.choice.folder.chooseWhenCreatingNote = value;
        this.reload();
      });
      if (!this.choice.folder?.chooseWhenCreatingNote) {
        this.addFolderSelector();
      }
      const chooseFolderFromSubfolderContainer = this.contentEl.createDiv("chooseFolderFromSubfolderContainer");
      const stn = new import_obsidian9.Setting(chooseFolderFromSubfolderContainer);
      stn.setName("Include subfolders").setDesc(
        "Get prompted to choose from both the selected folders and their subfolders when creating the note."
      ).addToggle(
        (toggle) => toggle.setValue(this.choice.folder?.chooseFromSubfolders).onChange((value) => {
          this.choice.folder.chooseFromSubfolders = value;
          this.reload();
        })
      );
    }
    if (!this.choice.folder?.chooseWhenCreatingNote) {
      const createInSameFolderAsActiveFileSetting = new import_obsidian9.Setting(
        this.contentEl
      );
      createInSameFolderAsActiveFileSetting.setName("Create in same folder as active file").setDesc(
        "Creates the file in the same folder as the currently active file. Will not create the file if there is no active file."
      ).addToggle(
        (toggle) => toggle.setValue(
          this.choice.folder?.createInSameFolderAsActiveFile
        ).onChange((value) => {
          this.choice.folder.createInSameFolderAsActiveFile = value;
          this.reload();
        })
      );
    }
  }
  addFolderSelector() {
    const folderSelectionContainer = this.contentEl.createDiv("folderSelectionContainer");
    const folderList = folderSelectionContainer.createDiv("folderList");
    const folderListEl = new FolderList_default({
      target: folderList,
      props: {
        folders: this.choice.folder.folders,
        deleteFolder: (folder) => {
          this.choice.folder.folders = this.choice.folder.folders.filter((f) => f !== folder);
          folderListEl.updateFolders(this.choice.folder.folders);
          suggester.updateCurrentItems(this.choice.folder.folders);
        }
      }
    });
    this.svelteElements.push(folderListEl);
    const inputContainer = folderSelectionContainer.createDiv(
      "folderInputContainer"
    );
    const folderInput = new import_obsidian9.TextComponent(inputContainer);
    folderInput.inputEl.style.width = "100%";
    folderInput.setPlaceholder("Folder path");
    const allFolders = getAllFolderPathsInVault(this.app);
    const suggester = new ExclusiveSuggester(
      this.app,
      folderInput.inputEl,
      allFolders,
      this.choice.folder.folders
    );
    const addFolder = () => {
      const input = folderInput.inputEl.value.trim();
      if (this.choice.folder.folders.some((folder) => folder === input)) {
        log.logWarning("cannot add same folder twice.");
        return;
      }
      this.choice.folder.folders.push(input);
      folderListEl.updateFolders(this.choice.folder.folders);
      folderInput.inputEl.value = "";
      suggester.updateCurrentItems(this.choice.folder.folders);
    };
    folderInput.inputEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        addFolder();
      }
    });
    const addButton = new import_obsidian9.ButtonComponent(inputContainer);
    addButton.setCta().setButtonText("Add").onClick((evt) => {
      addFolder();
    });
  }
  addAppendLinkSetting() {
    const appendLinkSetting = new import_obsidian9.Setting(this.contentEl);
    appendLinkSetting.setName("Append link").setDesc("Append link to created file to current file.").addToggle((toggle) => {
      toggle.setValue(this.choice.appendLink);
      toggle.onChange((value) => this.choice.appendLink = value);
    });
  }
  addFileAlreadyExistsSetting() {
    const fileAlreadyExistsSetting = new import_obsidian9.Setting(this.contentEl);
    fileAlreadyExistsSetting.setName("Set default behavior if file already exists").setDesc(
      "Set default behavior rather then prompting user on what to do if a file already exists."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.setFileExistsBehavior);
      toggle.onChange((value) => {
        this.choice.setFileExistsBehavior = value;
      });
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      if (!this.choice.fileExistsMode)
        this.choice.fileExistsMode = fileExistsDoNothing;
      dropdown.addOption(
        fileExistsAppendToBottom,
        fileExistsAppendToBottom
      ).addOption(fileExistsAppendToTop, fileExistsAppendToTop).addOption(fileExistsIncrement, fileExistsIncrement).addOption(fileExistsOverwriteFile, fileExistsOverwriteFile).addOption(fileExistsDoNothing, fileExistsDoNothing).setValue(this.choice.fileExistsMode).onChange(
        (value) => this.choice.fileExistsMode = value
      );
    });
  }
  addOpenFileSetting() {
    const noOpenSetting = new import_obsidian9.Setting(this.contentEl);
    noOpenSetting.setName("Open").setDesc("Open the created file.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFile);
      toggle.onChange((value) => {
        this.choice.openFile = value;
        this.reload();
      });
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      if (!this.choice.openFileInMode)
        this.choice.openFileInMode = "default";
      dropdown.addOption("source", "Source").addOption("preview", "Preview").addOption("default", "Default").setValue(this.choice.openFileInMode).onChange(
        (value) => this.choice.openFileInMode = value
      );
    });
  }
  addOpenFileInNewTabSetting() {
    const newTabSetting = new import_obsidian9.Setting(this.contentEl);
    newTabSetting.setName("New split").setDesc("Split your editor and open file in new split.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFileInNewTab.enabled);
      toggle.onChange(
        (value) => this.choice.openFileInNewTab.enabled = value
      );
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      dropdown.addOption("vertical" /* vertical */, "Vertical");
      dropdown.addOption("horizontal" /* horizontal */, "Horizontal");
      dropdown.setValue(this.choice.openFileInNewTab.direction);
      dropdown.onChange(
        (value) => this.choice.openFileInNewTab.direction = value
      );
    });
    new import_obsidian9.Setting(this.contentEl).setName("Focus new pane").setDesc("Focus the opened tab immediately after opening").addToggle(
      (toggle) => toggle.setValue(this.choice.openFileInNewTab.focus).onChange(
        (value) => this.choice.openFileInNewTab.focus = value
      )
    );
  }
};

// src/gui/ChoiceBuilder/captureChoiceBuilder.ts
var import_obsidian23 = require("obsidian");

// src/engine/QuickAddEngine.ts
var import_obsidian10 = require("obsidian");
var QuickAddEngine = class {
  constructor(app2) {
    this.app = app2;
  }
  async createFolder(folder) {
    const folderExists = await this.app.vault.adapter.exists(folder);
    if (!folderExists) {
      await this.app.vault.createFolder(folder);
    }
  }
  normalizeMarkdownFilePath(folderPath, fileName) {
    const actualFolderPath = folderPath ? `${folderPath}/` : "";
    const formattedFileName = fileName.replace(
      MARKDOWN_FILE_EXTENSION_REGEX,
      ""
    );
    return `${actualFolderPath}${formattedFileName}.md`;
  }
  async fileExists(filePath) {
    return await this.app.vault.adapter.exists(filePath);
  }
  getFileByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      log.logError(`${filePath} not found`);
      throw new Error(`${filePath} not found`);
    }
    if (file instanceof import_obsidian10.TFolder) {
      log.logError(`${filePath} found but it's a folder`);
      throw new Error(`${filePath} found but it's a folder`);
    }
    if (!(file instanceof import_obsidian10.TFile))
      throw new Error(`${filePath} is not a file`);
    return file;
  }
  async createFileWithInput(filePath, fileContent) {
    const dirMatch = filePath.match(/(.*)[/\\]/);
    let dirName = "";
    if (dirMatch)
      dirName = dirMatch[1];
    const dir = app.vault.getAbstractFileByPath(dirName);
    if (!dir || !(dir instanceof import_obsidian10.TFolder)) {
      await this.createFolder(dirName);
    }
    return await this.app.vault.create(filePath, fileContent);
  }
};

// src/gui/GenericSuggester/genericSuggester.ts
var import_obsidian11 = require("obsidian");
var GenericSuggester = class extends import_obsidian11.FuzzySuggestModal {
  constructor(app2, displayItems, items) {
    super(app2);
    this.displayItems = displayItems;
    this.items = items;
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.inputEl.addEventListener("keydown", (event) => {
      if (event.code !== "Tab" || !("chooser" in this)) {
        return;
      }
      const { values, selectedItem } = this.chooser;
      const { value } = this.inputEl;
      this.inputEl.value = values[selectedItem].item ?? value;
    });
    this.open();
  }
  static Suggest(app2, displayItems, items) {
    const newSuggester = new GenericSuggester(app2, displayItems, items);
    return newSuggester.promise;
  }
  getItemText(item) {
    return this.displayItems[this.items.indexOf(item)];
  }
  getItems() {
    return this.items;
  }
  selectSuggestion(value, evt) {
    this.resolved = true;
    super.selectSuggestion(value, evt);
  }
  onChooseItem(item, evt) {
    this.resolved = true;
    this.resolvePromise(item);
  }
  onClose() {
    super.onClose();
    if (!this.resolved)
      this.rejectPromise("no input given.");
  }
};

// src/engine/MacroChoiceEngine.ts
var obsidian = __toESM(require("obsidian"));

// src/gui/GenericInfoDialog/GenericInfoDialog.ts
var import_obsidian12 = require("obsidian");
var GenericInfoDialog = class extends import_obsidian12.Modal {
  constructor(app2, header, text2) {
    super(app2);
    this.header = header;
    this.text = text2;
    this.waitForClose = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
    this.open();
    this.display();
  }
  static Show(app2, header, text2) {
    const newPromptModal = new GenericInfoDialog(app2, header, text2);
    return newPromptModal.waitForClose;
  }
  display() {
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    if (String.isString(this.text))
      this.contentEl.createEl("p", { text: this.text });
    else if (Array.isArray(this.text))
      this.text.forEach(
        (line) => this.contentEl.createEl("p", { text: line })
      );
    const buttonsDiv = this.contentEl.createDiv();
    const noButton = new import_obsidian12.ButtonComponent(buttonsDiv).setButtonText("OK").onClick(() => this.close());
    Object.assign(buttonsDiv.style, {
      display: "flex",
      justifyContent: "flex-end"
    });
    noButton.buttonEl.focus();
  }
  onClose() {
    super.onClose();
    this.resolvePromise();
  }
};

// src/gui/GenericCheckboxPrompt/genericCheckboxPrompt.ts
var import_obsidian13 = require("obsidian");
var GenericCheckboxPrompt = class extends import_obsidian13.Modal {
  constructor(app2, items, selectedItems = []) {
    super(app2);
    this.items = items;
    this.selectedItems = selectedItems;
    this._selectedItems = [...selectedItems];
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
  }
  static Open(app2, items, selectedItems) {
    const newSuggester = new GenericCheckboxPrompt(
      app2,
      items,
      selectedItems
    );
    return newSuggester.promise;
  }
  display() {
    this.contentEl.empty();
    this.containerEl.addClass("quickAddModal", "checkboxPrompt");
    this.addCheckboxRows();
    this.addSubmitButton();
  }
  onClose() {
    super.onClose();
    if (!this.resolved)
      this.rejectPromise("no input given.");
  }
  addCheckboxRows() {
    const rowContainer = this.contentEl.createDiv(
      "checkboxRowContainer"
    );
    this.items.forEach((item) => this.addCheckboxRow(item, rowContainer));
  }
  addCheckboxRow(item, container) {
    const checkboxRow = container.createDiv("checkboxRow");
    checkboxRow.createEl("span", {
      text: item
    });
    const checkbox = new import_obsidian13.ToggleComponent(checkboxRow);
    checkbox.setTooltip(`Toggle ${item}`).setValue(this._selectedItems.contains(item)).onChange((value) => {
      if (value)
        this._selectedItems.push(item);
      else {
        const index = this._selectedItems.findIndex(
          (value2) => item === value2
        );
        this._selectedItems.splice(index, 1);
      }
    });
  }
  addSubmitButton() {
    const submitButtonContainer = this.contentEl.createDiv(
      "submitButtonContainer"
    );
    const submitButton = new import_obsidian13.ButtonComponent(
      submitButtonContainer
    );
    submitButton.setButtonText("Submit").setCta().onClick((evt) => {
      this.resolved = true;
      this.resolvePromise(this._selectedItems);
      this.close();
    });
  }
};

// src/quickAddApi.ts
var import_obsidian15 = require("obsidian");

// src/gui/GenericWideInputPrompt/GenericWideInputPrompt.ts
var import_obsidian14 = require("obsidian");
var GenericWideInputPrompt = class extends import_obsidian14.Modal {
  constructor(app2, header, placeholder, value) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.submitEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.placeholder = placeholder ?? "";
    this.input = value ?? "";
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
    this.fileSuggester = new SilentFileSuggester(
      app2,
      this.inputComponent.inputEl
    );
    this.tagSuggester = new SilentTagSuggester(
      app2,
      this.inputComponent.inputEl
    );
  }
  static Prompt(app2, header, placeholder, value) {
    const newPromptModal = new GenericWideInputPrompt(
      app2,
      header,
      placeholder,
      value
    );
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaWideInputPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    const mainContentContainer = this.contentEl.createDiv();
    this.inputComponent = this.createInputField(
      mainContentContainer,
      this.placeholder,
      this.input
    );
    this.createButtonBar(mainContentContainer);
  }
  createInputField(container, placeholder, value) {
    const textComponent = new import_obsidian14.TextAreaComponent(container);
    textComponent.inputEl.classList.add("wideInputPromptInputEl");
    textComponent.setPlaceholder(placeholder ?? "").setValue(value ?? "").onChange((value2) => this.input = value2).inputEl.addEventListener("keydown", this.submitEnterCallback);
    return textComponent;
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian14.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(this.input);
  }
  removeInputListener() {
    this.inputComponent.inputEl.removeEventListener(
      "keydown",
      this.submitEnterCallback
    );
  }
  onOpen() {
    super.onOpen();
    this.inputComponent.inputEl.focus();
    this.inputComponent.inputEl.select();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
};

// src/quickAddApi.ts
var QuickAddApi = class {
  static GetApi(app2, plugin, choiceExecutor) {
    return {
      inputPrompt: (header, placeholder, value) => {
        return this.inputPrompt(app2, header, placeholder, value);
      },
      wideInputPrompt: (header, placeholder, value) => {
        return this.wideInputPrompt(app2, header, placeholder, value);
      },
      yesNoPrompt: (header, text2) => {
        return this.yesNoPrompt(app2, header, text2);
      },
      infoDialog: (header, text2) => {
        return this.infoDialog(app2, header, text2);
      },
      suggester: (displayItems, actualItems) => {
        return this.suggester(app2, displayItems, actualItems);
      },
      checkboxPrompt: (items, selectedItems) => {
        return this.checkboxPrompt(app2, items, selectedItems);
      },
      executeChoice: async (choiceName, variables) => {
        const choice = plugin.getChoiceByName(choiceName);
        if (!choice)
          log.logError(`choice named '${choiceName}' not found`);
        if (variables) {
          Object.keys(variables).forEach((key) => {
            choiceExecutor.variables.set(key, variables[key]);
          });
        }
        await choiceExecutor.execute(choice);
        choiceExecutor.variables.clear();
      },
      format: async (input, variables, shouldClearVariables = true) => {
        if (variables) {
          Object.keys(variables).forEach((key) => {
            choiceExecutor.variables.set(key, variables[key]);
          });
        }
        const output = await new CompleteFormatter(
          app2,
          plugin,
          choiceExecutor
        ).formatFileContent(input);
        if (shouldClearVariables) {
          choiceExecutor.variables.clear();
        }
        return output;
      },
      utility: {
        getClipboard: async () => {
          return await navigator.clipboard.readText();
        },
        setClipboard: async (text2) => {
          return await navigator.clipboard.writeText(text2);
        },
        getSelectedText: () => {
          const activeView = app2.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
          if (!activeView) {
            log.logError(
              "no active view - could not get selected text."
            );
            return;
          }
          if (!activeView.editor.somethingSelected()) {
            log.logError("no text selected.");
            return;
          }
          return activeView.editor.getSelection();
        }
      },
      date: {
        now: (format3, offset2) => {
          return getDate({ format: format3, offset: offset2 });
        },
        tomorrow: (format3) => {
          return getDate({ format: format3, offset: 1 });
        },
        yesterday: (format3) => {
          return getDate({ format: format3, offset: -1 });
        }
      }
    };
  }
  static async inputPrompt(app2, header, placeholder, value) {
    try {
      return await GenericInputPrompt.Prompt(
        app2,
        header,
        placeholder,
        value
      );
    } catch {
      return void 0;
    }
  }
  static async wideInputPrompt(app2, header, placeholder, value) {
    try {
      return await GenericWideInputPrompt.Prompt(
        app2,
        header,
        placeholder,
        value
      );
    } catch {
      return void 0;
    }
  }
  static async yesNoPrompt(app2, header, text2) {
    try {
      return await GenericYesNoPrompt.Prompt(app2, header, text2);
    } catch {
      return void 0;
    }
  }
  static async infoDialog(app2, header, text2) {
    try {
      return await GenericInfoDialog.Show(app2, header, text2);
    } catch {
      return void 0;
    }
  }
  static async suggester(app2, displayItems, actualItems) {
    try {
      let displayedItems;
      if (typeof displayItems === "function") {
        displayedItems = actualItems.map(displayItems);
      } else {
        displayedItems = displayItems;
      }
      return await GenericSuggester.Suggest(
        app2,
        displayedItems,
        actualItems
      );
    } catch {
      return void 0;
    }
  }
  static async checkboxPrompt(app2, items, selectedItems) {
    try {
      return await GenericCheckboxPrompt.Open(app2, items, selectedItems);
    } catch {
      return void 0;
    }
  }
};

// src/engine/QuickAddChoiceEngine.ts
var QuickAddChoiceEngine = class extends QuickAddEngine {
};

// src/types/macros/Command.ts
var Command = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
    this.id = v4_default();
  }
};

// src/types/macros/EditorCommands/EditorCommand.ts
var import_obsidian16 = require("obsidian");
var EditorCommand = class extends Command {
  constructor(type) {
    super(type, "EditorCommand" /* EditorCommand */);
    this.editorCommandType = type;
  }
  static getSelectedText(app2) {
    return this.getActiveMarkdownView(app2).editor.getSelection();
  }
  static getActiveMarkdownView(app2) {
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
    if (!activeView) {
      log.logError("no active markdown view.");
      throw new Error("no active markdown view.");
    }
    return activeView;
  }
};

// src/types/macros/EditorCommands/CutCommand.ts
var CutCommand = class extends EditorCommand {
  constructor() {
    super("Cut" /* Cut */);
  }
  static async run(app2) {
    const selectedText = EditorCommand.getSelectedText(app2);
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    if (!selectedText) {
      log.logError("nothing selected.");
      return;
    }
    await navigator.clipboard.writeText(selectedText);
    activeView.editor.replaceSelection("");
  }
};

// src/types/macros/EditorCommands/CopyCommand.ts
var CopyCommand = class extends EditorCommand {
  constructor() {
    super("Copy" /* Copy */);
  }
  static async run(app2) {
    const selectedText = EditorCommand.getSelectedText(app2);
    await navigator.clipboard.writeText(selectedText);
  }
};

// src/types/macros/EditorCommands/PasteCommand.ts
var PasteCommand = class extends EditorCommand {
  constructor() {
    super("Paste" /* Paste */);
  }
  static async run(app2) {
    const clipboard = await navigator.clipboard.readText();
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    if (!activeView) {
      log.logError("no active markdown view.");
      return;
    }
    activeView.editor.replaceSelection(clipboard);
  }
};

// src/types/macros/EditorCommands/SelectActiveLineCommand.ts
var SelectActiveLineCommand = class extends EditorCommand {
  constructor() {
    super("Select active line" /* SelectActiveLine */);
  }
  static run(app2) {
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    const { line: lineNumber } = activeView.editor.getCursor();
    const line = activeView.editor.getLine(lineNumber);
    const lineLength = line.length;
    activeView.editor.setSelection(
      { line: lineNumber, ch: 0 },
      { line: lineNumber, ch: lineLength }
    );
  }
};

// src/types/macros/EditorCommands/SelectLinkOnActiveLineCommand.ts
var SelectLinkOnActiveLineCommand = class extends EditorCommand {
  constructor() {
    super("Select link on active line" /* SelectLinkOnActiveLine */);
  }
  static run(app2) {
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    const { line: lineNumber } = activeView.editor.getCursor();
    const line = activeView.editor.getLine(lineNumber);
    const match = WIKI_LINK_REGEX.exec(line);
    if (!match) {
      log.logError(`no internal link found on line ${lineNumber}.`);
      return;
    }
    const matchStart = match.index;
    const matchEnd = match[0].length + matchStart;
    activeView.editor.setSelection(
      { line: lineNumber, ch: matchStart },
      { line: lineNumber, ch: matchEnd }
    );
  }
};

// src/utility.ts
function waitFor(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
function getLinesInString(input) {
  const lines = [];
  let tempString = input;
  while (tempString.includes("\n")) {
    const lineEndIndex = tempString.indexOf("\n");
    lines.push(tempString.slice(0, lineEndIndex));
    tempString = tempString.slice(lineEndIndex + 1);
  }
  lines.push(tempString);
  return lines;
}
function escapeRegExp(text2) {
  return text2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

// src/ai/AIAssistant.ts
var import_obsidian17 = require("obsidian");

// src/utils/invariant.ts
function invariant(condition, message) {
  if (!condition) {
    throw new Error(typeof message === "function" ? message() : message);
  }
  return;
}

// node_modules/.pnpm/zustand@4.3.8/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env && import_meta.env.MODE) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// src/types/macros/QuickAddMacro.ts
var QuickAddMacro = class {
  constructor(name) {
    this.name = name;
    this.id = v4_default();
    this.commands = [];
    this.runOnStartup = false;
  }
};

// src/settingsStore.ts
var settingsStore = function() {
  const useSettingsStore = createStore((set, get2) => ({
    ...DEFAULT_SETTINGS,
    setSettings: (settings) => set((state) => ({ ...state, ...settings }))
  }));
  const { getState, setState, subscribe } = useSettingsStore;
  return {
    getState,
    setState,
    subscribe,
    setMacro: (macroId, macro) => {
      setState((state) => {
        const macroIdx = state.macros.findIndex(
          (m) => m.id === macroId
        );
        if (macroIdx === -1) {
          throw new Error("Macro not found");
        }
        const newState = {
          ...state,
          macros: [...state.macros]
        };
        newState.macros[macroIdx] = macro;
        return newState;
      });
    },
    createMacro: (name) => {
      if (name === "" || getState().macros.some((m) => m.name === name)) {
        throw new Error("Invalid macro name");
      }
      const macro = new QuickAddMacro(name);
      setState((state) => ({
        ...state,
        macros: [...state.macros, macro]
      }));
      return macro;
    },
    getMacro: (macroId) => {
      return getState().macros.find((m) => m.id === macroId);
    }
  };
}();

// src/ai/AIAssistant.ts
var noticeMsg = (task, message) => `Assistant is ${task}.${message ? `

${message}` : ""}`;
async function repeatUntilResolved(callback, promise, interval) {
  if (typeof callback !== "function") {
    throw new TypeError("Callback must be a function.");
  }
  if (!(promise instanceof Promise)) {
    throw new TypeError("Promise must be an instance of Promise.");
  }
  if (typeof interval !== "number" || interval <= 0) {
    throw new TypeError("Interval must be a positive number.");
  }
  let isDone = false;
  promise.finally(() => {
    isDone = true;
  });
  while (!isDone) {
    callback();
    await sleep(interval);
  }
}
async function getTargetPromptTemplate(userDefinedPromptTemplate, promptTemplates) {
  let targetFile;
  if (userDefinedPromptTemplate.enable) {
    targetFile = promptTemplates.find(
      (item) => item.path.endsWith(userDefinedPromptTemplate.name)
    );
  } else {
    const basenames = promptTemplates.map((f) => f.basename);
    targetFile = await GenericSuggester.Suggest(
      app,
      basenames,
      promptTemplates
    );
  }
  invariant(targetFile, "Prompt template does not exist");
  const targetTemplatePath = targetFile.path;
  const file = app.vault.getAbstractFileByPath(targetTemplatePath);
  invariant(file instanceof import_obsidian17.TFile, `${targetTemplatePath} is not a file`);
  const targetTemplateContent = await app.vault.cachedRead(file);
  return [targetFile.basename, targetTemplateContent];
}
async function runAIAssistant(settings, formatter) {
  if (settingsStore.getState().disableOnlineFeatures) {
    throw new Error(
      "Blocking request to OpenAI: Online features are disabled in settings."
    );
  }
  const notice = settings.showAssistantMessages ? new import_obsidian17.Notice(noticeMsg("starting", ""), 1e6) : { setMessage: () => {
  }, hide: () => {
  } };
  try {
    const {
      apiKey,
      model,
      outputVariableName: outputVariable,
      promptTemplate,
      systemPrompt,
      promptTemplateFolder
    } = settings;
    const promptTemplates = getMarkdownFilesInFolder(promptTemplateFolder);
    const [targetKey, targetPrompt] = await getTargetPromptTemplate(
      promptTemplate,
      promptTemplates
    );
    notice.setMessage(
      noticeMsg("waiting", "QuickAdd is formatting the prompt template.")
    );
    const formattedPrompt = await formatter(targetPrompt);
    const promptingMsg = [
      "prompting",
      `Using prompt template "${targetKey}".`
    ];
    notice.setMessage(noticeMsg(promptingMsg[0], promptingMsg[1]));
    const makeRequest = OpenAIRequest(
      apiKey,
      model,
      systemPrompt,
      settings.modelOptions
    );
    const res = makeRequest(formattedPrompt);
    const time_start = Date.now();
    await repeatUntilResolved(
      () => {
        notice.setMessage(
          noticeMsg(
            promptingMsg[0],
            `${promptingMsg[1]} (${((Date.now() - time_start) / 1e3).toFixed(2)}s)`
          )
        );
      },
      res,
      100
    );
    const result = await res;
    const time_end = Date.now();
    notice.setMessage(
      noticeMsg(`finished`, `Took ${(time_end - time_start) / 1e3}s.`)
    );
    const output = result.choices[0].message.content;
    const outputInMarkdownBlockQuote = ("> " + output).replace(
      /\n/g,
      "\n> "
    );
    const variables = {
      [outputVariable]: output,
      // For people that want the output in callouts or quote blocks.
      [`${outputVariable}-quoted`]: outputInMarkdownBlockQuote
    };
    setTimeout(() => notice.hide(), 5e3);
    return variables;
  } catch (error) {
    notice.setMessage(
      noticeMsg("dead", error.message)
    );
    setTimeout(() => notice.hide(), 5e3);
  }
}
function OpenAIRequest(apiKey, model, systemPrompt, modelParams = {}) {
  return async function makeRequest(prompt) {
    if (settingsStore.getState().disableOnlineFeatures) {
      throw new Error(
        "Blocking request to OpenAI: Online features are disabled in settings."
      );
    }
    try {
      const response = await (0, import_obsidian17.requestUrl)({
        url: `https://api.openai.com/v1/chat/completions`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model,
          ...modelParams,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: prompt }
          ]
        })
      });
      return response.json;
    } catch (error) {
      console.log(error);
      throw new Error(
        `Error while making request to OpenAI API: ${error.message}`
      );
    }
  };
}

// src/ai/models.ts
var models = ["gpt-3.5-turbo", "gpt-4", "text-davinci-003"];
var models_and_ask_me = [...models, "Ask me"];

// src/engine/MacroChoiceEngine.ts
var MacroChoiceEngine = class extends QuickAddChoiceEngine {
  constructor(app2, plugin, choice, macros, choiceExecutor, variables) {
    super(app2);
    this.choice = choice;
    this.plugin = plugin;
    this.macros = macros;
    this.choiceExecutor = choiceExecutor;
    this.params = {
      app: this.app,
      quickAddApi: QuickAddApi.GetApi(app2, plugin, choiceExecutor),
      variables: {},
      obsidian
    };
    variables?.forEach((value, key) => {
      this.params.variables[key] = value;
    });
  }
  async run() {
    const macroId = this.choice.macroId ?? this.choice?.macro?.id;
    const macro = this.macros.find((m) => m.id === macroId);
    if (!macro || !macro?.commands) {
      log.logError(
        `No commands in the selected macro. Did you select a macro for '${this.choice.name}'?`
      );
      return;
    }
    await this.executeCommands(macro.commands);
  }
  async executeCommands(commands2) {
    for (const command of commands2) {
      if (command?.type === "Obsidian" /* Obsidian */)
        this.executeObsidianCommand(command);
      if (command?.type === "UserScript" /* UserScript */)
        await this.executeUserScript(command);
      if (command?.type === "Choice" /* Choice */)
        await this.executeChoice(command);
      if (command?.type === "Wait" /* Wait */) {
        const waitCommand = command;
        await waitFor(waitCommand.time);
      }
      if (command?.type === "NestedChoice" /* NestedChoice */) {
        await this.executeNestedChoice(command);
      }
      if (command?.type === "EditorCommand" /* EditorCommand */) {
        await this.executeEditorCommand(command);
      }
      if (command?.type === "AIAssistant" /* AIAssistant */) {
        await this.executeAIAssistant(command);
      }
      Object.keys(this.params.variables).forEach((key) => {
        this.choiceExecutor.variables.set(
          key,
          this.params.variables[key]
        );
      });
    }
  }
  // Slightly modified from Templater's user script engine:
  // https://github.com/SilentVoid13/Templater/blob/master/src/UserTemplates/UserTemplateParser.ts
  async executeUserScript(command) {
    const userScript = await getUserScript(command, this.app);
    if (!userScript) {
      log.logError(`failed to load user script ${command.path}.`);
      return;
    }
    if (userScript.settings) {
      this.userScriptCommand = command;
    }
    try {
      await this.userScriptDelegator(userScript);
    } catch (error) {
      log.logError(
        `failed to run user script ${command.name}. Error:

${error.message}`
      );
    }
    if (this.userScriptCommand)
      this.userScriptCommand = null;
  }
  async runScriptWithSettings(userScript, command) {
    if (typeof userScript !== "function" && userScript.entry && typeof userScript.entry === "function") {
      return await this.onExportIsFunction(
        userScript.entry,
        command.settings
      );
    }
    if (typeof userScript === "function") {
      return await this.onExportIsFunction(userScript, command.settings);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async userScriptDelegator(userScript) {
    switch (typeof userScript) {
      case "function":
        if (this.userScriptCommand) {
          await this.runScriptWithSettings(
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            userScript,
            this.userScriptCommand
          );
        } else {
          await this.onExportIsFunction(userScript);
        }
        break;
      case "object":
        await this.onExportIsObject(userScript);
        break;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        this.output = userScript.toString();
        break;
      default:
        log.logError(
          `user script in macro for '${this.choice.name}' is invalid`
        );
    }
  }
  async onExportIsFunction(userScript, settings) {
    this.output = await userScript(this.params, settings || {});
  }
  async onExportIsObject(obj) {
    if (Object.keys(obj).length === 0) {
      throw new Error(
        `user script in macro for '${this.choice.name}' is an empty object`
      );
    }
    if (this.userScriptCommand && obj.entry !== null) {
      await this.runScriptWithSettings(
        obj,
        this.userScriptCommand
      );
      return;
    }
    try {
      const keys = Object.keys(obj);
      const selected = await GenericSuggester.Suggest(
        this.app,
        keys,
        keys
      );
      await this.userScriptDelegator(obj[selected]);
    } catch (e) {
      log.logMessage(e);
    }
  }
  executeObsidianCommand(command) {
    this.app.commands.executeCommandById(command.commandId);
  }
  async executeChoice(command) {
    const targetChoice = this.plugin.getChoiceById(
      command.choiceId
    );
    if (!targetChoice) {
      log.logError("choice could not be found.");
      return;
    }
    await this.choiceExecutor.execute(targetChoice);
  }
  async executeNestedChoice(command) {
    const choice = command.choice;
    if (!choice) {
      log.logError(`choice in ${command.name} is invalid`);
      return;
    }
    await this.choiceExecutor.execute(choice);
  }
  async executeEditorCommand(command) {
    switch (command.editorCommandType) {
      case "Cut" /* Cut */:
        await CutCommand.run(this.app);
        break;
      case "Copy" /* Copy */:
        await CopyCommand.run(this.app);
        break;
      case "Paste" /* Paste */:
        await PasteCommand.run(this.app);
        break;
      case "Select active line" /* SelectActiveLine */:
        SelectActiveLineCommand.run(this.app);
        break;
      case "Select link on active line" /* SelectLinkOnActiveLine */:
        SelectLinkOnActiveLineCommand.run(this.app);
        break;
    }
  }
  async executeAIAssistant(command) {
    if (settingsStore.getState().disableOnlineFeatures) {
      throw new Error(
        "Blocking request to OpenAI: Online features are disabled in settings."
      );
    }
    const aiSettings = settingsStore.getState().ai;
    const options = [...models];
    const model = command.model === "Ask me" ? await GenericSuggester.Suggest(app, options, options) : command.model;
    const formatter = new CompleteFormatter(
      app,
      QuickAdd.instance,
      this.choiceExecutor
    );
    const aiOutputVariables = await runAIAssistant(
      {
        apiKey: aiSettings.OpenAIApiKey,
        model,
        outputVariableName: command.outputVariableName,
        promptTemplate: command.promptTemplate,
        promptTemplateFolder: aiSettings.promptTemplatesFolderPath,
        systemPrompt: command.systemPrompt,
        showAssistantMessages: aiSettings.showAssistant,
        modelOptions: command.modelParameters
      },
      async (input) => {
        return formatter.formatFileContent(input);
      }
    );
    for (const key in aiOutputVariables) {
      this.choiceExecutor.variables.set(key, aiOutputVariables[key]);
    }
  }
};

// src/engine/SingleMacroEngine.ts
var SingleMacroEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, macros, choiceExecutor, variables) {
    super(app2, plugin, null, macros, choiceExecutor, variables);
  }
  async runAndGetOutput(macroName) {
    const { basename, memberAccess } = getUserScriptMemberAccess(macroName);
    const macro = this.macros.find((macro2) => macro2.name === basename);
    if (!macro) {
      log.logError(`macro '${macroName}' does not exist.`);
      throw new Error(`macro '${macroName}' does not exist.`);
    }
    if (memberAccess && memberAccess.length > 0) {
      this.memberAccess = memberAccess;
    }
    await this.executeCommands(macro.commands);
    return this.output;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async onExportIsObject(obj) {
    if (!this.memberAccess)
      return await super.onExportIsObject(obj);
    let newObj = obj;
    this.memberAccess.forEach((key) => {
      newObj = newObj[key];
    });
    await this.userScriptDelegator(newObj);
  }
};

// src/formatters/completeFormatter.ts
var import_obsidian21 = require("obsidian");

// src/engine/SingleInlineScriptEngine.ts
var SingleInlineScriptEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, choiceExecutor, variables) {
    super(app2, plugin, null, null, choiceExecutor, variables);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async runAndGetOutput(code) {
    const AsyncFunction = Object.getPrototypeOf(
      async function() {
      }
    ).constructor;
    const userCode = new AsyncFunction(code);
    return await userCode.bind(this.params, this).call();
  }
};

// src/gui/MathModal.ts
var import_obsidian19 = require("obsidian");

// src/LaTeXSymbols.ts
var LATEX_CURSOR_MOVE_HERE = "\u261A";
var commands = [
  "\\!",
  "\\,",
  "\\:",
  "\\>",
  "\\;",
  "\\#",
  "\\$",
  "\\%",
  "\\&",
  "\\",
  "_",
  "{ }",
  "|",
  `^{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `[${LATEX_CURSOR_MOVE_HERE}]${LATEX_CURSOR_MOVE_HERE}`,
  "\\above",
  "\\abovewithdelims",
  "\\acute",
  "\\aleph",
  "\\alpha",
  "\\amalg",
  "\\And",
  "\\angle",
  "\\approx",
  "\\approxeq",
  "\\arccos",
  "\\arcsin",
  "\\arctan",
  "\\arg",
  "\\array",
  "\\arrowvert",
  "\\Arrowvert",
  "\\ast",
  "\\asymp",
  "\\atop",
  "\\atopwithdelims",
  "\\backepsilon",
  "\\backprime",
  "\\backsim",
  "\\backsimeq",
  "\\backslash",
  "\\bar",
  "\\barwedge",
  "\\Bbb",
  "\\Bbbk",
  "\\because",
  "\\begin",
  "\\beta",
  "\\beth",
  "\\between",
  "\\bf",
  "\\Bigg",
  "\\bigg",
  "\\Big",
  "\\big",
  "\\Biggl",
  "\\Biggm",
  "\\Biggr",
  "\\biggl",
  "\\biggm",
  "\\biggr",
  "\\Bigl",
  "\\Bigm",
  "\\Bigl",
  "\\bigl",
  "\\bigm",
  "\\bigr",
  "\\bigcap",
  "\\bigcirc",
  "\\bigcup",
  "\\bigodot",
  "\\bigoplus",
  "\\bigotimes",
  "\\bigsqcup",
  "\\bigstar",
  "\\bigtriangledown",
  "\\bigtriangleup",
  "\\biguplus",
  "\\bigvee",
  "\\bigwedge",
  "\\binom",
  "\\blacklozenge",
  "\\blacksquare",
  "\\blacktriangle",
  "\\blacktriangledown",
  "\\blacktriangleleft",
  "\\blacktriangleright",
  "\\bmod",
  "\\boldsymbol",
  "\\bot",
  "\\bowtie",
  "\\Box",
  "\\boxdot",
  "\\boxed",
  "\\boxminus",
  "\\boxplus",
  "\\boxtimes",
  "\\brace",
  "\\bracevert",
  "\\brack",
  "\\breve",
  "\\bullet",
  "\\Bumpeq",
  "\\bumpeq",
  "\\cal",
  "\\cancel",
  "\\Cap",
  "\\cap",
  "\\cases",
  "\\cdot",
  "\\cdotp",
  "\\cdots",
  "\\centerdot",
  `\\cfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\check",
  "\\checkmark",
  "\\chi",
  "\\choose",
  "\\circ",
  "\\circeq",
  "\\circlearrowleft",
  "\\circlearrowright",
  "\\circledast",
  "\\circledcirc",
  "\\circleddash",
  "\\circledR",
  "\\circledS",
  "\\class",
  "\\clubsuit",
  "\\colon",
  "\\color",
  "\\complement",
  "\\cong",
  "\\coprod",
  "\\cos",
  "\\cosh",
  "\\cot",
  "\\coth",
  "\\cr",
  "\\csc",
  "\\cssId",
  "\\Cup",
  "\\cup",
  "\\curlyeqprec",
  "\\curlyeqsucc",
  "\\curlyvee",
  "\\curlywedge",
  "\\curvearrowleft",
  "\\curvearrowright",
  "\\dagger",
  "\\ddagger",
  "\\daleth",
  "\\dashleftarrow",
  "\\dashrightarrow",
  "\\dashv",
  "\\dbinom",
  "\\dot",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\ddots",
  "\\DeclareMathOperator",
  "\\def",
  "\\deg",
  "\\Delta",
  "\\delta",
  "\\det",
  `\\dfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\diagdown",
  "\\diagup",
  "\\Diamond",
  "\\diamond",
  "\\diamondsuit",
  "\\digamma",
  "\\dim",
  "\\displaylines",
  "\\displaystyle",
  "\\div",
  "\\divideontimes",
  "\\Doteq",
  "\\doteq",
  "\\dotplus",
  "\\dots",
  "\\dotsb",
  "\\dotsc",
  "\\dotsi",
  "\\dotsm",
  "\\dotso",
  "\\doublebarwedge",
  "\\doublecap",
  "\\doublecup",
  "\\downarrow",
  "\\Downarrow",
  "\\downdownarrows",
  "\\downharpoonleft",
  "\\downharpoonright",
  "\\ell",
  "\\emptyset",
  "\\end",
  "\\enspace",
  "\\epsilon",
  "\\eqalign",
  "\\eqalignno",
  "\\eqcirc",
  "\\eqsim",
  "\\eqslantgtr",
  "\\eqslantless",
  "\\equiv",
  "\\eta",
  "\\eth",
  "\\exists",
  "\\exp",
  "\\fallingdotseq",
  "\\fbox",
  "\\Finv",
  "\\flat",
  "\\forall",
  `\\frac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\frak",
  "\\frown",
  "\\Game",
  "\\Gamma",
  "\\gamma",
  "\\gcd",
  "\\ge",
  "\\geq",
  "\\geqq",
  "\\geqslant",
  "\\genfrac",
  "\\gets",
  "\\gg",
  "\\ggg",
  "\\gggtr",
  "\\gimel",
  "\\gtrapprox",
  "\\gnapprox",
  "\\gneq",
  "\\gneqq",
  "\\gvertneqq",
  "\\gtrsim",
  "\\gnsim",
  "\\grave",
  "\\gt",
  "\\gtrdot",
  "\\gtreqless",
  "\\gtreqqless",
  "\\gtrless",
  "\\hat",
  "\\hbar",
  "\\hbox",
  "\\hdashline",
  "\\hline",
  "\\heartsuit",
  "\\hfil",
  "\\hfill",
  "\\hom",
  "\\hookleftarrow",
  "\\hookrightarrow",
  "\\hphantom",
  "\\href",
  "\\hskip",
  "\\hslash",
  "\\hspace",
  "\\Huge",
  "\\huge",
  "\\iddots",
  "\\idotsint",
  "\\iff",
  "\\iiiint",
  "\\iiint",
  "\\iint",
  "\\int",
  "\\intop",
  "\\Im",
  "\\imath",
  "\\impliedby",
  "\\implies",
  "\\in",
  "\\inf",
  "\\infty",
  "\\injlim",
  "\\intercal",
  "\\iota",
  "\\it",
  "\\jmath",
  "\\Join",
  "\\kappa",
  "\\ker",
  "\\kern",
  "\\Lambda",
  "\\lambda",
  "\\land",
  "\\langle",
  "\\LARGE",
  "\\Large",
  "\\large",
  "\\LaTeX",
  "\\lbrace",
  "\\lbrack",
  "\\lceil",
  "\\ldotp",
  "\\ldots",
  "\\le",
  "\\leq",
  "\\leqq",
  "\\leqslant",
  "\\leadsto",
  "\\left",
  "\\leftarrow",
  "\\Leftarrow",
  "\\leftarrowtail",
  "\\leftharpoondown",
  "\\leftharpoonup",
  "\\leftleftarrows",
  "\\leftrightarrow",
  "\\Leftrightarrow",
  "\\leftrightarrows",
  "\\leftrightharpoons",
  "\\leftrightsquigarrow",
  "\\leftroot",
  "\\leftthreetimes",
  "\\leqalignno",
  "\\lessapprox",
  "\\lessdot",
  "\\lesseqgtr",
  "\\lesseqqgtr",
  "\\lessgtr",
  "\\lesssim",
  "\\lfloor",
  "\\lg",
  "\\lgroup",
  "\\lhd",
  "\\lim",
  "\\liminf",
  "\\limits",
  "\\limsup",
  "\\ll",
  "\\llap",
  "\\llcorner",
  "\\lrcorner",
  "\\Lleftarrow",
  "\\lll",
  "\\llless",
  "\\lmoustache",
  "\\ln",
  "\\lnapprox",
  "\\lneq",
  "\\lneqq",
  "\\lnot",
  "\\lnsim",
  "\\log",
  "\\longleftarrow",
  "\\Longleftarrow",
  "\\longrightarrow",
  "\\Longrightarrow",
  "\\longleftrightarrow",
  "\\Longleftrightarrow",
  "\\longmapsto",
  "\\looparrowleft",
  "\\looparrowright",
  "\\lor",
  "\\lower",
  "\\lozenge",
  "\\Lsh",
  "\\lt",
  "\\ltimes",
  "\\lvert",
  "\\lVert",
  "\\lvertneqq",
  "\\maltese",
  "\\mapsto",
  "\\mathbb",
  "\\mathbf",
  "\\mathbin",
  "\\mathcal",
  "\\mathchoice",
  "\\mathclose",
  "\\mathfrak",
  "\\mathinner",
  "\\mathit",
  "\\mathop",
  "\\mathopen",
  "\\mathord",
  "\\mathpunct",
  "\\mathrel",
  "\\mathring",
  "\\mathrm",
  "\\mathscr",
  "\\mathsf",
  "\\mathstrut",
  "\\mathtt",
  "\\matrix",
  "\\max",
  "\\mbox",
  "\\measuredangle",
  "\\mho",
  "\\mid",
  "\\min",
  "\\mit",
  "\\mod",
  "\\models",
  "\\moveleft",
  "\\moveright",
  "\\mp",
  "\\mskip",
  "\\mspace",
  "\\mu",
  "\\multimap",
  "\\nabla",
  "\\natural",
  "\\ncong",
  "\\ne",
  "\\nearrow",
  "\\neg",
  "\\negthinspace",
  "\\negmedspace",
  "\\negthickspace",
  "\\neq",
  "\\newcommand",
  "\\newenvironment",
  "\\newline",
  "\\nexists",
  "\\ngeq",
  "\\ngeqq",
  "\\ngeqslant",
  "\\ngtr",
  "\\ni",
  "\\nleftarrow",
  "\\nLeftarrow",
  "\\nleftrightarrow",
  "\\nLeftrightarrow",
  "\\nleq",
  "\\nleqq",
  "\\nleqslant",
  "\\nless",
  "\\nmid",
  "\\nobreakspace",
  "\\nolimits",
  "\\normalsize",
  "\\not",
  "\\notag",
  "\\notin",
  "\\nparallel",
  "\\nprec",
  "\\npreceq",
  "\\nrightarrow",
  "\\nRightarrow",
  "\\nshortmid",
  "\\nshortparallel",
  "\\nsim",
  "\\nsubseteq",
  "\\nsubseteqq",
  "\\nsucc",
  "\\nsucceq",
  "\\nsupseteq",
  "\\nsupseteqq",
  "\\ntriangleleft",
  "\\ntrianglelefteq",
  "\\ntriangleright",
  "\\ntrianglerighteq",
  "\\nu",
  "\\nVDash",
  "\\nVdash",
  "\\nvDash",
  "\\nvdash",
  "\\nwarrow",
  "\\odot",
  "\\ominus",
  "\\oplus",
  "\\oslash",
  "\\otimes",
  "\\oint",
  "\\oldstyle",
  "\\omega",
  "\\Omega",
  "\\omicron",
  "\\operatorname",
  "\\over",
  "\\overbrace",
  "\\overleftarrow",
  "\\overrightarrow",
  "\\overleftrightarrow",
  "\\overline",
  "\\overparen",
  "\\overset",
  "\\overwithdelims",
  "\\owns",
  "\\parallel",
  "\\partial",
  "\\perp",
  "\\phantom",
  "\\phi",
  "\\Phi",
  "\\pi",
  "\\Pi",
  "\\pitchfork",
  "\\pm",
  "\\pmatrix",
  "\\pmb",
  "\\pmod",
  "\\pod",
  "\\Pr",
  "\\prec",
  "\\precapprox",
  "\\precnapprox",
  "\\preccurlyeq",
  "\\preceq",
  "\\precneqq",
  "\\precsim",
  "\\precnsim",
  "\\prime",
  "\\prod",
  "\\projlim",
  "\\propto",
  "\\psi",
  "\\Psi",
  "\\quad",
  "\\qquad",
  "\\raise",
  "\\rangle",
  "\\rbrace",
  "\\rbrack",
  "\\rceil",
  "\\Re",
  "\\renewcommand",
  "\\require (non-standard)",
  "\\restriction",
  "\\rfloor",
  "\\rgroup",
  "\\rhd",
  "\\rho",
  "\\right",
  "\\rightarrow",
  "\\Rightarrow",
  "\\rightarrowtail",
  "\\rightharpoondown",
  "\\rightharpoonup",
  "\\rightleftarrows",
  "\\rightleftharpoons",
  "\\rightrightarrows",
  "\\rightsquigarrow",
  "\\rightthreetimes",
  "\\risingdotseq",
  "\\rlap",
  "\\rm",
  "\\rmoustache",
  "\\Rrightarrow",
  "\\Rsh",
  "\\rtimes",
  "\\Rule (non-standard)",
  "\\rvert",
  "\\rVert",
  "\\S",
  "\\scr",
  "\\scriptscriptstyle",
  "\\scriptsize",
  "\\scriptstyle",
  "\\searrow",
  "\\sec",
  "\\setminus",
  "\\sf",
  "\\sharp",
  "\\shortmid",
  "\\shortparallel",
  "\\shoveleft",
  "\\shoveright",
  "\\sideset",
  "\\sigma",
  "\\Sigma",
  "\\sim",
  "\\simeq",
  "\\sin",
  "\\sinh",
  "\\skew",
  "\\small",
  "\\smallfrown",
  "\\smallint",
  "\\smallsetminus",
  "\\smallsmile",
  "\\smash",
  "\\smile",
  "\\space",
  "\\Space (non-standard)",
  "\\spadesuit",
  "\\sphericalangle",
  "\\sqcap",
  "\\sqcup",
  "\\sqrt",
  "\\sqsubset",
  "\\sqsupset",
  "\\sqsubseteq",
  "\\sqsupseteq",
  "\\square",
  "\\stackrel",
  "\\star",
  "\\strut",
  "\\style",
  "\\subset",
  "\\Subset",
  "\\subseteq",
  "\\subsetneq",
  "\\subseteqq",
  "\\subsetneqq",
  "\\substack",
  "\\succ",
  "\\succapprox",
  "\\succnapprox",
  "\\succcurlyeq",
  "\\succeq",
  "\\succneqq",
  "\\succsim",
  "\\succnsim",
  "\\sum",
  "\\sup",
  "\\supset",
  "\\Supset",
  "\\supseteq",
  "\\supsetneq",
  "\\supseteqq",
  "\\supsetneqq",
  "\\surd",
  "\\swarrow",
  "\\tag",
  "\\tan",
  "\\tanh",
  "\\tau",
  "\\tbinom",
  "\\TeX",
  `\\text{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textbf{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textit{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textrm{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textsf{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\texttt{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\textstyle",
  `\\tfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\therefore",
  "\\theta",
  "\\Theta",
  "\\thickapprox",
  "\\thicksim",
  "\\thinspace",
  "\\tilde",
  "\\times",
  "\\tiny",
  "\\Tiny",
  "\\to",
  "\\top",
  "\\triangle",
  "\\triangledown",
  "\\triangleleft",
  "\\triangleright",
  "\\trianglelefteq",
  "\\trianglerighteq",
  "\\triangleq",
  "\\tt",
  "\\twoheadleftarrow",
  "\\twoheadrightarrow",
  "\\ulcorner",
  "\\urcorner",
  "\\underbrace",
  "\\underleftarrow",
  "\\underrightarrow",
  "\\underleftrightarrow",
  "\\underline",
  "\\underparen",
  "\\underset",
  "\\unicode",
  "\\unlhd",
  "\\unrhd",
  "\\uparrow",
  "\\Uparrow",
  "\\updownarrow",
  "\\Updownarrow",
  "\\upharpoonleft",
  "\\upharpoonright",
  "\\uplus",
  "\\uproot",
  "\\upsilon",
  "\\Upsilon",
  "\\upuparrows",
  "\\varDelta",
  "\\varepsilon",
  "\\varGamma",
  "\\varinjlim",
  "\\varkappa",
  "\\varLambda",
  "\\varlimsup",
  "\\varliminf",
  "\\varnothing",
  "\\varOmega",
  "\\varphi",
  "\\varPhi",
  "\\varpi",
  "\\varPi",
  "\\varprojlim",
  "\\varpropto",
  "\\varPsi",
  "\\varrho",
  "\\varsigma",
  "\\varSigma",
  "\\varsubsetneq",
  "\\varsubsetneqq",
  "\\varsupsetneq",
  "\\varsupsetneqq",
  "\\vartheta",
  "\\varTheta",
  "\\vartriangle",
  "\\vartriangleleft",
  "\\vartriangleright",
  "\\varUpsilon",
  "\\varXi",
  "\\vcenter",
  "\\vdash",
  "\\Vdash",
  "\\vDash",
  "\\vdots",
  "\\vec",
  "\\vee",
  "\\veebar",
  "\\verb",
  "\\vert",
  "\\Vert",
  "\\vphantom",
  "\\Vvdash",
  "\\wedge",
  "\\widehat",
  "\\widetilde",
  "\\wp",
  "\\wr",
  "\\Xi",
  "\\xi",
  "\\xleftarrow",
  "\\xrightarrow",
  "\\yen",
  "\\zeta",
  "\\{%C\\}%C",
  "\\langle %C \\rangle%C"
];
var environments = [
  "align",
  "align*",
  "alignat",
  "alignat*",
  "array",
  "Bmatrix",
  "bmatrix",
  "cases",
  "eqnarray",
  "eqnarray*",
  "equation",
  "equation*",
  "gather",
  "gather*",
  "matrix",
  "pmatrix",
  "smallmatrix",
  "subarray",
  "Vmatrix",
  "vmatrix"
];
function beginEndGen(symbol) {
  return `\\begin{${symbol}}
${LATEX_CURSOR_MOVE_HERE}
\\end{${symbol}}${LATEX_CURSOR_MOVE_HERE}`;
}
var LaTeXSymbols = [...commands, ...environments.map(beginEndGen)];

// src/gui/suggesters/LaTeXSuggester.ts
var import_obsidian18 = require("obsidian");
var LATEX_REGEX = new RegExp(/\\([a-z{}A-Z0-9]*)$/);
var LaTeXSuggester = class extends TextInputSuggest {
  constructor(inputEl) {
    super(QuickAdd.instance.app, inputEl);
    this.inputEl = inputEl;
    this.lastInput = "";
    this.symbols = Object.assign([], LaTeXSymbols);
    this.elementsRendered = this.symbols.reduce((elements, symbol) => {
      try {
        elements[symbol.toString()] = (0, import_obsidian18.renderMath)(symbol, true);
      } catch {
      }
      return elements;
    }, {});
  }
  getSuggestions(inputStr) {
    if (this.inputEl.selectionStart === null) {
      return [];
    }
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const lastBackslashPos = inputBeforeCursor.lastIndexOf("\\");
    const commandText = inputBeforeCursor.substr(lastBackslashPos);
    const match = LATEX_REGEX.exec(commandText);
    let suggestions = [];
    if (match) {
      this.lastInput = match[1];
      suggestions = this.symbols.filter(
        (val) => (
          //@ts-ignore
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          val.toLowerCase().contains(this.lastInput)
        )
      );
    }
    const fuse = new Fuse(suggestions, {
      findAllMatches: true,
      threshold: 0.8
    });
    const searchResults = fuse.search(this.lastInput);
    return searchResults.map((value) => value.item);
  }
  renderSuggestion(item, el) {
    if (item) {
      el.setText(item);
      el.append(this.elementsRendered[item]);
    }
  }
  selectSuggestion(item) {
    if (this.inputEl.selectionStart === null)
      return;
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const textToInsert = item.replace(/\\\\/g, "\\");
    this.inputEl.value = `${currentInputValue.substr(
      0,
      cursorPosition - lastInputLength - 1
    )}${textToInsert}${currentInputValue.substr(cursorPosition)}`;
    insertedEndPosition = cursorPosition - lastInputLength + item.length - 1;
    this.inputEl.trigger("input");
    this.close();
    if (item.contains(LATEX_CURSOR_MOVE_HERE)) {
      const cursorPos = this.inputEl.value.indexOf(
        LATEX_CURSOR_MOVE_HERE
      );
      this.inputEl.value = this.inputEl.value.replace(
        LATEX_CURSOR_MOVE_HERE,
        ""
      );
      this.inputEl.setSelectionRange(cursorPos, cursorPos);
    } else {
      this.inputEl.setSelectionRange(
        insertedEndPosition,
        insertedEndPosition
      );
    }
  }
};

// src/gui/MathModal.ts
var MathModal = class extends import_obsidian19.Modal {
  constructor() {
    super(QuickAdd.instance.app);
    this.didSubmit = false;
    this.keybindListener = (evt) => {
      if (evt.ctrlKey && evt.key === "Enter") {
        this.submit();
      }
      if (evt.key === "Tab") {
        evt.preventDefault();
        this.cursorToGoTo();
      }
    };
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.open();
    this.display();
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    new LaTeXSuggester(this.inputEl);
    this.inputEl.focus();
    this.inputEl.select();
  }
  static Prompt() {
    return new MathModal().waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaMathModal");
    this.contentEl.empty();
    const mathDiv = this.contentEl.createDiv();
    mathDiv.className = "math math-block is-loaded";
    const tc = new import_obsidian19.TextAreaComponent(this.contentEl);
    tc.inputEl.style.width = "100%";
    tc.inputEl.style.height = "10rem";
    this.inputEl = tc.inputEl;
    tc.onChange(
      (0, import_obsidian19.debounce)(
        async (value) => await this.mathjaxLoop(mathDiv, value),
        50
      )
    );
    tc.inputEl.addEventListener("keydown", this.keybindListener);
    this.createButtonBar(this.contentEl.createDiv());
  }
  async onOpen() {
    super.onOpen();
    await (0, import_obsidian19.loadMathJax)();
  }
  async mathjaxLoop(container, value) {
    const html = (0, import_obsidian19.renderMath)(value, true);
    await (0, import_obsidian19.finishRenderMath)();
    container.empty();
    container.append(html);
  }
  cursorToGoTo() {
    if (this.inputEl.value.contains(LATEX_CURSOR_MOVE_HERE)) {
      const cursorPos = this.inputEl.value.indexOf(
        LATEX_CURSOR_MOVE_HERE
      );
      this.inputEl.value = this.inputEl.value.replace(
        LATEX_CURSOR_MOVE_HERE,
        ""
      );
      this.inputEl.setSelectionRange(cursorPos, cursorPos);
    }
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian19.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  removeInputListeners() {
    this.inputEl.removeEventListener("keydown", this.keybindListener);
  }
  resolveInput() {
    const output = this.inputEl.value.replace("\\n", `\\\\n`).replace(new RegExp(LATEX_CURSOR_MOVE_HERE, "g"), "");
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(output);
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListeners();
  }
};

// src/gui/InputPrompt.ts
var InputPrompt = class {
  factory() {
    if (QuickAdd.instance.settings.inputPrompt === "multi-line") {
      return GenericWideInputPrompt;
    } else {
      return GenericInputPrompt;
    }
  }
};

// src/gui/InputSuggester/inputSuggester.ts
var import_obsidian20 = require("obsidian");
var InputSuggester = class extends import_obsidian20.FuzzySuggestModal {
  constructor(app2, displayItems, items, options = {}) {
    super(app2);
    this.displayItems = displayItems;
    this.items = items;
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.inputEl.addEventListener("keydown", (event) => {
      if (event.code !== "Tab" || !("chooser" in this)) {
        return;
      }
      const { values, selectedItem } = this.chooser;
      const { value } = this.inputEl;
      this.inputEl.value = values[selectedItem].item ?? value;
    });
    if (options.placeholder)
      this.setPlaceholder(options.placeholder);
    if (options.limit)
      this.limit = options.limit;
    if (options.emptyStateText)
      this.emptyStateText = options.emptyStateText;
    this.open();
  }
  static Suggest(app2, displayItems, items, options = {}) {
    const newSuggester = new InputSuggester(
      app2,
      displayItems,
      items,
      options
    );
    return newSuggester.promise;
  }
  getItemText(item) {
    if (item === this.inputEl.value)
      return item;
    return this.displayItems[this.items.indexOf(item)];
  }
  getItems() {
    if (this.inputEl.value === "")
      return this.items;
    return [this.inputEl.value, ...this.items];
  }
  selectSuggestion(value, evt) {
    this.resolved = true;
    super.selectSuggestion(value, evt);
  }
  onChooseItem(item, evt) {
    this.resolved = true;
    this.resolvePromise(item);
  }
  onClose() {
    super.onClose();
    if (!this.resolved)
      this.rejectPromise("no input given.");
  }
};

// src/formatters/completeFormatter.ts
var CompleteFormatter = class extends Formatter {
  constructor(app2, plugin, choiceExecutor) {
    super();
    this.app = app2;
    this.plugin = plugin;
    this.choiceExecutor = choiceExecutor;
    if (choiceExecutor) {
      this.variables = choiceExecutor?.variables;
    }
  }
  async format(input) {
    let output = input;
    output = await this.replaceInlineJavascriptInString(output);
    output = await this.replaceMacrosInString(output);
    output = await this.replaceTemplateInString(output);
    output = this.replaceDateInString(output);
    output = this.replaceTimeInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceSelectedInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    output = await this.replaceFieldVarInString(output);
    output = await this.replaceMathValueInString(output);
    return output;
  }
  async formatFileName(input, valueHeader) {
    this.valueHeader = valueHeader;
    return await this.format(input);
  }
  async formatFileContent(input) {
    let output = input;
    output = await this.format(output);
    output = await this.replaceLinkToCurrentFileInString(output);
    return output;
  }
  async formatFolderPath(folderName) {
    return await this.format(folderName);
  }
  getCurrentFileLink() {
    const currentFile = this.app.workspace.getActiveFile();
    if (!currentFile)
      return null;
    return this.app.fileManager.generateMarkdownLink(currentFile, "");
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  getVariableValue(variableName) {
    return this.variables.get(variableName);
  }
  async promptForValue(header) {
    if (!this.value) {
      const selectedText = await this.getSelectedText();
      this.value = selectedText ? selectedText : await new InputPrompt().factory().Prompt(this.app, this.valueHeader ?? `Enter value`);
    }
    return this.value;
  }
  async promptForVariable(header) {
    return await new InputPrompt().factory().Prompt(this.app, header);
  }
  async promptForMathValue() {
    return await MathModal.Prompt();
  }
  async suggestForValue(suggestedValues) {
    return await GenericSuggester.Suggest(
      this.app,
      suggestedValues,
      suggestedValues
    );
  }
  async suggestForField(variableName) {
    const suggestedValues = /* @__PURE__ */ new Set();
    for (const file of this.app.vault.getMarkdownFiles()) {
      const cache = this.app.metadataCache.getFileCache(file);
      const value = cache?.frontmatter?.[variableName];
      if (!value || typeof value == "object")
        continue;
      suggestedValues.add(value.toString());
    }
    if (suggestedValues.size === 0) {
      return await GenericInputPrompt.Prompt(
        app,
        `Enter value for ${variableName}`,
        `No existing values were found in your vault.`
      );
    }
    const suggestedValuesArr = Array.from(suggestedValues);
    return await InputSuggester.Suggest(
      this.app,
      suggestedValuesArr,
      suggestedValuesArr,
      {
        placeholder: `Enter value for ${variableName}`
      }
    );
  }
  async getMacroValue(macroName) {
    const macroEngine = new SingleMacroEngine(
      this.app,
      this.plugin,
      this.plugin.settings.macros,
      //@ts-ignore
      this.choiceExecutor,
      this.variables
    );
    const macroOutput = await macroEngine.runAndGetOutput(macroName) ?? "";
    Object.keys(macroEngine.params.variables).forEach((key) => {
      this.variables.set(key, macroEngine.params.variables[key]);
    });
    return macroOutput;
  }
  async getTemplateContent(templatePath) {
    return await new SingleTemplateEngine(
      this.app,
      this.plugin,
      templatePath,
      this.choiceExecutor
    ).run();
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getSelectedText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
    if (!activeView)
      return "";
    return activeView.editor.getSelection();
  }
  async replaceInlineJavascriptInString(input) {
    let output = input;
    while (INLINE_JAVASCRIPT_REGEX.test(output)) {
      const match = INLINE_JAVASCRIPT_REGEX.exec(output);
      const code = match?.at(1)?.trim();
      if (code) {
        const executor = new SingleInlineScriptEngine(
          this.app,
          this.plugin,
          //@ts-ignore
          this.choiceExecutor,
          this.variables
        );
        const outVal = await executor.runAndGetOutput(code);
        for (const key in executor.params.variables) {
          this.variables.set(key, executor.params.variables[key]);
        }
        output = typeof outVal === "string" ? this.replacer(output, INLINE_JAVASCRIPT_REGEX, outVal) : this.replacer(output, INLINE_JAVASCRIPT_REGEX, "");
      }
    }
    return output;
  }
};

// src/engine/TemplateEngine.ts
var import_obsidian22 = require("obsidian");
var TemplateEngine = class extends QuickAddEngine {
  constructor(app2, plugin, choiceFormatter) {
    super(app2);
    this.plugin = plugin;
    this.templater = getTemplater(app2);
    this.formatter = new CompleteFormatter(app2, plugin, choiceFormatter);
  }
  async getOrCreateFolder(folders) {
    let folderPath;
    if (folders.length > 1) {
      folderPath = await GenericSuggester.Suggest(
        this.app,
        folders,
        folders
      );
      if (!folderPath)
        throw new Error("No folder selected.");
    } else {
      folderPath = folders[0];
    }
    if (folderPath)
      await this.createFolder(folderPath);
    else
      folderPath = "";
    return folderPath;
  }
  async getFormattedFilePath(folderPath, format3, promptHeader) {
    const formattedName = await this.formatter.formatFileName(
      format3,
      promptHeader
    );
    return this.normalizeMarkdownFilePath(folderPath, formattedName);
  }
  async incrementFileName(fileName) {
    const exec = FILE_NUMBER_REGEX.exec(fileName);
    const numStr = exec && typeof exec.at === "function" ? exec?.at(1) : void 0;
    const fileExists = await this.app.vault.adapter.exists(fileName);
    let newFileName = fileName;
    if (fileExists && numStr) {
      const number = parseInt(numStr);
      if (!number)
        throw new Error("detected numbers but couldn't get them.");
      newFileName = newFileName.replace(
        FILE_NUMBER_REGEX,
        `${number + 1}.md`
      );
    } else if (fileExists) {
      newFileName = newFileName.replace(FILE_NUMBER_REGEX, `${1}.md`);
    }
    const newFileExists = await this.app.vault.adapter.exists(newFileName);
    if (newFileExists)
      newFileName = await this.incrementFileName(newFileName);
    return newFileName;
  }
  async createFileWithTemplate(filePath, templatePath) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      const createdFile = await this.createFileWithInput(
        filePath,
        formattedTemplateContent
      );
      await replaceTemplaterTemplatesInCreatedFile(this.app, createdFile);
      return createdFile;
    } catch (e) {
      log.logError(
        `Could not create file with template: 

${e.message}`
      );
      return null;
    }
  }
  async overwriteFileWithTemplate(file, templatePath) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      await this.app.vault.modify(file, formattedTemplateContent);
      await replaceTemplaterTemplatesInCreatedFile(this.app, file, true);
      return file;
    } catch (e) {
      log.logError(e);
      return null;
    }
  }
  async appendToFileWithTemplate(file, templatePath, section) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      const fileContent = await this.app.vault.cachedRead(file);
      const newFileContent = section === "top" ? `${formattedTemplateContent}
${fileContent}` : `${fileContent}
${formattedTemplateContent}`;
      await this.app.vault.modify(file, newFileContent);
      await replaceTemplaterTemplatesInCreatedFile(this.app, file, true);
      return file;
    } catch (e) {
      log.logError(e);
      return null;
    }
  }
  async getTemplateContent(templatePath) {
    let correctTemplatePath = templatePath;
    if (!MARKDOWN_FILE_EXTENSION_REGEX.test(templatePath))
      correctTemplatePath += ".md";
    const templateFile = this.app.vault.getAbstractFileByPath(correctTemplatePath);
    if (!(templateFile instanceof import_obsidian22.TFile))
      throw new Error(
        `Template file not found at path "${correctTemplatePath}".`
      );
    return await this.app.vault.cachedRead(templateFile);
  }
};

// src/engine/SingleTemplateEngine.ts
var SingleTemplateEngine = class extends TemplateEngine {
  constructor(app2, plugin, templatePath, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.templatePath = templatePath;
  }
  async run() {
    let templateContent = await this.getTemplateContent(
      this.templatePath
    );
    if (!templateContent) {
      log.logError(`Template ${this.templatePath} not found.`);
    }
    templateContent = await this.formatter.formatFileContent(
      templateContent
    );
    return templateContent;
  }
};

// src/formatters/formatDisplayFormatter.ts
var FormatDisplayFormatter = class extends Formatter {
  constructor(app2, plugin) {
    super();
    this.app = app2;
    this.plugin = plugin;
  }
  async format(input) {
    let output = input;
    output = this.replaceDateInString(output);
    output = this.replaceTimeInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    output = await this.replaceLinkToCurrentFileInString(output);
    output = await this.replaceMacrosInString(output);
    output = await this.replaceTemplateInString(output);
    output = await this.replaceFieldVarInString(output);
    output = this.replaceLinebreakInString(output);
    return output;
  }
  promptForValue(header) {
    return "_value_";
  }
  getVariableValue(variableName) {
    return variableName;
  }
  getCurrentFileLink() {
    return this.app.workspace.getActiveFile()?.path ?? "_noPageOpen_";
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  suggestForValue(suggestedValues) {
    return "_suggest_";
  }
  getMacroValue(macroName) {
    return `_macro: ${macroName}_`;
  }
  promptForMathValue() {
    return Promise.resolve("_math_");
  }
  promptForVariable(variableName) {
    return Promise.resolve(`${variableName}_`);
  }
  async getTemplateContent(templatePath) {
    try {
      return await new SingleTemplateEngine(
        this.app,
        this.plugin,
        templatePath,
        void 0
      ).run();
    } catch (e) {
      return `Template (not found): ${templatePath}`;
    }
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getSelectedText() {
    return "_selected_";
  }
  async suggestForField(variableName) {
    return Promise.resolve(`_field: ${variableName}_`);
  }
};

// src/gui/ChoiceBuilder/captureChoiceBuilder.ts
var CaptureChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, plugin) {
    super(app2);
    this.plugin = plugin;
    this.choice = choice;
    this.display();
  }
  display() {
    this.containerEl.addClass("captureChoiceBuilder");
    this.contentEl.empty();
    this.addCenteredChoiceNameHeader(this.choice);
    this.addCapturedToSetting();
    if (!this.choice?.captureToActiveFile) {
      this.addCreateIfNotExistsSetting();
      if (this.choice?.createFileIfItDoesntExist?.enabled)
        this.addCreateWithTemplateSetting();
    }
    this.addTaskSetting();
    this.addPrependSetting();
    this.addAppendLinkSetting();
    this.addInsertAfterSetting();
    if (!this.choice.captureToActiveFile) {
      this.addOpenFileSetting();
      if (this.choice.openFile) {
        this.addOpenFileInNewTabSetting();
      }
    }
    this.addFormatSetting();
  }
  addCapturedToSetting() {
    let textField;
    new import_obsidian23.Setting(this.contentEl).setName("Capture To").setDesc("File to capture to. Supports some format syntax.");
    const captureToContainer = this.contentEl.createDiv("captureToContainer");
    const captureToActiveFileContainer = captureToContainer.createDiv("captureToActiveFileContainer");
    const captureToActiveFileText = captureToActiveFileContainer.createEl("span");
    captureToActiveFileText.textContent = "Capture to active file";
    const captureToActiveFileToggle = new import_obsidian23.ToggleComponent(
      captureToActiveFileContainer
    );
    captureToActiveFileToggle.setValue(this.choice?.captureToActiveFile);
    captureToActiveFileToggle.onChange((value) => {
      this.choice.captureToActiveFile = value;
      this.reload();
    });
    if (!this.choice?.captureToActiveFile) {
      const captureToFileContainer = captureToContainer.createDiv("captureToFileContainer");
      const formatDisplay = captureToFileContainer.createEl("span");
      const displayFormatter = new FileNameDisplayFormatter(this.app);
      void (async () => formatDisplay.textContent = await displayFormatter.format(
        this.choice.captureTo
      ))();
      const formatInput = new import_obsidian23.TextComponent(captureToFileContainer);
      formatInput.setPlaceholder("File name format");
      textField = formatInput;
      formatInput.inputEl.style.width = "100%";
      formatInput.inputEl.style.marginBottom = "8px";
      formatInput.setValue(this.choice.captureTo).setDisabled(this.choice?.captureToActiveFile).onChange(async (value) => {
        this.choice.captureTo = value;
        formatDisplay.textContent = await displayFormatter.format(
          value
        );
      });
      const markdownFilesAndFormatSyntax = [
        ...this.app.vault.getMarkdownFiles().map((f) => f.path),
        ...FILE_NAME_FORMAT_SYNTAX
      ];
      new GenericTextSuggester(
        this.app,
        textField.inputEl,
        markdownFilesAndFormatSyntax,
        50
      );
    }
  }
  addPrependSetting() {
    const prependSetting = new import_obsidian23.Setting(this.contentEl);
    prependSetting.setName("Write to bottom of file").setDesc(
      `Put value at the bottom of the file - otherwise at the ${this.choice?.captureToActiveFile ? "active cursor location" : "top"}.`
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.prepend);
      toggle.onChange((value) => {
        this.choice.prepend = value;
        if (this.choice.prepend && this.choice.insertAfter.enabled) {
          this.choice.insertAfter.enabled = false;
          this.reload();
        }
      });
    });
  }
  addTaskSetting() {
    const taskSetting = new import_obsidian23.Setting(this.contentEl);
    taskSetting.setName("Task").setDesc("Formats the value as a task.").addToggle((toggle) => {
      toggle.setValue(this.choice.task);
      toggle.onChange((value) => this.choice.task = value);
    });
  }
  addAppendLinkSetting() {
    const appendLinkSetting = new import_obsidian23.Setting(this.contentEl);
    appendLinkSetting.setName("Append link").setDesc(
      "Add a link on your current cursor position, linking to the file you're capturing to."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.appendLink);
      toggle.onChange((value) => this.choice.appendLink = value);
    });
  }
  addInsertAfterSetting() {
    let insertAfterInput;
    const insertAfterSetting = new import_obsidian23.Setting(this.contentEl);
    insertAfterSetting.setName("Insert after").setDesc(
      "Insert capture after specified line. Accepts format syntax."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.insertAfter.enabled);
      toggle.onChange((value) => {
        this.choice.insertAfter.enabled = value;
        insertAfterInput.setDisabled(!value);
        if (this.choice.insertAfter.enabled && this.choice.prepend) {
          this.choice.prepend = false;
        }
        this.reload();
      });
    });
    const insertAfterFormatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FormatDisplayFormatter(this.app, this.plugin);
    void (async () => insertAfterFormatDisplay.innerText = await displayFormatter.format(
      this.choice.insertAfter.after
    ))();
    insertAfterInput = new import_obsidian23.TextComponent(this.contentEl);
    insertAfterInput.setPlaceholder("Insert after");
    insertAfterInput.inputEl.style.width = "100%";
    insertAfterInput.inputEl.style.marginBottom = "8px";
    insertAfterInput.setValue(this.choice.insertAfter.after).setDisabled(!this.choice.insertAfter.enabled).onChange(async (value) => {
      this.choice.insertAfter.after = value;
      insertAfterFormatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(
      this.app,
      insertAfterInput.inputEl,
      this.plugin
    );
    if (this.choice.insertAfter.enabled) {
      const insertAtEndSetting = new import_obsidian23.Setting(this.contentEl);
      insertAtEndSetting.setName("Insert at end of section").setDesc(
        "Insert the text at the end of the section, rather than at the top."
      ).addToggle(
        (toggle) => toggle.setValue(this.choice.insertAfter?.insertAtEnd).onChange(
          (value) => this.choice.insertAfter.insertAtEnd = value
        )
      );
      const considerSubsectionsSetting = new import_obsidian23.Setting(
        this.contentEl
      );
      considerSubsectionsSetting.setName("Consider subsections").setDesc(
        "Enabling this will insert the text at the end of the section & its subsections, rather than just at the end of the target section.A section is defined by a heading, and its subsections are all the headings inside that section."
      ).addToggle(
        (toggle) => toggle.setValue(this.choice.insertAfter?.considerSubsections).onChange((value) => {
          if (!value) {
            this.choice.insertAfter.considerSubsections = false;
            return;
          }
          const targetIsHeading = this.choice.insertAfter.after.startsWith("#");
          if (targetIsHeading) {
            this.choice.insertAfter.considerSubsections = value;
          } else {
            this.choice.insertAfter.considerSubsections = false;
            log.logError(
              "'Consider subsections' can only be enabled if the insert after line starts with a # (heading)."
            );
            this.display();
          }
        })
      );
      const createLineIfNotFound = new import_obsidian23.Setting(this.contentEl);
      createLineIfNotFound.setName("Create line if not found").setDesc("Creates the 'insert after' line if it is not found.").addToggle((toggle) => {
        if (!this.choice.insertAfter?.createIfNotFound)
          this.choice.insertAfter.createIfNotFound = false;
        toggle.setValue(this.choice.insertAfter?.createIfNotFound).onChange(
          (value) => this.choice.insertAfter.createIfNotFound = value
        ).toggleEl.style.marginRight = "1em";
      }).addDropdown((dropdown) => {
        if (!this.choice.insertAfter?.createIfNotFoundLocation)
          this.choice.insertAfter.createIfNotFoundLocation = CREATE_IF_NOT_FOUND_TOP;
        dropdown.addOption(CREATE_IF_NOT_FOUND_TOP, "Top").addOption(CREATE_IF_NOT_FOUND_BOTTOM, "Bottom").setValue(
          this.choice.insertAfter?.createIfNotFoundLocation
        ).onChange(
          (value) => this.choice.insertAfter.createIfNotFoundLocation = value
        );
      });
    }
  }
  addFormatSetting() {
    let textField;
    const enableSetting = new import_obsidian23.Setting(this.contentEl);
    enableSetting.setName("Capture format").setDesc("Set the format of the capture.").addToggle((toggleComponent) => {
      toggleComponent.setValue(this.choice.format.enabled).onChange((value) => {
        this.choice.format.enabled = value;
        textField.setDisabled(!value);
      });
    });
    const formatInput = new import_obsidian23.TextAreaComponent(this.contentEl);
    formatInput.setPlaceholder("Format");
    textField = formatInput;
    formatInput.inputEl.style.width = "100%";
    formatInput.inputEl.style.marginBottom = "8px";
    formatInput.inputEl.style.height = "10rem";
    formatInput.inputEl.style.minHeight = "10rem";
    formatInput.setValue(this.choice.format.format).setDisabled(!this.choice.format.enabled).onChange(async (value) => {
      this.choice.format.format = value;
      formatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(this.app, textField.inputEl, this.plugin);
    const formatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FormatDisplayFormatter(this.app, this.plugin);
    void (async () => formatDisplay.innerText = await displayFormatter.format(
      this.choice.format.format
    ))();
  }
  addCreateIfNotExistsSetting() {
    if (!this.choice.createFileIfItDoesntExist)
      this.choice.createFileIfItDoesntExist = {
        enabled: false,
        createWithTemplate: false,
        template: ""
      };
    const createFileIfItDoesntExist = new import_obsidian23.Setting(this.contentEl);
    createFileIfItDoesntExist.setName("Create file if it doesn't exist").addToggle(
      (toggle) => toggle.setValue(this.choice?.createFileIfItDoesntExist?.enabled).setTooltip("Create file if it doesn't exist").onChange((value) => {
        this.choice.createFileIfItDoesntExist.enabled = value;
        this.reload();
      })
    );
  }
  addCreateWithTemplateSetting() {
    let templateSelector;
    const createWithTemplateSetting = new import_obsidian23.Setting(this.contentEl);
    createWithTemplateSetting.setName("Create file with given template.").addToggle(
      (toggle) => toggle.setValue(
        this.choice.createFileIfItDoesntExist?.createWithTemplate
      ).onChange((value) => {
        this.choice.createFileIfItDoesntExist.createWithTemplate = value;
        templateSelector.setDisabled(!value);
      })
    );
    templateSelector = new import_obsidian23.TextComponent(this.contentEl);
    templateSelector.setValue(this.choice?.createFileIfItDoesntExist?.template ?? "").setPlaceholder("Template path").setDisabled(
      !this.choice?.createFileIfItDoesntExist?.createWithTemplate
    );
    templateSelector.inputEl.style.width = "100%";
    templateSelector.inputEl.style.marginBottom = "8px";
    const templateFilePaths = this.plugin.getTemplateFiles().map((f) => f.path);
    new GenericTextSuggester(
      this.app,
      templateSelector.inputEl,
      templateFilePaths,
      50
    );
    templateSelector.onChange((value) => {
      this.choice.createFileIfItDoesntExist.template = value;
    });
  }
  addOpenFileSetting() {
    const noOpenSetting = new import_obsidian23.Setting(this.contentEl);
    noOpenSetting.setName("Open").setDesc("Open the file that is captured to.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFile);
      toggle.onChange((value) => {
        this.choice.openFile = value;
        this.reload();
      });
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      if (!this.choice.openFileInMode)
        this.choice.openFileInMode = "default";
      dropdown.addOption("source", "Source").addOption("preview", "Preview").addOption("default", "Default").setValue(this.choice.openFileInMode).onChange(
        (value) => this.choice.openFileInMode = value
      );
    });
  }
  addOpenFileInNewTabSetting() {
    const newTabSetting = new import_obsidian23.Setting(this.contentEl);
    newTabSetting.setName("New Tab").setDesc("Open the file that is captured to in a new tab.").addToggle((toggle) => {
      toggle.setValue(this.choice?.openFileInNewTab?.enabled);
      toggle.onChange(
        (value) => this.choice.openFileInNewTab.enabled = value
      );
    }).addDropdown((dropdown) => {
      if (!this.choice?.openFileInNewTab) {
        this.choice.openFileInNewTab = {
          enabled: false,
          direction: "vertical" /* vertical */,
          focus: true
        };
      }
      dropdown.selectEl.style.marginLeft = "10px";
      dropdown.addOption("vertical" /* vertical */, "Vertical");
      dropdown.addOption("horizontal" /* horizontal */, "Horizontal");
      dropdown.setValue(this.choice?.openFileInNewTab?.direction);
      dropdown.onChange(
        (value) => this.choice.openFileInNewTab.direction = value
      );
    });
    new import_obsidian23.Setting(this.contentEl).setName("Focus new pane").setDesc("Focus the opened tab immediately").addToggle(
      (toggle) => toggle.setValue(this.choice.openFileInNewTab.focus).onChange(
        (value) => this.choice.openFileInNewTab.focus = value
      )
    );
  }
};

// src/gui/ChoiceBuilder/macroChoiceBuilder.ts
var import_obsidian27 = require("obsidian");
var import_obsidian28 = require("obsidian");

// src/gui/MacroGUIs/MacroBuilder.ts
var import_obsidian26 = require("obsidian");

// src/types/macros/UserScript.ts
var UserScript = class extends Command {
  constructor(name, path) {
    super(name, "UserScript" /* UserScript */);
    this.path = path;
    this.settings = {};
  }
};

// src/types/macros/ObsidianCommand.ts
var ObsidianCommand = class extends Command {
  constructor(name, commandId) {
    super(name, "Obsidian" /* Obsidian */);
    this.generateId = () => this.id = v4_default();
    this.commandId = commandId;
  }
};

// src/gui/MacroGUIs/Components/StandardCommand.svelte
function create_fragment10(ctx) {
  let div1;
  let li;
  let t0_value = (
    /*command*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let span1_style_value;
  let span1_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faTrash } });
  icon1 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "aria-label", "Drag-handle");
      attr(span1, "style", span1_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span1, "tabindex", span1_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(span1, "mousedown", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(span1, "touchstart", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*command*/
      1) && t0_value !== (t0_value = /*command*/
      ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*dragDisabled*/
      4 && span1_style_value !== (span1_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span1, "style", span1_style_value);
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span1_tabindex_value !== (span1_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1)) {
        attr(span1, "tabindex", span1_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand(commandId) {
    dispatch("deleteCommand", commandId);
  }
  const click_handler = () => deleteCommand(command.id);
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [command, startDrag, dragDisabled, deleteCommand, click_handler];
}
var StandardCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var StandardCommand_default = StandardCommand;

// src/gui/MacroGUIs/Components/WaitCommand.svelte
function add_css7(target) {
  append_styles(target, "svelte-1196d9p", ".dotInput.svelte-1196d9p{border:none;display:inline;font-family:inherit;font-size:inherit;padding:0;width:0;text-decoration:underline dotted;background-color:transparent}.dotInput.svelte-1196d9p:hover{background-color:transparent}");
}
function create_fragment11(ctx) {
  let div1;
  let li;
  let t0_value = (
    /*command*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let input;
  let t2;
  let t3;
  let div0;
  let span0;
  let icon0;
  let t4;
  let span1;
  let icon1;
  let span1_style_value;
  let span1_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faTrash } });
  icon1 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = text(" for ");
      input = element("input");
      t2 = text("ms");
      t3 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t4 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      attr(input, "type", "number");
      attr(input, "placeholder", "   ");
      attr(input, "class", "dotInput svelte-1196d9p");
      attr(span0, "class", "clickable");
      attr(span1, "aria-label", "Drag-handle");
      attr(span1, "style", span1_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span1, "tabindex", span1_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(li, t1);
      append(li, input);
      ctx[6](input);
      set_input_value(
        input,
        /*command*/
        ctx[0].time
      );
      append(li, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t4);
      append(div0, span1);
      mount_component(icon1, span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "keyup",
            /*resizeInput*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            span0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(span1, "mousedown", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(span1, "touchstart", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*command*/
      1) && t0_value !== (t0_value = /*command*/
      ctx[0].name + ""))
        set_data(t0, t0_value);
      if (dirty & /*command*/
      1 && to_number(input.value) !== /*command*/
      ctx[0].time) {
        set_input_value(
          input,
          /*command*/
          ctx[0].time
        );
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span1_style_value !== (span1_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span1, "style", span1_style_value);
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span1_tabindex_value !== (span1_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1)) {
        attr(span1, "tabindex", span1_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[6](null);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  let inputEl;
  function deleteCommand(commandId) {
    dispatch("deleteCommand", commandId);
  }
  function resizeInput() {
    const length = inputEl.value.length;
    $$invalidate(3, inputEl.style.width = (length === 0 ? 2 : length) + "ch", inputEl);
  }
  onMount(resizeInput);
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(3, inputEl);
    });
  }
  function input_input_handler() {
    command.time = to_number(this.value);
    $$invalidate(0, command);
  }
  const click_handler = () => deleteCommand(command.id);
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    inputEl,
    deleteCommand,
    resizeInput,
    input_binding,
    input_input_handler,
    click_handler
  ];
}
var WaitCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        command: 0,
        startDrag: 1,
        dragDisabled: 2
      },
      add_css7
    );
  }
};
var WaitCommand_default = WaitCommand;

// src/gui/MacroGUIs/Components/NestedChoiceCommand.svelte
function create_fragment12(ctx) {
  let div1;
  let li;
  let t0_value = (
    /*command*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let t3;
  let span2;
  let icon2;
  let span2_style_value;
  let span2_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faCog } });
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      t3 = space();
      span2 = element("span");
      create_component(icon2.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "class", "clickable");
      attr(span2, "aria-label", "Drag-handle");
      attr(span2, "style", span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span2, "tabindex", span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      append(div0, t3);
      append(div0, span2);
      mount_component(icon2, span2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            span1,
            "click",
            /*click_handler_1*/
            ctx[6]
          ),
          listen(span2, "mousedown", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(span2, "touchstart", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*command*/
      1) && t0_value !== (t0_value = /*command*/
      ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*dragDisabled*/
      4 && span2_style_value !== (span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span2, "style", span2_style_value);
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span2_tabindex_value !== (span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1)) {
        attr(span2, "tabindex", span2_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand() {
    dispatch("deleteCommand", command.id);
  }
  function configureChoice() {
    dispatch("configureChoice", command);
  }
  const click_handler = () => configureChoice();
  const click_handler_1 = () => deleteCommand();
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    deleteCommand,
    configureChoice,
    click_handler,
    click_handler_1
  ];
}
var NestedChoiceCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var NestedChoiceCommand_default = NestedChoiceCommand;

// src/gui/MacroGUIs/Components/UserScriptCommand.svelte
function create_fragment13(ctx) {
  let div1;
  let li;
  let t0_value = (
    /*command*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let t3;
  let span2;
  let icon2;
  let span2_style_value;
  let span2_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faCog } });
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      t3 = space();
      span2 = element("span");
      create_component(icon2.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "class", "clickable");
      attr(span2, "aria-label", "Drag-handle");
      attr(span2, "style", span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span2, "tabindex", span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      append(div0, t3);
      append(div0, span2);
      mount_component(icon2, span2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            span0,
            "keypress",
            /*keypress_handler*/
            ctx[6]
          ),
          listen(
            span1,
            "click",
            /*click_handler_1*/
            ctx[7]
          ),
          listen(
            span1,
            "keypress",
            /*keypress_handler_1*/
            ctx[8]
          ),
          listen(span2, "mousedown", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(span2, "touchstart", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*command*/
      1) && t0_value !== (t0_value = /*command*/
      ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*dragDisabled*/
      4 && span2_style_value !== (span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span2, "style", span2_style_value);
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span2_tabindex_value !== (span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1)) {
        attr(span2, "tabindex", span2_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand() {
    dispatch("deleteCommand", command.id);
  }
  function configureChoice() {
    dispatch("configureScript", command);
  }
  const click_handler = () => configureChoice();
  const keypress_handler = () => configureChoice();
  const click_handler_1 = () => deleteCommand();
  const keypress_handler_1 = () => configureChoice();
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    deleteCommand,
    configureChoice,
    click_handler,
    keypress_handler,
    click_handler_1,
    keypress_handler_1
  ];
}
var UserScriptCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var UserScriptCommand_default = UserScriptCommand;

// src/gui/MacroGUIs/UserScriptSettingsModal.ts
var import_obsidian24 = require("obsidian");

// src/utils/setPasswordOnBlur.ts
function setPasswordOnBlur(el) {
  el.addEventListener("focus", () => {
    el.type = "text";
  });
  el.addEventListener("blur", () => {
    el.type = "password";
  });
  el.type = "password";
}

// src/gui/MacroGUIs/UserScriptSettingsModal.ts
var UserScriptSettingsModal = class extends import_obsidian24.Modal {
  constructor(app2, command, settings) {
    super(app2);
    this.command = command;
    this.settings = settings;
    this.display();
    if (!this.command.settings)
      this.command.settings = {};
    if (this.settings.options) {
      for (const setting in this.settings.options) {
        const valueIsNotSetAlready = this.command.settings[setting] === void 0;
        const defaultValueAvailable = "defaultValue" in this.settings.options[setting] && this.settings.options[setting].defaultValue !== void 0;
        if (valueIsNotSetAlready && // Checking that the setting is an object & getting the default value...
        defaultValueAvailable) {
          this.command.settings[setting] = this.settings.options[setting].defaultValue;
        }
      }
    }
  }
  display() {
    this.containerEl.addClass("quickAddModal", "userScriptSettingsModal");
    this.contentEl.empty();
    this.titleEl.innerText = `${this.settings?.name}${this.settings?.author ? " by " + this.settings?.author : ""}`;
    const options = this.settings.options;
    if (!options) {
      return;
    }
    for (const option in options) {
      if (!options.hasOwnProperty(option))
        continue;
      const entry = options[option];
      let value = entry.defaultValue;
      if (this.command.settings[option] !== void 0) {
        value = this.command.settings[option];
      }
      const type = entry.type;
      if (type === "text" || type === "input") {
        this.addInputBox(
          option,
          value,
          entry?.placeholder,
          entry.secret
        );
      } else if (type === "checkbox" || type === "toggle") {
        this.addToggle(option, value);
      } else if (type === "dropdown" || type === "select") {
        this.addDropdown(option, entry.options, value);
      } else if (type === "format") {
        this.addFormatInput(option, value, entry.placeholder);
      }
    }
  }
  addInputBox(name, value, placeholder, passwordOnBlur) {
    new import_obsidian24.Setting(this.contentEl).setName(name).addText((input) => {
      input.setValue(value).onChange((value2) => this.command.settings[name] = value2).setPlaceholder(placeholder ?? "");
      if (passwordOnBlur) {
        setPasswordOnBlur(input.inputEl);
      }
    });
  }
  addToggle(name, value) {
    new import_obsidian24.Setting(this.contentEl).setName(name).addToggle(
      (toggle) => toggle.setValue(value).onChange((value2) => this.command.settings[name] = value2)
    );
  }
  addDropdown(name, options, value) {
    new import_obsidian24.Setting(this.contentEl).setName(name).addDropdown((dropdown) => {
      options.forEach((item) => void dropdown.addOption(item, item));
      dropdown.setValue(value);
      dropdown.onChange((value2) => this.command.settings[name] = value2);
    });
  }
  addFormatInput(name, value, placeholder) {
    new import_obsidian24.Setting(this.contentEl).setName(name);
    const formatDisplay = this.contentEl.createEl("span");
    const input = new import_obsidian24.TextAreaComponent(this.contentEl);
    new FormatSyntaxSuggester(this.app, input.inputEl, QuickAdd.instance);
    const displayFormatter = new FormatDisplayFormatter(
      this.app,
      QuickAdd.instance
    );
    input.setValue(value).onChange(async (value2) => {
      this.command.settings[name] = value2;
      formatDisplay.innerText = await displayFormatter.format(value2);
    }).setPlaceholder(placeholder ?? "");
    input.inputEl.style.width = "100%";
    input.inputEl.style.height = "100px";
    input.inputEl.style.marginBottom = "1em";
    void (async () => formatDisplay.innerText = await displayFormatter.format(value))();
  }
};

// src/gui/MacroGUIs/Components/AIAssistantCommand.svelte
function create_fragment14(ctx) {
  let div1;
  let li;
  let t0_value = (
    /*command*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let t3;
  let span2;
  let icon2;
  let span2_style_value;
  let span2_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faCog } });
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      t3 = space();
      span2 = element("span");
      create_component(icon2.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "class", "clickable");
      attr(span2, "aria-label", "Drag-handle");
      attr(span2, "style", span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span2, "tabindex", span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      append(div0, t3);
      append(div0, span2);
      mount_component(icon2, span2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            span1,
            "click",
            /*click_handler_1*/
            ctx[6]
          ),
          listen(span2, "mousedown", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(span2, "touchstart", function() {
            if (is_function(
              /*startDrag*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*command*/
      1) && t0_value !== (t0_value = /*command*/
      ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*dragDisabled*/
      4 && span2_style_value !== (span2_style_value = /*dragDisabled*/
      (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span2, "style", span2_style_value);
      }
      if (!current || dirty & /*dragDisabled*/
      4 && span2_tabindex_value !== (span2_tabindex_value = /*dragDisabled*/
      ctx[2] ? 0 : -1)) {
        attr(span2, "tabindex", span2_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand() {
    dispatch("deleteCommand", command.id);
  }
  function configureAssistant() {
    dispatch("configureAssistant", command);
  }
  const click_handler = () => configureAssistant();
  const click_handler_1 = () => deleteCommand();
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    deleteCommand,
    configureAssistant,
    click_handler,
    click_handler_1
  ];
}
var AIAssistantCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var AIAssistantCommand_default = AIAssistantCommand;

// src/gui/MacroGUIs/AIAssistantCommandSettingsModal.ts
var import_obsidian25 = require("obsidian");

// src/ai/OpenAIModelParameters.ts
var DEFAULT_TOP_P = 1;
var DEFAULT_TEMPERATURE = 1;
var DEFAULT_FREQUENCY_PENALTY = 0;
var DEFAULT_PRESENCE_PENALTY = 0;

// src/gui/MacroGUIs/AIAssistantCommandSettingsModal.ts
var AIAssistantCommandSettingsModal = class extends import_obsidian25.Modal {
  constructor(settings) {
    super(app);
    this.showAdvancedSettings = false;
    this.settings = settings;
    this.waitForClose = new Promise(
      (resolve, reject) => {
        this.rejectPromise = reject;
        this.resolvePromise = resolve;
      }
    );
    this.open();
    this.display();
  }
  display() {
    const header = this.contentEl.createEl("h2", {
      text: `${this.settings.name} Settings`
    });
    header.style.textAlign = "center";
    header.style.cursor = "pointer";
    header.style.userSelect = "none";
    header.addEventListener("click", async () => {
      try {
        const newName = await GenericInputPrompt.Prompt(
          app,
          "New name",
          this.settings.name,
          this.settings.name
        );
        if (newName && newName !== this.settings.name) {
          this.settings.name = newName;
          this.reload();
        }
      } catch (error) {
      }
    });
    this.addPromptTemplateSetting(this.contentEl);
    this.addModelSetting(this.contentEl);
    this.addOutputVariableNameSetting(this.contentEl);
    this.addShowAdvancedSettingsToggle(this.contentEl);
    if (this.showAdvancedSettings) {
      if (!this.settings.modelParameters)
        this.settings.modelParameters = {};
      this.addTemperatureSetting(this.contentEl);
      this.addTopPSetting(this.contentEl);
      this.addFrequencyPenaltySetting(this.contentEl);
      this.addPresencePenaltySetting(this.contentEl);
    }
    this.addSystemPromptSetting(this.contentEl);
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addPromptTemplateSetting(container) {
    const promptTemplatesFolder = settingsStore.getState().ai.promptTemplatesFolderPath;
    const promptTemplateFiles = getMarkdownFilesInFolder(
      promptTemplatesFolder
    ).map((f) => f.name);
    new import_obsidian25.Setting(container).setName("Prompt Template").setDesc(
      "Enabling this will have the assistant use the prompt template you specify. If disable, the assistant will ask you for a prompt template to use."
    ).addToggle((toggle) => {
      toggle.setValue(this.settings.promptTemplate.enable);
      toggle.onChange((value) => {
        this.settings.promptTemplate.enable = value;
      });
    }).addText((text2) => {
      text2.setValue(this.settings.promptTemplate.name).onChange(
        (value) => {
          this.settings.promptTemplate.name = value;
        }
      );
      new GenericTextSuggester(
        app,
        text2.inputEl,
        promptTemplateFiles
      );
    });
  }
  addModelSetting(container) {
    new import_obsidian25.Setting(container).setName("Model").setDesc("The model the AI Assistant will use").addDropdown((dropdown) => {
      for (const model of models_and_ask_me) {
        dropdown.addOption(model, model);
      }
      dropdown.setValue(this.settings.model);
      dropdown.onChange((value) => {
        this.settings.model = value;
      });
    });
  }
  addOutputVariableNameSetting(container) {
    new import_obsidian25.Setting(container).setName("Output variable name").setDesc(
      "The name of the variable used to store the AI Assistant output, i.e. {{value:output}}."
    ).addText((text2) => {
      text2.setValue(this.settings.outputVariableName).onChange(
        (value) => {
          this.settings.outputVariableName = value;
        }
      );
    });
  }
  addSystemPromptSetting(contentEl) {
    new import_obsidian25.Setting(contentEl).setName("System Prompt").setDesc("The system prompt for the AI Assistant");
    const textAreaComponent = new import_obsidian25.TextAreaComponent(contentEl);
    textAreaComponent.setValue(this.settings.systemPrompt).onChange(async (value) => {
      this.settings.systemPrompt = value;
      formatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(
      this.app,
      textAreaComponent.inputEl,
      QuickAdd.instance
    );
    const displayFormatter = new FormatDisplayFormatter(
      this.app,
      QuickAdd.instance
    );
    textAreaComponent.inputEl.style.width = "100%";
    textAreaComponent.inputEl.style.height = "100px";
    textAreaComponent.inputEl.style.minHeight = "100px";
    textAreaComponent.inputEl.style.marginBottom = "1em";
    const formatDisplay = this.contentEl.createEl("span");
    void (async () => formatDisplay.innerText = await displayFormatter.format(
      this.settings.systemPrompt ?? ""
    ))();
  }
  addShowAdvancedSettingsToggle(container) {
    new import_obsidian25.Setting(container).setName("Show advanced settings").setDesc(
      "Show advanced settings such as temperature, top p, and frequency penalty."
    ).addToggle((toggle) => {
      toggle.setValue(this.showAdvancedSettings);
      toggle.onChange((value) => {
        this.showAdvancedSettings = value;
        this.reload();
      });
    });
  }
  addTemperatureSetting(container) {
    new import_obsidian25.Setting(container).setName("Temperature").setDesc(
      "Sampling temperature. Higher values like 0.8 makes the output more random, whereas lower values like 0.2 will make it more focused and deterministic. The default is 1."
    ).addSlider((slider) => {
      slider.setLimits(0, 1, 0.1);
      slider.setDynamicTooltip();
      slider.setValue(
        this.settings.modelParameters.temperature ?? DEFAULT_TEMPERATURE
      );
      slider.onChange((value) => {
        this.settings.modelParameters.temperature = value;
      });
    });
  }
  addTopPSetting(container) {
    new import_obsidian25.Setting(container).setName("Top P").setDesc(
      "Nucleus sampling - consider this an alternative to temperature. The model considers the results of the tokens with top_p probability mass. 0.1 means only tokens compromising the top 10% probability mass are considered. The default is 1."
    ).addSlider((slider) => {
      slider.setLimits(0, 1, 0.1);
      slider.setDynamicTooltip();
      slider.setValue(
        this.settings.modelParameters.top_p ?? DEFAULT_TOP_P
      );
      slider.onChange((value) => {
        this.settings.modelParameters.top_p = value;
      });
    });
  }
  addFrequencyPenaltySetting(container) {
    new import_obsidian25.Setting(container).setName("Frequency Penalty").setDesc(
      "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. The default is 0."
    ).addSlider((slider) => {
      slider.setLimits(0, 2, 0.1);
      slider.setDynamicTooltip();
      slider.setValue(
        this.settings.modelParameters.frequency_penalty ?? DEFAULT_FREQUENCY_PENALTY
      );
      slider.onChange((value) => {
        this.settings.modelParameters.frequency_penalty = value;
      });
    });
  }
  addPresencePenaltySetting(container) {
    new import_obsidian25.Setting(container).setName("Presence Penalty").setDesc(
      "Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. The default is 0."
    ).addSlider((slider) => {
      slider.setLimits(0, 2, 0.1);
      slider.setDynamicTooltip();
      slider.setValue(
        this.settings.modelParameters.presence_penalty ?? DEFAULT_PRESENCE_PENALTY
      );
      slider.onChange((value) => {
        this.settings.modelParameters.presence_penalty = value;
      });
    });
  }
  onClose() {
    this.resolvePromise(this.settings);
    super.onClose();
  }
};

// src/gui/MacroGUIs/CommandList.svelte
function add_css8(target) {
  append_styles(target, "svelte-1ngraqt", ".quickAddCommandList.svelte-1ngraqt{display:grid;grid-template-columns:auto;width:auto;border:0 solid black;overflow-y:auto;height:auto;margin-bottom:8px;padding:20px}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[38] = list[i];
  child_ctx[39] = list;
  child_ctx[40] = i;
  return child_ctx;
}
function create_else_block2(ctx) {
  let standardcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function standardcommand_command_binding(value) {
    ctx[32](
      value,
      /*command*/
      ctx[38],
      /*each_value*/
      ctx[39],
      /*command_index*/
      ctx[40]
    );
  }
  function standardcommand_dragDisabled_binding(value) {
    ctx[33](value);
  }
  function standardcommand_startDrag_binding(value) {
    ctx[34](value);
  }
  let standardcommand_props = {};
  if (
    /*command*/
    ctx[38] !== void 0
  ) {
    standardcommand_props.command = /*command*/
    ctx[38];
  }
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    standardcommand_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*startDrag*/
    ctx[4] !== void 0
  ) {
    standardcommand_props.startDrag = /*startDrag*/
    ctx[4];
  }
  standardcommand = new StandardCommand_default({ props: standardcommand_props });
  binding_callbacks.push(() => bind(standardcommand, "command", standardcommand_command_binding));
  binding_callbacks.push(() => bind(standardcommand, "dragDisabled", standardcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(standardcommand, "startDrag", standardcommand_startDrag_binding));
  standardcommand.$on(
    "deleteCommand",
    /*deleteCommand_handler_4*/
    ctx[35]
  );
  standardcommand.$on(
    "updateCommand",
    /*updateCommandFromEvent*/
    ctx[7]
  );
  return {
    c() {
      create_component(standardcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(standardcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const standardcommand_changes = {};
      if (!updating_command && dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID*/
      5) {
        updating_command = true;
        standardcommand_changes.command = /*command*/
        ctx[38];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        standardcommand_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & /*startDrag*/
      16) {
        updating_startDrag = true;
        standardcommand_changes.startDrag = /*startDrag*/
        ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      standardcommand.$set(standardcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(standardcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(standardcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(standardcommand, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let aiassistantcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function aiassistantcommand_command_binding(value) {
    ctx[28](
      value,
      /*command*/
      ctx[38],
      /*each_value*/
      ctx[39],
      /*command_index*/
      ctx[40]
    );
  }
  function aiassistantcommand_dragDisabled_binding(value) {
    ctx[29](value);
  }
  function aiassistantcommand_startDrag_binding(value) {
    ctx[30](value);
  }
  let aiassistantcommand_props = {};
  if (
    /*command*/
    ctx[38] !== void 0
  ) {
    aiassistantcommand_props.command = /*command*/
    ctx[38];
  }
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    aiassistantcommand_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*startDrag*/
    ctx[4] !== void 0
  ) {
    aiassistantcommand_props.startDrag = /*startDrag*/
    ctx[4];
  }
  aiassistantcommand = new AIAssistantCommand_default({ props: aiassistantcommand_props });
  binding_callbacks.push(() => bind(aiassistantcommand, "command", aiassistantcommand_command_binding));
  binding_callbacks.push(() => bind(aiassistantcommand, "dragDisabled", aiassistantcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(aiassistantcommand, "startDrag", aiassistantcommand_startDrag_binding));
  aiassistantcommand.$on(
    "deleteCommand",
    /*deleteCommand_handler_3*/
    ctx[31]
  );
  aiassistantcommand.$on(
    "updateCommand",
    /*updateCommandFromEvent*/
    ctx[7]
  );
  aiassistantcommand.$on(
    "configureAssistant",
    /*configureAssistant*/
    ctx[10]
  );
  return {
    c() {
      create_component(aiassistantcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(aiassistantcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const aiassistantcommand_changes = {};
      if (!updating_command && dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID*/
      5) {
        updating_command = true;
        aiassistantcommand_changes.command = /*command*/
        ctx[38];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        aiassistantcommand_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & /*startDrag*/
      16) {
        updating_startDrag = true;
        aiassistantcommand_changes.startDrag = /*startDrag*/
        ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      aiassistantcommand.$set(aiassistantcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(aiassistantcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(aiassistantcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(aiassistantcommand, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let userscriptcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function userscriptcommand_command_binding(value) {
    ctx[24](
      value,
      /*command*/
      ctx[38],
      /*each_value*/
      ctx[39],
      /*command_index*/
      ctx[40]
    );
  }
  function userscriptcommand_dragDisabled_binding(value) {
    ctx[25](value);
  }
  function userscriptcommand_startDrag_binding(value) {
    ctx[26](value);
  }
  let userscriptcommand_props = {};
  if (
    /*command*/
    ctx[38] !== void 0
  ) {
    userscriptcommand_props.command = /*command*/
    ctx[38];
  }
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    userscriptcommand_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*startDrag*/
    ctx[4] !== void 0
  ) {
    userscriptcommand_props.startDrag = /*startDrag*/
    ctx[4];
  }
  userscriptcommand = new UserScriptCommand_default({ props: userscriptcommand_props });
  binding_callbacks.push(() => bind(userscriptcommand, "command", userscriptcommand_command_binding));
  binding_callbacks.push(() => bind(userscriptcommand, "dragDisabled", userscriptcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(userscriptcommand, "startDrag", userscriptcommand_startDrag_binding));
  userscriptcommand.$on(
    "deleteCommand",
    /*deleteCommand_handler_2*/
    ctx[27]
  );
  userscriptcommand.$on(
    "updateCommand",
    /*updateCommandFromEvent*/
    ctx[7]
  );
  userscriptcommand.$on(
    "configureScript",
    /*configureScript*/
    ctx[9]
  );
  return {
    c() {
      create_component(userscriptcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(userscriptcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const userscriptcommand_changes = {};
      if (!updating_command && dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID*/
      5) {
        updating_command = true;
        userscriptcommand_changes.command = /*command*/
        ctx[38];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        userscriptcommand_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & /*startDrag*/
      16) {
        updating_startDrag = true;
        userscriptcommand_changes.startDrag = /*startDrag*/
        ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      userscriptcommand.$set(userscriptcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userscriptcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userscriptcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(userscriptcommand, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let nestedchoicecommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function nestedchoicecommand_command_binding(value) {
    ctx[20](
      value,
      /*command*/
      ctx[38],
      /*each_value*/
      ctx[39],
      /*command_index*/
      ctx[40]
    );
  }
  function nestedchoicecommand_dragDisabled_binding(value) {
    ctx[21](value);
  }
  function nestedchoicecommand_startDrag_binding(value) {
    ctx[22](value);
  }
  let nestedchoicecommand_props = {};
  if (
    /*command*/
    ctx[38] !== void 0
  ) {
    nestedchoicecommand_props.command = /*command*/
    ctx[38];
  }
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    nestedchoicecommand_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*startDrag*/
    ctx[4] !== void 0
  ) {
    nestedchoicecommand_props.startDrag = /*startDrag*/
    ctx[4];
  }
  nestedchoicecommand = new NestedChoiceCommand_default({ props: nestedchoicecommand_props });
  binding_callbacks.push(() => bind(nestedchoicecommand, "command", nestedchoicecommand_command_binding));
  binding_callbacks.push(() => bind(nestedchoicecommand, "dragDisabled", nestedchoicecommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(nestedchoicecommand, "startDrag", nestedchoicecommand_startDrag_binding));
  nestedchoicecommand.$on(
    "deleteCommand",
    /*deleteCommand_handler_1*/
    ctx[23]
  );
  nestedchoicecommand.$on(
    "updateCommand",
    /*updateCommandFromEvent*/
    ctx[7]
  );
  nestedchoicecommand.$on(
    "configureChoice",
    /*configureChoice*/
    ctx[8]
  );
  return {
    c() {
      create_component(nestedchoicecommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nestedchoicecommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const nestedchoicecommand_changes = {};
      if (!updating_command && dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID*/
      5) {
        updating_command = true;
        nestedchoicecommand_changes.command = /*command*/
        ctx[38];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        nestedchoicecommand_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & /*startDrag*/
      16) {
        updating_startDrag = true;
        nestedchoicecommand_changes.startDrag = /*startDrag*/
        ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      nestedchoicecommand.$set(nestedchoicecommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestedchoicecommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestedchoicecommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nestedchoicecommand, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let waitcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function waitcommand_command_binding(value) {
    ctx[16](
      value,
      /*command*/
      ctx[38],
      /*each_value*/
      ctx[39],
      /*command_index*/
      ctx[40]
    );
  }
  function waitcommand_dragDisabled_binding(value) {
    ctx[17](value);
  }
  function waitcommand_startDrag_binding(value) {
    ctx[18](value);
  }
  let waitcommand_props = {};
  if (
    /*command*/
    ctx[38] !== void 0
  ) {
    waitcommand_props.command = /*command*/
    ctx[38];
  }
  if (
    /*dragDisabled*/
    ctx[3] !== void 0
  ) {
    waitcommand_props.dragDisabled = /*dragDisabled*/
    ctx[3];
  }
  if (
    /*startDrag*/
    ctx[4] !== void 0
  ) {
    waitcommand_props.startDrag = /*startDrag*/
    ctx[4];
  }
  waitcommand = new WaitCommand_default({ props: waitcommand_props });
  binding_callbacks.push(() => bind(waitcommand, "command", waitcommand_command_binding));
  binding_callbacks.push(() => bind(waitcommand, "dragDisabled", waitcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(waitcommand, "startDrag", waitcommand_startDrag_binding));
  waitcommand.$on(
    "deleteCommand",
    /*deleteCommand_handler*/
    ctx[19]
  );
  waitcommand.$on(
    "updateCommand",
    /*updateCommandFromEvent*/
    ctx[7]
  );
  return {
    c() {
      create_component(waitcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(waitcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const waitcommand_changes = {};
      if (!updating_command && dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID*/
      5) {
        updating_command = true;
        waitcommand_changes.command = /*command*/
        ctx[38];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & /*dragDisabled*/
      8) {
        updating_dragDisabled = true;
        waitcommand_changes.dragDisabled = /*dragDisabled*/
        ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & /*startDrag*/
      16) {
        updating_startDrag = true;
        waitcommand_changes.startDrag = /*startDrag*/
        ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      waitcommand.$set(waitcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(waitcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(waitcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(waitcommand, detaching);
    }
  };
}
function create_each_block4(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block5,
    create_if_block_14,
    create_if_block_22,
    create_if_block_32,
    create_else_block2
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*command*/
      ctx2[38].type === "Wait" /* Wait */
    )
      return 0;
    if (
      /*command*/
      ctx2[38].type === "NestedChoice" /* NestedChoice */
    )
      return 1;
    if (
      /*command*/
      ctx2[38].type === "UserScript" /* UserScript */
    )
      return 2;
    if (
      /*command*/
      ctx2[38].type === "AIAssistant" /* AIAssistant */
    )
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment15(ctx) {
  let ol;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*commands*/
    ctx[0].filter(
      /*func*/
      ctx[15]
    )
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[38].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ol, "class", "quickAddCommandList svelte-1ngraqt");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone3.call(null, ol, {
            items: (
              /*commands*/
              ctx[0]
            ),
            dragDisabled: (
              /*dragDisabled*/
              ctx[3]
            ),
            dropTargetStyle: {},
            type: "command"
          })),
          listen(
            ol,
            "consider",
            /*handleConsider*/
            ctx[5]
          ),
          listen(
            ol,
            "finalize",
            /*handleSort*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*commands, SHADOW_PLACEHOLDER_ITEM_ID, dragDisabled, startDrag, deleteCommand, updateCommandFromEvent, configureChoice, configureScript, configureAssistant*/
      1951) {
        each_value = /*commands*/
        ctx2[0].filter(
          /*func*/
          ctx2[15]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ol, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty[0] & /*commands, dragDisabled*/
      9)
        dndzone_action.update.call(null, {
          items: (
            /*commands*/
            ctx2[0]
          ),
          dragDisabled: (
            /*dragDisabled*/
            ctx2[3]
          ),
          dropTargetStyle: {},
          type: "command"
        });
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { commands: commands2 } = $$props;
  let { deleteCommand } = $$props;
  let { saveCommands } = $$props;
  let { app: app2 } = $$props;
  let { plugin } = $$props;
  let dragDisabled = true;
  const updateCommandList = (newCommands) => {
    $$invalidate(0, commands2 = newCommands);
  };
  function handleConsider(e) {
    let { items: newItems } = e.detail;
    $$invalidate(0, commands2 = newItems);
  }
  function handleSort(e) {
    let { items: newItems, info: { source } } = e.detail;
    $$invalidate(0, commands2 = newItems);
    if (source === SOURCES.POINTER) {
      $$invalidate(3, dragDisabled = true);
    }
    saveCommands(commands2);
  }
  let startDrag = (e) => {
    e.preventDefault();
    $$invalidate(3, dragDisabled = false);
  };
  function updateCommandFromEvent(e) {
    const command = e.detail;
    updateCommand(command);
  }
  function updateCommand(command) {
    const index = commands2.findIndex((c) => c.id === command.id);
    $$invalidate(0, commands2[index] = command, commands2);
    saveCommands(commands2);
  }
  async function configureChoice(e) {
    const command = e.detail;
    const newChoice = await getChoiceBuilder(command.choice)?.waitForClose;
    if (!newChoice)
      return;
    command.choice = newChoice;
    command.name = newChoice.name;
    updateCommand(command);
  }
  function getChoiceBuilder(choice) {
    switch (choice.type) {
      case "Template":
        return new TemplateChoiceBuilder(app2, choice, plugin);
      case "Capture":
        return new CaptureChoiceBuilder(app2, choice, plugin);
      case "Macro":
      case "Multi":
      default:
        break;
    }
  }
  async function configureScript(e) {
    const command = e.detail;
    const userScript = await getUserScript(command, app2);
    if (!userScript?.settings) {
      log.logWarning(`${command.name} has no settings.`);
      return;
    }
    new UserScriptSettingsModal(app2, command, userScript.settings).open();
  }
  async function configureAssistant(e) {
    const command = e.detail;
    const newSetings = await new AIAssistantCommandSettingsModal(command).waitForClose;
    if (newSetings) {
      updateCommand(command);
    }
  }
  const func = (c) => c.id !== SHADOW_PLACEHOLDER_ITEM_ID;
  function waitcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function waitcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function waitcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler = async (e) => await deleteCommand(e.detail);
  function nestedchoicecommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function nestedchoicecommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function nestedchoicecommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_1 = async (e) => await deleteCommand(e.detail);
  function userscriptcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function userscriptcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function userscriptcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_2 = async (e) => await deleteCommand(e.detail);
  function aiassistantcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function aiassistantcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function aiassistantcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_3 = async (e) => await deleteCommand(e.detail);
  function standardcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function standardcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function standardcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_4 = async (e) => await deleteCommand(e.detail);
  $$self.$$set = ($$props2) => {
    if ("commands" in $$props2)
      $$invalidate(0, commands2 = $$props2.commands);
    if ("deleteCommand" in $$props2)
      $$invalidate(1, deleteCommand = $$props2.deleteCommand);
    if ("saveCommands" in $$props2)
      $$invalidate(11, saveCommands = $$props2.saveCommands);
    if ("app" in $$props2)
      $$invalidate(12, app2 = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(13, plugin = $$props2.plugin);
  };
  return [
    commands2,
    deleteCommand,
    SHADOW_PLACEHOLDER_ITEM_ID,
    dragDisabled,
    startDrag,
    handleConsider,
    handleSort,
    updateCommandFromEvent,
    configureChoice,
    configureScript,
    configureAssistant,
    saveCommands,
    app2,
    plugin,
    updateCommandList,
    func,
    waitcommand_command_binding,
    waitcommand_dragDisabled_binding,
    waitcommand_startDrag_binding,
    deleteCommand_handler,
    nestedchoicecommand_command_binding,
    nestedchoicecommand_dragDisabled_binding,
    nestedchoicecommand_startDrag_binding,
    deleteCommand_handler_1,
    userscriptcommand_command_binding,
    userscriptcommand_dragDisabled_binding,
    userscriptcommand_startDrag_binding,
    deleteCommand_handler_2,
    aiassistantcommand_command_binding,
    aiassistantcommand_dragDisabled_binding,
    aiassistantcommand_startDrag_binding,
    deleteCommand_handler_3,
    standardcommand_command_binding,
    standardcommand_dragDisabled_binding,
    standardcommand_startDrag_binding,
    deleteCommand_handler_4
  ];
}
var CommandList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        commands: 0,
        deleteCommand: 1,
        saveCommands: 11,
        app: 12,
        plugin: 13,
        updateCommandList: 14
      },
      add_css8,
      [-1, -1]
    );
  }
  get updateCommandList() {
    return this.$$.ctx[14];
  }
};
var CommandList_default = CommandList;

// src/types/macros/ChoiceCommand.ts
var ChoiceCommand = class extends Command {
  constructor(name, choiceId) {
    super(name, "Choice" /* Choice */);
    this.choiceId = choiceId;
  }
};

// src/types/macros/QuickCommands/WaitCommand.ts
var WaitCommand2 = class extends Command {
  constructor(time) {
    super("Wait", "Wait" /* Wait */);
    this.time = time;
  }
};

// src/types/macros/QuickCommands/NestedChoiceCommand.ts
var NestedChoiceCommand2 = class extends Command {
  constructor(choice) {
    super(choice.name, "NestedChoice" /* NestedChoice */);
    this.choice = choice;
  }
};

// src/types/macros/QuickCommands/AIAssistantCommand.ts
var AIAssistantCommand2 = class extends Command {
  constructor() {
    super("AI Assistant", "AIAssistant" /* AIAssistant */);
    const defaults = settingsStore.getState().ai;
    this.model = defaults.defaultModel;
    this.systemPrompt = defaults.defaultSystemPrompt;
    this.outputVariableName = "output";
    this.promptTemplate = { enable: false, name: "" };
    this.modelParameters = {
      temperature: DEFAULT_TEMPERATURE,
      top_p: DEFAULT_TOP_P,
      frequency_penalty: DEFAULT_FREQUENCY_PENALTY,
      presence_penalty: DEFAULT_PRESENCE_PENALTY
    };
  }
};

// src/gui/MacroGUIs/MacroBuilder.ts
function getChoicesAsList(nestedChoices) {
  const arr = [];
  const recursive = (choices) => {
    choices.forEach((choice) => {
      if (choice.type === "Multi") {
        recursive(choice.choices);
      } else {
        arr.push(choice);
      }
    });
  };
  recursive(nestedChoices);
  return arr;
}
var MacroBuilder = class extends import_obsidian26.Modal {
  constructor(app2, plugin, macro, choices) {
    super(app2);
    this.commands = [];
    this.javascriptFiles = [];
    this.choices = [];
    this.macro = macro;
    this.svelteElements = [];
    this.choices = getChoicesAsList(choices);
    this.plugin = plugin;
    this.waitForClose = new Promise(
      (resolve) => this.resolvePromise = resolve
    );
    this.getObsidianCommands();
    this.getJavascriptFiles();
    this.display();
    this.open();
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.macro);
    this.svelteElements.forEach((el) => {
      if (el && el.$destroy)
        el.$destroy();
    });
  }
  display() {
    this.containerEl.addClass("quickAddModal", "macroBuilder");
    this.contentEl.empty();
    this.addCenteredHeader(this.macro.name);
    this.addCommandList();
    this.addCommandBar();
    this.addAddObsidianCommandSetting();
    this.addAddEditorCommandsSetting();
    this.addAddUserScriptSetting();
    this.addAddChoiceSetting();
  }
  addCenteredHeader(header) {
    const headerEl = this.contentEl.createEl("h2");
    headerEl.style.textAlign = "center";
    headerEl.setText(header);
    headerEl.addClass("clickable");
    headerEl.addEventListener("click", async () => {
      const newMacroName = await GenericInputPrompt.Prompt(
        this.app,
        `Update name for ${this.macro.name}`,
        this.macro.name
      );
      if (!newMacroName)
        return;
      this.macro.name = newMacroName;
      this.reload();
    });
  }
  reload() {
    this.display();
  }
  addAddObsidianCommandSetting() {
    let input;
    const addObsidianCommandFromInput = () => {
      const value = input.getValue();
      const obsidianCommand = this.commands.find((v) => v.name === value);
      if (!obsidianCommand) {
        log.logError(
          `Could not find Obsidian command with name "${value}"`
        );
        return;
      }
      const command = new ObsidianCommand(
        obsidianCommand.name,
        obsidianCommand.commandId
      );
      command.generateId();
      this.addCommandToMacro(command);
      input.setValue("");
    };
    new import_obsidian26.Setting(this.contentEl).setName("Obsidian command").setDesc("Add an Obsidian command").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("Obsidian command");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.commands.map((c) => c.name)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addObsidianCommandFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addObsidianCommandFromInput)
    );
  }
  addAddEditorCommandsSetting() {
    let dropdownComponent;
    const addEditorCommandFromDropdown = () => {
      const type = dropdownComponent.getValue();
      let command;
      switch (type) {
        case "Copy" /* Copy */:
          command = new CopyCommand();
          break;
        case "Cut" /* Cut */:
          command = new CutCommand();
          break;
        case "Paste" /* Paste */:
          command = new PasteCommand();
          break;
        case "Select active line" /* SelectActiveLine */:
          command = new SelectActiveLineCommand();
          break;
        case "Select link on active line" /* SelectLinkOnActiveLine */:
          command = new SelectLinkOnActiveLineCommand();
          break;
        default:
          log.logError("invalid editor command type");
          throw new Error("invalid editor command type");
      }
      this.addCommandToMacro(command);
    };
    new import_obsidian26.Setting(this.contentEl).setName("Editor commands").setDesc("Add editor command").addDropdown((dropdown) => {
      dropdownComponent = dropdown;
      dropdown.selectEl.style.marginRight = "1em";
      dropdown.addOption("Copy" /* Copy */, "Copy" /* Copy */).addOption("Cut" /* Cut */, "Cut" /* Cut */).addOption("Paste" /* Paste */, "Paste" /* Paste */).addOption(
        "Select active line" /* SelectActiveLine */,
        "Select active line" /* SelectActiveLine */
      ).addOption(
        "Select link on active line" /* SelectLinkOnActiveLine */,
        "Select link on active line" /* SelectLinkOnActiveLine */
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addEditorCommandFromDropdown)
    );
  }
  addAddUserScriptSetting() {
    let input;
    const addUserScriptFromInput = () => {
      const value = input.getValue();
      const scriptBasename = getUserScriptMemberAccess(value).basename;
      const file = this.javascriptFiles.find(
        (f) => f.basename === scriptBasename
      );
      if (!file)
        return;
      this.addCommandToMacro(new UserScript(value, file.path));
      input.setValue("");
    };
    new import_obsidian26.Setting(this.contentEl).setName("User Scripts").setDesc("Add user script").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("User script");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.javascriptFiles.map((f) => f.basename)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addUserScriptFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setButtonText("Add").setCta().onClick(addUserScriptFromInput)
    );
  }
  addAddChoiceSetting() {
    let input;
    const addChoiceFromInput = () => {
      const value = input.getValue();
      const choice = this.choices.find((c) => c.name === value);
      if (!choice)
        return;
      this.addCommandToMacro(new ChoiceCommand(choice.name, choice.id));
      input.setValue("");
    };
    new import_obsidian26.Setting(this.contentEl).setName("Choices").setDesc("Add existing choice").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("Choice");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.choices.map((c) => c.name)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addChoiceFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addChoiceFromInput)
    );
  }
  getObsidianCommands() {
    Object.keys(this.app.commands.commands).forEach((key) => {
      const command = this.app.commands.commands[key];
      this.commands.push(new ObsidianCommand(command.name, command.id));
    });
  }
  getJavascriptFiles() {
    this.javascriptFiles = this.app.vault.getFiles().filter((file) => JAVASCRIPT_FILE_EXTENSION_REGEX.test(file.path));
  }
  addCommandList() {
    const commandList = this.contentEl.createDiv("commandList");
    this.commandListEl = new CommandList_default({
      target: commandList,
      props: {
        app: this.app,
        plugin: this.plugin,
        commands: this.macro.commands,
        deleteCommand: async (commandId) => {
          const command = this.macro.commands.find(
            (c) => c.id === commandId
          );
          if (!command) {
            log.logError("command not found");
            throw new Error("command not found");
          }
          const promptAnswer = await GenericYesNoPrompt.Prompt(
            this.app,
            "Are you sure you wish to delete this command?",
            `If you click yes, you will delete '${command.name}'.`
          );
          if (!promptAnswer)
            return;
          this.macro.commands = this.macro.commands.filter(
            (c) => c.id !== commandId
          );
          this.commandListEl.updateCommandList(this.macro.commands);
        },
        saveCommands: (commands2) => {
          this.macro.commands = commands2;
        }
      }
    });
    this.svelteElements.push(this.commandListEl);
  }
  addCommandBar() {
    const quickCommandContainer = this.contentEl.createDiv(
      "quickCommandContainer"
    );
    this.newChoiceButton(quickCommandContainer, "Capture", CaptureChoice);
    this.newChoiceButton(quickCommandContainer, "Template", TemplateChoice);
    this.addAddWaitCommandButton(quickCommandContainer);
    if (!settingsStore.getState().disableOnlineFeatures) {
      this.addAIAssistantCommandButton(quickCommandContainer);
    }
  }
  addAIAssistantCommandButton(quickCommandContainer) {
    const button = new import_obsidian26.ButtonComponent(
      quickCommandContainer
    );
    button.setIcon("bot").setTooltip("Add AI Assistant command").onClick(() => {
      this.addCommandToMacro(new AIAssistantCommand2());
    });
  }
  addAddWaitCommandButton(quickCommandContainer) {
    const button = new import_obsidian26.ButtonComponent(
      quickCommandContainer
    );
    button.setIcon("clock").setTooltip("Add wait command").onClick(() => {
      this.addCommandToMacro(new WaitCommand2(100));
    });
  }
  newChoiceButton(container, typeName, type) {
    const button = new import_obsidian26.ButtonComponent(container);
    button.setButtonText(typeName).setTooltip(`Add ${typeName} Choice`).onClick(() => {
      const captureChoice = new type(
        `Untitled ${typeName} Choice`
      );
      this.addCommandToMacro(new NestedChoiceCommand2(captureChoice));
    });
  }
  addCommandToMacro(command) {
    this.macro.commands.push(command);
    this.commandListEl.updateCommandList(this.macro.commands);
  }
};

// src/gui/ChoiceBuilder/macroChoiceBuilder.ts
var MacroChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, macros, choices) {
    super(app2);
    this.choice = choice;
    this.macros = macros;
    this.choices = choices;
    this.unsubscribe = settingsStore.subscribe((newSettings) => {
      this.macros = newSettings.macros;
      this.choices = newSettings.choices;
      this.reload();
    });
    this.display();
  }
  onClose() {
    this.unsubscribe();
  }
  display() {
    this.containerEl.addClass("macroChoiceBuilder");
    this.addCenteredChoiceNameHeader(this.choice);
    const macroDropdownContainer = this.contentEl.createDiv();
    macroDropdownContainer.addClass("macroDropdownContainer");
    this.addSelectMacroSearch(macroDropdownContainer);
    const buttonsContainer = macroDropdownContainer.createDiv();
    buttonsContainer.addClass("macro-choice-buttonsContainer");
    this.addConfigureMacroButton(buttonsContainer);
    this.addCreateMacroButton(buttonsContainer);
  }
  addCreateMacroButton(container) {
    const hasOwnMacro = settingsStore.getMacro(this.choice.macroId)?.name === this.choice.name;
    if (hasOwnMacro)
      return;
    const createMacroButtonContainer = container.createDiv();
    const createMacroButton = new import_obsidian27.ButtonComponent(
      createMacroButtonContainer
    );
    createMacroButton.setIcon("plus").setCta().setTooltip("Create Macro").onClick(() => {
      try {
        const macro = settingsStore.createMacro(this.choice.name);
        this.choice.macroId = macro.id;
        this.reload();
      } catch (error) {
        log.logError(error);
      }
    });
  }
  addConfigureMacroButton(container) {
    const configureMacroButtonContainer = container.createDiv();
    const configureMacroButton = new import_obsidian27.ButtonComponent(
      configureMacroButtonContainer
    );
    configureMacroButton.setIcon("cog").setTooltip("Configure Macro").onClick(async () => {
      const macro = this.macros.find(
        (m) => m.id === this.choice.macroId
      );
      if (!macro)
        return log.logError("Could not find macro to configure");
      const builder = new MacroBuilder(
        app,
        QuickAdd.instance,
        macro,
        this.choices
      );
      const newMacro = await builder.waitForClose;
      settingsStore.setMacro(this.choice.macroId, newMacro);
    });
  }
  addSelectMacroSearch(container) {
    const selectMacroDropdownContainer = container.createDiv("selectMacroDropdownContainer");
    const dropdown = new import_obsidian28.DropdownComponent(
      selectMacroDropdownContainer
    );
    const macroOptions = {};
    this.macros.forEach((macro) => {
      macroOptions[macro.name] = macro.name;
    });
    dropdown.addOptions(macroOptions);
    dropdown.onChange((value) => {
      this.selectMacro(value);
    });
    const selectedMacro = this.macros.find(
      (m) => m.id === this.choice.macroId
    );
    if (selectedMacro) {
      dropdown.setValue(selectedMacro.name);
    } else {
      const value = dropdown.getValue();
      if (value) {
        this.selectMacro(value);
      }
    }
  }
  selectMacro(value) {
    const targetMacro = this.macros.find((m) => m.name === value);
    if (!targetMacro)
      return;
    this.choice.macroId = targetMacro.id;
    settingsStore.setMacro(targetMacro.id, targetMacro);
  }
};

// src/MacrosManager.ts
var import_obsidian29 = require("obsidian");
var MacrosManager = class extends import_obsidian29.Modal {
  constructor(app2, plugin, macros, choices) {
    super(app2);
    this.app = app2;
    this.macros = macros;
    this.choices = choices;
    this.plugin = plugin;
    this.waitForClose = new Promise((resolve, reject) => {
      this.rejectPromise = reject;
      this.resolvePromise = resolve;
    });
    this.unsubscribe = settingsStore.subscribe((newSettings) => {
      this.macros = newSettings.macros;
      this.choices = newSettings.choices;
      this.reload();
    });
    this.open();
    this.display();
  }
  display() {
    this.contentEl.createEl("h2", {
      text: "Macro Manager"
    }).style.textAlign = "center";
    this.addMacroSettings();
    this.addAddMacroBar();
  }
  addMacroSettings() {
    this.macroContainer = this.contentEl.createDiv();
    this.updateMacroContainer = () => {
      if (this.macros.length <= 1)
        this.macroContainer.className = "macroContainer macroContainer1";
      if (this.macros.length === 2)
        this.macroContainer.className = "macroContainer macroContainer2";
      if (this.macros.length > 2)
        this.macroContainer.className = "macroContainer macroContainer3";
    };
    this.macros.forEach(
      (macro) => this.addMacroSetting(macro, this.macroContainer)
    );
    this.updateMacroContainer();
  }
  addMacroSetting(macro, container) {
    const configureMacroContainer = container.createDiv();
    const macroSetting = new import_obsidian29.Setting(configureMacroContainer);
    macroSetting.setName(macro.name);
    macroSetting.infoEl.style.fontWeight = "bold";
    this.addMacroConfigurationItem(
      configureMacroContainer,
      (itemContainerEl) => {
        this.addSpanWithText(itemContainerEl, "Run on plugin load");
        const toggle = new import_obsidian29.ToggleComponent(
          itemContainerEl
        );
        toggle.setValue(macro.runOnStartup);
        toggle.onChange((value) => {
          macro.runOnStartup = value;
          this.updateMacro(macro);
        });
      }
    );
    configureMacroContainer.addClass("configureMacroDiv");
    this.addMacroConfigurationItem(
      configureMacroContainer,
      (itemContainerEl) => {
        const deleteButton = new import_obsidian29.ButtonComponent(
          itemContainerEl
        );
        deleteButton.setClass("mod-warning");
        deleteButton.buttonEl.style.marginRight = "0";
        deleteButton.setButtonText("Delete").onClick((evt) => {
          this.macros = this.macros.filter((m) => m.id !== macro.id);
          const scroll = this.macroContainer.scrollTop;
          this.reload();
          this.macroContainer.scrollTop = scroll;
        });
        const configureButton = new import_obsidian29.ButtonComponent(
          itemContainerEl
        );
        configureButton.setClass("mod-cta");
        configureButton.buttonEl.style.marginRight = "0";
        configureButton.setButtonText("Configure").onClick(async (evt) => {
          const newMacro = await new MacroBuilder(
            this.app,
            this.plugin,
            macro,
            this.choices
          ).waitForClose;
          if (newMacro) {
            this.updateMacro(newMacro);
            this.reload();
          }
        });
      }
    );
  }
  addMacroConfigurationItem(container, callback, classString = "configureMacroDivItem") {
    const item = container.createDiv();
    item.addClass(classString);
    callback(item);
  }
  addSpanWithText(container, text2) {
    const configureText = container.createEl("span");
    configureText.setText(text2);
  }
  updateMacro(macro) {
    const index = this.macros.findIndex((v) => v.id === macro.id);
    this.macros[index] = macro;
    if (this.updateMacroContainer)
      this.updateMacroContainer();
    this.reload();
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addAddMacroBar() {
    const addMacroBarContainer = this.contentEl.createDiv();
    addMacroBarContainer.addClass("addMacroBarContainer");
    const nameInput = new import_obsidian29.TextComponent(
      addMacroBarContainer
    );
    nameInput.setPlaceholder("Macro name");
    const addMacroButton = new import_obsidian29.ButtonComponent(
      addMacroBarContainer
    );
    addMacroButton.setButtonText("Add macro").setClass("mod-cta").onClick(() => {
      const inputValue = nameInput.getValue();
      try {
        settingsStore.createMacro(inputValue);
        this.reload();
        this.macroContainer.scrollTo(
          0,
          this.macroContainer.scrollHeight
        );
      } catch (error) {
        log.logError(error);
      }
    });
  }
  onClose() {
    super.onClose();
    this.unsubscribe();
    this.resolvePromise(this.macros);
  }
};

// src/gui/AIAssistantSettingsModal.ts
var import_obsidian30 = require("obsidian");
var AIAssistantSettingsModal = class extends import_obsidian30.Modal {
  constructor(settings) {
    super(app);
    this.settings = settings;
    this.waitForClose = new Promise(
      (resolve, reject) => {
        this.rejectPromise = reject;
        this.resolvePromise = resolve;
      }
    );
    this.open();
    this.display();
  }
  display() {
    this.contentEl.createEl("h2", {
      text: "AI Assistant Settings"
    }).style.textAlign = "center";
    this.addApiKeySetting(this.contentEl);
    this.addDefaultModelSetting(this.contentEl);
    this.addPromptTemplateFolderPathSetting(this.contentEl);
    this.addShowAssistantSetting(this.contentEl);
    this.addDefaultSystemPromptSetting(this.contentEl);
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addApiKeySetting(container) {
    new import_obsidian30.Setting(container).setName("API Key").setDesc("The API Key for the AI Assistant").addText((text2) => {
      setPasswordOnBlur(text2.inputEl);
      text2.setValue(this.settings.OpenAIApiKey).onChange((value) => {
        this.settings.OpenAIApiKey = value;
      });
      text2.inputEl.placeholder = "sk-...";
    });
  }
  addDefaultModelSetting(container) {
    new import_obsidian30.Setting(container).setName("Default Model").setDesc("The default model for the AI Assistant").addDropdown((dropdown) => {
      for (const model of models_and_ask_me) {
        dropdown.addOption(model, model);
      }
      dropdown.setValue(this.settings.defaultModel);
      dropdown.onChange((value) => {
        this.settings.defaultModel = value;
      });
    });
  }
  addPromptTemplateFolderPathSetting(container) {
    new import_obsidian30.Setting(container).setName("Prompt Template Folder Path").setDesc("Path to your folder with prompt templates").addText((text2) => {
      text2.setValue(this.settings.promptTemplatesFolderPath).onChange(
        (value) => {
          this.settings.promptTemplatesFolderPath = value;
        }
      );
    });
  }
  addShowAssistantSetting(container) {
    new import_obsidian30.Setting(container).setName("Show Assistant").setDesc("Show status messages from the AI Assistant").addToggle((toggle) => {
      toggle.setValue(this.settings.showAssistant);
      toggle.onChange((value) => {
        this.settings.showAssistant = value;
      });
    });
  }
  addDefaultSystemPromptSetting(contentEl) {
    new import_obsidian30.Setting(contentEl).setName("Default System Prompt").setDesc("The default system prompt for the AI Assistant");
    const textAreaComponent = new import_obsidian30.TextAreaComponent(contentEl);
    textAreaComponent.setValue(this.settings.defaultSystemPrompt).onChange(async (value) => {
      this.settings.defaultSystemPrompt = value;
      formatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(
      this.app,
      textAreaComponent.inputEl,
      QuickAdd.instance
    );
    const displayFormatter = new FormatDisplayFormatter(
      this.app,
      QuickAdd.instance
    );
    textAreaComponent.inputEl.style.width = "100%";
    textAreaComponent.inputEl.style.height = "100px";
    textAreaComponent.inputEl.style.minHeight = "100px";
    textAreaComponent.inputEl.style.marginBottom = "1em";
    const formatDisplay = this.contentEl.createEl("span");
    void (async () => formatDisplay.innerText = await displayFormatter.format(
      this.settings.defaultSystemPrompt ?? ""
    ))();
  }
  onClose() {
    this.resolvePromise(this.settings);
    super.onClose();
  }
};

// src/gui/choiceList/ChoiceView.svelte
function add_css9(target) {
  append_styles(target, "svelte-1ikpkxq", ".choiceViewBottomBar.svelte-1ikpkxq{display:flex;flex-direction:row;align-items:center;justify-content:space-between;margin-top:1rem}@media(max-width: 800px){.choiceViewBottomBar.svelte-1ikpkxq{flex-direction:column}}");
}
function create_if_block6(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "AI Assistant";
      attr(button, "class", "mod-cta");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openAISettings*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment16(ctx) {
  let div2;
  let choicelist;
  let updating_choices;
  let t0;
  let div1;
  let div0;
  let button;
  let t2;
  let show_if = !settingsStore.getState().disableOnlineFeatures;
  let t3;
  let addchoicebox;
  let current;
  let mounted;
  let dispose;
  function choicelist_choices_binding(value) {
    ctx[13](value);
  }
  let choicelist_props = { type: "main" };
  if (
    /*choices*/
    ctx[0] !== void 0
  ) {
    choicelist_props.choices = /*choices*/
    ctx[0];
  }
  choicelist = new ChoiceList_default({ props: choicelist_props });
  binding_callbacks.push(() => bind(choicelist, "choices", choicelist_choices_binding));
  choicelist.$on(
    "deleteChoice",
    /*deleteChoice*/
    ctx[3]
  );
  choicelist.$on(
    "configureChoice",
    /*configureChoice*/
    ctx[4]
  );
  choicelist.$on(
    "toggleCommand",
    /*toggleCommandForChoice*/
    ctx[5]
  );
  choicelist.$on(
    "duplicateChoice",
    /*handleDuplicateChoice*/
    ctx[6]
  );
  choicelist.$on(
    "reorderChoices",
    /*reorderChoices_handler*/
    ctx[14]
  );
  let if_block = show_if && create_if_block6(ctx);
  addchoicebox = new AddChoiceBox_default({});
  addchoicebox.$on(
    "addChoice",
    /*addChoiceToList*/
    ctx[2]
  );
  return {
    c() {
      div2 = element("div");
      create_component(choicelist.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      button.textContent = "Manage Macros";
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      create_component(addchoicebox.$$.fragment);
      attr(button, "class", "mod-cta");
      set_style(div0, "display", "flex");
      set_style(div0, "gap", "4px");
      attr(div1, "class", "choiceViewBottomBar svelte-1ikpkxq");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(choicelist, div2, null);
      append(div2, t0);
      append(div2, div1);
      append(div1, div0);
      append(div0, button);
      append(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      append(div1, t3);
      mount_component(addchoicebox, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openMacroManager*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const choicelist_changes = {};
      if (!updating_choices && dirty & /*choices*/
      1) {
        updating_choices = true;
        choicelist_changes.choices = /*choices*/
        ctx2[0];
        add_flush_callback(() => updating_choices = false);
      }
      choicelist.$set(choicelist_changes);
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelist.$$.fragment, local);
      transition_in(addchoicebox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelist.$$.fragment, local);
      transition_out(addchoicebox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(choicelist);
      if (if_block)
        if_block.d();
      destroy_component(addchoicebox);
      mounted = false;
      dispose();
    }
  };
}
function deleteChoiceHelper(id, value) {
  if (value.type === "Multi") {
    value.choices = value.choices.filter((v) => deleteChoiceHelper(id, v));
  }
  return value.id !== id;
}
function updateChoiceHelper(oldChoice, newChoice) {
  if (oldChoice.id === newChoice.id) {
    oldChoice = { ...oldChoice, ...newChoice };
    return oldChoice;
  }
  if (oldChoice.type === "Multi") {
    const multiChoice = oldChoice;
    const multiChoiceChoices = multiChoice.choices.map((c) => updateChoiceHelper(c, newChoice));
    return {
      ...multiChoice,
      choices: multiChoiceChoices
    };
  }
  return oldChoice;
}
function instance16($$self, $$props, $$invalidate) {
  let { choices = [] } = $$props;
  let { macros = [] } = $$props;
  let { saveChoices } = $$props;
  let { saveMacros } = $$props;
  let { app: app2 } = $$props;
  let { plugin } = $$props;
  onMount(() => {
    const unsubSettingsStore = settingsStore.subscribe((settings) => {
      $$invalidate(0, choices = settings.choices);
      $$invalidate(9, macros = settings.macros);
    });
    return () => {
      unsubSettingsStore();
    };
  });
  function addChoiceToList(event) {
    const { name, type } = event.detail;
    switch (type) {
      case "Template":
        const templateChoice = new TemplateChoice(name);
        $$invalidate(0, choices = [...choices, templateChoice]);
        break;
      case "Capture":
        const captureChoice = new CaptureChoice(name);
        $$invalidate(0, choices = [...choices, captureChoice]);
        break;
      case "Macro":
        const macroChoice = new MacroChoice(name);
        $$invalidate(0, choices = [...choices, macroChoice]);
        break;
      case "Multi":
        const multiChoice = new MultiChoice(name);
        $$invalidate(0, choices = [...choices, multiChoice]);
        break;
    }
    saveChoices(choices);
  }
  async function deleteChoice(e) {
    const choice = e.detail.choice;
    const hasOwnMacro = choice.type === "Macro" && macros.some((macro) => macro.name === choice.name);
    const isMulti = choice.type === "Multi";
    const userConfirmed = await GenericYesNoPrompt.Prompt(app2, `Confirm deletion of choice`, `Please confirm that you wish to delete '${choice.name}'.
            ${isMulti ? "Deleting this choice will delete all (" + choice.choices.length + ") choices inside it!" : ""}
            ${hasOwnMacro ? "Deleting this choice will delete the macro associated with it!" : ""}
            `);
    if (!userConfirmed)
      return;
    if (hasOwnMacro) {
      $$invalidate(9, macros = macros.filter((macro) => macro.id !== choice.macroId));
      saveMacros(macros);
    }
    $$invalidate(0, choices = choices.filter((value) => deleteChoiceHelper(choice.id, value)));
    plugin.removeCommandForChoice(choice);
    saveChoices(choices);
  }
  async function configureChoice(e) {
    const { choice: oldChoice } = e.detail;
    let updatedChoice;
    if (oldChoice.type === "Multi") {
      updatedChoice = oldChoice;
      const name = await GenericInputPrompt.Prompt(app2, `Rename ${oldChoice.name}`, "", oldChoice.name);
      if (!name)
        return;
      updatedChoice.name = name;
    } else {
      const builder = getChoiceBuilder(oldChoice);
      if (!builder) {
        throw new Error("Invalid choice type");
      }
      updatedChoice = await builder.waitForClose;
    }
    if (!updatedChoice)
      return;
    $$invalidate(0, choices = choices.map((choice) => updateChoiceHelper(choice, updatedChoice)));
    plugin.removeCommandForChoice(oldChoice);
    plugin.addCommandForChoice(updatedChoice);
    saveChoices(choices);
  }
  async function toggleCommandForChoice(e) {
    const { choice: oldChoice } = e.detail;
    const updatedChoice = {
      ...oldChoice,
      command: !oldChoice.command
    };
    updatedChoice.command ? plugin.addCommandForChoice(updatedChoice) : plugin.removeCommandForChoice(updatedChoice);
    $$invalidate(0, choices = choices.map((choice) => updateChoiceHelper(choice, updatedChoice)));
    saveChoices(choices);
  }
  async function handleDuplicateChoice(e) {
    const { choice: sourceChoice } = e.detail;
    const newChoice = duplicateChoice(sourceChoice);
    $$invalidate(0, choices = [...choices, newChoice]);
    saveChoices(choices);
  }
  function duplicateChoice(choice) {
    if (!getChoiceType(choice))
      throw new Error("Invalid choice type");
    let newChoice;
    switch (choice.type) {
      case "Template":
        newChoice = new TemplateChoice(`${choice.name} (copy)`);
        break;
      case "Capture":
        newChoice = new CaptureChoice(`${choice.name} (copy)`);
        break;
      case "Macro":
        newChoice = new MacroChoice(`${choice.name} (copy)`);
        break;
      case "Multi":
        newChoice = new MultiChoice(`${choice.name} (copy)`);
        break;
    }
    if (choice.type !== "Multi") {
      Object.assign(newChoice, excludeKeys(choice, ["id", "name"]));
    } else {
      newChoice.choices = choice.choices.map((c) => duplicateChoice(c));
    }
    return newChoice;
  }
  function getChoiceBuilder(choice) {
    switch (choice.type) {
      case "Template":
        return new TemplateChoiceBuilder(app2, choice, plugin);
      case "Capture":
        return new CaptureChoiceBuilder(app2, choice, plugin);
      case "Macro":
        return new MacroChoiceBuilder(app2, choice, macros, settingsStore.getState().choices);
      case "Multi":
      default:
        break;
    }
  }
  async function openMacroManager() {
    const newMacros = await new MacrosManager(app2, plugin, macros, choices).waitForClose;
    if (newMacros) {
      saveMacros(newMacros);
      $$invalidate(9, macros = newMacros);
    }
  }
  async function openAISettings() {
    const newSettings = await new AIAssistantSettingsModal(settingsStore.getState().ai).waitForClose;
    if (newSettings) {
      settingsStore.setState((state) => ({ ...state, ai: newSettings }));
    }
  }
  function choicelist_choices_binding(value) {
    choices = value;
    $$invalidate(0, choices);
  }
  const reorderChoices_handler = (e) => saveChoices(e.detail.choices);
  $$self.$$set = ($$props2) => {
    if ("choices" in $$props2)
      $$invalidate(0, choices = $$props2.choices);
    if ("macros" in $$props2)
      $$invalidate(9, macros = $$props2.macros);
    if ("saveChoices" in $$props2)
      $$invalidate(1, saveChoices = $$props2.saveChoices);
    if ("saveMacros" in $$props2)
      $$invalidate(10, saveMacros = $$props2.saveMacros);
    if ("app" in $$props2)
      $$invalidate(11, app2 = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(12, plugin = $$props2.plugin);
  };
  return [
    choices,
    saveChoices,
    addChoiceToList,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    handleDuplicateChoice,
    openMacroManager,
    openAISettings,
    macros,
    saveMacros,
    app2,
    plugin,
    choicelist_choices_binding,
    reorderChoices_handler
  ];
}
var ChoiceView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        choices: 0,
        macros: 9,
        saveChoices: 1,
        saveMacros: 10,
        app: 11,
        plugin: 12
      },
      add_css9
    );
  }
};
var ChoiceView_default = ChoiceView;

// src/quickAddSettingsTab.ts
var DEFAULT_SETTINGS = {
  choices: [],
  macros: [],
  inputPrompt: "single-line",
  devMode: false,
  templateFolderPath: "",
  announceUpdates: true,
  version: "0.0.0",
  disableOnlineFeatures: true,
  ai: {
    OpenAIApiKey: "",
    defaultModel: "Ask me",
    defaultSystemPrompt: `As an AI assistant within Obsidian, your primary goal is to help users manage their ideas and knowledge more effectively. Format your responses using Markdown syntax. Please use the [[Obsidian]] link format. You can write aliases for the links by writing [[Obsidian|the alias after the pipe symbol]]. To use mathematical notation, use LaTeX syntax. LaTeX syntax for larger equations should be on separate lines, surrounded with double dollar signs ($$). You can also inline math expressions by wrapping it in $ symbols. For example, use $$w_{ij}^{	ext{new}}:=w_{ij}^{	ext{current}}+etacdotdelta_jcdot x_{ij}$$ on a separate line, but you can write "($eta$ = learning rate, $delta_j$ = error term, $x_{ij}$ = input)" inline.`,
    promptTemplatesFolderPath: "",
    showAssistant: true
  },
  migrations: {
    migrateToMacroIDFromEmbeddedMacro: false,
    useQuickAddTemplateFolder: false,
    incrementFileNameSettingMoveToDefaultBehavior: false,
    mutualExclusionInsertAfterAndWriteToBottomOfFile: false,
    setVersionAfterUpdateModalRelease: false
  }
};
var QuickAddSettingsTab = class extends import_obsidian31.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "QuickAdd Settings" });
    this.addChoicesSetting();
    this.addUseMultiLineInputPromptSetting();
    this.addTemplateFolderPathSetting();
    this.addAnnounceUpdatesSetting();
    this.addDisableOnlineFeaturesSetting();
  }
  addAnnounceUpdatesSetting() {
    const setting = new import_obsidian31.Setting(this.containerEl);
    setting.setName("Announce Updates");
    setting.setDesc(
      "Display release notes when a new version is installed. This includes new features, demo videos, and bug fixes."
    );
    setting.addToggle((toggle) => {
      toggle.setValue(settingsStore.getState().announceUpdates);
      toggle.onChange((value) => {
        settingsStore.setState({ announceUpdates: value });
      });
    });
  }
  hide() {
    if (this.choiceView)
      this.choiceView.$destroy();
  }
  addChoicesSetting() {
    const setting = new import_obsidian31.Setting(this.containerEl);
    setting.infoEl.remove();
    setting.settingEl.style.display = "block";
    this.choiceView = new ChoiceView_default({
      target: setting.settingEl,
      props: {
        app: this.app,
        plugin: this.plugin,
        choices: settingsStore.getState().choices,
        saveChoices: (choices) => {
          settingsStore.setState({ choices });
        },
        macros: settingsStore.getState().macros,
        saveMacros: (macros) => {
          settingsStore.setState({ macros });
        }
      }
    });
  }
  addUseMultiLineInputPromptSetting() {
    new import_obsidian31.Setting(this.containerEl).setName("Use Multi-line Input Prompt").setDesc(
      "Use multi-line input prompt instead of single-line input prompt"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.inputPrompt === "multi-line").setTooltip("Use multi-line input prompt").onChange((value) => {
        if (value) {
          settingsStore.setState({
            inputPrompt: "multi-line"
          });
        } else {
          settingsStore.setState({
            inputPrompt: "single-line"
          });
        }
      })
    );
  }
  addTemplateFolderPathSetting() {
    const setting = new import_obsidian31.Setting(this.containerEl);
    setting.setName("Template Folder Path");
    setting.setDesc(
      "Path to the folder where templates are stored. Used to suggest template files when configuring QuickAdd."
    );
    setting.addText((text2) => {
      text2.setPlaceholder("templates/").setValue(settingsStore.getState().templateFolderPath).onChange((value) => {
        settingsStore.setState({ templateFolderPath: value });
      });
      new GenericTextSuggester(
        app,
        text2.inputEl,
        app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian31.TFolder && f.path !== "/").map((f) => f.path)
      );
    });
  }
  addDisableOnlineFeaturesSetting() {
    new import_obsidian31.Setting(this.containerEl).setName("Disable AI & Online features").setDesc(
      "This prevents the plugin from making requests to external providers like OpenAI. You can still use User Scripts to execute arbitrary code, inclulding contacting external providers. However, this setting disables plugin features like the AI Assistant from doing so. You need to disable this setting to use the AI Assistant."
    ).addToggle(
      (toggle) => toggle.setValue(settingsStore.getState().disableOnlineFeatures).onChange((value) => {
        settingsStore.setState({
          disableOnlineFeatures: value
        });
        this.display();
      })
    );
  }
};

// src/logger/quickAddLogger.ts
var QuickAddLogger = class {
  formatOutputString(error) {
    return `QuickAdd: (${error.level}) ${error.message}`;
  }
  getQuickAddError(message, level) {
    return { message, level, time: Date.now() };
  }
};

// src/logger/consoleErrorLogger.ts
var ConsoleErrorLogger = class extends QuickAddLogger {
  constructor() {
    super(...arguments);
    this.ErrorLog = [];
  }
  logError(errorMsg) {
    const error = this.getQuickAddError(errorMsg, "ERROR" /* Error */);
    this.addMessageToErrorLog(error);
    console.error(this.formatOutputString(error));
  }
  logWarning(warningMsg) {
    const warning = this.getQuickAddError(warningMsg, "WARNING" /* Warning */);
    this.addMessageToErrorLog(warning);
    console.warn(this.formatOutputString(warning));
  }
  logMessage(logMsg) {
    const log2 = this.getQuickAddError(logMsg, "LOG" /* Log */);
    this.addMessageToErrorLog(log2);
    console.log(this.formatOutputString(log2));
  }
  addMessageToErrorLog(error) {
    this.ErrorLog.push(error);
  }
};

// src/logger/guiLogger.ts
var import_obsidian32 = require("obsidian");
var GuiLogger = class extends QuickAddLogger {
  constructor(plugin) {
    super();
    this.plugin = plugin;
  }
  logError(msg) {
    const error = this.getQuickAddError(msg, "ERROR" /* Error */);
    new import_obsidian32.Notice(this.formatOutputString(error), 15e3);
  }
  logWarning(msg) {
    const warning = this.getQuickAddError(msg, "WARNING" /* Warning */);
    new import_obsidian32.Notice(this.formatOutputString(warning));
  }
  logMessage(msg) {
  }
};

// src/engine/StartupMacroEngine.ts
var StartupMacroEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, macros, choiceExecutor) {
    super(app2, plugin, null, macros, choiceExecutor, null);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async run() {
    this.macros.forEach((macro) => {
      if (macro.runOnStartup) {
        void this.executeCommands(macro.commands);
      }
    });
  }
};

// src/engine/TemplateChoiceEngine.ts
var import_obsidian33 = require("obsidian");
var TemplateChoiceEngine = class extends TemplateEngine {
  constructor(app2, plugin, choice, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.choice = choice;
  }
  async run() {
    try {
      invariant(this.choice.templatePath, () => {
        return `Invalid template path for ${this.choice.name}. ${this.choice.templatePath.length === 0 ? "Template path is empty." : `Template path is not valid: ${this.choice.templatePath}`}`;
      });
      let folderPath = "";
      if (this.choice.folder.enabled) {
        folderPath = await this.getFolderPath();
      }
      let filePath;
      if (this.choice.fileNameFormat.enabled) {
        filePath = await this.getFormattedFilePath(
          folderPath,
          this.choice.fileNameFormat.format,
          this.choice.name
        );
      } else {
        filePath = await this.getFormattedFilePath(
          folderPath,
          VALUE_SYNTAX,
          this.choice.name
        );
      }
      if (this.choice.fileExistsMode === fileExistsIncrement)
        filePath = await this.incrementFileName(filePath);
      let createdFile;
      if (await this.app.vault.adapter.exists(filePath)) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian33.TFile) || file.extension !== "md") {
          log.logError(
            `'${filePath}' already exists and is not a valid markdown file.`
          );
          return;
        }
        let userChoice = this.choice.fileExistsMode;
        if (!this.choice.setFileExistsBehavior) {
          userChoice = await GenericSuggester.Suggest(
            this.app,
            [...fileExistsChoices],
            [...fileExistsChoices]
          );
        }
        switch (userChoice) {
          case fileExistsAppendToTop:
            createdFile = await this.appendToFileWithTemplate(
              file,
              this.choice.templatePath,
              "top"
            );
            break;
          case fileExistsAppendToBottom:
            createdFile = await this.appendToFileWithTemplate(
              file,
              this.choice.templatePath,
              "bottom"
            );
            break;
          case fileExistsOverwriteFile:
            createdFile = await this.overwriteFileWithTemplate(
              file,
              this.choice.templatePath
            );
            break;
          case fileExistsDoNothing:
            createdFile = file;
            break;
          case fileExistsIncrement: {
            const incrementFileName = await this.incrementFileName(
              filePath
            );
            createdFile = await this.createFileWithTemplate(
              incrementFileName,
              this.choice.templatePath
            );
            break;
          }
          default:
            log.logWarning("File not written to.");
            return;
        }
      } else {
        createdFile = await this.createFileWithTemplate(
          filePath,
          this.choice.templatePath
        );
        if (!createdFile) {
          log.logWarning(`Could not create file '${filePath}'.`);
          return;
        }
      }
      if (this.choice.appendLink && createdFile) {
        appendToCurrentLine(
          this.app.fileManager.generateMarkdownLink(createdFile, ""),
          this.app
        );
      }
      if (this.choice.openFile && createdFile) {
        await openFile(this.app, createdFile, {
          openInNewTab: this.choice.openFileInNewTab.enabled,
          direction: this.choice.openFileInNewTab.direction,
          focus: this.choice.openFileInNewTab.focus,
          mode: this.choice.openFileInMode
        });
      }
    } catch (error) {
      log.logError(error);
    }
  }
  async formatFolderPaths(folders) {
    const folderPaths = await Promise.all(
      folders.map(async (folder) => {
        return await this.formatter.formatFolderPath(folder);
      })
    );
    return folderPaths;
  }
  async getFolderPath() {
    const folders = await this.formatFolderPaths([
      ...this.choice.folder.folders
    ]);
    if (this.choice.folder?.chooseFromSubfolders && !(this.choice.folder?.chooseWhenCreatingNote || this.choice.folder?.createInSameFolderAsActiveFile)) {
      const allFoldersInVault = getAllFolderPathsInVault(
        this.app
      );
      const subfolders = allFoldersInVault.filter((folder) => {
        return folders.some((f) => folder.startsWith(f));
      });
      return await this.getOrCreateFolder(subfolders);
    }
    if (this.choice.folder?.chooseWhenCreatingNote) {
      const allFoldersInVault = getAllFolderPathsInVault(
        this.app
      );
      return await this.getOrCreateFolder(allFoldersInVault);
    }
    if (this.choice.folder?.createInSameFolderAsActiveFile) {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || !activeFile.parent) {
        log.logWarning(
          "No active file or active file has no parent. Cannot create file in same folder as active file. Creating in root folder."
        );
        return "";
      }
      return this.getOrCreateFolder([activeFile.parent.path]);
    }
    return await this.getOrCreateFolder(folders);
  }
};

// src/formatters/helpers/getEndOfSection.ts
function isSameHeading(heading1, heading2) {
  return heading1.line === heading2.line;
}
function getMarkdownHeadings(bodyLines) {
  const headers = [];
  bodyLines.forEach((line, index) => {
    const match = line.match(/^(#+)[\s]?(.*)$/);
    if (!match)
      return;
    headers.push({
      level: match[1].length,
      text: match[2],
      line: index
    });
  });
  return headers;
}
function getEndOfSection(lines, targetLine, shouldConsiderSubsections = false) {
  const headings = getMarkdownHeadings(lines);
  const targetHeading = headings.find(
    (heading) => heading.line === targetLine
  );
  const targetIsHeading = !!targetHeading;
  if (!targetIsHeading && shouldConsiderSubsections) {
    throw new Error(
      `Target line ${targetLine} is not a heading, but we are trying to find the end of its section.`
    );
  }
  if (!targetIsHeading && !shouldConsiderSubsections) {
    const nextEmptyStringIdx = findNextIdx(
      lines,
      targetLine,
      (str) => str.trim() === ""
    );
    if (nextEmptyStringIdx !== null && nextEmptyStringIdx > targetLine) {
      return nextEmptyStringIdx - 1;
    }
    return targetLine;
  }
  const lastLineInBodyIdx = lines.length - 1;
  const endOfSectionLineIdx = getEndOfSectionLineByHeadings(
    targetHeading,
    headings,
    lines,
    shouldConsiderSubsections
  );
  const lastNonEmptyLineInSectionIdx = findPriorIdx(
    lines,
    endOfSectionLineIdx,
    (str) => str.trim() !== ""
  );
  if (lastNonEmptyLineInSectionIdx !== null) {
    if (lastNonEmptyLineInSectionIdx < targetLine) {
      return targetLine;
    }
    const lineIsEmpty = lines[lastNonEmptyLineInSectionIdx + 1].trim() === "";
    if (lastNonEmptyLineInSectionIdx + 1 === lastLineInBodyIdx && !lineIsEmpty) {
      return endOfSectionLineIdx;
    }
    if (lastNonEmptyLineInSectionIdx === 0) {
      return lastNonEmptyLineInSectionIdx + 1;
    }
    return lastNonEmptyLineInSectionIdx;
  }
  return endOfSectionLineIdx;
}
function getEndOfSectionLineByHeadings(targetHeading, headings, lines, shouldConsiderSubsections) {
  const targetHeadingIdx = headings.findIndex(
    (heading) => isSameHeading(heading, targetHeading)
  );
  const targetHeadingIsLastHeading = targetHeadingIdx === headings.length - 1;
  const lastLineInBodyIdx = lines.length - 1;
  if (targetHeadingIsLastHeading) {
    return lastLineInBodyIdx;
  }
  const [nextHigherOrSameLevelHeadingIndex, foundHigherOrSameLevelHeading] = findNextHigherOrSameLevelHeading(targetHeading, headings);
  const higherLevelSectionIsLastHeading = foundHigherOrSameLevelHeading && nextHigherOrSameLevelHeadingIndex === headings.length;
  if (higherLevelSectionIsLastHeading) {
    return lastLineInBodyIdx;
  }
  if (foundHigherOrSameLevelHeading && shouldConsiderSubsections) {
    const nextHigherLevelHeadingLineIdx = headings[nextHigherOrSameLevelHeadingIndex].line;
    return nextHigherLevelHeadingLineIdx - 1;
  }
  if (foundHigherOrSameLevelHeading && !shouldConsiderSubsections) {
    return headings[targetHeadingIdx + 1].line;
  }
  if (!shouldConsiderSubsections && !foundHigherOrSameLevelHeading) {
    const nextHeading = findNextHeading(targetHeading.line, headings);
    if (nextHeading === null) {
      return lastLineInBodyIdx;
    }
    return nextHeading;
  }
  return lastLineInBodyIdx;
}
function findNextHigherOrSameLevelHeading(targetHeading, headings) {
  const targetHeadingIdx = headings.findIndex(
    (heading) => isSameHeading(heading, targetHeading)
  );
  const nextSameOrHigherLevelHeadingIdx = findNextIdx(
    headings,
    targetHeadingIdx,
    (heading) => heading.level <= targetHeading.level
  );
  if (nextSameOrHigherLevelHeadingIdx === null) {
    return [-1, false];
  }
  return [nextSameOrHigherLevelHeadingIdx, true];
}
function findNextHeading(fromIdxInBody, headings) {
  const nextheading = headings.findIndex(
    (heading) => heading.line > fromIdxInBody
  );
  return nextheading === -1 ? null : nextheading;
}
function findPriorIdx(items, fromIdx, condition) {
  for (let i = fromIdx - 1; i >= 0; i--) {
    if (condition(items[i])) {
      return i;
    }
  }
  return null;
}
function findNextIdx(items, fromIdx, condition) {
  for (let i = fromIdx + 1; i < items.length; i++) {
    if (condition(items[i])) {
      return i;
    }
  }
  return null;
}

// src/formatters/captureChoiceFormatter.ts
var CaptureChoiceFormatter = class extends CompleteFormatter {
  constructor(app2, plugin, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.file = null;
    this.fileContent = "";
  }
  async formatContentWithFile(input, choice, fileContent, file) {
    this.choice = choice;
    this.file = file;
    this.fileContent = fileContent;
    if (!choice || !file || fileContent === null)
      return input;
    const formatted = await this.formatFileContent(input);
    const templaterFormatted = templaterParseTemplate(
      this.app,
      formatted,
      this.file
    );
    if (!await templaterFormatted)
      return formatted;
    return templaterFormatted;
  }
  async formatContent(input, choice) {
    this.choice = choice;
    if (!choice)
      return input;
    return await this.formatFileContent(input);
  }
  async formatFileContent(input) {
    let formatted = await super.formatFileContent(input);
    formatted = this.replaceLinebreakInString(formatted);
    const formattedContentIsEmpty = formatted.trim() === "";
    if (formattedContentIsEmpty)
      return this.fileContent;
    if (this.choice.prepend) {
      const shouldInsertLinebreak = !this.choice.task;
      return `${this.fileContent}${shouldInsertLinebreak ? "\n" : ""}${formatted}`;
    }
    if (this.choice.insertAfter.enabled) {
      return await this.insertAfterHandler(formatted);
    }
    const frontmatterEndPosition = this.file ? this.getFrontmatterEndPosition(this.file) : null;
    if (!frontmatterEndPosition)
      return `${formatted}${this.fileContent}`;
    return this.insertTextAfterPositionInBody(
      formatted,
      this.fileContent,
      frontmatterEndPosition
    );
  }
  async formatContentOnly(input) {
    let formatted = await super.formatFileContent(input);
    formatted = this.replaceLinebreakInString(formatted);
    const formattedContentIsEmpty = formatted.trim() === "";
    if (formattedContentIsEmpty)
      return this.fileContent;
    return formatted;
  }
  async insertAfterHandler(formatted) {
    const targetString = await this.format(
      this.choice.insertAfter.after
    );
    const targetRegex = new RegExp(
      `\\s*${escapeRegExp(targetString.replace("\\n", ""))}\\s*`
    );
    const fileContentLines = getLinesInString(this.fileContent);
    let targetPosition = fileContentLines.findIndex(
      (line) => targetRegex.test(line)
    );
    const targetNotFound = targetPosition === -1;
    if (targetNotFound) {
      if (this.choice.insertAfter?.createIfNotFound) {
        return await this.createInsertAfterIfNotFound(formatted);
      }
      log.logError("unable to find insert after line in file.");
    }
    if (this.choice.insertAfter?.insertAtEnd) {
      if (!this.file)
        throw new Error("Tried to get sections without file.");
      const endOfSectionIndex = getEndOfSection(
        fileContentLines,
        targetPosition,
        !!this.choice.insertAfter.considerSubsections
      );
      targetPosition = endOfSectionIndex ?? fileContentLines.length - 1;
    }
    return this.insertTextAfterPositionInBody(
      formatted,
      this.fileContent,
      targetPosition
    );
  }
  async createInsertAfterIfNotFound(formatted) {
    const insertAfterLine = this.replaceLinebreakInString(
      await this.format(this.choice.insertAfter.after)
    );
    const insertAfterLineAndFormatted = `${insertAfterLine}
${formatted}`;
    if (this.choice.insertAfter?.createIfNotFoundLocation === CREATE_IF_NOT_FOUND_TOP) {
      const frontmatterEndPosition = this.file ? this.getFrontmatterEndPosition(this.file) : -1;
      return this.insertTextAfterPositionInBody(
        insertAfterLineAndFormatted,
        this.fileContent,
        frontmatterEndPosition
      );
    }
    if (this.choice.insertAfter?.createIfNotFoundLocation === CREATE_IF_NOT_FOUND_BOTTOM) {
      return `${this.fileContent}
${insertAfterLineAndFormatted}`;
    }
  }
  getFrontmatterEndPosition(file) {
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache || !fileCache.frontmatter) {
      log.logMessage("could not get frontmatter. Maybe there isn't any.");
      return -1;
    }
    if (fileCache.frontmatter.position)
      return fileCache.frontmatter.position.end.line;
    return -1;
  }
  insertTextAfterPositionInBody(text2, body, pos) {
    if (pos === -1) {
      const shouldAddLinebreak = !this.choice.task;
      return `${text2}${shouldAddLinebreak ? "\n" : ""}${body}`;
    }
    const splitContent = body.split("\n");
    const pre = splitContent.slice(0, pos + 1).join("\n");
    const post = splitContent.slice(pos + 1).join("\n");
    return `${pre}
${text2}${post}`;
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/outcomes.js
var Outcome = class {
  isResolved() {
    return !this.hasConflicts;
  }
  isConflicted() {
    return this.hasConflicts;
  }
};
var Conflicted = class extends Outcome {
  constructor(left2, base, right2) {
    super();
    this.left = left2;
    this.base = base;
    this.right = right2;
    this.hasConflicts = true;
  }
  // Special constructor because left/base/right positional params
  // are confusing
  static create(opts) {
    return new Conflicted(opts.left, opts.base, opts.right);
  }
  apply(fun) {
    return Conflicted.create({
      left: fun(this.left),
      base: fun(this.base),
      right: fun(this.right)
    });
  }
};
var Resolved = class extends Outcome {
  constructor(result) {
    super();
    this.hasConflicts = false;
    this.result = result;
  }
  combine(other) {
    this.result = this.result.concat(other.result);
  }
  apply(fun) {
    return new Resolved(fun(this.result));
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/heckel-diff.js
var HeckelDiff = class {
  constructor(left2, right2) {
    this.left = left2;
    this.right = right2;
  }
  static executeDiff(oldTextArray, newTextArray) {
    if (!oldTextArray.push) {
      throw new Error("Argument is not an array");
    }
    const diffResult = HeckelDiff.diff(oldTextArray, newTextArray);
    return new HeckelDiffWrapper(oldTextArray, newTextArray, diffResult).convertToTypedOutput();
  }
  static diff(left2, right2) {
    const differ = new HeckelDiff(left2, right2);
    return differ.performDiff();
  }
  performDiff() {
    let uniquePositions = this.identifyUniquePositions();
    uniquePositions.sort((a, b) => b[0] - a[0]);
    const [leftChangePos, rightChangePos] = this.findNextChange();
    let initChanges = new ChangeData(leftChangePos, rightChangePos, []);
    uniquePositions.forEach((pos) => {
      initChanges = this.getDifferences(initChanges, pos);
    });
    return initChanges.changeRanges;
  }
  getDifferences(changeData, uniquePositions) {
    const [leftPos, rightPos] = [
      changeData.leftChangePos,
      changeData.rightChangePos
    ];
    const [leftUniqPos, rightUniqPos] = uniquePositions;
    if (leftUniqPos < leftPos || rightUniqPos < rightPos) {
      return changeData;
    } else {
      const [leftLo, leftHi, rightLo, rightHi] = this.findPrevChange(leftPos, rightPos, leftUniqPos - 1, rightUniqPos - 1);
      const [nextLeftPos, nextRightPos] = this.findNextChange(leftUniqPos + 1, rightUniqPos + 1);
      const updatedRanges = this.appendChangeRange(changeData.changeRanges, leftLo, leftHi, rightLo, rightHi);
      return new ChangeData(nextLeftPos, nextRightPos, updatedRanges);
    }
  }
  findNextChange(leftStartPos = 0, rightStartPos = 0) {
    const lArr = this.left.slice(leftStartPos) || [];
    const rArr = this.right.slice(rightStartPos) || [];
    const offset2 = this.mismatchOffset(lArr, rArr);
    return [leftStartPos + offset2, rightStartPos + offset2];
  }
  findPrevChange(leftLo, rightLo, leftHi, rightHi) {
    if (leftLo > leftHi || rightLo > rightHi) {
      return [leftLo, leftHi, rightLo, rightHi];
    } else {
      const lArr = this.left.slice(leftLo, leftHi + 1).reverse() || [];
      const rArr = this.right.slice(rightLo, rightHi + 1).reverse() || [];
      const offset2 = this.mismatchOffset(lArr, rArr);
      return [leftLo, leftHi - offset2, rightLo, rightHi - offset2];
    }
  }
  mismatchOffset(lArr, rArr) {
    const max2 = Math.max(lArr.length, rArr.length);
    for (let i = 0; i < max2; i++) {
      if (lArr[i] !== rArr[i]) {
        return i;
      }
    }
    return Math.min(lArr.length, rArr.length);
  }
  identifyUniquePositions() {
    const leftUniques = this.findUnique(this.left);
    const rightUniques = this.findUnique(this.right);
    const leftKeys = new Set(...leftUniques.keys());
    const rightKeys = new Set(...rightUniques.keys());
    const sharedKeys = new Set([...leftKeys].filter((k) => rightKeys.has(k)));
    const uniqRanges = [...sharedKeys].map((k) => {
      return [
        leftUniques.get(k),
        rightUniques.get(k)
      ];
    });
    uniqRanges.unshift([this.left.length, this.right.length]);
    return uniqRanges;
  }
  findUnique(array) {
    const flaggedUniques = /* @__PURE__ */ new Map();
    array.forEach((item, pos) => {
      flaggedUniques.set(item, new UniqueItem(pos, !flaggedUniques.has(item)));
    });
    const uniques = /* @__PURE__ */ new Map();
    for (let [key, value] of flaggedUniques.entries()) {
      if (value.unique) {
        uniques.set(key, value.pos);
      }
    }
    return uniques;
  }
  // given the calculated bounds of the 2 way diff, create the proper
  // change type and add it to the queue.
  appendChangeRange(changesRanges, leftLo, leftHi, rightLo, rightHi) {
    if (leftLo <= leftHi && rightLo <= rightHi) {
      changesRanges.push(new ChangeRange(Action.change, leftLo + 1, leftHi + 1, rightLo + 1, rightHi + 1));
    } else if (leftLo <= leftHi) {
      changesRanges.push(new ChangeRange(Action.remove, leftLo + 1, leftHi + 1, rightLo + 1, rightLo));
    } else if (rightLo <= rightHi) {
      changesRanges.push(new ChangeRange(Action.add, leftLo + 1, leftLo, rightLo + 1, rightHi + 1));
    }
    return changesRanges;
  }
};
var UniqueItem = class {
  constructor(pos, unique) {
    this.pos = pos;
    this.unique = unique;
  }
};
var TextNode = class {
  constructor(text2, low) {
    this.text = text2;
    this.low = low;
  }
};
var HeckelDiffWrapper = class {
  constructor(oldTextArray, newTextArray, chunks) {
    this.oldTextArray = oldTextArray;
    this.newTextArray = newTextArray;
    this.chunks = chunks;
    this.oldText = [];
    this.newText = [];
  }
  convertToTypedOutput() {
    let finalIndexes = new IndexTracker(0, 0);
    this.chunks.forEach((chunk) => {
      const [oldIteration, newIteration] = this.setTextNodeIndexes(chunk, finalIndexes.oldIndex, finalIndexes.newIndex);
      const [oldIndex, newIndex] = this.appendChanges(chunk, finalIndexes.oldIndex + oldIteration, finalIndexes.newIndex + newIteration);
      finalIndexes.oldIndex = oldIndex;
      finalIndexes.newIndex = newIndex;
    });
    this.setTheRemainingTextNodeIndexes(finalIndexes.oldIndex, finalIndexes.newIndex);
    return {
      oldText: this.oldText,
      newText: this.newText
    };
  }
  setTextNodeIndexes(chunk, oldIndex, newIndex) {
    let oldIteration = 0;
    while (oldIndex + oldIteration < chunk.leftLo - 1) {
      this.oldText.push(new TextNode(this.oldTextArray[oldIndex + oldIteration], newIndex + oldIteration));
      oldIteration += 1;
    }
    let newIteration = 0;
    while (newIndex + newIteration < chunk.rightLo - 1) {
      this.newText.push(new TextNode(this.newTextArray[newIndex + newIteration], oldIndex + newIteration));
      newIteration += 1;
    }
    return [oldIteration, newIteration];
  }
  appendChanges(chunk, oldIndex, newIndex) {
    while (oldIndex <= chunk.leftHi - 1) {
      this.oldText.push(this.oldTextArray[oldIndex]);
      oldIndex += 1;
    }
    while (newIndex <= chunk.rightHi - 1) {
      this.newText.push(this.newTextArray[newIndex]);
      newIndex += 1;
    }
    return [oldIndex, newIndex];
  }
  setTheRemainingTextNodeIndexes(oldIndex, newIndex) {
    let iteration = 0;
    while (oldIndex + iteration < this.oldTextArray.length) {
      this.oldText.push(new TextNode(this.oldTextArray[oldIndex + iteration], newIndex + iteration));
      iteration += 1;
    }
    while (newIndex + iteration < this.newTextArray.length) {
      this.newText.push(new TextNode(this.newTextArray[newIndex + iteration], oldIndex + iteration));
      iteration += 1;
    }
  }
};
var IndexTracker = class {
  constructor(oldIndex, newIndex) {
    this.oldIndex = oldIndex;
    this.newIndex = newIndex;
  }
};
var Action;
(function(Action2) {
  Action2["change"] = "change";
  Action2["add"] = "add";
  Action2["remove"] = "remove";
})(Action || (Action = {}));
var ChangeRange = class {
  constructor(action, leftLo, leftHi, rightLo, rightHi) {
    this.action = action;
    this.leftLo = leftLo;
    this.leftHi = leftHi;
    this.rightLo = rightLo;
    this.rightHi = rightHi;
  }
};
var ChangeData = class {
  constructor(leftChangePos, rightChangePos, changeRanges) {
    this.leftChangePos = leftChangePos;
    this.rightChangePos = rightChangePos;
    this.changeRanges = changeRanges;
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/diff3.js
var Diff2Command = class {
  constructor(code, baseLo, baseHi, sideLo, sideHi) {
    this.code = code;
    this.baseLo = baseLo;
    this.baseHi = baseHi;
    this.sideLo = sideLo;
    this.sideHi = sideHi;
  }
  static fromChangeRange(changeRange) {
    return new Diff2Command(changeRange.action, changeRange.leftLo, changeRange.leftHi, changeRange.rightLo, changeRange.rightHi);
  }
};
var Diff3 = class {
  constructor(left2, base, right2) {
    this.left = left2;
    this.base = base;
    this.right = right2;
  }
  static executeDiff(left2, base, right2) {
    return new Diff3(left2, base, right2).getDifferences();
  }
  getDifferences() {
    const leftDiff = HeckelDiff.diff(this.base, this.left).map((d) => {
      return Diff2Command.fromChangeRange(d);
    });
    const rightDiff = HeckelDiff.diff(this.base, this.right).map((d) => {
      return Diff2Command.fromChangeRange(d);
    });
    return this.collapseDifferences(new DiffDoubleQueue(leftDiff, rightDiff));
  }
  collapseDifferences(diffsQueue, differences = []) {
    if (diffsQueue.isFinished()) {
      return differences;
    } else {
      const resultQueue = new DiffDoubleQueue();
      const initSide = diffsQueue.chooseSide();
      const topDiff = diffsQueue.dequeue();
      resultQueue.enqueue(initSide, topDiff);
      diffsQueue.switchSides();
      this.buildResultQueue(diffsQueue, topDiff.baseHi, resultQueue);
      differences.push(this.determineDifference(resultQueue, initSide, diffsQueue.switchSides()));
      return this.collapseDifferences(diffsQueue, differences);
    }
  }
  buildResultQueue(diffsQueue, prevBaseHi, resultQueue) {
    if (this.queueIsFinished(diffsQueue.peek(), prevBaseHi)) {
      return resultQueue;
    } else {
      const topDiff = diffsQueue.dequeue();
      resultQueue.enqueue(diffsQueue.currentSide, topDiff);
      if (prevBaseHi < topDiff.baseHi) {
        diffsQueue.switchSides();
        return this.buildResultQueue(diffsQueue, topDiff.baseHi, resultQueue);
      } else {
        return this.buildResultQueue(diffsQueue, prevBaseHi, resultQueue);
      }
    }
  }
  queueIsFinished(queue, prevBaseHi) {
    return queue.length === 0 || queue[0].baseLo > prevBaseHi + 1;
  }
  determineDifference(diffDiffsQueue, initSide, finalSide) {
    const baseLo = diffDiffsQueue.get(initSide)[0].baseLo;
    const finalQueue = diffDiffsQueue.get(finalSide);
    const baseHi = finalQueue[finalQueue.length - 1].baseHi;
    const [leftLo, leftHi] = this.diffableEndpoints(diffDiffsQueue.get(Side.left), baseLo, baseHi);
    const [rightLo, rightHi] = this.diffableEndpoints(diffDiffsQueue.get(Side.right), baseLo, baseHi);
    const leftSubset = this.left.slice(leftLo - 1, leftHi);
    const rightSubset = this.right.slice(rightLo - 1, rightHi);
    const changeType = this.decideAction(diffDiffsQueue, leftSubset, rightSubset);
    return new Difference(changeType, leftLo, leftHi, rightLo, rightHi, baseLo, baseHi);
  }
  diffableEndpoints(commands2, baseLo, baseHi) {
    if (commands2.length) {
      const firstCommand = commands2[0];
      const lastCommand = commands2[commands2.length - 1];
      const lo = firstCommand.sideLo - firstCommand.baseLo + baseLo;
      const hi = lastCommand.sideHi - lastCommand.baseHi + baseHi;
      return [lo, hi];
    } else {
      return [baseLo, baseHi];
    }
  }
  decideAction(diffDiffsQueue, leftSubset, rightSubset) {
    if (diffDiffsQueue.isEmpty(Side.left)) {
      return ChangeType.chooseRight;
    } else if (diffDiffsQueue.isEmpty(Side.right)) {
      return ChangeType.chooseLeft;
    } else {
      if (!leftSubset.every((x, i) => rightSubset[i] === x)) {
        return ChangeType.possibleConflict;
      } else {
        return ChangeType.noConflictFound;
      }
    }
  }
};
var Difference = class {
  constructor(changeType, leftLo, leftHi, rightLo, rightHi, baseLo, baseHi) {
    this.changeType = changeType;
    this.leftLo = leftLo;
    this.leftHi = leftHi;
    this.rightLo = rightLo;
    this.rightHi = rightHi;
    this.baseLo = baseLo;
    this.baseHi = baseHi;
  }
};
var ChangeType;
(function(ChangeType2) {
  ChangeType2["chooseRight"] = "choose_right";
  ChangeType2["chooseLeft"] = "choose_left";
  ChangeType2["possibleConflict"] = "possible_conflict";
  ChangeType2["noConflictFound"] = "no_conflict_found";
})(ChangeType || (ChangeType = {}));
var Side;
(function(Side2) {
  Side2["left"] = "left";
  Side2["right"] = "right";
})(Side || (Side = {}));
var DiffDoubleQueue = class {
  constructor(left2 = [], right2 = []) {
    this.diffs = { left: left2, right: right2 };
  }
  dequeue(side = this.currentSide) {
    return this.diffs[side].shift();
  }
  peek(side = this.currentSide) {
    return this.diffs[side];
  }
  isFinished() {
    return this.isEmpty(Side.left) && this.isEmpty(Side.right);
  }
  enqueue(side = this.currentSide, val) {
    return this.diffs[side].push(val);
  }
  get(side = this.currentSide) {
    return this.diffs[side];
  }
  isEmpty(side = this.currentSide) {
    return this.diffs[side].length === 0;
  }
  switchSides(side = this.currentSide) {
    return this.currentSide = side === Side.left ? Side.right : Side.left;
  }
  chooseSide() {
    if (this.isEmpty(Side.left)) {
      this.currentSide = Side.right;
    } else if (this.isEmpty(Side.right)) {
      this.currentSide = Side.left;
    } else {
      this.currentSide = this.get(Side.left)[0].baseLo <= this.get(Side.right)[0].baseLo ? Side.left : Side.right;
    }
    return this.currentSide;
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/merger.js
var Merger = class {
  static merge(left2, base, right2) {
    const merger = new Merger(left2, base, right2);
    merger.executeThreeWayMerge();
    return merger.result;
  }
  constructor(left2, base, right2) {
    this.result = [];
    this.text3 = new Text3(left2, right2, base);
  }
  executeThreeWayMerge() {
    const differences = Diff3.executeDiff(this.text3.left, this.text3.base, this.text3.right);
    let index = 1;
    differences.forEach((difference) => {
      let initialText = [];
      for (let lineno = index; lineno < difference.baseLo; lineno++) {
        initialText.push(this.text3.base[lineno - 1]);
      }
      if (initialText.length) {
        this.result.push(new Resolved(initialText));
      }
      this.interpretChunk(difference);
      index = difference.baseHi + 1;
    });
    const endingText = this.accumulateLines(index, this.text3.base.length, this.text3.base);
    if (endingText.length) {
      this.result.push(new Resolved(endingText));
    }
  }
  setConflict(difference) {
    const conflict = Conflicted.create({
      left: this.accumulateLines(difference.leftLo, difference.leftHi, this.text3.left),
      base: this.accumulateLines(difference.baseLo, difference.baseHi, this.text3.base),
      right: this.accumulateLines(difference.rightLo, difference.rightHi, this.text3.right)
    });
    this.result.push(conflict);
  }
  determineConflict(d, left2, right2) {
    let ia = 1;
    d.forEach((changeRange) => {
      for (let lineno = ia; lineno <= changeRange.leftLo; lineno++) {
        this.result.push(new Resolved(this.accumulateLines(ia, lineno, right2)));
      }
      const outcome = this.determineOutcome(changeRange, left2, right2);
      ia = changeRange.rightHi + 1;
      if (outcome) {
        this.result.push(outcome);
      }
    });
    let finalText = this.accumulateLines(ia, right2.length + 1, right2);
    if (finalText.length) {
      this.result.push(new Resolved(finalText));
    }
  }
  determineOutcome(changeRange, left2, right2) {
    if (changeRange.action === Action.change) {
      return Conflicted.create({
        left: this.accumulateLines(changeRange.rightLo, changeRange.rightHi, left2),
        right: this.accumulateLines(changeRange.leftLo, changeRange.leftHi, right2),
        base: []
      });
    } else if (changeRange.action === Action.add) {
      return new Resolved(this.accumulateLines(changeRange.rightLo, changeRange.rightHi, left2));
    } else {
      return null;
    }
  }
  setText(origText, lo, hi) {
    let text2 = [];
    for (let i = lo; i <= hi; i++) {
      text2.push(origText[i - 1]);
    }
    return text2;
  }
  _conflictRange(difference) {
    const right2 = this.setText(this.text3.right, difference.rightLo, difference.rightHi);
    const left2 = this.setText(this.text3.left, difference.leftLo, difference.leftHi);
    const d = HeckelDiff.diff(right2, left2);
    if ((this._assocRange(d, Action.change) || this._assocRange(d, Action.remove)) && difference.baseLo <= difference.baseHi) {
      this.setConflict(difference);
    } else {
      this.determineConflict(d, left2, right2);
    }
  }
  interpretChunk(difference) {
    if (difference.changeType == ChangeType.chooseLeft) {
      const tempText = this.accumulateLines(difference.leftLo, difference.leftHi, this.text3.left);
      if (tempText.length) {
        this.result.push(new Resolved(tempText));
      }
    } else if (difference.changeType !== ChangeType.possibleConflict) {
      const tempText = this.accumulateLines(difference.rightLo, difference.rightHi, this.text3.right);
      if (tempText.length) {
        this.result.push(new Resolved(tempText));
      }
    } else {
      this._conflictRange(difference);
    }
  }
  _assocRange(diff, action) {
    for (let i = 0; i < diff.length; i++) {
      let d = diff[i];
      if (d.action === action) {
        return d;
      }
    }
    return null;
  }
  accumulateLines(lo, hi, text2) {
    let lines = [];
    for (let lineno = lo; lineno <= hi; lineno++) {
      if (text2[lineno - 1]) {
        lines.push(text2[lineno - 1]);
      }
    }
    return lines;
  }
};
var Text3 = class {
  constructor(left2, right2, base) {
    this.left = left2;
    this.right = right2;
    this.base = base;
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/merge-result.js
var MergeResult = class {
  constructor(results, joinFunction, options = {}) {
    this.results = results;
    this.joinFunction = joinFunction;
    this.conflictHandler = options.conflictHandler;
    this.conflict = options.conflict || false;
  }
  isSuccess() {
    return !this.conflict;
  }
  isConflict() {
    return !!this.conflict;
  }
  joinedResults() {
    if (this.isConflict()) {
      if (this.conflictHandler) {
        return this.conflictHandler(this.results);
      } else {
        return this.results;
      }
    } else {
      const [first, rest] = [this.results[0], this.results.slice(1)];
      let rs = first;
      rest.forEach((r) => rs.combine(r));
      return rs.apply(this.joinFunction).result;
    }
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/collater.js
var Collater = class {
  static collateMerge(mergeResult, joinFunction, conflictHandler) {
    if (!mergeResult.length) {
      return new MergeResult([new Resolved([])], joinFunction);
    } else {
      mergeResult = Collater.combineNonConflicts(mergeResult);
      if (mergeResult.length === 1 && mergeResult[0].isResolved()) {
        return new MergeResult(mergeResult, joinFunction);
      } else {
        return new MergeResult(mergeResult, joinFunction, {
          conflict: true,
          conflictHandler
        });
      }
    }
  }
  static combineNonConflicts(results) {
    let rs = [];
    results.forEach((r) => {
      if (rs.length && rs[rs.length - 1].isResolved() && r.isResolved()) {
        const last = rs[rs.length - 1];
        last.combine(r);
      } else {
        rs.push(r);
      }
    });
    return rs;
  }
};

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/resolver.js
function resolver_default(leftLabel, baseLabel, rightLabel, joinFunction) {
  return function resolveConflicts(results) {
    return results.map((result) => {
      if (result.isResolved()) {
        const joined = result.apply(joinFunction);
        return joined.result;
      } else {
        const joined = result.apply(joinFunction);
        const { left: left2, right: right2 } = joined;
        return [
          leftLabel,
          left2,
          baseLabel,
          right2,
          rightLabel
        ].join("\n");
      }
    }).join("\n");
  };
}

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/three-way-merge.js
var defaultJoinFunction = (a) => a.join("");
var defaultSplitFunction = (s) => s.split(/\b/);
var defaultConflictFunction = resolver_default("<<<<<<< YOUR CHANGES", "=======", ">>>>>>> APP AUTHORS CHANGES", defaultJoinFunction);
var defaultOptions = {
  splitFunction: defaultSplitFunction,
  joinFunction: defaultJoinFunction,
  conflictFunction: defaultConflictFunction
};
function merge(left2, base, right2, options = {}) {
  options = Object.assign({}, defaultOptions, options);
  const [splitLeft, splitBase, splitRight] = [left2, base, right2].map((t) => {
    return options.splitFunction.call(options, t);
  });
  const mergeResult = Merger.merge(splitLeft, splitBase, splitRight);
  const collatedMergeResults = Collater.collateMerge(mergeResult, options.joinFunction, options.conflictFunction);
  return collatedMergeResults;
}

// node_modules/.pnpm/three-way-merge@0.1.0/node_modules/three-way-merge/dist/modules/src/index.js
var src_default = merge;

// src/engine/CaptureChoiceEngine.ts
var CaptureChoiceEngine = class extends QuickAddChoiceEngine {
  constructor(app2, plugin, choice, choiceExecutor) {
    super(app2);
    this.choiceExecutor = choiceExecutor;
    this.choice = choice;
    this.plugin = plugin;
    this.formatter = new CaptureChoiceFormatter(
      app2,
      plugin,
      choiceExecutor
    );
  }
  async run() {
    try {
      const filePath = await this.getFormattedPathToCaptureTo(
        this.choice.captureToActiveFile
      );
      const content = this.getCaptureContent();
      let getFileAndAddContentFn;
      if (await this.fileExists(filePath)) {
        getFileAndAddContentFn = this.onFileExists.bind(
          this
        );
      } else if (this.choice?.createFileIfItDoesntExist?.enabled) {
        getFileAndAddContentFn = this.onCreateFileIfItDoesntExist.bind(
          this
        );
      } else {
        log.logWarning(
          `The file ${filePath} does not exist and "Create file if it doesn't exist" is disabled.`
        );
        return;
      }
      const { file, newFileContent, captureContent } = await getFileAndAddContentFn(filePath, content);
      if (this.choice.captureToActiveFile && !this.choice.prepend && !this.choice.insertAfter.enabled) {
        const content2 = await templaterParseTemplate(
          app,
          captureContent,
          file
        );
        appendToCurrentLine(content2, this.app);
      } else {
        await this.app.vault.modify(file, newFileContent);
      }
      if (this.choice.appendLink) {
        const markdownLink = this.app.fileManager.generateMarkdownLink(
          file,
          ""
        );
        appendToCurrentLine(markdownLink, this.app);
      }
      if (this.choice?.openFile) {
        await openFile(this.app, file, {
          openInNewTab: this.choice.openFileInNewTab.enabled,
          direction: this.choice.openFileInNewTab.direction,
          focus: this.choice.openFileInNewTab.focus,
          mode: this.choice.openFileInMode
        });
      }
    } catch (e) {
      log.logError(e);
    }
  }
  getCaptureContent() {
    let content;
    if (!this.choice.format.enabled)
      content = VALUE_SYNTAX;
    else
      content = this.choice.format.format;
    if (this.choice.task)
      content = `- [ ] ${content}
`;
    return content;
  }
  /**
   * Gets a formatted file path to capture content to, either the active file or a specified location.
   * If capturing to a folder, suggests a file within the folder to capture the content to.
   *
   * @param {boolean} shouldCaptureToActiveFile - Determines if the content should be captured to the active file.
   * @returns {Promise<string>} A promise that resolves to the formatted file path where the content should be captured.
   *
   * @throws {Error} Throws an error if there's no active file when trying to capture to active file,
   *                 if the capture path is invalid, or if the target folder is empty.
   */
  async getFormattedPathToCaptureTo(shouldCaptureToActiveFile) {
    if (shouldCaptureToActiveFile) {
      const activeFile = this.app.workspace.getActiveFile();
      invariant(
        activeFile,
        `Cannot capture to active file - no active file.`
      );
      return activeFile.path;
    }
    const captureTo = this.choice.captureTo;
    const formattedCaptureTo = await this.formatFilePath(captureTo);
    const folderPath = formattedCaptureTo.replace(
      /^\/$|\/\.md$|^\.md$/,
      ""
    );
    const captureAnywhereInVault = folderPath === "";
    const shouldCaptureToFolder = captureAnywhereInVault || isFolder(folderPath);
    const shouldCaptureWithTag = formattedCaptureTo.startsWith("#");
    if (shouldCaptureToFolder) {
      return this.selectFileInFolder(folderPath, captureAnywhereInVault);
    }
    if (shouldCaptureWithTag) {
      const tag = formattedCaptureTo.replace(/\.md$/, "");
      return this.selectFileWithTag(tag);
    }
    return formattedCaptureTo;
  }
  async selectFileInFolder(folderPath, captureAnywhereInVault) {
    const folderPathSlash = folderPath.endsWith("/") || captureAnywhereInVault ? folderPath : `${folderPath}/`;
    const filesInFolder = getMarkdownFilesInFolder(folderPathSlash);
    invariant(
      filesInFolder.length > 0,
      `Folder ${folderPathSlash} is empty.`
    );
    const filePaths = filesInFolder.map((f) => f.path);
    const targetFilePath = await InputSuggester.Suggest(
      app,
      filePaths.map((item) => item.replace(folderPathSlash, "")),
      filePaths
    );
    invariant(
      !!targetFilePath && targetFilePath.length > 0,
      `No file selected for capture.`
    );
    const filePath = targetFilePath.startsWith(`${folderPathSlash}`) ? targetFilePath : `${folderPathSlash}/${targetFilePath}`;
    return await this.formatFilePath(filePath);
  }
  async selectFileWithTag(tag) {
    const tagWithHash = tag.startsWith("#") ? tag : `#${tag}`;
    const filesWithTag = getMarkdownFilesWithTag(tagWithHash);
    invariant(filesWithTag.length > 0, `No files with tag ${tag}.`);
    const filePaths = filesWithTag.map((f) => f.path);
    const targetFilePath = await InputSuggester.Suggest(
      app,
      filePaths,
      filePaths
    );
    invariant(
      !!targetFilePath && targetFilePath.length > 0,
      `No file selected for capture.`
    );
    return await this.formatFilePath(targetFilePath);
  }
  async onFileExists(filePath, content) {
    const file = this.getFileByPath(filePath);
    if (!file)
      throw new Error("File not found");
    const formatted = await this.formatter.formatContentOnly(content);
    const fileContent = await this.app.vault.read(file);
    const formattedFileContent = await this.formatter.formatContentWithFile(
      formatted,
      this.choice,
      fileContent,
      file
    );
    const secondReadFileContent = await this.app.vault.read(file);
    let newFileContent = formattedFileContent;
    if (secondReadFileContent !== fileContent) {
      const res = src_default(
        secondReadFileContent,
        fileContent,
        formattedFileContent
      );
      invariant(
        !res.isSuccess,
        () => `The file ${filePath} has been modified since the last read.
QuickAdd could not merge the versions two without conflicts, and will not modify the file.
This is in order to prevent data loss.`
      );
      newFileContent = res.joinedResults();
    }
    return { file, newFileContent, captureContent: formatted };
  }
  async onCreateFileIfItDoesntExist(filePath, captureContent) {
    let fileContent = "";
    if (this.choice.createFileIfItDoesntExist.createWithTemplate) {
      const singleTemplateEngine = new SingleTemplateEngine(
        this.app,
        this.plugin,
        this.choice.createFileIfItDoesntExist.template,
        this.choiceExecutor
      );
      fileContent = await singleTemplateEngine.run();
    }
    const file = await this.createFileWithInput(
      filePath,
      fileContent
    );
    await replaceTemplaterTemplatesInCreatedFile(this.app, file);
    const updatedFileContent = await this.app.vault.cachedRead(
      file
    );
    const newFileContent = await this.formatter.formatContentWithFile(
      captureContent,
      this.choice,
      updatedFileContent,
      file
    );
    return { file, newFileContent, captureContent };
  }
  async formatFilePath(captureTo) {
    const formattedCaptureTo = await this.formatter.formatFileName(
      captureTo,
      this.choice.name
    );
    return this.normalizeMarkdownFilePath("", formattedCaptureTo);
  }
};

// src/gui/suggesters/choiceSuggester.ts
var import_obsidian34 = require("obsidian");
var ChoiceSuggester = class extends import_obsidian34.FuzzySuggestModal {
  constructor(plugin, choices, choiceExecutor) {
    super(plugin.app);
    this.plugin = plugin;
    this.choices = choices;
    this.choiceExecutor = new ChoiceExecutor(
      this.app,
      this.plugin
    );
    if (choiceExecutor)
      this.choiceExecutor = choiceExecutor;
  }
  static Open(plugin, choices, choiceExecutor) {
    new ChoiceSuggester(plugin, choices, choiceExecutor).open();
  }
  renderSuggestion(item, el) {
    el.empty();
    void import_obsidian34.MarkdownRenderer.renderMarkdown(item.item.name, el, "", this.plugin);
    el.classList.add("quickadd-choice-suggestion");
  }
  getItemText(item) {
    return item.name;
  }
  getItems() {
    return this.choices;
  }
  async onChooseItem(item, evt) {
    if (item.type === "Multi")
      this.onChooseMultiType(item);
    else
      await this.choiceExecutor.execute(item);
  }
  onChooseMultiType(multi) {
    const choices = [...multi.choices];
    if (multi.name != "\u2190 Back")
      choices.push(new MultiChoice("\u2190 Back").addChoices(this.choices));
    ChoiceSuggester.Open(this.plugin, choices);
  }
};

// src/choiceExecutor.ts
var ChoiceExecutor = class {
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
    this.variables = /* @__PURE__ */ new Map();
  }
  async execute(choice) {
    switch (choice.type) {
      case "Template": {
        const templateChoice = choice;
        await this.onChooseTemplateType(templateChoice);
        break;
      }
      case "Capture": {
        const captureChoice = choice;
        await this.onChooseCaptureType(captureChoice);
        break;
      }
      case "Macro": {
        const macroChoice = choice;
        await this.onChooseMacroType(macroChoice);
        break;
      }
      case "Multi": {
        const multiChoice = choice;
        this.onChooseMultiType(multiChoice);
        break;
      }
      default:
        break;
    }
  }
  async onChooseTemplateType(templateChoice) {
    await new TemplateChoiceEngine(
      this.app,
      this.plugin,
      templateChoice,
      this
    ).run();
  }
  async onChooseCaptureType(captureChoice) {
    await new CaptureChoiceEngine(
      this.app,
      this.plugin,
      captureChoice,
      this
    ).run();
  }
  async onChooseMacroType(macroChoice) {
    const macroEngine = new MacroChoiceEngine(
      this.app,
      this.plugin,
      macroChoice,
      this.plugin.settings.macros,
      this,
      this.variables
    );
    await macroEngine.run();
    Object.entries(macroEngine.params.variables).forEach(([key, value]) => {
      this.variables.set(key, value);
    });
  }
  onChooseMultiType(multiChoice) {
    ChoiceSuggester.Open(this.plugin, multiChoice.choices, this);
  }
};

// src/migrations/migrateToMacroIDFromEmbeddedMacro.ts
var migrateToMacroIDFromEmbeddedMacro_default = {
  description: "Migrate to macro ID from embedded macro in macro choices.",
  migrate: async (plugin) => {
    function convertMacroChoiceMacroToIdHelper(choice) {
      if (choice.type === "Multi") {
        let multiChoice = choice;
        const multiChoices = multiChoice.choices.map(
          convertMacroChoiceMacroToIdHelper
        );
        multiChoice = { ...multiChoice, choices: multiChoices };
        return multiChoice;
      }
      if (choice.type !== "Macro")
        return choice;
      const macroChoice = choice;
      if (macroChoice.macro) {
        macroChoice.macroId = macroChoice.macro.id;
        delete macroChoice.macro;
      }
      return macroChoice;
    }
    plugin.settings.choices = plugin.settings.choices.map(
      convertMacroChoiceMacroToIdHelper
    );
    await plugin.saveSettings();
  }
};

// src/migrations/useQuickAddTemplateFolder.ts
var useQuickAddTemplateFolder_default = {
  description: "Use QuickAdd template folder instead of Obsidian templates plugin folder / Templater templates folder.",
  // eslint-disable-next-line @typescript-eslint/require-await
  migrate: async (plugin) => {
    try {
      const templaterPlugin = app.plugins.plugins["templater"];
      const obsidianTemplatesPlugin = app.internalPlugins.plugins["templates"];
      if (!templaterPlugin && !obsidianTemplatesPlugin) {
        log.logMessage("No template plugin found. Skipping migration.");
        return;
      }
      if (obsidianTemplatesPlugin) {
        const obsidianTemplatesSettings = (
          //@ts-ignore
          obsidianTemplatesPlugin.instance.options
        );
        if (obsidianTemplatesSettings["folder"]) {
          plugin.settings.templateFolderPath = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          obsidianTemplatesSettings["folder"];
          log.logMessage(
            "Migrated template folder path to Obsidian Templates' setting."
          );
        }
      }
      if (templaterPlugin) {
        const templaterSettings = templaterPlugin.settings;
        if (templaterSettings["template_folder"]) {
          plugin.settings.templateFolderPath = //@ts-ignore
          templaterSettings["template_folder"];
          log.logMessage(
            "Migrated template folder path to Templaters setting."
          );
        }
      }
    } catch (error) {
      log.logError("Failed to migrate template folder path.");
      throw error;
    }
  }
};

// src/migrations/helpers/isMultiChoice.ts
function isMultiChoice(choice) {
  if (choice === null || typeof choice !== "object" || !("type" in choice) || !("choices" in choice)) {
    return false;
  }
  return choice.type === "Multi" && choice.choices !== void 0;
}

// src/migrations/helpers/isNestedChoiceCommand.ts
function isNestedChoiceCommand(command) {
  if (command === null || typeof command !== "object" || !("choice" in command)) {
    return false;
  }
  return command.choice !== void 0;
}

// src/migrations/helpers/isOldTemplateChoice.ts
function isOldTemplateChoice(choice) {
  if (typeof choice !== "object" || choice === null)
    return false;
  return "incrementFileName" in choice;
}

// src/migrations/incrementFileNameSettingMoveToDefaultBehavior.ts
function recursiveRemoveIncrementFileName(choices) {
  for (const choice of choices) {
    if (isMultiChoice(choice)) {
      choice.choices = recursiveRemoveIncrementFileName(choice.choices);
    }
    if (isOldTemplateChoice(choice)) {
      choice.setFileExistsBehavior = true;
      choice.fileExistsMode = "Increment the file name";
      delete choice.incrementFileName;
    }
  }
  return choices;
}
function removeIncrementFileName(macros) {
  for (const macro of macros) {
    if (!Array.isArray(macro.commands))
      continue;
    for (const command of macro.commands) {
      if (isNestedChoiceCommand(command) && isOldTemplateChoice(command.choice)) {
        command.choice.setFileExistsBehavior = true;
        command.choice.fileExistsMode = "Increment the file name";
        delete command.choice.incrementFileName;
      }
    }
  }
  return macros;
}
var incrementFileNameSettingMoveToDefaultBehavior = {
  description: "'Increment file name' setting moved to 'Set default behavior if file already exists' setting",
  // eslint-disable-next-line @typescript-eslint/require-await
  migrate: async (plugin) => {
    const choicesCopy = structuredClone(plugin.settings.choices);
    const choices = recursiveRemoveIncrementFileName(choicesCopy);
    const macrosCopy = structuredClone(plugin.settings.macros);
    const macros = removeIncrementFileName(macrosCopy);
    plugin.settings.choices = structuredClone(choices);
    plugin.settings.macros = structuredClone(macros);
  }
};
var incrementFileNameSettingMoveToDefaultBehavior_default = incrementFileNameSettingMoveToDefaultBehavior;

// src/migrations/helpers/isCaptureChoice.ts
function isCaptureChoice(choice) {
  return choice.type === "Capture";
}

// src/migrations/mutualExclusionInsertAfterAndWriteToBottomOfFile.ts
function recursiveMigrateSettingInChoices(choices) {
  for (const choice of choices) {
    if (isMultiChoice(choice)) {
      choice.choices = recursiveMigrateSettingInChoices(choice.choices);
    }
    if (isCaptureChoice(choice)) {
      if (choice.insertAfter.enabled && choice.prepend) {
        choice.prepend = false;
      }
    }
  }
  return choices;
}
function migrateSettingsInMacros(macros) {
  for (const macro of macros) {
    if (!Array.isArray(macro.commands))
      continue;
    for (const command of macro.commands) {
      if (isNestedChoiceCommand(command) && isCaptureChoice(command.choice)) {
        if (command.choice.insertAfter.enabled && command.choice.prepend) {
          command.choice.prepend = false;
        }
      }
    }
  }
  return macros;
}
var mutualExclusionInsertAfterAndWriteToBottomOfFile = {
  description: "Mutual exclusion of insertAfter and writeToBottomOfFile settings. If insertAfter is enabled, writeToBottomOfFile is disabled. To support changes in settings UI.",
  // eslint-disable-next-line @typescript-eslint/require-await
  migrate: async (plugin) => {
    const choicesCopy = structuredClone(plugin.settings.choices);
    const choices = recursiveMigrateSettingInChoices(choicesCopy);
    const macrosCopy = structuredClone(plugin.settings.macros);
    const macros = migrateSettingsInMacros(macrosCopy);
    plugin.settings.choices = choices;
    plugin.settings.macros = macros;
  }
};
var mutualExclusionInsertAfterAndWriteToBottomOfFile_default = mutualExclusionInsertAfterAndWriteToBottomOfFile;

// src/migrations/setVersionAfterUpdateModalRelease.ts
var setVersionAfterUpdateModalRelease = {
  description: "Set version to 0.14.0, which is the release version prior to the update modal release.",
  // eslint-disable-next-line @typescript-eslint/require-await
  migrate: async (_) => {
    settingsStore.setState({ version: "0.14.0" });
  }
};
var setVersionAfterUpdateModalRelease_default = setVersionAfterUpdateModalRelease;

// src/migrations/migrate.ts
var migrations = {
  migrateToMacroIDFromEmbeddedMacro: migrateToMacroIDFromEmbeddedMacro_default,
  useQuickAddTemplateFolder: useQuickAddTemplateFolder_default,
  incrementFileNameSettingMoveToDefaultBehavior: incrementFileNameSettingMoveToDefaultBehavior_default,
  mutualExclusionInsertAfterAndWriteToBottomOfFile: mutualExclusionInsertAfterAndWriteToBottomOfFile_default,
  setVersionAfterUpdateModalRelease: setVersionAfterUpdateModalRelease_default
};
async function migrate(plugin) {
  const migrationsToRun = Object.keys(migrations).filter(
    (migration) => !plugin.settings.migrations[migration]
  );
  if (migrationsToRun.length === 0) {
    log.logMessage("No migrations to run.");
    return;
  }
  for (const migration of migrationsToRun) {
    log.logMessage(
      `Running migration ${migration}: ${migrations[migration].description}`
    );
    const backup = structuredClone(plugin.settings);
    try {
      await migrations[migration].migrate(plugin);
      plugin.settings.migrations[migration] = true;
      log.logMessage(`Migration ${migration} successful.`);
    } catch (error) {
      log.logError(
        `Migration '${migration}' was unsuccessful. Please create an issue with the following error message: 

${error}

QuickAdd will now revert to backup.`
      );
      plugin.settings = backup;
    }
  }
  void plugin.saveSettings();
}
var migrate_default = migrate;

// src/gui/UpdateModal/UpdateModal.ts
var import_obsidian35 = require("obsidian");
var import_obsidian36 = require("obsidian");
async function getReleaseNotesAfter(repoOwner, repoName, releaseTagName) {
  const response = await fetch(
    `https://api.github.com/repos/${repoOwner}/${repoName}/releases`
  );
  const releases = await response.json();
  if (!response.ok && "message" in releases || !Array.isArray(releases)) {
    throw new Error(
      `Failed to fetch releases: ${releases.message ?? "Unknown error"}`
    );
  }
  const startReleaseIdx = releases.findIndex(
    (release) => release.tag_name === releaseTagName
  );
  if (startReleaseIdx === -1) {
    throw new Error(`Could not find release with tag ${releaseTagName}`);
  }
  return releases.slice(0, startReleaseIdx).filter((release) => !release.draft && !release.prerelease);
}
function addExtraHashToHeadings(markdownText, numHashes = 1) {
  const lines = markdownText.split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith("#")) {
      lines[i] = "#".repeat(numHashes) + lines[i];
    }
  }
  return lines.join("\n");
}
var UpdateModal = class extends import_obsidian36.Modal {
  constructor(previousQAVersion) {
    super(app);
    this.previousVersion = previousQAVersion;
    this.releaseNotesPromise = getReleaseNotesAfter(
      "chhoumann",
      "quickadd",
      previousQAVersion
    );
    this.releaseNotesPromise.then((releases) => {
      this.releases = releases;
      if (this.releases.length === 0) {
        this.close();
        return;
      }
      this.display();
    }).catch((err) => {
      log.logError(`Failed to fetch release notes: ${err}`);
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", {
      text: "Fetching release notes..."
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.classList.add("quickadd-update-modal-container");
    const header = `### New in QuickAdd v${this.releases[0].tag_name}
`;
    const text2 = `Thank you for using QuickAdd! If you like the plugin, please consider supporting me by buying me a coffee. With your sponsorship, I'll be able to contribute more to my existing projects, start new ones, and be more responsive to issues & feature requests.`;
    const buymeacoffee = `<div class="quickadd-bmac-container"><a href="https://www.buymeacoffee.com/chhoumann" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 40px !important;width: 144px !important;" ></a></div>`;
    const contentDiv = contentEl.createDiv("quickadd-update-modal");
    const releaseNotes = this.releases.map((release) => release.body).join("\n---\n");
    const andNow = `And now, here is everything new in QuickAdd since your last update (v${this.previousVersion}):`;
    const feedbackForm = `I'd love to get your feedback on QuickAdd! Please fill out this <a href="https://forms.gle/WRq1ewcKK8qmkqps6">feedback form</a> to let me know what you think.`;
    const markdownStr = `${header}
${text2}
${buymeacoffee}
${feedbackForm}

${andNow}

---

${addExtraHashToHeadings(
      releaseNotes
    )}`;
    void import_obsidian36.MarkdownRenderer.renderMarkdown(
      markdownStr,
      contentDiv,
      app.vault.getRoot().path,
      new import_obsidian35.Component()
    );
  }
};

// src/main.ts
var QuickAdd = class extends import_obsidian37.Plugin {
  get api() {
    return QuickAddApi.GetApi(app, this, new ChoiceExecutor(app, this));
  }
  async onload() {
    console.log("Loading QuickAdd");
    QuickAdd.instance = this;
    await this.loadSettings();
    settingsStore.setState(this.settings);
    this.unsubscribeSettingsStore = settingsStore.subscribe((settings) => {
      this.settings = settings;
      void this.saveSettings();
    });
    this.addCommand({
      id: "runQuickAdd",
      name: "Run QuickAdd",
      callback: () => {
        ChoiceSuggester.Open(this, this.settings.choices);
      }
    });
    this.addCommand({
      id: "reloadQuickAdd",
      name: "Reload QuickAdd (dev)",
      checkCallback: (checking) => {
        if (checking) {
          return this.settings.devMode;
        }
        const id = this.manifest.id, plugins = this.app.plugins;
        void plugins.disablePlugin(id).then(() => plugins.enablePlugin(id));
      }
    });
    this.addCommand({
      id: "testQuickAdd",
      name: "Test QuickAdd (dev)",
      checkCallback: (checking) => {
        if (checking) {
          return this.settings.devMode;
        }
        console.log(`Test QuickAdd (dev)`);
        const fn2 = () => {
          new UpdateModal("0.12.0").open();
        };
        void fn2();
      }
    });
    log.register(new ConsoleErrorLogger()).register(new GuiLogger(this));
    this.addSettingTab(new QuickAddSettingsTab(this.app, this));
    this.app.workspace.onLayoutReady(
      () => new StartupMacroEngine(
        this.app,
        this,
        this.settings.macros,
        new ChoiceExecutor(this.app, this)
      ).run()
    );
    this.addCommandsForChoices(this.settings.choices);
    await migrate_default(this);
    this.announceUpdate();
  }
  onunload() {
    console.log("Unloading QuickAdd");
    this.unsubscribeSettingsStore?.call(this);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  addCommandsForChoices(choices) {
    choices.forEach((choice) => this.addCommandForChoice(choice));
  }
  addCommandForChoice(choice) {
    if (choice.type === "Multi") {
      this.addCommandsForChoices(choice.choices);
    }
    if (choice.command) {
      this.addCommand({
        id: `choice:${choice.id}`,
        name: choice.name,
        callback: async () => {
          await new ChoiceExecutor(this.app, this).execute(choice);
        }
      });
    }
  }
  getChoiceById(choiceId) {
    const choice = this.getChoice("id", choiceId);
    if (!choice) {
      throw new Error(`Choice ${choiceId} not found`);
    }
    return choice;
  }
  getChoiceByName(choiceName) {
    const choice = this.getChoice("name", choiceName);
    if (!choice) {
      throw new Error(`Choice ${choiceName} not found`);
    }
    return choice;
  }
  getChoice(by, targetPropertyValue, choices = this.settings.choices) {
    for (const choice of choices) {
      if (choice[by] === targetPropertyValue) {
        return choice;
      }
      if (choice.type === "Multi") {
        const subChoice = this.getChoice(
          by,
          targetPropertyValue,
          choice.choices
        );
        if (subChoice) {
          return subChoice;
        }
      }
    }
    return null;
  }
  removeCommandForChoice(choice) {
    deleteObsidianCommand(this.app, `quickadd:choice:${choice.id}`);
  }
  getTemplateFiles() {
    if (!String.isString(this.settings.templateFolderPath))
      return [];
    return this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(this.settings.templateFolderPath)
    );
  }
  announceUpdate() {
    const currentVersion = this.manifest.version;
    const knownVersion = this.settings.version;
    if (currentVersion === knownVersion)
      return;
    this.settings.version = currentVersion;
    void this.saveSettings();
    if (this.settings.announceUpdates === false)
      return;
    const updateModal = new UpdateModal(knownVersion);
    updateModal.open();
  }
};
