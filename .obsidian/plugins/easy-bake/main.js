/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EasyBake
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/BakeModal.ts
var import_obsidian = require("obsidian");

// src/util.ts
var wordCountRE = /\P{Z}*[\p{L}\p{N}]\P{Z}*/gu;
var commentRE = /(?:<!--[\s\S]*?-->|%%[\s\S]*?(?!%%)[\s\S]+?%%)/g;
function stripComments(text) {
  return text.replace(commentRE, "");
}
function getWordCount(text) {
  return (stripComments(text).match(wordCountRE) || []).length;
}
function dedent(text) {
  const firstIndent = text.match(/^([ \t]*)/);
  if (firstIndent) {
    return text.replace(
      //                            Escape tab chars
      new RegExp(`^${firstIndent[0].replace(/\\/g, "\\$&")}`, "gm"),
      ""
    );
  }
  return text;
}
function applyIndent(text, indent) {
  if (!indent)
    return text;
  return text.trim().replace(/(\r?\n)/g, `$1${indent}`);
}
function stripFirstBullet(text) {
  if (!text)
    return text;
  return text.replace(/^[ \t]*(?:[-*+]|[0-9]+[.)]) +/, "");
}
function stripBlockId(text) {
  if (!text)
    return text;
  return text.replace(/ +\^[^ \n\r]+$/gm, "");
}
function stripFrontmatter(text) {
  if (!text)
    return text;
  return text.replace(/^---[\s\S]+?\r?\n---(?:\r?\n\s*|$)/, "");
}
function sanitizeBakedContent(text) {
  return stripBlockId(stripFrontmatter(text));
}
function extractSubpath(content, subpathResult, cache) {
  let text = content;
  if (subpathResult.type === "block" && subpathResult.list && cache.listItems) {
    const targetItem = subpathResult.list;
    const ancestors = /* @__PURE__ */ new Set([targetItem.position.start.line]);
    const start = targetItem.position.start.offset - targetItem.position.start.col;
    let end = targetItem.position.end.offset;
    let found = false;
    for (const item of cache.listItems) {
      if (targetItem === item) {
        found = true;
        continue;
      } else if (!found) {
        continue;
      }
      if (!ancestors.has(item.parent))
        break;
      ancestors.add(item.position.start.line);
      end = item.position.end.offset;
    }
    text = stripBlockId(dedent(content.substring(start, end)));
  } else {
    const start = subpathResult.start.offset;
    const end = subpathResult.end ? subpathResult.end.offset : content.length;
    text = stripBlockId(content.substring(start, end));
  }
  return text;
}

// src/BakeModal.ts
var lineStartRE = /(?:^|\n) *$/;
var listLineStartRE = /(?:^|\n)([ \t]*)(?:[-*+]|[0-9]+[.)]) +$/;
var lineEndRE = /^ *(?:\r?\n|$)/;
async function bake(app, file, subpath, ancestors, settings) {
  const { vault, metadataCache } = app;
  let text = await vault.cachedRead(file);
  const cache = metadataCache.getFileCache(file);
  if (!cache)
    return text;
  const resolvedSubpath = subpath ? (0, import_obsidian.resolveSubpath)(cache, subpath) : null;
  if (resolvedSubpath) {
    text = extractSubpath(text, resolvedSubpath, cache);
  }
  const links = settings.bakeLinks ? cache.links || [] : [];
  const embeds = settings.bakeEmbeds ? cache.embeds || [] : [];
  const targets = [...links, ...embeds];
  if (targets.length === 0)
    return text;
  targets.sort((a, b) => a.position.start.offset - b.position.start.offset);
  const newAncestors = new Set(ancestors);
  newAncestors.add(file);
  let posOffset = 0;
  for (const target of targets) {
    const { path, subpath: subpath2 } = (0, import_obsidian.parseLinktext)(target.link);
    const linkedFile = metadataCache.getFirstLinkpathDest(path, file.path);
    if (!linkedFile)
      continue;
    const start = target.position.start.offset + posOffset;
    const end = target.position.end.offset + posOffset;
    const prevLen = end - start;
    const before = text.substring(0, start);
    const after = text.substring(end);
    const listMatch = settings.bakeInList ? before.match(listLineStartRE) : null;
    const isInline = !(listMatch || lineStartRE.test(before)) || !lineEndRE.test(after);
    const isMarkdownFile = linkedFile.extension === "md";
    const replaceTarget = (replacement) => {
      text = before + replacement + after;
      posOffset += replacement.length - prevLen;
    };
    if (!isMarkdownFile) {
      if (!settings.convertFileLinks)
        continue;
      const adapter = app.vault.adapter;
      if (!adapter.getFullPath)
        continue;
      const fullPath = adapter.getFullPath(linkedFile.path);
      const protocol = import_obsidian.Platform.isWin ? "file:///" : "file://";
      replaceTarget(`![](${protocol}${encodeURI(fullPath)})`);
      continue;
    }
    if (newAncestors.has(linkedFile) || isInline) {
      replaceTarget(target.displayText || path);
      continue;
    }
    const baked = sanitizeBakedContent(
      await bake(app, linkedFile, subpath2, newAncestors, settings)
    );
    replaceTarget(
      listMatch ? applyIndent(stripFirstBullet(baked), listMatch[1]) : baked
    );
  }
  return text;
}
function disableBtn(btn) {
  btn.removeClass("mod-cta");
  btn.addClass("mod-muted");
  btn.setAttrs({
    disabled: "true",
    "aria-disabled": "true"
  });
}
function enableBtn(btn) {
  btn.removeClass("mod-muted");
  btn.addClass("mod-cta");
  btn.setAttrs({
    disabled: "false",
    "aria-disabled": "false"
  });
}
var BakeModal = class extends import_obsidian.Modal {
  constructor(plugin, file) {
    super(plugin.app);
    const { contentEl } = this;
    const { settings } = plugin;
    this.titleEl.setText("Bake file");
    this.modalEl.addClass("mod-narrow", "easy-bake-modal");
    this.contentEl.createEl("p", { text: "Input file: " }).createEl("strong", { text: file.path });
    new import_obsidian.Setting(contentEl).setName("Bake embedded markdown").setDesc(
      "Include the content of ![[embedded markdown files]] when the link is on its own line."
    ).addToggle(
      (toggle) => toggle.setValue(settings.bakeEmbeds).onChange((value) => {
        settings.bakeEmbeds = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Bake links").setDesc(
      "Include the content of [[any link]] when it is on its own line."
    ).addToggle(
      (toggle) => toggle.setValue(settings.bakeLinks).onChange((value) => {
        settings.bakeLinks = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Bake links and embeds in lists").setDesc(
      "Include the content of [[any link]] or ![[embedded markdown file]] when it takes up an entire list bullet."
    ).addToggle(
      (toggle) => toggle.setValue(settings.bakeInList).onChange((value) => {
        settings.bakeInList = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Bake file links").setDesc(
      "Convert links to ![[non-markdown files.png]] to ![](file:///full/path/to/non-markdown%20files.png)"
    ).addToggle(
      (toggle) => toggle.setValue(settings.convertFileLinks).onChange((value) => {
        settings.convertFileLinks = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Output file name").then((setting) => {
      new import_obsidian.Setting(contentEl).then((setting2) => {
        setting2.addButton(
          (btn) => btn.setButtonText("Calculate word count").onClick(async () => {
            const baked = await bake(this.app, file, null, /* @__PURE__ */ new Set(), settings);
            setting2.descEl.setText(getWordCount(baked).toString());
          })
        );
      });
      this.modalEl.createDiv("modal-button-container", (el) => {
        var _a;
        let outputName = file.basename + ".baked";
        let outputFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
        if (outputFolder)
          outputFolder += "/";
        const btn = el.createEl("button", {
          cls: "mod-cta",
          text: "Bake"
        });
        activeWindow.setTimeout(() => {
          btn.focus();
        });
        btn.addEventListener("click", async () => {
          disableBtn(btn);
          if (outputName) {
            const { vault } = this.app;
            const baked = await bake(this.app, file, null, /* @__PURE__ */ new Set(), settings);
            const nextPath = outputFolder + outputName + ".md";
            let existing = vault.getAbstractFileByPath(nextPath);
            if (existing instanceof import_obsidian.TFile) {
              await vault.modify(existing, baked);
            } else {
              existing = await vault.create(nextPath, baked);
            }
            if (existing instanceof import_obsidian.TFile) {
              this.app.workspace.getLeaf("tab").openFile(existing);
            }
          }
          this.close();
        });
        setting.addText(
          (text) => text.setValue(outputName).onChange((value) => {
            outputName = value;
            if (!value) {
              disableBtn(btn);
            } else if (btn.disabled) {
              enableBtn(btn);
            }
          })
        );
      });
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  bakeLinks: true,
  bakeEmbeds: true,
  bakeInList: true,
  convertFileLinks: true
};
var EasyBake = class extends import_obsidian2.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  get activeMarkdownFile() {
    var _a;
    return (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.file;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "bake-file",
      name: "Bake current file",
      checkCallback: (checking) => {
        const file = this.activeMarkdownFile;
        if (checking || !file)
          return !!file;
        new BakeModal(this, file).open();
      }
    });
  }
};
