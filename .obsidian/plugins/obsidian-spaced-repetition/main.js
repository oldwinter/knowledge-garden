/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/pagerank.js/lib/index.js
var require_lib = __commonJS({
  "node_modules/pagerank.js/lib/index.js"(exports, module2) {
    "use strict";
    function forOwn(object, callback2) {
      if (typeof object === "object" && typeof callback2 === "function") {
        for (var key in object) {
          if (object.hasOwnProperty(key) === true) {
            if (callback2(key, object[key]) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = function() {
      var self = {
        count: 0,
        edges: {},
        nodes: {}
      };
      self.link = function(source, target, weight) {
        if (isFinite(weight) !== true || weight === null) {
          weight = 1;
        }
        weight = parseFloat(weight);
        if (self.nodes.hasOwnProperty(source) !== true) {
          self.count++;
          self.nodes[source] = {
            weight: 0,
            outbound: 0
          };
        }
        self.nodes[source].outbound += weight;
        if (self.nodes.hasOwnProperty(target) !== true) {
          self.count++;
          self.nodes[target] = {
            weight: 0,
            outbound: 0
          };
        }
        if (self.edges.hasOwnProperty(source) !== true) {
          self.edges[source] = {};
        }
        if (self.edges[source].hasOwnProperty(target) !== true) {
          self.edges[source][target] = 0;
        }
        self.edges[source][target] += weight;
      };
      self.rank = function(alpha2, epsilon, callback2) {
        var delta = 1, inverse = 1 / self.count;
        forOwn(self.edges, function(source) {
          if (self.nodes[source].outbound > 0) {
            forOwn(self.edges[source], function(target) {
              self.edges[source][target] /= self.nodes[source].outbound;
            });
          }
        });
        forOwn(self.nodes, function(key) {
          self.nodes[key].weight = inverse;
        });
        while (delta > epsilon) {
          var leak = 0, nodes = {};
          forOwn(self.nodes, function(key, value) {
            nodes[key] = value.weight;
            if (value.outbound === 0) {
              leak += value.weight;
            }
            self.nodes[key].weight = 0;
          });
          leak *= alpha2;
          forOwn(self.nodes, function(source) {
            forOwn(self.edges[source], function(target, weight) {
              self.nodes[target].weight += alpha2 * nodes[source] * weight;
            });
            self.nodes[source].weight += (1 - alpha2) * inverse + leak * inverse;
          });
          delta = 0;
          forOwn(self.nodes, function(key, value) {
            delta += Math.abs(value.weight - nodes[key]);
          });
        }
        forOwn(self.nodes, function(key) {
          return callback2(key, self.nodes[key].weight);
        });
      };
      self.reset = function() {
        self.count = 0;
        self.edges = {};
        self.nodes = {};
      };
      return self;
    }();
  }
});

// node_modules/vhtml/dist/vhtml.js
var require_vhtml = __commonJS({
  "node_modules/vhtml/dist/vhtml.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.vhtml = factory();
    })(exports, function() {
      "use strict";
      var emptyTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
      var esc = function esc2(str) {
        return String(str).replace(/[&<>"']/g, function(s) {
          return "&" + map3[s] + ";";
        });
      };
      var map3 = { "&": "amp", "<": "lt", ">": "gt", '"': "quot", "'": "apos" };
      var setInnerHTMLAttr = "dangerouslySetInnerHTML";
      var DOMAttributeNames = {
        className: "class",
        htmlFor: "for"
      };
      var sanitized = {};
      function h4(name2, attrs) {
        var stack = [], s = "";
        attrs = attrs || {};
        for (var i = arguments.length; i-- > 2; ) {
          stack.push(arguments[i]);
        }
        if (typeof name2 === "function") {
          attrs.children = stack.reverse();
          return name2(attrs);
        }
        if (name2) {
          s += "<" + name2;
          if (attrs)
            for (var _i in attrs) {
              if (attrs[_i] !== false && attrs[_i] != null && _i !== setInnerHTMLAttr) {
                s += " " + (DOMAttributeNames[_i] ? DOMAttributeNames[_i] : esc(_i)) + '="' + esc(attrs[_i]) + '"';
              }
            }
          s += ">";
        }
        if (emptyTags.indexOf(name2) === -1) {
          if (attrs[setInnerHTMLAttr]) {
            s += attrs[setInnerHTMLAttr].__html;
          } else
            while (stack.length) {
              var child = stack.pop();
              if (child) {
                if (child.pop) {
                  for (var _i2 = child.length; _i2--; ) {
                    stack.push(child[_i2]);
                  }
                } else {
                  s += sanitized[child] === true ? child : esc(child);
                }
              }
            }
          s += name2 ? "</" + name2 + ">" : "";
        }
        sanitized[s] = true;
        return s;
      }
      return h4;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SRPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");
var graph = __toESM(require_lib());

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/af.ts
var af_default = {};

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {
  DECKS: "Bal\xED\u010Dky",
  DUE_CARDS: "Karti\u010Dky po term\xEDnu",
  NEW_CARDS: "Nov\xE9 karti\u010Dky",
  TOTAL_CARDS: "Karti\u010Dek celkem",
  BACK: "Back",
  EDIT_LATER: "Upravit pozd\u011Bji",
  RESET_CARD_PROGRESS: "Vynulovat pokrok karti\u010Dky",
  HARD: "Te\u017Ek\xE9",
  GOOD: "Dobr\xE9",
  EASY: "Jednoduch\xE9",
  SHOW_ANSWER: "Uk\xE1zat odpov\u011B\u010F",
  CARD_PROGRESS_RESET: "Pokrok karti\u010Dky byl vynulov\xE1n.",
  OPEN_NOTE_FOR_REVIEW: "Otev\u0159\xEDt pozn\xE1mku k revizi",
  REVIEW_CARDS: "Pozn\xE1mek k revizi",
  REVIEW_EASY_FILE_MENU: "Revize: Jednoduch\xE9",
  REVIEW_GOOD_FILE_MENU: "Revize: Dobr\xE9",
  REVIEW_HARD_FILE_MENU: "Revize: T\u011B\u017Ek\xE9",
  REVIEW_NOTE_EASY_CMD: "Ozna\u010Dit pozn\xE1mku jako jednoduchou",
  REVIEW_NOTE_GOOD_CMD: "Ozna\u010Dit pozn\xE1mku jako dobrou",
  REVIEW_NOTE_HARD_CMD: "Ozna\u010Dit pozn\xE1mku jako te\u017Ekou",
  REVIEW_CARDS_IN_NOTE: "Revidovat karti\u010Dky v t\xE9to pozn\xE1mce.",
  CRAM_CARDS_IN_NOTE: "Cram karti\u010Dky v t\xE9to pozn\xE1mce.",
  REVIEW_ALL_CARDS: "Revidovat karti\u010Dky ve v\u0161ech pozn\xE1mk\xE1ch",
  VIEW_STATS: "Uk\xE1zat statistiky",
  STATUS_BAR: "Revize: ${dueNotesCount} pozn\xE1mek, ${dueFlashcardsCount} karti\u010Dek po term\xEDnu",
  SYNC_TIME_TAKEN: "Synchronizace trvala ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Pozn\xE1mka je ulo\u017Eena v ignorovan\xE9 slo\u017Ece (zkontrolujte nastaven\xED).",
  PLEASE_TAG_NOTE: "Pros\xEDm ozna\u010Dne pozn\xE1mku odpov\xEDdaj\xEDc\xEDm tagem pro revizi (v nastaven\xED).",
  RESPONSE_RECEIVED: "Odpov\u011B\u010F p\u0159ijata.",
  NO_DECK_EXISTS: "Neexistuje \u017E\xE1dn\xFD bal\xED\u010Dek pro ${deckName}",
  ALL_CAUGHT_UP: "V\u0161e zrevidov\xE1no",
  DAYS_STR_IVL: "${interval} den/dn\xED",
  MONTHS_STR_IVL: "${interval} m\u011Bs\xEDc(\u016F)",
  YEARS_STR_IVL: "${interval} rok(\u016F)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}r",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Nastaven\xED",
  CHECK_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Ignorovan\xE9 slo\u017Eky",
  FOLDERS_TO_IGNORE_DESC: "Zadejte cesty ke slo\u017Ek\xE1m odd\u011Blen\xE9 od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDkad. \u0160ablony Meta/Scripts",
  FLASHCARDS: "Karti\u010Dky",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Tag pro karti\u010Dky",
  FLASHCARD_TAGS_DESC: "Zadete tagy ood\u011Blen\xE9 mezerou nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad. #karti\u010Dky #bal\xED\u010Dke2 #bal\xED\u010Dek3.",
  CONVERT_FOLDERS_TO_DECKS: "P\u0159ev\xE9st slo\u017Eky na bal\xED\u010Dky a podbal\xED\u010Dky?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Toto je alternativa k tag\u016Fm karti\u010Dek viz nastaven\xED v\xFD\u0161e.",
  INLINE_SCHEDULING_COMMENTS: "Ulo\u017Eit pl\xE1novac\xED koment\xE1\u0159 na stejn\xFD \u0159\xE1dek jako posledn\xED polo\u017Eka karti\u010Dky?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Zapnut\xED t\xE9to volby zp\u016Fsob\xED, \u017Ee HTML koment\xE1\u0159e nebudou rozb\xEDjet form\xE1tov\xE1n\xED list\u016F.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Odlo\u017Eit p\u0159\xEDbuzn\xE9 karti\u010Dky na dal\u0161\xED den?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "P\u0159\xEDbuzn\xE9 karti\u010Dky jsou karti\u010Dky generovan\xE9 z textu stejn\xE9 pozn\xE1mky nap\u0159\xEDklad cloze smaz\xE1n\xED",
  SHOW_CARD_CONTEXT: "Uk\xE1zat kontext v karti\u010Dce?",
  SHOW_CARD_CONTEXT_DESC: "nap\u0159\xEDklad Titulek > Nadpis1 > Podnadpis > ... > Podnadpis",
  CARD_MODAL_HEIGHT_PERCENT: "V\xFD\u0161ka karti\u010Dek v procentech",
  CARD_MODAL_SIZE_PERCENT_DESC: "M\u011Blo by b\xFDt nastaveno na 100% na mobilu nebo kdy\u017E pou\u017E\xEDv\xE1te velk\xE9 obr\xE1zky",
  RESET_DEFAULT: "Resetovat v\xFDchoz\xED nastaven\xED",
  CARD_MODAL_WIDTH_PERCENT: "\u0160\xED\u0159ka karti\u010Dek v procentech",
  FILENAME_OR_OPEN_FILE: "Zobrazit jm\xE9no souboru m\xEDsto 'Zm\u011Bnit pozd\u011Bji' v revizi karti\u010Dky?",
  RANDOMIZE_CARD_ORDER: "N\xE1hodn\u011B zm\u011Bnit po\u0159ad\xED karti\u010Dek b\u011Bhem revize?",
  DISABLE_CLOZE_CARDS: "Vypnout cloze karti\u010Dky?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "P\u0159ev\xE9st ==zv\xFDrazn\u011Bn\xED== na clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "P\u0159ev\xE9st **tu\u010Dn\xFD text** na clozes?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "P\u0159ev\xE9st {{slo\u017Een\xE9 z\xE1vorky}} na clozes?",
  INLINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro inline karti\u010Dky",
  FIX_SEPARATORS_MANUALLY_WARNING: "Pozor. Jakmile toto zm\u011Bn\xEDte, budete muset ru\u010Dn\u011B upravit v\u0161echny existuj\xEDc\xED karti\u010Dky.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro oto\u010Den\xE9 inline karti\u010Dky",
  MULTILINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkov\xE9 karti\u010Dky",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkove oto\u010Den\xE9 karti\u010Dky",
  NOTES: "Pozn\xE1mky",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tag pro revizi",
  TAGS_TO_REVIEW_DESC: "Zadejte tagy odd\u011Blen\xE9 mezerami nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Otev\u0159\xEDt n\xE1hodnou pozn\xE1mku pro revizi",
  OPEN_RANDOM_NOTE_DESC: "Pokud toto vypnete, pozn\xE1mky budou \u0159azeny dle d\u016Fle\u017Eitosti (PageRank).",
  AUTO_NEXT_NOTE: "Otev\u0159\xEDt automaticky dal\u0161\xED pozn\xE1mku po dokon\u010Den\xED revize",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Vypnout volby revize v menu souboru nap\u0159\xEDklad 'Revize: Jednoduch\xE9'",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Po vypnut\xED m\u016F\u017Eete pou\u017E\xEDvat kl\xE1vesov\xE9 zkratky. Restartujte Obsidian po zm\u011Bn\u011B nastaven\xED.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maxim\xE1ln\xED po\u010Det dn\xED zobrazen\xFDch v prav\xE9m panelu",
  MIN_ONE_DAY: "Po\u010Det dn\xED mus\xED b\xFDt minim\xE1ln\u011B 1.",
  VALID_NUMBER_WARNING: "Pros\xEDm zadejte validn\xED \u010D\xEDslo.",
  UI_PREFERENCES: "P\u0159edvolby u\u017Eivatelsk\xE9ho rozhran\xED",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Stromy bal\xED\u010Dky by m\u011Bly b\xFDt zpo\u010D\xE1tku zobrazeny jako rozbalen\xE9",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Vypn\u011Bte toto, chcete-li sbalit vno\u0159en\xE9 bal\xED\u010Dky na stejn\xE9 kart\u011B. To je u\u017Eite\u010Dn\xE9, pokud m\xE1te karti\u010Dky, kter\xE9 pat\u0159\xED k mnoha bal\xED\u010Dk\u016Fm ve stejn\xE9m souboru.",
  ALGORITHM: "Algoritmus",
  CHECK_ALGORITHM_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${algo_url}">popis algoritmu</a>.',
  BASE_EASE: "Z\xE1kladn\xED slo\u017Eitost",
  BASE_EASE_DESC: "minimum = 130, nejl\xE9pe p\u0159ibli\u017En\u011B 250.",
  BASE_EASE_MIN_WARNING: "Z\xE1kladn\xED slo\u017Eitost mus\xED b\xFDt minim\xE1ln\u011B 130.",
  LAPSE_INTERVAL_CHANGE: "Zm\u011Bna intervalu pokud karti\u010Dku/pozn\xE1mku ozna\u010D\xEDte jako slo\u017Eitou",
  LAPSE_INTERVAL_CHANGE_DESC: "nov\xFD_inteval = star\xFD_interval * zm\u011Bna_intevalu / 100.",
  EASY_BONUS: "Bonus pro jednoduch\xE9",
  EASY_BONUS_DESC: "Tento bonus umo\u017E\u0148uje nastavit rozd\xEDl intervalu mezi jednoduch\xFDmi a dobr\xFDmi karti\u010Dkami/pozn\xE1mkami (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Bonus pro jednoduchost mus\xED b\xFDt minim\xE1ln\u011B 100.",
  MAX_INTERVAL: "Maxim\xE1ln\xED interval",
  MAX_INTERVAL_DESC: "Umo\u017E\u0148uje nastavit horn\xED limit pro interval (defaultn\u011B = 100 let).",
  MAX_INTERVAL_MIN_WARNING: "Maxim\xE1ln\xED interval mus\xED b\xFDt alespo\u0148 1 den.",
  MAX_LINK_CONTRIB: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bv\u011Bk prolinkov\xE1n\xED",
  MAX_LINK_CONTRIB_DESC: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bvek v\xE1\u017Een\xE9 slo\u017Eitosti prolinkovan\xFDch pozn\xE1mek pou\u017Eit\xFD pro ur\u010Den\xED po\u010D\xE1te\u010Dn\xED slo\u017Eitosti.",
  LOGGING: "Zaznamen\xE1v\xE1m",
  DISPLAY_DEBUG_INFO: "Zobrazit informace pro lad\u011Bn\xED na v\xFDvoj\xE1\u0159sk\xE9 konzoli?",
  NOTES_REVIEW_QUEUE: "Fronta pozn\xE1mek k revizi",
  CLOSE: "Uzav\u0159en\xE9",
  NEW: "Nov\xE9",
  YESTERDAY: "V\u010Dera",
  TODAY: "Dnes",
  TOMORROW: "Z\xEDtra",
  STATS_TITLE: "Statistiky",
  MONTH: "M\u011Bs\xEDc",
  QUARTER: "\u010Ctvrtlet\xED",
  YEAR: "Rok",
  LIFETIME: "Celkov\u011B",
  FORECAST: "P\u0159edpov\u011B\u010F",
  FORECAST_DESC: "Celkov\xFD po\u010Det karti\u010Dek, kter\xFDm vypr\u0161\xED term\xEDn",
  SCHEDULED: "Napl\xE1nov\xE1no",
  DAYS: "Dn\xED",
  NUMBER_OF_CARDS: "Po\u010Det karti\u010Dek",
  REVIEWS_PER_DAY: "Pr\u016Fm\u011Br: ${avg} revize/den",
  INTERVALS: "Intervaly",
  INTERVALS_DESC: "Doba, za kterou bude znovu zobrazeno k revize",
  COUNT: "Po\u010Det",
  INTERVALS_SUMMARY: "Pr\u016Fm\u011Brn\xFD interval: ${avg}, Nejdel\u0161\xED interval: ${longest}",
  EASES: "Slo\u017Eitost",
  EASES_SUMMARY: "Pr\u016Fm\u011Brn\xE1 slo\u017Eitost: ${avgEase}",
  CARD_TYPES: "Typy karti\u010Dek",
  CARD_TYPES_DESC: "Obsahuje i odlo\u017Een\xE9 karti\u010Dky (pokud existuj\xED)",
  CARD_TYPE_NEW: "Nov\xE1",
  CARD_TYPE_YOUNG: "Mlad\xE1",
  CARD_TYPE_MATURE: "Dosp\u011Bl\xE1",
  CARD_TYPES_SUMMARY: "Karti\u010Dek celkem: ${totalCardsCount}"
};

// src/lang/locale/bn.ts
var bn_default = {};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {
  DECKS: "Stapel",
  DUE_CARDS: "Anstehende Karten",
  NEW_CARDS: "Neue Karten",
  TOTAL_CARDS: "Alle Karten",
  BACK: "Back",
  EDIT_LATER: "Sp\xE4ter bearbeiten",
  RESET_CARD_PROGRESS: "Kartenfortschritt zur\xFCcksetzten",
  HARD: "Schwer",
  GOOD: "Gut",
  EASY: "Einfach",
  SHOW_ANSWER: "Zeige Antwort",
  CARD_PROGRESS_RESET: "Kartenfortschritt wurde zur\xFCckgesetzt.",
  OPEN_NOTE_FOR_REVIEW: "Notiz zur Wiederholung \xF6ffnen",
  REVIEW_CARDS: "Lernkarten wiederholen",
  REVIEW_EASY_FILE_MENU: "Notiz abschliessen als: Einfach",
  REVIEW_GOOD_FILE_MENU: "Notiz abschliessen als: Gut",
  REVIEW_HARD_FILE_MENU: "Notiz abschliessen als: Schwer",
  REVIEW_NOTE_EASY_CMD: "Notiz abschliessen als: Einfach",
  REVIEW_NOTE_GOOD_CMD: "Notiz abschliessen als: Gut",
  REVIEW_NOTE_HARD_CMD: "Notiz abschliessen als: Schwer",
  REVIEW_CARDS_IN_NOTE: "Lernkarten in dieser Notiz wiederholen",
  CRAM_CARDS_IN_NOTE: "Lernkarten in dieser Notiz pauken.",
  REVIEW_ALL_CARDS: "Alle Lernkarten wiederholen",
  VIEW_STATS: "Statistiken anzeigen",
  STATUS_BAR: "Wiederholung: ${dueNotesCount} Notiz(en), ${dueFlashcardsCount} Karte(n) anstehend",
  SYNC_TIME_TAKEN: "Sync dauerte ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Notiz befindet sich in einem ausgeschlossenen Ordner (siehe Einstellungen).",
  PLEASE_TAG_NOTE: "Bitte die Notiz f\xFCr Wiederholungen entsprechend taggen (siehe Einstellungen).",
  RESPONSE_RECEIVED: "Antwort erhalten.",
  NO_DECK_EXISTS: "Kein Stapel f\xFCr ${deckName} gefunden.",
  ALL_CAUGHT_UP: "Yuhu! Alles geschafft! :D.",
  DAYS_STR_IVL: "${interval} Tag(e)",
  MONTHS_STR_IVL: "${interval} Monat(e)",
  YEARS_STR_IVL: "${interval} Jahr(e)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Einstellungen",
  CHECK_WIKI: 'Weitere Informationen gibt es im <a href="${wiki_url}">Wiki</a> (english).',
  FOLDERS_TO_IGNORE: "Ausgeschlossene Ordner",
  FOLDERS_TO_IGNORE_DESC: "Mehrere Ordner mit Zeilenumbr\xFCchen getrennt angeben. Bsp. OrdnerA[Zeilenumbruch]OrdnerB/Unterordner",
  FLASHCARDS: "Lernkarten",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Lernkarten Tags",
  FLASHCARD_TAGS_DESC: "Mehrere Tags mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angeben. Bsp. #karte #stapel2 #stapel3.",
  CONVERT_FOLDERS_TO_DECKS: "Ordner in Stapel und Substapel umwandeln?",
  CONVERT_FOLDERS_TO_DECKS_DESC: 'Eine Alternative zur oberen "Lernkarten Tags" Option.',
  INLINE_SCHEDULING_COMMENTS: "Den Fortschritt in der gleichen Zeile wie die letzte Zeile einer Lernkartei speichern?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Wenn aktiviert, wird der HTML Kommentar die umgebende Liste nicht aufbrechen.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Verwandte Karten auf den n\xE4chsten Tag verlegen?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Verwandte Karten sind aus der gleichen Karte generiert worden (z.B. L\xFCckentextkarten oder beidseitige Karten).",
  SHOW_CARD_CONTEXT: "Kontext in den Karten anzeigen?",
  SHOW_CARD_CONTEXT_DESC: "Bsp. Titel > \xDCberschrift 1 > Sektion > ... > Untersektion",
  CARD_MODAL_HEIGHT_PERCENT: "H\xF6he der Lernkartei in Prozent",
  CARD_MODAL_SIZE_PERCENT_DESC: "Auf kleinen Bildschirmen (z.B. Smartphones) oder bei sehr grossen Bildern sollte dieser Wert auf 100% gesetzt werden.",
  RESET_DEFAULT: "Standardeinstellung wiederherstellen",
  CARD_MODAL_WIDTH_PERCENT: "Breite einer Lernkarte in Prozent",
  FILENAME_OR_OPEN_FILE: "W\xE4hrend der Wiederholung den Notiznamen statt 'Sp\xE4ter bearbeiten' anzeigen?",
  RANDOMIZE_CARD_ORDER: "W\xE4hrend der Wiederhoung die Reihenfolge zuf\xE4llig mischen?",
  DISABLE_CLOZE_CARDS: "L\xFCckentextkarten (cloze deletions) deaktivieren?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==Hervorgehobenen== Text in L\xFCckentextkarten umwandeln?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**Fettgedruckten** Text in L\xFCckentextkarten umwandeln?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{Geschweifte Klammern}} Text in L\xFCckentextkarten umwandeln?",
  INLINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige Lernkarten",
  FIX_SEPARATORS_MANUALLY_WARNING: "Wenn diese Einstellung ge\xE4ndert wird, dann m\xFCssen die entsprechenden Lernkarten manuell angepasst werden.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige beidseitige Lernkarten",
  MULTILINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige Lernkarten",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige beidseitige Lernkarten",
  NOTES: "Notizen",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Zu wiederholende Tags",
  TAGS_TO_REVIEW_DESC: "Mehrere Tags k\xF6nnen mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angegeben werden. Bsp. #karte #tag1 #tag2.",
  OPEN_RANDOM_NOTE: "Zuf\xE4llige Karten wiederholen",
  OPEN_RANDOM_NOTE_DESC: "Wenn dies deaktiviert wird, dann werden die Notizen nach Wichtigkeit wiederholt (PageRank).",
  AUTO_NEXT_NOTE: "Nach einer Wiederholung automatisch die n\xE4chste Karte \xF6ffnen",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Optionen zur Wiederholung im Men\xFC einer Datei deaktivieren. Bsp. Wiederholen: Einfach Gut Schwer",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Nach dem Deaktivieren k\xF6nnen die Tastenk\xFCrzel zur Wiederholung verwendet werden. Obsidian muss nach einer \xC4nderung neu geladen weren.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximale Anzahl anstehender Notizen, die im rechten Fensterbereich angezeigt werden",
  MIN_ONE_DAY: "Anzahl der Tage muss mindestens 1 sein.",
  VALID_NUMBER_WARNING: "Bitte eine g\xFCltige Zahl eingeben.",
  UI_PREFERENCES: "Einstellungen der Benutzeroberfl\xE4che",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deckb\xE4ume sollten anf\xE4nglich erweitert angezeigt werden",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Deaktivieren Sie dies, um verschachtelte Decks in derselben Karte zu reduzieren. N\xFCtzlich, wenn Sie Karten haben, die zu vielen Decks in derselben Datei geh\xF6ren.",
  ALGORITHM: "Algorithmus",
  CHECK_ALGORITHM_WIKI: 'Weiterf\xFChrende Informationen: <a href="${algo_url}">Implementierung des Algorithmus</a> (english).',
  BASE_EASE: "Basis der Einfachheit",
  BASE_EASE_DESC: "Minimum ist 130. Empfohlen wird ca. 250.",
  BASE_EASE_MIN_WARNING: "Basis der Einfachheit muss mindestens 130 sein.",
  LAPSE_INTERVAL_CHANGE: "Anpassungsfaktor des Intervalls wenn eine Notiz / Karte 'Schwer' abgeschlossen wird",
  LAPSE_INTERVAL_CHANGE_DESC: "neuesIntervall = altesIntervall * anpassungsfaktor / 100.",
  EASY_BONUS: "Einfachheit-Bonus",
  EASY_BONUS_DESC: "Der Einfachheit-Bonus gibt an um welchen Faktor (in Prozent) das Intervall l\xE4nger sein soll, wenn eine Notiz / Karte 'Einfach' statt 'Gut' abgeschlossen wird. Minimum ist 100%.",
  EASY_BONUS_MIN_WARNING: "Der Einfachheit-Bonus muss mindestens 100 sein.",
  MAX_INTERVAL: "Maximales Intervall",
  MAX_INTERVAL_DESC: "Das maximale Intervall (in Tagen) f\xFCr Wiederholungen. Standard sind 100 Jahre.",
  MAX_INTERVAL_MIN_WARNING: "Das maximale Interall muss mindestens ein Tag sein.",
  MAX_LINK_CONTRIB: "Maximaler Einfluss von Links",
  MAX_LINK_CONTRIB_DESC: "Maximaler Einfluss der Einfachheiten verlinkter Notizen zur gewichteten initialen Einfachheit einer neuen Lernkarte.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Informationen zum Debugging in der Entwicklerkonsole anzeigen?",
  NOTES_REVIEW_QUEUE: "Anstehende Notizen zur Wiederholung",
  CLOSE: "Schliessen",
  NEW: "Neu",
  YESTERDAY: "Gestern",
  TODAY: "Heute",
  TOMORROW: "Morgen",
  STATS_TITLE: "Statistiken",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Prognose",
  FORECAST_DESC: "Anzahl der k\xFCnftig anstehenden Karten",
  SCHEDULED: "Anstehend",
  DAYS: "Tage",
  NUMBER_OF_CARDS: "Anzahl der Karten",
  REVIEWS_PER_DAY: "Durchschnitt: ${avg} Wiederholungen/Tag",
  INTERVALS: "Intervalle",
  INTERVALS_DESC: "Intervalle bis Wiederholungen anstehen",
  COUNT: "Anzahl",
  INTERVALS_SUMMARY: "Durchschnittliches Intervall: ${avg}, L\xE4ngstes Intervall: ${longest}",
  EASES: "Einfachheit",
  EASES_SUMMARY: "Durchschnittliche Einfachheit: ${avgEase}",
  CARD_TYPES: "Kategorisierung",
  CARD_TYPES_DESC: "Verlegte Karten eingeschlossen",
  CARD_TYPE_NEW: "Neu",
  CARD_TYPE_YOUNG: "Jung",
  CARD_TYPE_MATURE: "Ausgereift",
  CARD_TYPES_SUMMARY: "Insgesamt ${totalCardsCount} Karten"
};

// src/lang/locale/en.ts
var en_default = {
  DECKS: "Decks",
  DUE_CARDS: "Due Cards",
  NEW_CARDS: "New Cards",
  TOTAL_CARDS: "Total Cards",
  BACK: "Back",
  EDIT_LATER: "Edit Later",
  RESET_CARD_PROGRESS: "Reset card's progress",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "Show Answer",
  CARD_PROGRESS_RESET: "Card's progress has been reset.",
  OPEN_NOTE_FOR_REVIEW: "Open a note for review",
  REVIEW_CARDS: "Review flashcards",
  REVIEW_EASY_FILE_MENU: "Review: Easy",
  REVIEW_GOOD_FILE_MENU: "Review: Good",
  REVIEW_HARD_FILE_MENU: "Review: Hard",
  REVIEW_NOTE_EASY_CMD: "Review note as easy",
  REVIEW_NOTE_GOOD_CMD: "Review note as good",
  REVIEW_NOTE_HARD_CMD: "Review note as hard",
  REVIEW_CARDS_IN_NOTE: "Review flashcards in this note",
  CRAM_CARDS_IN_NOTE: "Cram flashcards in this note.",
  REVIEW_ALL_CARDS: "Review flashcards from all notes",
  VIEW_STATS: "View statistics",
  STATUS_BAR: "Review: ${dueNotesCount} note(s), ${dueFlashcardsCount} card(s) due",
  SYNC_TIME_TAKEN: "Sync took ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Note is saved under ignored folder (check settings).",
  PLEASE_TAG_NOTE: "Please tag the note appropriately for reviewing (in settings).",
  RESPONSE_RECEIVED: "Response received.",
  NO_DECK_EXISTS: "No deck exists for ${deckName}",
  ALL_CAUGHT_UP: "You're all caught up now :D.",
  DAYS_STR_IVL: "${interval} day(s)",
  MONTHS_STR_IVL: "${interval} month(s)",
  YEARS_STR_IVL: "${interval} year(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - Settings",
  CHECK_WIKI: 'For more information, check the <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Folders to ignore",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths separated by newlines i.e. Templates Meta/Scripts",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "Flashcard tags",
  FLASHCARD_TAGS_DESC: "Enter tags separated by spaces or newlines i.e. #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Convert folders to decks and subdecks?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "This is an alternative to the Flashcard tags option above.",
  INLINE_SCHEDULING_COMMENTS: "Save scheduling comment on the same line as the flashcard's last line?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Turning this on will make the HTML comments not break list formatting.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Bury sibling cards until the next day?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Siblings are cards generated from the same card text i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "Show context in cards?",
  SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "Flashcard Height Percentage",
  CARD_MODAL_SIZE_PERCENT_DESC: "Should be set to 100% on mobile or if you have very large images",
  RESET_DEFAULT: "Reset to default",
  CARD_MODAL_WIDTH_PERCENT: "Flashcard Width Percentage",
  FILENAME_OR_OPEN_FILE: "Show file name instead of 'Edit Later' in flashcard review?",
  RANDOMIZE_CARD_ORDER: "Randomize card order during review?",
  DISABLE_CLOZE_CARDS: "Disable cloze cards?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==hightlights== to clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes?",
  INLINE_CARDS_SEPARATOR: "Separator for inline flashcards",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note that after changing this you have to manually edit any flashcards you already have.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separator for inline reversed flashcards",
  MULTILINE_CARDS_SEPARATOR: "Separator for multiline flashcards",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator for multiline reversed flashcards",
  NOTES: "Notes",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tags to review",
  TAGS_TO_REVIEW_DESC: "Enter tags separated by spaces or newlines i.e. #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Open a random note for review",
  OPEN_RANDOM_NOTE_DESC: "When you turn this off, notes are ordered by importance (PageRank).",
  AUTO_NEXT_NOTE: "Open next note automatically after a review",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Disable review options in the file menu i.e. Review: Easy Good Hard",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "After disabling, you can review using the command hotkeys. Reload Obsidian after changing this.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximum number of days to display on right panel",
  MIN_ONE_DAY: "The number of days must be at least 1.",
  VALID_NUMBER_WARNING: "Please provide a valid number.",
  UI_PREFERENCES: "UI Preferences",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deck trees should be initially displayed as expanded",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Turn this off to collapse nested decks in the same card. Useful if you have cards which belong to many decks in the same file.",
  ALGORITHM: "Algorithm",
  CHECK_ALGORITHM_WIKI: 'For more information, check the <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "Base ease",
  BASE_EASE_DESC: "minimum = 130, preferrably approximately 250.",
  BASE_EASE_MIN_WARNING: "The base ease must be at least 130.",
  LAPSE_INTERVAL_CHANGE: "Interval change when you review a flashcard/note as hard",
  LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
  EASY_BONUS: "Easy Bonus",
  EASY_BONUS_DESC: "The easy bonus allows you to set the difference in intervals between answering Good and Easy on a flashcard/note (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "The easy bonus must be at least 100.",
  MAX_INTERVAL: "Maximum Interval",
  MAX_INTERVAL_DESC: "Allows you to place an upper limit on the interval (default = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "The maximum interval must be at least 1 day.",
  MAX_LINK_CONTRIB: "Maximum link contribution",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Display debugging information on the developer console?",
  NOTES_REVIEW_QUEUE: "Notes Review Queue",
  CLOSE: "Close",
  NEW: "New",
  YESTERDAY: "Yesterday",
  TODAY: "Today",
  TOMORROW: "Tomorrow",
  STATS_TITLE: "Statistics",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Forecast",
  FORECAST_DESC: "The number of cards due in the future",
  SCHEDULED: "Scheduled",
  DAYS: "Days",
  NUMBER_OF_CARDS: "Number of cards",
  REVIEWS_PER_DAY: "Average: ${avg} reviews/day",
  INTERVALS: "Intervals",
  INTERVALS_DESC: "Delays until reviews are shown again",
  COUNT: "Count",
  INTERVALS_SUMMARY: "Average interval: ${avg}, Longest interval: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  CARD_TYPES: "Card Types",
  CARD_TYPES_DESC: "This includes buried cards as well, if any",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "Total cards: ${totalCardsCount}"
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {
  DECKS: "\u30C7\u30C3\u30AD",
  DUE_CARDS: "\u671F\u65E5\u306E\u30AB\u30FC\u30C9",
  NEW_CARDS: "\u65B0\u898F\u306E\u30AB\u30FC\u30C9",
  TOTAL_CARDS: "\u30AB\u30FC\u30C9\u5408\u8A08",
  BACK: "Back",
  EDIT_LATER: "\u5F8C\u3067\u7DE8\u96C6",
  RESET_CARD_PROGRESS: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u3092\u30EA\u30BB\u30C3\u30C8",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "\u89E3\u7B54\u3092\u8868\u793A",
  CARD_PROGRESS_RESET: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u304C\u30EA\u30BB\u30C3\u30C8\u3055\u308C\u307E\u3057\u305F\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u30CE\u30FC\u30C8\u3092\u958B\u304F",
  REVIEW_CARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u30EC\u30D3\u30E5\u30FC",
  REVIEW_EASY_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Easy",
  REVIEW_GOOD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Good",
  REVIEW_HARD_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: Hard",
  REVIEW_NOTE_EASY_CMD: "\u30CE\u30FC\u30C8\u3092Easy\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_GOOD_CMD: "\u30CE\u30FC\u30C8\u3092Good\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_NOTE_HARD_CMD: "\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  CRAM_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u8A70\u3081\u8FBC\u307F\u5B66\u7FD2\u3059\u308B",
  REVIEW_ALL_CARDS: "\u3059\u3079\u3066\u306E\u30CE\u30FC\u30C8\u304B\u3089\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  VIEW_STATS: "\u7D71\u8A08\u3092\u95B2\u89A7\u3059\u308B",
  STATUS_BAR: "\u30EC\u30D3\u30E5\u30FC: ${dueNotesCount}\u30CE\u30FC\u30C8, ${dueFlashcardsCount}\u30AB\u30FC\u30C9\u304C\u671F\u65E5",
  SYNC_TIME_TAKEN: "\u540C\u671F\u306B${t}ms\u304B\u304B\u308A\u307E\u3057\u305F\u3002",
  NOTE_IN_IGNORED_FOLDER: "\u30CE\u30FC\u30C8\u304C\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306B\u4FDD\u5B58\u3055\u308C\u3066\u3044\u307E\u3059(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  PLEASE_TAG_NOTE: "\u30EC\u30D3\u30E5\u30FC\u3092\u884C\u3046\u306B\u306F\u30CE\u30FC\u30C8\u306B\u5BFE\u3057\u3066\u6B63\u3057\u304F\u30BF\u30B0\u4ED8\u3051\u3057\u3066\u304F\u3060\u3055\u3044(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  RESPONSE_RECEIVED: "\u7B54\u3048\u3092\u53D7\u3051\u53D6\u308A\u307E\u3057\u305F\u3002",
  NO_DECK_EXISTS: "${deckName}\u306B\u306F\u30C7\u30C3\u30AD\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002",
  ALL_CAUGHT_UP: "\u4ECA\u65E5\u306E\u8AB2\u984C\u3092\u3059\u3079\u3066\u9054\u6210\u3057\u307E\u3057\u305F :D",
  DAYS_STR_IVL: "${interval}\u65E5\u5F8C",
  MONTHS_STR_IVL: "${interval}\u6708\u5F8C",
  YEARS_STR_IVL: "${interval}\u5E74\u5F8C",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - \u8A2D\u5B9A",
  CHECK_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${wiki_url}">wiki</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  FOLDERS_TO_IGNORE: "\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0",
  FOLDERS_TO_IGNORE_DESC: '\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9\u3092\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002"Templates Meta/Scripts" \u306E\u3088\u3046\u306A\u30B9\u30DA\u30FC\u30B9\u306B\u3088\u308B\u533A\u5207\u308A\u3067\u306E\u66F8\u304D\u65B9\u306F\u7121\u52B9\u3067\u3059\u3002',
  FLASHCARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  FLASHCARD_TAGS_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#flashcards #deck2 #deck3"',
  CONVERT_FOLDERS_TO_DECKS: "\u30D5\u30A9\u30EB\u30C0\u3092\u30C7\u30C3\u30AD\u3068\u30B5\u30D6\u30C7\u30C3\u30AD\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u3053\u308C\u306F\u4E0A\u8A18\u306E\u30BF\u30B0\u3092\u4F7F\u7528\u3057\u305F\u30C7\u30C3\u30AD\u69CB\u7BC9\u306E\u4EE3\u66FF\u3068\u306A\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3059\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6700\u7D42\u884C\u3068\u540C\u4E00\u306E\u884C\u306B\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001HTML\u30B3\u30E1\u30F3\u30C8\u306B\u3088\u3063\u3066Markdown\u306E\u30EA\u30B9\u30C8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u304C\u5D29\u308C\u306A\u304F\u306A\u308A\u307E\u3059\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u307E\u3067\u30B7\u30D6\u30EA\u30F3\u30B0\u3092\u5EF6\u671F\u3057\u307E\u3059\u304B\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u30B7\u30D6\u30EA\u30F3\u30B0\u306F\u540C\u4E00\u306E\u30AB\u30FC\u30C9\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u751F\u6210\u3055\u308C\u305F\u30AB\u30FC\u30C9\u3001\u3064\u307E\u308A\u7A74\u57CB\u3081\u554F\u984C\u306E\u6D3E\u751F\u30AB\u30FC\u30C9\u3067\u3059\u3002",
  SHOW_CARD_CONTEXT: "\u30AB\u30FC\u30C9\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\uFF62\u30BF\u30A4\u30C8\u30EB > \u898B\u51FA\u3057 1 > \u526F\u898B\u51FA\u3057 > ... > \u526F\u898B\u51FA\u3057\uFF63\u306E\u8868\u793A\u3092\u884C\u3046\u304B\u3069\u3046\u304B\u3092\u6C7A\u3081\u307E\u3059\u3002",
  CARD_MODAL_HEIGHT_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7E26\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u30E2\u30D0\u30A4\u30EB\u7248\u3001\u307E\u305F\u306F\u975E\u5E38\u306B\u5927\u304D\u306A\u30B5\u30A4\u30BA\u306E\u753B\u50CF\u304C\u3042\u308B\u5834\u5408\u306B\u306F100%\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002",
  RESET_DEFAULT: "\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306B\u30EA\u30BB\u30C3\u30C8\u3059\u308B",
  CARD_MODAL_WIDTH_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6A2A\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  FILENAME_OR_OPEN_FILE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u30EC\u30D3\u30E5\u30FC\u3067\uFF62\u5F8C\u3067\u7DE8\u96C6\uFF63\u306E\u4EE3\u308F\u308A\u306B\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u30EC\u30D3\u30E5\u30FC\u4E2D\u306E\u30AB\u30FC\u30C9\u306E\u9806\u756A\u3092\u30E9\u30F3\u30C0\u30E0\u306B\u3057\u307E\u3059\u304B\uFF1F",
  DISABLE_CLOZE_CARDS: "\u7A74\u57CB\u3081\u30AB\u30FC\u30C9\u3092\u7121\u52B9\u5316\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==\u30CF\u30A4\u30E9\u30A4\u30C8==\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**\u30DC\u30FC\u30EB\u30C9\u4F53**\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{\u4E2D\u62EC\u5F27}}\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3059\u308B\u5834\u5408\u306B\u306F\u3001\u4F5C\u6210\u6E08\u307F\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u624B\u52D5\u3067\u7DE8\u96C6\u3057\u76F4\u3059\u5FC5\u8981\u304C\u3042\u308B\u3053\u3068\u306B\u6CE8\u610F\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  NOTES: "\u30CE\u30FC\u30C8",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  TAGS_TO_REVIEW_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#review #tag2 #tag3"',
  OPEN_RANDOM_NOTE: "\u30E9\u30F3\u30C0\u30E0\u306B\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  OPEN_RANDOM_NOTE_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u7121\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u72B6\u614B\u3067\u306F\u3001\u30CE\u30FC\u30C8\u306F\u91CD\u8981\u5EA6(\u30DA\u30FC\u30B8\u30E9\u30F3\u30AF)\u306B\u3088\u308B\u9806\u756A\u3067\u8868\u793A\u3055\u308C\u307E\u3059\u3002",
  AUTO_NEXT_NOTE: "\u30EC\u30D3\u30E5\u30FC\u5F8C\u306B\u6B21\u306E\u30CE\u30FC\u30C8\u3092\u81EA\u52D5\u7684\u306B\u958B\u304F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u306E\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u7121\u52B9\u5316(\uFF62\u30EC\u30D3\u30E5\u30FC: Easy\uFF63\u7B49\u306E\u9805\u76EE\u3092\u975E\u8868\u793A\u306B\u3059\u308B)",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u7121\u52B9\u5316\u3057\u305F\u5F8C\u3001\u30B3\u30DE\u30F3\u30C9\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u4F7F\u3063\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u3053\u3068\u304C\u53EF\u80FD\u306B\u306A\u308A\u307E\u3059\u3002\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3057\u305F\u5834\u5408\u306B\u306FObsidian\u3092\u30EA\u30ED\u30FC\u30C9\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u30D1\u30CD\u30EB\u306B\u8868\u793A\u3059\u308B\u6700\u5927\u306E\u65E5\u6570",
  MIN_ONE_DAY: "\u65E5\u6570\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  VALID_NUMBER_WARNING: "\u6709\u52B9\u306A\u6570\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  UI_PREFERENCES: "\u30E6\u30FC\u30B6\u30FC \u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30A4\u30B9\u306E\u8A2D\u5B9A",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u30C7\u30C3\u30AD \u30C4\u30EA\u30FC\u306F\u6700\u521D\u306F\u5C55\u958B\u3057\u3066\u8868\u793A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u3053\u308C\u3092\u30AA\u30D5\u306B\u3059\u308B\u3068\u3001\u540C\u3058\u30AB\u30FC\u30C9\u5185\u306E\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30C7\u30C3\u30AD\u304C\u6298\u308A\u305F\u305F\u307E\u308C\u307E\u3059\u3002\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u591A\u304F\u306E\u30C7\u30C3\u30AD\u306B\u5C5E\u3059\u308B\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u4FBF\u5229\u3067\u3059\u3002",
  ALGORITHM: "\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0",
  CHECK_ALGORITHM_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${algo_url}">\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u5B9F\u88C5</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  BASE_EASE: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055",
  BASE_EASE_DESC: "\u6700\u5C0F\u5024\u306F130\u3067\u3059\u304C\u3001 \u9069\u6B63\u5024\u306F\u304A\u304A\u3088\u305D250\u3067\u3059\u3002",
  BASE_EASE_MIN_WARNING: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055\u306B\u306F130\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LAPSE_INTERVAL_CHANGE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3057\u305F\u969B\u306E\u9593\u9694\u5909\u66F4",
  LAPSE_INTERVAL_CHANGE_DESC: '"\u65B0\u3057\u3044\u9593\u9694 = \u4EE5\u524D\u306E\u9593\u9694 * \u9593\u9694\u5909\u66F4 / 100" \u3068\u3057\u3066\u8A08\u7B97\u3055\u308C\u307E\u3059\u3002',
  EASY_BONUS: "Easy\u30DC\u30FC\u30CA\u30B9",
  EASY_BONUS_DESC: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u3088\u3063\u3066\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u306B\u304A\u3051\u308B\u9593\u9694\u306E\u5DEE\u5206\u3092\u8A2D\u5B9A\u3067\u304D\u307E\u3059(\u6700\u5C0F\u5024 = 100%)\u3002",
  EASY_BONUS_MIN_WARNING: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u306F100\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_INTERVAL: "\u9593\u9694\u306E\u6700\u5927\u5024",
  MAX_INTERVAL_DESC: "\u9593\u9694\u306B\u4E0A\u9650\u5024\u3092\u8A2D\u5B9A\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8\u5024 = 100\u5E74)\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u9593\u9694\u306E\u6700\u5927\u5024\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_LINK_CONTRIB: "\u30EA\u30F3\u30AF\u30B3\u30F3\u30C8\u30EA\u30D3\u30E5\u30FC\u30B7\u30E7\u30F3\u306E\u6700\u5927\u5024",
  MAX_LINK_CONTRIB_DESC: "\u6700\u521D\u306E\u6613\u3057\u3055\u306B\u5BFE\u3057\u3066\u3001\u30EA\u30F3\u30AF\u3055\u308C\u305F\u30CE\u30FC\u30C8\u306E\u91CD\u307F\u4ED8\u3051\u3055\u308C\u305F\u6613\u3057\u3055\u304C\u5BC4\u4E0E\u3059\u308B\u6700\u5927\u5024\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LOGGING: "\u30ED\u30B0\u7BA1\u7406",
  DISPLAY_DEBUG_INFO: "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u3066\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  NOTES_REVIEW_QUEUE: "\u30CE\u30FC\u30C8\u30EC\u30D3\u30E5\u30FC\u306E\u30AD\u30E5\u30FC",
  CLOSE: "\u9589\u3058\u308B",
  NEW: "\u65B0\u898F",
  YESTERDAY: "\u6628\u65E5",
  TODAY: "\u4ECA\u65E5",
  TOMORROW: "\u660E\u65E5",
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "\u4E88\u6E2C",
  FORECAST_DESC: "\u5FA9\u7FD2\u671F\u65E5\u304C\u6765\u308B\u30AB\u30FC\u30C9\u306E\u679A\u6570",
  SCHEDULED: "\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u6E08\u307F",
  DAYS: "\u65E5",
  NUMBER_OF_CARDS: "\u30AB\u30FC\u30C9\u6570",
  REVIEWS_PER_DAY: "\u5E73\u5747: ${avg}\u30EC\u30D3\u30E5\u30FC/\u65E5",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u4E88\u5B9A\u65E5",
  COUNT: "\u30AB\u30A6\u30F3\u30C8",
  INTERVALS_SUMMARY: "\u9593\u9694\u306E\u5E73\u5747\u5024: ${avg}, \u6700\u9577\u306E\u9593\u9694: ${longest}",
  EASES: "\u6613\u3057\u3055",
  EASES_SUMMARY: "\u6613\u3057\u3055\u306E\u5E73\u5747\u5024: ${avgEase}",
  CARD_TYPES: "\u30AB\u30FC\u30C9\u30BF\u30A4\u30D7",
  CARD_TYPES_DESC: "\u5EF6\u671F\u306E\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u306F\u3053\u308C\u306B\u542B\u307E\u308C\u307E\u3059",
  CARD_TYPE_NEW: "\u65B0\u898F",
  CARD_TYPE_YOUNG: "\u5FA9\u7FD2(\u521D\u671F)",
  CARD_TYPE_MATURE: "\u5FA9\u7FD2(\u5F8C\u671F)",
  CARD_TYPES_SUMMARY: "\u30AB\u30FC\u30C9\u306E\u5408\u8A08: ${totalCardsCount}\u679A"
};

// src/lang/locale/ko.ts
var ko_default = {
  DECKS: "\uB371",
  DUE_CARDS: "\uB2E4\uC2DC \uBCFC \uCE74\uB4DC\uB4E4",
  NEW_CARDS: "\uC0C8\uB85C\uC6B4 \uCE74\uB4DC\uB4E4",
  TOTAL_CARDS: "\uC804\uCCB4 \uCE74\uB4DC\uB4E4",
  BACK: "Back",
  EDIT_LATER: "\uB098\uC911\uC5D0 \uD3B8\uC9D1\uD558\uAE30",
  RESET_CARD_PROGRESS: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC744 \uCD08\uAE30\uD654\uD569\uB2C8\uB2E4.",
  HARD: "\uC5B4\uB824\uC6C0(Hard)",
  GOOD: "\uC88B\uC74C(Good)",
  EASY: "\uC26C\uC6C0(Easy)",
  SHOW_ANSWER: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30",
  CARD_PROGRESS_RESET: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC774 \uCD08\uAE30\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
  OPEN_NOTE_FOR_REVIEW: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uC5F4\uAE30",
  REVIEW_CARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0",
  REVIEW_EASY_FILE_MENU: "\uB9AC\uBDF0: \uC26C\uC6C0(Easy)",
  REVIEW_GOOD_FILE_MENU: "\uB9AC\uBDF0: \uC88B\uC74C(Good)",
  REVIEW_HARD_FILE_MENU: "\uB9AC\uBDF0: \uC5B4\uB824\uC6C0(Hard)",
  REVIEW_NOTE_EASY_CMD: "\uB178\uD2B8\uB97C \uC26C\uC6C0(easy)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_NOTE_GOOD_CMD: "\uB178\uD2B8\uB97C \uC88B\uC74C(good)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_NOTE_HARD_CMD: "\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(hard)\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  CRAM_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uBCBC\uB77D\uCE58\uAE30\uD569\uB2C8\uB2E4.",
  REVIEW_ALL_CARDS: "\uBAA8\uB4E0 \uB178\uD2B8\uB4E4\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  VIEW_STATS: "\uD1B5\uACC4 \uD655\uC778",
  STATUS_BAR: "--\uB9AC\uBDF0: ${dueNotesCount} \uB178\uD2B8, ${dueFlashcardsCount} \uCE74\uB4DC \uB0A8\uC558\uC2B5\uB2C8\uB2E4.",
  SYNC_TIME_TAKEN: "\uB3D9\uAE30\uD654\uC5D0 ${t}\uBC00\uB9AC\uCD08 \uAC78\uB838\uC2B5\uB2C8\uB2E4",
  NOTE_IN_IGNORED_FOLDER: "\uB178\uD2B8\uAC00 \uBB34\uC2DC\uB41C \uD3F4\uB354 \uC544\uB798\uC5D0 \uC800\uC7A5\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  PLEASE_TAG_NOTE: "\uB9AC\uBDF0\uB97C \uD558\uAE30\uC704\uD574 \uB178\uD2B8\uC5D0 \uC801\uC808\uD788 \uD0DC\uADF8\uD574\uC8FC\uC138\uC694. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  RESPONSE_RECEIVED: "\uC694\uCCAD\uC774 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  NO_DECK_EXISTS: "${deckName}\uC774\uB77C\uB294 \uC774\uB984\uC758 \uB371\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  ALL_CAUGHT_UP: "\uBAA8\uB450 \uD655\uC778\uD588\uC2B5\uB2C8\uB2E4. :D",
  DAYS_STR_IVL: "${interval} \uC77C \uD6C4",
  MONTHS_STR_IVL: "${interval} \uAC1C\uC6D4 \uD6C4",
  YEARS_STR_IVL: "${interval} \uB144 \uD6C4",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  SETTINGS_HEADER: "Spaced Repetition Plugin - \uC124\uC815",
  CHECK_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${wiki_url}">wiki</a>\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  FOLDERS_TO_IGNORE: "\uBB34\uC2DC\uD560 \uD3F4\uB354\uB4E4",
  FOLDERS_TO_IGNORE_DESC: "\uD3F4\uB354 \uACBD\uB85C\uB97C \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. 'Templates Meta/Scripts' \uC640 \uAC19\uC774 \uC785\uB825\uD558\uB294 \uAC83\uC740 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  FLASHCARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8",
  FLASHCARD_TAGS_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#flashcards #deck2 #deck3'",
  CONVERT_FOLDERS_TO_DECKS: "\uD3F4\uB354\uB97C \uB371\uACFC \uC11C\uBE0C\uB371\uC73C\uB85C \uC0AC\uC6A9\uD560\uAE4C\uC694?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\uC774 \uAE30\uB2A5\uC740 \uC704\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8 \uC635\uC158\uC744 \uB300\uCCB4\uD569\uB2C8\uB2E4.",
  INLINE_SCHEDULING_COMMENTS: "\uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB9C8\uC9C0\uB9C9 \uC904\uACFC \uB3D9\uC77C\uD55C \uC904\uC5D0 \uC2A4\uCF00\uC904\uB9C1 \uCF54\uBA58\uD2B8\uB97C \uC800\uC7A5\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\uC774 \uC635\uC158\uC744 \uC0AC\uC6A9\uD558\uBA74 HTML \uC8FC\uC11D\uC774 \uBAA9\uB85D\uC758 \uD3EC\uB9E4\uD305\uC744 \uBB34\uB108\uD2B8\uB9AC\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Sibling \uCE74\uB4DC\uB97C \uB2E4\uC74C\uB0A0\uAE4C\uC9C0 \uBB3B\uC5B4\uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Sibling \uCE74\uB4DC\uB294 \uB3D9\uC77C\uD55C \uCE74\uB4DC \uD14D\uC2A4\uD2B8\uC5D0\uC11C \uC0DD\uC131\uB41C \uCE74\uB4DC\uC785\uB2C8\uB2E4. i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "\uCE74\uB4DC\uC758 \uBB38\uB9E5(context)\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  SHOW_CARD_CONTEXT_DESC: "\uCE74\uB4DC\uC5D0\uC11C 'Title > Heading 1 > Subheading > ... > Subheading' \uC758 \uD45C\uC2DC\uB97C \uD560\uC9C0 \uC124\uC815\uD569\uB2C8\uB2E4.",
  CARD_MODAL_HEIGHT_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB192\uC774 \uBE44\uC728",
  CARD_MODAL_SIZE_PERCENT_DESC: "\uBAA8\uBC14\uC77C \uBC84\uC804 \uD639\uC740 \uB9E4\uC6B0 \uD070 \uC774\uBBF8\uC9C0\uAC00 \uC788\uB294 \uACBD\uC6B0 100%\uB85C \uC124\uC815\uD574\uC57C \uD569\uB2C8\uB2E4.",
  RESET_DEFAULT: "\uAE30\uBCF8\uAC12\uC73C\uB85C \uCD08\uAE30\uD654",
  CARD_MODAL_WIDTH_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB108\uBE44 \uBE44\uC728",
  FILENAME_OR_OPEN_FILE: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0\uC5D0\uC11C 'Edit Later' \uB300\uC2E0\uC5D0 \uD30C\uC77C \uC774\uB984\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  RANDOMIZE_CARD_ORDER: "\uB9AC\uBDF0\uC911\uC778 \uCE74\uB4DC\uC758 \uC21C\uC11C\uB97C \uB79C\uB364\uC73C\uB85C \uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  DISABLE_CLOZE_CARDS: "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uCE74\uB4DC\uB97C \uBE44\uD65C\uC131\uD654\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==hightlights== \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**bolded text** \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{curly brackets}} \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  INLINE_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  FIX_SEPARATORS_MANUALLY_WARNING: "\uC8FC\uC758: \uC774 \uC635\uC158\uC744 \uC218\uC815\uD55C \uD6C4\uC5D0\uB294 \uC774\uBBF8 \uC791\uC131\uB41C \uD50C\uB798\uC2DC\uCE74\uB4DC\uB97C \uC218\uB3D9\uC73C\uB85C \uC218\uC815\uD574\uC57C \uD568\uC744 \uC8FC\uC758\uD558\uC2ED\uC2DC\uC624.",
  INLINE_REVERSED_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  NOTES: "\uB178\uD2B8",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\uB9AC\uBDF0\uC5D0 \uC0AC\uC6A9\uD560 \uD0DC\uADF8",
  TAGS_TO_REVIEW_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#review #tag2 #tag3'",
  OPEN_RANDOM_NOTE: "\uB9AC\uBDF0\uB97C \uC704\uD574 \uB79C\uB364 \uB178\uD2B8\uB97C \uC5FD\uB2C8\uB2E4.",
  OPEN_RANDOM_NOTE_DESC: "\uC774 \uC635\uC158\uC774 \uAEBC\uC838\uC788\uC73C\uBA74, \uB178\uD2B8\uB294 \uC911\uC694\uB3C4(\uD398\uC774\uC9C0 \uB7AD\uD06C)\uC5D0 \uB530\uB77C \uC815\uB82C\uB429\uB2C8\uB2E4.",
  AUTO_NEXT_NOTE: "\uB9AC\uBDF0 \uD6C4\uC5D0 \uB2E4\uC74C \uB178\uD2B8\uB97C \uC790\uB3D9\uC73C\uB85C \uC5FD\uB2C8\uB2E4.",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C\uC758 \uB9AC\uBDF0 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654 \uD569\uB2C8\uB2E4. \uC608) \uB9AC\uBDF0: Easy Good Hard",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\uC774 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654 \uD55C \uD6C4, \uBA85\uB839 \uB2E8\uCD95\uD0A4\uB97C \uC774\uC6A9\uD574 \uB9AC\uBDF0\uD558\uC2E4 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uC774 \uC635\uC158\uC744 \uBCC0\uACBD\uD55C \uD6C4\uC5D0 \uC635\uC2DC\uB514\uC5B8\uC744 \uC0C8\uB85C\uACE0\uCE68 \uD558\uC2ED\uC2DC\uC624.",
  MAX_N_DAYS_REVIEW_QUEUE: "\uC624\uB978\uCABD \uD328\uB110\uC5D0 \uD45C\uC2DC\uD560 \uCD5C\uB300 \uC77C\uC218",
  MIN_ONE_DAY: "\uC801\uC5B4\uB3C4 1\uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  VALID_NUMBER_WARNING: "\uC720\uD6A8\uD55C \uC22B\uC790\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
  UI_PREFERENCES: "\uC0AC\uC6A9\uC790 \uC778\uD130\uD398\uC774\uC2A4 \uAE30\uBCF8 \uC124\uC815",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\uB371 \uD2B8\uB9AC\uB294 \uCC98\uC74C\uC5D0 \uD655\uC7A5\uB41C \uAC83\uC73C\uB85C \uD45C\uC2DC\uB418\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\uAC19\uC740 \uCE74\uB4DC\uC5D0 \uC911\uCCA9\uB41C \uB371\uC744 \uC811\uC73C\uB824\uBA74 \uC774 \uC635\uC158\uC744 \uB044\uC2ED\uC2DC\uC624. \uAC19\uC740 \uD30C\uC77C\uC5D0 \uC5EC\uB7EC \uB371\uC5D0 \uC18D\uD55C \uCE74\uB4DC\uAC00 \uC788\uB294 \uACBD\uC6B0 \uC720\uC6A9\uD569\uB2C8\uB2E4.",
  ALGORITHM: "\uC54C\uACE0\uB9AC\uC998",
  CHECK_ALGORITHM_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${algo_url}">algorithm implementation</a>\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  BASE_EASE: "\uAE30\uBCF8 ease",
  BASE_EASE_DESC: "\uCD5C\uC19F\uAC12 = 130, \uC801\uC815\uCE58\uB294 \uB300\uB7B5 250\uC785\uB2C8\uB2E4.",
  BASE_EASE_MIN_WARNING: "\uAE30\uBCF8 ease\uB294 \uC801\uC5B4\uB3C4 130 \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  LAPSE_INTERVAL_CHANGE: "\uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(Hard)\uC73C\uB85C \uB9AC\uBDF0\uD588\uC744 \uB54C\uC758 \uAC04\uACA9 \uBCC0\uACBD",
  LAPSE_INTERVAL_CHANGE_DESC: "\uC0C8\uB85C\uC6B4 \uAC04\uACA9 = \uC774\uC804 \uAC04\uACA9 * \uAC04\uACA9\uBCC0\uACBD \uAC12 / 100.",
  EASY_BONUS: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4",
  EASY_BONUS_DESC: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uC5D0\uC11C \uC88B\uC74C(Good)\uACFC \uC26C\uC6C0(Easy) \uC0AC\uC774\uC758 \uAC04\uACA9 \uCC28\uC774\uB97C \uC124\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uCD5C\uC18C = 100%)",
  EASY_BONUS_MIN_WARNING: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uC801\uC5B4\uB3C4 100\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  MAX_INTERVAL: "\uCD5C\uB300 \uAC04\uACA9",
  MAX_INTERVAL_DESC: "\uAC04\uACA9\uC758 \uC0C1\uD55C\uC120\uC744 \uB458 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uAE30\uBCF8\uAC12 = 100\uB144)",
  MAX_INTERVAL_MIN_WARNING: "\uCD5C\uB300 \uAC04\uACA9\uC740 \uC801\uC5B4\uB3C4 1\uC77C\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  MAX_LINK_CONTRIB: "\uCD5C\uB300 \uC5F0\uACB0 \uAE30\uC5EC\uB3C4",
  MAX_LINK_CONTRIB_DESC: "\uB9C1\uD06C\uB41C \uB178\uD2B8\uC758 \uCD08\uAE30 ease\uC5D0 \uB300\uD55C \uAC00\uC911\uCE58\uAC00 \uC801\uC6A9\uB41C ease\uC758 \uCD5C\uB300 \uAE30\uC5EC\uB3C4\uC785\uB2C8\uB2E4.",
  LOGGING: "\uB85C\uAE45",
  DISPLAY_DEBUG_INFO: "\uB514\uBC84\uAE45 \uC815\uBCF4\uB97C \uAC1C\uBC1C\uC790 \uCF58\uC194\uC5D0 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  NOTES_REVIEW_QUEUE: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uB300\uAE30\uC5F4",
  CLOSE: "\uB2EB\uAE30",
  NEW: "New",
  YESTERDAY: "\uC5B4\uC81C",
  TODAY: "\uC624\uB298",
  TOMORROW: "\uB0B4\uC77C",
  STATS_TITLE: "\uD1B5\uACC4",
  MONTH: "\uC6D4",
  QUARTER: "\uBD84\uAE30",
  YEAR: "\uB144",
  LIFETIME: "\uD3C9\uC0DD",
  FORECAST: "\uC608\uCE21",
  FORECAST_DESC: "\uC774\uD6C4\uC5D0 \uD559\uC2B5\uD560 \uCE74\uB4DC\uC758 \uC218",
  SCHEDULED: "Scheduled",
  DAYS: "\uC77C",
  NUMBER_OF_CARDS: "\uCE74\uB4DC\uC758 \uC218",
  REVIEWS_PER_DAY: "\uD3C9\uADE0: ${avg} \uB9AC\uBDF0/\uC77C",
  INTERVALS: "\uAC04\uACA9",
  INTERVALS_DESC: "\uB9AC\uBDF0\uB97C \uB2E4\uC2DC \uD560 \uB54C \uAE4C\uC9C0\uC758 \uAE30\uAC04",
  COUNT: "Count",
  INTERVALS_SUMMARY: "\uD3C9\uADE0 \uAC04\uACA9: ${avg}, \uAC00\uC7A5 \uAE34 \uAC04\uACA9: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  CARD_TYPES: "\uCE74\uB4DC \uD0C0\uC785",
  CARD_TYPES_DESC: "\uC5EC\uAE30\uC5D0\uB294 \uBB3B\uC5B4\uB454 \uCE74\uB4DC\uB3C4 \uD3EC\uD568\uB429\uB2C8\uB2E4.",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "\uC804\uCCB4 \uCE74\uB4DC \uC218: ${totalCardsCount}"
};

// src/lang/locale/mr.ts
var mr_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {
  DECKS: "Baralhos",
  DUE_CARDS: "Cartas para Colocar em Dia",
  NEW_CARDS: "Novas Cartas",
  TOTAL_CARDS: "Total de Cartas",
  BACK: "Back",
  EDIT_LATER: "Editar Depois",
  RESET_CARD_PROGRESS: "Reiniciar o Progresso da Carta",
  HARD: "Dif\xEDcil",
  GOOD: "OK",
  EASY: "F\xE1cil",
  SHOW_ANSWER: "Mostrar Resposta",
  CARD_PROGRESS_RESET: "O Progresso da Carta foi reiniciado",
  OPEN_NOTE_FOR_REVIEW: "Abrir uma nota para revisar",
  REVIEW_CARDS: "Revisar flashcards",
  REVIEW_EASY_FILE_MENU: "Revis\xE3o: F\xE1cil",
  REVIEW_GOOD_FILE_MENU: "Revis\xE3o: OK",
  REVIEW_HARD_FILE_MENU: "Revis\xE3o: Dif\xEDcil",
  REVIEW_NOTE_EASY_CMD: "Revisar nota como f\xE1cil",
  REVIEW_NOTE_GOOD_CMD: "Revisar nota como OK",
  REVIEW_NOTE_HARD_CMD: "Revisar nota como dif\xEDcil",
  REVIEW_CARDS_IN_NOTE: "Revisar flashcards nessa nota",
  CRAM_CARDS_IN_NOTE: "Revisar todas as flashcards nessa nota",
  REVIEW_ALL_CARDS: "Revisar flashcards de todas as notas",
  VIEW_STATS: "Ver estat\xEDsticas",
  STATUS_BAR: "Revis\xE3o: ${dueNotesCount} nota(s), ${dueFlashcardsCount} Carta(s) para colocar em dia",
  SYNC_TIME_TAKEN: "Sicroniza\xE7\xE3o levou ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Nota \xE9 salva na pasta ignorada (cheque as configura\xE7\xF5es).",
  PLEASE_TAG_NOTE: "Por favor etiquete a nota apropriadamente para revisar (nas configura\xE7\xF5es).",
  RESPONSE_RECEIVED: "Resposta recebida.",
  NO_DECK_EXISTS: "Nenhum baralho existe para ${deckName}",
  ALL_CAUGHT_UP: "Voc\xEA colocou tudo em prazo agora :D.",
  DAYS_STR_IVL: "${interval} dia(s)",
  MONTHS_STR_IVL: "${interval} m\xEAs(es)",
  YEARS_STR_IVL: "${interval} ano(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}a",
  SETTINGS_HEADER: "Plguin Spaced Repetition - Configura\xE7\xE3o",
  CHECK_WIKI: 'Para mais informa\xE7\xF5es, checke o <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "Pastas para ignorar",
  FOLDERS_TO_IGNORE_DESC: "Ensira o caminho das pastas separado por quebras de linha ex: Templates Meta/Scripts",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Texto do Bot\xE3o de F\xE1cil",
  FLASHCARD_GOOD_LABEL: "Texto do Bot\xE3o de OK",
  FLASHCARD_HARD_LABEL: "Texto do Bot\xE3o de Dif\xEDcil",
  FLASHCARD_EASY_DESC: 'Costumize o r\xF3tulo para o bot\xE3o de "F\xE1cil"',
  FLASHCARD_GOOD_DESC: 'Costumize o r\xF3tulo para o bot\xE3o de "OK"',
  FLASHCARD_HARD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "Dif\xEDcil"',
  FLASHCARD_TAGS: "Etiquetas dos Flashcards",
  FLASHCARD_TAGS_DESC: "Ensira etiquetas separadas por espa\xE7os ou quebras de linha ex: #flashcards #baralho2 #baralho3.",
  CONVERT_FOLDERS_TO_DECKS: "Converter pastas para baralhos e sub-baralhos?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Isso \xE9 uma alternativa para a op\xE7\xE3o de etiqueta dos Flashcards em cima.",
  INLINE_SCHEDULING_COMMENTS: "Salvar coment\xE1rios de agendamento na mesma linha que a \xFAltima linha do flashcard?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Ligar isso vai fazer com que os coment\xE1rios em HTML n\xE3o quebrem a formata\xE7\xE3o de listas.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrar cartas irm\xE3s at\xE9 o pr\xF3ximo dia?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Cartas irm\xE3s s\xE3o geradas pelo texto da mesma carta ex: omiss\xE3o de palavras",
  SHOW_CARD_CONTEXT: "Mostrar conxtexto nas cartas?",
  SHOW_CARD_CONTEXT_DESC: "ex: T\xEDtulo > Cabe\xE7alho 1 > Subcabe\xE7alho > ... > Subcabe\xE7alho",
  CARD_MODAL_HEIGHT_PERCENT: "Porcentagem da Altura do Flashcard",
  CARD_MODAL_SIZE_PERCENT_DESC: "Deveria estar configurado em 100% em dispositivos m\xF3veis ou se voc\xEA tem imagens muito grandes",
  RESET_DEFAULT: "Reiniciar para a pr\xE9-defini\xE7\xE3o",
  CARD_MODAL_WIDTH_PERCENT: "Porcentagem de Largura do Flashcard",
  FILENAME_OR_OPEN_FILE: "Mostrar o nome do arquivo ao inv\xE9s de 'Editar Depois' na revis\xE3o dos flashcards?",
  RANDOMIZE_CARD_ORDER: "Aleatorizar a ordem das cartas durante a revis\xE3o?",
  DISABLE_CLOZE_CARDS: "Desabilitar cartas que usam omiss\xE3o de palavras?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Converter ==marca-texto== em omiss\xF5es?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "Converter **texto em negrito** em omiss\xF5es?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Converter {{chaves}} em omiss\xF5es?",
  INLINE_CARDS_SEPARATOR: "Separador para flashcards inline",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note que depois de mudar isso voc\xEA vai ter que manualmente mudar quaisquer flashcards que voc\xEA tenha.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards inline reversos",
  MULTILINE_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas reversos",
  NOTES: "Notas",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Etiquetas para revisar",
  TAGS_TO_REVIEW_DESC: "Ensira etiquetas separadas por espa\xE7os ou quebra de linhas ex: #revisar #etiqueta2 #etiqueta3.",
  OPEN_RANDOM_NOTE: "Abrir uma nota aleat\xF3ria para revisar",
  OPEN_RANDOM_NOTE_DESC: "Quando voc\xEA desabilitar isso, as notas v\xE3o ser ordenadas por import\xE2ncia (PageRank).",
  AUTO_NEXT_NOTE: "Abrir a pr\xF3xima nota automaticamente depois de uma revis\xE3o",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "Desabilitar op\xE7\xF5es de revis\xE3o no menu de arquivos ex: Revis\xE3o: F\xE1cil OK Dif\xEDcil",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Depois de desabilitar, voc\xEA pode revisar usando os atalhos de comando. Reinicie Obsidian depois de mudar isso.",
  MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de dias para exibir no painel direito",
  MIN_ONE_DAY: "O n\xFAmero de dias deve ser pelo menos 1.",
  VALID_NUMBER_WARNING: "Por favor ensira um n\xFAmero v\xE1lido.",
  UI_PREFERENCES: "Prefer\xEAncias de UI",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\xC1rvores de baralhos devem inicialmente serem exibidas como expandidas",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Desabilite isso para colapsar baralhos que est\xE3o um dentro do outro na mesma carta. \xDAtil se voc\xEA tem cartas que pertencem a muitos baralhos em um mesmo arquivo.",
  ALGORITHM: "Algor\xEDtmo",
  CHECK_ALGORITHM_WIKI: 'Para mais informa\xE7\xF5es, cheque a <a href="${algo_url}">implementa\xE7\xE3o do algor\xEDtmo</a>.',
  BASE_EASE: "Facilidade base",
  BASE_EASE_DESC: "m\xEDnimo = 130, preferivelmente aproximadamente 250.",
  BASE_EASE_MIN_WARNING: "A facilidade base deve ser pelo menos 130.",
  LAPSE_INTERVAL_CHANGE: "Mudan\xE7a de intervalo quando voc\xEA revisa um(a) flashcard/nota como dif\xEDcil",
  LAPSE_INTERVAL_CHANGE_DESC: "novoIntervalo = velhoIntervalo * mudancaIntervalo / 100.",
  EASY_BONUS: "B\xF4nus de F\xE1cil",
  EASY_BONUS_DESC: "O b\xF4nus de f\xE1cil te permite mudar a difer\xEAncia entre intervalos de responder OK e F\xE1cil em um(a) flashcard/nota (m\xEDnimo = 100%).",
  EASY_BONUS_MIN_WARNING: "O b\xF4nus de f\xE1cil deve ser pelo menos 100.",
  MAX_INTERVAL: "Intervalo M\xE1ximo",
  MAX_INTERVAL_DESC: "Te permite colocar um limite m\xE1ximo no intervalo (pr\xE9-defini\xE7\xE3o = 100 anos).",
  MAX_INTERVAL_MIN_WARNING: "O intervalo m\xE1ximo deve ser pelo menos 1 dia.",
  MAX_LINK_CONTRIB: "Contribui\xE7\xE3o M\xE1xima de Links",
  MAX_LINK_CONTRIB_DESC: "Contribui\xE7\xE3o m\xE1xima da facilidade ponderada das notas linkadas \xE0 facilidade inicial.",
  LOGGING: "Logging",
  DISPLAY_DEBUG_INFO: "Mostrar informa\xE7\xE3o de debugging no console de desenvolvimento?",
  NOTES_REVIEW_QUEUE: "Fila de Notas para Revisar",
  CLOSE: "Fechar",
  NEW: "Novo",
  YESTERDAY: "Ontem",
  TODAY: "Hoje",
  TOMORROW: "Amanh\xE3",
  STATS_TITLE: "Estat\xEDsticas",
  MONTH: "M\xEAs",
  QUARTER: "Quarto",
  YEAR: "Ano",
  LIFETIME: "Tempo Total",
  FORECAST: "Previs\xE3o",
  FORECAST_DESC: "O n\xFAmero de cartas a serem colocadas em dia no futuro",
  SCHEDULED: "Agendado",
  DAYS: "Dias",
  NUMBER_OF_CARDS: "N\xFAmero de cartas",
  REVIEWS_PER_DAY: "M\xE9dia: ${avg} revis\xF5es/dia",
  INTERVALS: "Intervalos",
  INTERVALS_DESC: "Atrasos at\xE9 que as revis\xF5es sejam exibidas de novo",
  COUNT: "Contagem",
  INTERVALS_SUMMARY: "Intervalo em m\xE9dia: ${avg}, Maior intervalo: ${longest}",
  EASES: "Facilidades",
  EASES_SUMMARY: "Facilidade em m\xE9dia: ${avgEase}",
  CARD_TYPES: "Tipos de Cartas",
  CARD_TYPES_DESC: "Isso tamb\xE9m inclui cartas enterrados, caso existam",
  CARD_TYPE_NEW: "Novo",
  CARD_TYPE_YOUNG: "Jovem",
  CARD_TYPE_MATURE: "Amadurecido",
  CARD_TYPES_SUMMARY: "Total de cartas: ${totalCardsCount}"
};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {
  DECKS: "\u0423\u0440\u043E\u0432\u043D\u0438",
  DUE_CARDS: "\u041F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  NEW_CARDS: "\u041D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  TOTAL_CARDS: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  EDIT_LATER: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435",
  BACK: "Back",
  RESET_CARD_PROGRESS: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  HARD: "\u0421\u043B\u043E\u0436\u043D\u043E",
  GOOD: "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  EASY: "\u041B\u0435\u0433\u043A\u043E",
  SHOW_ANSWER: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u0442\u0432\u0435\u0442",
  CARD_PROGRESS_RESET: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  OPEN_NOTE_FOR_REVIEW: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  REVIEW_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  REVIEW_EASY_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E",
  REVIEW_GOOD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  REVIEW_HARD_FILE_MENU: "\u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u0421\u043B\u043E\u0436\u043D\u043E",
  REVIEW_NOTE_EASY_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041B\u0451\u0433\u043A\u0443\u044E",
  REVIEW_NOTE_GOOD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u0443\u044E",
  REVIEW_NOTE_HARD_CMD: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u0421\u043B\u043E\u0436\u043D\u0443\u044E",
  REVIEW_CARDS_IN_NOTE: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  CRAM_CARDS_IN_NOTE: "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  REVIEW_ALL_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
  VIEW_STATS: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443",
  STATUS_BAR: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C: ${dueNotesCount} \u0437\u0430\u043C\u0435\u0442\u043E\u043A(-\u043A\u0438), ${dueFlashcardsCount} \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A(-\u043A\u0438) \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u0438\u0442",
  SYNC_TIME_TAKEN: "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u043D\u044F\u043B\u0430 ${t}\u043C\u0441",
  NOTE_IN_IGNORED_FOLDER: "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u0443\u044E \u043F\u0430\u043F\u043A\u0443 (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  PLEASE_TAG_NOTE: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u043F\u043E\u043C\u0435\u0442\u044C\u0442\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A \u043D\u0430\u0434\u043E \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F (\u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  RESPONSE_RECEIVED: "\u041E\u0442\u0432\u0435\u0442 \u043F\u043E\u043B\u0443\u0447\u0435\u043D.",
  NO_DECK_EXISTS: "\u041D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u0440\u043E\u0432\u043D\u044F ${deckName}",
  ALL_CAUGHT_UP: "\u0415\u0441\u0442\u044C! \u0422\u044B \u0441\u043F\u0440\u0430\u0432\u0438\u043B\u0441\u044F! :D.",
  DAYS_STR_IVL: "${interval} \u0434\u043D\u0435\u0439",
  MONTHS_STR_IVL: "${interval} \u043C\u0435\u0441\u044F\u0446\u043E\u0432",
  YEARS_STR_IVL: "${interval} \u0433\u043E\u0434\u0430(\u043B\u0435\u0442)",
  DAYS_STR_IVL_MOBILE: "${interval}\u0434",
  MONTHS_STR_IVL_MOBILE: "${interval}\u043C",
  YEARS_STR_IVL_MOBILE: "${interval}\u0433",
  SETTINGS_HEADER: "Spaced Repetition \u041F\u043B\u0430\u0433\u0438\u043D - \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  CHECK_WIKI: '\u0414\u043B\u044F \u0434\u043E\u043F \u0438\u043D\u0444\u044B, \u0441\u043C\u043E\u0442\u0440\u0438 <a href="${wiki_url}">wiki</a>. \u0421\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434 :3',
  FOLDERS_TO_IGNORE: "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
  FOLDERS_TO_IGNORE_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u043F\u0443\u0442\u0438 \u043F\u0430\u043F\u043E\u043A \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: Templates Meta/Scripts",
  FLASHCARDS: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  FLASHCARD_TAGS: "\u0422\u044D\u0433\u0438 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FLASHCARD_TAGS_DESC: "\u0412\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 enter'\u043E\u043C \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u043C \u043F\u0440\u0438\u043C\u0435\u0440: #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0432 \u0443\u0440\u043E\u0432\u043D\u0438 \u0438 \u043F\u043E\u0434\u0443\u0440\u043E\u0432\u043D\u0438?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u042D\u0442\u043E \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u0430 \u0442\u044D\u0433\u0430\u043C \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A, \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u0441\u0432\u0435\u0440\u0445\u0443.",
  INLINE_SCHEDULING_COMMENTS: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0430 \u0441\u0442\u0440\u043E\u043A\u0435 \u043F\u043E\u0441\u043B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0433\u043E \u0441\u0434\u0435\u043B\u0430\u0435\u0442 \u0442\u0430\u043A, \u0447\u0442\u043E HTML \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043C\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u041F\u0440\u044F\u0442\u0430\u0442\u044C \u0440\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0434\u043E \u0441\u043B\u0435\u0434. \u0434\u043D\u044F?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u0420\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 - \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u044B \u0438\u0437 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438([...])",
  SHOW_CARD_CONTEXT: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442(\u0443\u0440\u043E\u0432\u0435\u043D\u044C) \u0432 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0430\u0445(\u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F)?",
  SHOW_CARD_CONTEXT_DESC: "\u043F\u0440\u0438\u043C\u0435\u0440: Title > Heading 1 > Subheading > ... > Subheading",
  CARD_MODAL_HEIGHT_PERCENT: "\u0412\u044B\u0441\u043E\u0442\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u0415\u0441\u043B\u0438 \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0435\u0441\u044C \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u043C \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u043E\u043C, \u0432\u044B\u0441\u0442\u0430\u0432\u044C\u0442\u0435 100% \u0438\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0431\u0443\u0434\u0443\u0442 \u043E\u0433\u0440\u043E\u043C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
  RESET_DEFAULT: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  CARD_MODAL_WIDTH_PERCENT: "\u0428\u0438\u0440\u0438\u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  FILENAME_OR_OPEN_FILE: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0438\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0432\u043C\u0435\u0441\u0442\u043E '\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435' \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  RANDOMIZE_CARD_ORDER: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u044B\u0439 \u043F\u043E\u0440\u044F\u0434\u043E\u043A \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F?",
  DISABLE_CLOZE_CARDS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u044B \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C ==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442== \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C **\u0436\u0438\u0440\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442** \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C {{\u0444\u0438\u0433\u0443\u0440\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438}} \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438(\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  INLINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435! \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u0432\u0430\u043C \u043F\u0440\u0438\u0434\u0451\u0442\u0441\u044F \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  NOTES: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u0422\u044D\u0433\u0438 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  TAGS_TO_REVIEW_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u044D\u0433\u0438, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0440\u043E\u0431\u0435\u043B\u0430\u043C\u0438 \u0438\u043B\u0438 enter`\u0430\u043C\u0438, \u043F\u0440\u0438\u043C\u0435\u0440: #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  OPEN_RANDOM_NOTE_DESC: "\u0415\u0441\u043B\u0438 \u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C, \u0442\u043E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0432\u0430\u0436\u043D\u043E\u0441\u0442\u0438 (PageRank).",
  AUTO_NEXT_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u044B\u0431\u043E\u0440 \u0441\u043B\u043E\u0436\u043D\u043E\u0441\u0442\u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0432 \u043C\u0435\u043D\u044E \u0444\u0430\u0439\u043B\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E \u0421\u043B\u043E\u0436\u043D\u043E",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u041F\u043E\u0441\u043B\u0435 \u0432\u044B\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0432\u044B \u0441\u043C\u043E\u0436\u0435\u0442\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0442\u044C \u043F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u0445\u043E\u0442\u043A\u0435\u0435\u0432. \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 Obsidian \u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E.",
  MAX_N_DAYS_REVIEW_QUEUE: "\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u043F\u0440\u0430\u0432\u0430",
  MIN_ONE_DAY: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  VALID_NUMBER_WARNING: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0435\u0435 \u0447\u0438\u0441\u043B\u043E.",
  UI_PREFERENCES: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u0414\u0435\u0440\u0435\u0432\u044C\u044F \u043A\u043E\u043B\u043E\u0434 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0437\u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u0440\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044B\u0435",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u044D\u0442\u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440, \u0447\u0442\u043E\u0431\u044B \u0441\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u043A\u043E\u043B\u043E\u0434\u044B \u043D\u0430 \u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435. \u041F\u043E\u043B\u0435\u0437\u043D\u043E, \u0435\u0441\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044C \u043A\u0430\u0440\u0442\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043F\u0440\u0438\u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0442 \u043C\u043D\u043E\u0433\u0438\u043C \u043A\u043E\u043B\u043E\u0434\u0430\u043C \u0432 \u043E\u0434\u043D\u043E\u043C \u0444\u0430\u0439\u043B\u0435.",
  ALGORITHM: "\u0410\u043B\u0433\u043E\u0440\u0438\u0442\u043C",
  CHECK_ALGORITHM_WIKI: '\u0417\u0430 \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E\u0431\u0440\u0430\u0449\u0430\u0439\u0442\u0435\u0441\u044C \u043A <a href="${algo_url}">\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430</a>(\u0441\u043A\u043E\u0440\u043E \u0431\u0443\u0434\u0435\u0442 \u043F\u0435\u0440\u0435\u0432\u043E\u0434).',
  BASE_EASE: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C",
  BASE_EASE_DESC: "\u043C\u0438\u043D\u0438\u043C\u0443\u043C = 130, \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043E\u043A\u043E\u043B\u043E 250.",
  BASE_EASE_MIN_WARNING: "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C 130.",
  LAPSE_INTERVAL_CHANGE: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 \u043A\u043E\u0433\u0434\u0430 \u0432\u044B \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442\u0435 \u0421\u043B\u043E\u0436\u043D\u043E \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438/\u0437\u0430\u043C\u0435\u0442\u043A\u0438",
  LAPSE_INTERVAL_CHANGE_DESC: "\u043D\u043E\u0432\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A = \u0441\u0442\u0430\u0440\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A * \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 / 100.",
  EASY_BONUS: "\u041B\u0435\u0433\u043A\u043E: \u0431\u043E\u043D\u0443\u0441",
  EASY_BONUS_DESC: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u043D\u0438\u0446\u0443 \u0432 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043E\u0442\u0432\u0435\u0442\u0430\u043C\u0438 \u0425\u043E\u0440\u043E\u0448\u043E \u0438 \u041B\u0435\u0433\u043A\u043E \u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435/\u0437\u0430\u043C\u0435\u0442\u043A\u0435 (\u043C\u0438\u043D. = 100%).",
  EASY_BONUS_MIN_WARNING: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 100.",
  MAX_INTERVAL: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A(\u043E\u0442\u043A\u043B\u0430\u0434\u044B\u0432\u0430\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438)",
  MAX_INTERVAL_DESC: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u044E\u044E \u0433\u0440\u0430\u043D\u0438\u0446\u0443 \u043D\u0430 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  MAX_LINK_CONTRIB: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0432\u044F\u0437\u0438(\u0441\u0441\u044B\u043B\u043A\u0438)",
  MAX_LINK_CONTRIB_DESC: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0432\u0437\u0432\u0435\u0448\u0435\u043D\u043D\u043E\u0439 \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438 \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u0443\u044E \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C.",
  LOGGING: "\u0412\u0435\u0434\u0435\u043D\u0438\u0435 \u043B\u043E\u0433\u0430",
  DISPLAY_DEBUG_INFO: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E\u0442\u043B\u0430\u0434\u043A\u0438 \u043D\u0430 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430(developer console)?",
  NOTES_REVIEW_QUEUE: "\u041E\u0447\u0435\u0440\u0435\u0434\u044C \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435",
  CLOSE: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
  NEW: "\u041D\u043E\u0432\u044B\u0435",
  YESTERDAY: "\u0412\u0447\u0435\u0440\u0430\u0448\u043D\u0438\u0435",
  TODAY: "\u0421\u0435\u0433\u043E\u0434\u043D\u044F\u0448\u043D\u0438\u0435",
  TOMORROW: "\u0417\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
  STATS_TITLE: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430",
  MONTH: "\u041C\u0435\u0441\u044F\u0446",
  QUARTER: "\u0427\u0435\u0442\u0432\u0435\u0440\u0442\u044C",
  YEAR: "\u0413\u043E\u0434",
  LIFETIME: "\u0412\u0441\u0451 \u0432\u0440\u0435\u043C\u044F",
  FORECAST: "\u041F\u0440\u043E\u0433\u043D\u043E\u0437",
  FORECAST_DESC: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0445 \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C",
  SCHEDULED: "\u0417\u0430\u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
  DAYS: "\u0414\u043D\u0435\u0439",
  NUMBER_OF_CARDS: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  REVIEWS_PER_DAY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0441\u0442\u0432\u043E: ${avg} \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0439/\u0434\u0435\u043D\u044C",
  INTERVALS: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B",
  INTERVALS_DESC: "\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  COUNT: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E",
  INTERVALS_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0438\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${avg}, \u0421\u0430\u043C\u044B\u0439 \u0434\u043B\u0438\u043D\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${longest}",
  EASES: "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C(\u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440 \u0432 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u0432\u043B\u0438\u044F\u0435\u0442 \u043D\u0430 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442 \u0438 \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A) \n (\u043E\u0442 \u0430\u043D\u0433\u043B. ease, \u0441\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430)",
  EASES_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438: ${avgEase}",
  CARD_TYPES: "\u0422\u0438\u043F\u044B \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  CARD_TYPES_DESC: "\u042D\u0442\u043E \u0432\u043A\u043B\u044E\u0447\u0430\u044F \u0441\u043F\u0440\u044F\u0442\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0435\u0441\u043B\u0438 \u0447\u0442\u043E:",
  CARD_TYPE_NEW: "\u041D\u043E\u0432\u044B\u0445",
  CARD_TYPE_YOUNG: "\u041C\u043E\u043B\u043E\u0434\u044B\u0445",
  CARD_TYPE_MATURE: "\u0412\u0437\u0440\u043E\u0441\u043B\u044B\u0445",
  CARD_TYPES_SUMMARY: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A: ${totalCardsCount}"
};

// src/lang/locale/ta.ts
var ta_default = {};

// src/lang/locale/te.ts
var te_default = {};

// src/lang/locale/th.ts
var th_default = {};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/uk.ts
var uk_default = {};

// src/lang/locale/ur.ts
var ur_default = {};

// src/lang/locale/vi.ts
var vi_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  DECKS: "\u5361\u7EC4",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  BACK: "Back",
  EDIT_LATER: "\u7A0D\u540E\u7F16\u8F91",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F83\u96BE",
  GOOD: "\u8BB0\u5F97",
  EASY: "\u7B80\u5355",
  SHOW_ANSWER: "\u663E\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u5F00\u59CB\u590D\u4E60",
  REVIEW_CARDS: "\u590D\u4E60\u5361\u7247",
  REVIEW_EASY_FILE_MENU: "\u590D\u4E60\uFF1A\u7B80\u5355",
  REVIEW_GOOD_FILE_MENU: "\u590D\u4E60\uFF1A\u8BB0\u5F97",
  REVIEW_HARD_FILE_MENU: "\u590D\u4E60\uFF1A\u8F83\u96BE",
  REVIEW_NOTE_EASY_CMD: "\u6807\u8BB0\u4E3A\u201C\u7B80\u5355\u201D",
  REVIEW_NOTE_GOOD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8BB0\u5F97\u201D",
  REVIEW_NOTE_HARD_CMD: "\u6807\u8BB0\u4E3A\u201C\u8F83\u96BE\u201D",
  REVIEW_CARDS_IN_NOTE: "\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  REVIEW_ALL_CARDS: "\u590D\u4E60\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u67E5\u770B\u6570\u636E",
  STATUS_BAR: "\u590D\u4E60: ${dueNotesCount} \u7B14\u8BB0, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u65F6\u95F4 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B14\u8BB0\u4FDD\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F84\u4E2D\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8BF7\u5C06\u9700\u8981\u590D\u4E60\u7684\u7B14\u8BB0\u4E2D\u52A0\u5165\u6B63\u786E\u7684\u6807\u7B7E\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  RESPONSE_RECEIVED: "\u53CD\u9988\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6CA1\u6709 ${deckName} \u5361\u7EC4",
  ALL_CAUGHT_UP: "\u90FD\u590D\u4E60\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  DAYS_STR_IVL: "${interval} \u5929",
  MONTHS_STR_IVL: "${interval} \u6708",
  YEARS_STR_IVL: "${interval} \u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  SETTINGS_HEADER: "\u95F4\u9694\u91CD\u590D\u63D2\u4EF6 - \u8BBE\u7F6E",
  CHECK_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u6587\u4EF6\u5939",
  FOLDERS_TO_IGNORE_DESC: "\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84\uFF0C\u7528\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1ATemplates Meta/Scripts",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u201C\u7B80\u5355\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_GOOD_LABEL: "\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_HARD_LABEL: "\u201C\u8F83\u96BE\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_EASY_DESC: "\u81EA\u5B9A\u4E49\u201C\u7B80\u5355\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_GOOD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_HARD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8F83\u96BE\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_TAGS: "\u5361\u7247\u6807\u7B7E",
  FLASHCARD_TAGS_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C06\u6587\u4EF6\u5939\u5185\u5BB9\u8F6C\u6362\u4E3A\u5361\u7247\u7EC4\u548C\u5B50\u5361\u7247\u7EC4\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9009\u9879\u4E3A\u5361\u7247\u6807\u7B7E\u9009\u9879\u7684\u66FF\u4EE3\u9009\u9879\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C06\u8BA1\u5212\u91CD\u590D\u65F6\u95F4\u4FDD\u5B58\u5728\u5361\u7247\u6700\u540E\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "HTML\u6CE8\u91CA\u4E0D\u518D\u7834\u574F\u5217\u8868\u683C\u5F0F",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C06\u5173\u8054\u5361\u7247\u9690\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u5173\u8054\u5361\u7247\u662F\u6765\u81EA\u540C\u4E00\u5361\u7247\u7684\u4E0D\u540C\u5F62\u5F0F\uFF0C \u4F8B\u5982\uFF1A\u5B8C\u5F62\u586B\u7A7A\u5361\u7247",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u663E\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6807\u9898 > \u526F\u6807\u9898 > \u5C0F\u6807\u9898 > ... > \u5C0F\u6807\u9898",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u8BF7\u5728\u79FB\u52A8\u7AEF\u4F7F\u7528\u5E76\u9700\u8981\u6D4F\u89C8\u8F83\u5927\u56FE\u7247\u65F6\u8BBE\u4E3A100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BBD\u5EA6\u767E\u5206\u6BD4",
  FILENAME_OR_OPEN_FILE: "\u5728\u590D\u4E60\u5361\u7247\u65F6\u663E\u793A\u6587\u4EF6\u540D\u79F0\u800C\u4E0D\u662F\u201C\u7A0D\u540E\u7F16\u8F91\u201D\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u590D\u4E60\u65F6\u968F\u673A\u663E\u793A\u5361\u7247\uFF1F",
  DISABLE_CLOZE_CARDS: "\u4E0D\u8FDB\u884C\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C06 ==\u9AD8\u4EAE== \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C06 **\u7C97\u4F53** \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C06 {{\u5927\u62EC\u53F7}} \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u5355\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9009\u9879\u540E\u4F60\u5C06\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u7B26\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u5355\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  NOTES: "\u7B14\u8BB0",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u590D\u4E60\u6807\u7B7E",
  TAGS_TO_REVIEW_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u590D\u4E60\u968F\u673A\u7B14\u8BB0",
  OPEN_RANDOM_NOTE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\uFF0C\u7B14\u8BB0\u5C06\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u590D\u4E60\u540E\u81EA\u52A8\u6253\u5F00\u4E0B\u4E00\u4E2A\u7B14\u8BB0",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u5173\u95ED\u6587\u4EF6\u9009\u5355\u4E2D\u7684\u590D\u4E60\u9009\u9879 \u4F8B\u5982\uFF1A\u590D\u4E60\uFF1A\u7B80\u5355 \u8BB0\u5F97 \u8F83\u96BE",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u540E\u4F60\u53EF\u4EE5\u4F7F\u7528\u5FEB\u6377\u952E\u5F00\u59CB\u590D\u4E60\u3002\u91CD\u65B0\u542F\u52A8Obsidian\u4F7F\u672C\u9009\u9879\u751F\u6548\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u8FB9\u680F\u4E2D\u663E\u793A\u7684\u6700\u5927\u5929\u6570",
  MIN_ONE_DAY: "\u5929\u6570\u6700\u5C0F\u503C\u4E3A1",
  VALID_NUMBER_WARNING: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u6570\u5B57\u3002",
  UI_PREFERENCES: "\u7528\u6237\u754C\u9762\u9996\u9009\u9879",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u7532\u677F\u6811\u6700\u521D\u5E94\u663E\u793A\u4E3A\u5C55\u5F00",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u6298\u53E0\u540C\u4E00\u5F20\u5361\u7247\u4E2D\u7684\u5D4C\u5957\u724C\u7EC4\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C5E\u4E8E\u540C\u4E00\u6587\u4EF6\u4E2D\u7684\u8BB8\u591A\u5957\u724C\uFF0C\u5219\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u8350\u503C\u7EA6250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u4E3A130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C06\u590D\u4E60\u65F6\u6807\u6CE8\u4E3A\u201C\u8F83\u96BE\u201D\u7684\u5361\u7247\u6216\u7B14\u8BB0\u590D\u4E60\u95F4\u9694\u7F29\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u590D\u4E60\u95F4\u9694 = \u539F\u590D\u4E60\u95F4\u9694 * \u95F4\u9694\u6539\u53D8\u7CFB\u6570 / 100.",
  EASY_BONUS: "\u7B80\u5355\u5956\u52B1",
  EASY_BONUS_DESC: "\u7B80\u5355\u5956\u52B1\u8BBE\u5B9A\u201C\u8BB0\u5F97\u201D\u548C\u201C\u7B80\u5355\u201D\u5361\u7247\u6216\u7B14\u8BB0\u7684\u590D\u4E60\u95F4\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7B80\u5355\u5956\u52B1\u81F3\u5C11\u4E3A100\u3002",
  MAX_INTERVAL: "\u6700\u5927\u95F4\u9694",
  MAX_INTERVAL_DESC: "\u8BBE\u5B9A\u590D\u4E60\u7684\u6700\u5927\u95F4\u9694\u65F6\u95F4\uFF08\u9ED8\u8BA4\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u95F4\u9694\u81F3\u5C11\u4E3A1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u94FE\u63A5\u6536\u76CA",
  MAX_LINK_CONTRIB_DESC: "\u7531\u539F\u638C\u63E1\u7A0B\u5EA6\u94FE\u63A5\u7684\u7B14\u8BB0\u7ED9\u4E0E\u7684\u6700\u5927\u52A0\u6743\u638C\u63E1\u5EA6\u6536\u76CA\u3002",
  LOGGING: "\u8BB0\u5F55\u4E2D",
  DISPLAY_DEBUG_INFO: "\u5728\u5F00\u53D1\u8005\u63A7\u5236\u53F0\u4E2D\u663E\u793A\u8C03\u8BD5\u4FE1\u606F\uFF1F",
  NOTES_REVIEW_QUEUE: "\u7B14\u8BB0\u590D\u4E60\u5E8F\u5217",
  CLOSE: "\u4E34\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  STATS_TITLE: "\u6570\u636E",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9884\u671F",
  FORECAST_DESC: "\u5C06\u8981\u5230\u671F\u7684\u5361\u7247\u6570\u91CF",
  SCHEDULED: "\u5DF2\u6392\u671F",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6570\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u590D\u4E60${avg} /\u5929",
  INTERVALS: "\u95F4\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u590D\u4E60\u7684\u65F6\u95F4\u95F4\u9694",
  COUNT: "\u8BA1\u6570",
  INTERVALS_SUMMARY: "\u5E73\u5747\u95F4\u9694\u65F6\u95F4: ${avg}, \u6700\u957F\u95F4\u9694\u65F6\u95F4: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  CARD_TYPES: "\u5361\u7247\u7C7B\u578B",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C06\u663E\u793A\u9690\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F83\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u603B\u5361\u7247\u6570: ${totalCardsCount}"
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {
  DECKS: "\u724C\u7D44",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  EDIT_LATER: "\u7A0D\u5F8C\u7DE8\u8F2F",
  BACK: "Back",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F03\u96E3",
  GOOD: "\u8A18\u5F97",
  EASY: "\u7C21\u55AE",
  SHOW_ANSWER: "\u986F\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  OPEN_NOTE_FOR_REVIEW: "\u6253\u958B\u4E00\u500B\u7B46\u8A18\u958B\u59CB\u5FA9\u7FD2",
  REVIEW_CARDS: "\u5FA9\u7FD2\u5361\u7247",
  REVIEW_EASY_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u7C21\u55AE",
  REVIEW_GOOD_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u8A18\u5F97",
  REVIEW_HARD_FILE_MENU: "\u5FA9\u7FD2\uFF1A\u8F03\u96E3",
  REVIEW_NOTE_EASY_CMD: "\u6A19\u8A18\u70BA\u300C\u7C21\u55AE\u300D",
  REVIEW_NOTE_GOOD_CMD: "\u6A19\u8A18\u70BA\u300C\u8A18\u5F97\u300D",
  REVIEW_NOTE_HARD_CMD: "\u6A19\u8A18\u70BA\u300C\u8F03\u96E3\u300D",
  REVIEW_CARDS_IN_NOTE: "\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  REVIEW_ALL_CARDS: "\u5FA9\u7FD2\u6240\u6709\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u6AA2\u8996\u6578\u64DA",
  STATUS_BAR: "\u5FA9\u7FD2: ${dueNotesCount} \u7B46\u8A18, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u6642\u9593 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B46\u8A18\u5132\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F91\u4E2D\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8ACB\u5C07\u9700\u8981\u5FA9\u7FD2\u7684\u7B46\u8A18\u4E2D\u52A0\u5165\u6B63\u78BA\u7684\u6A19\u7C64\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  RESPONSE_RECEIVED: "\u56DE\u994B\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6C92\u6709 ${deckName} \u724C\u7D44",
  ALL_CAUGHT_UP: "\u90FD\u5FA9\u7FD2\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  DAYS_STR_IVL: "${interval} \u5929",
  MONTHS_STR_IVL: "${interval} \u6708",
  YEARS_STR_IVL: "${interval} \u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  SETTINGS_HEADER: "\u9593\u9694\u91CD\u8907\u5916\u639B - \u8A2D\u5B9A",
  CHECK_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078 <a href="${wiki_url}">wiki</a>.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u8CC7\u6599\u593E",
  FOLDERS_TO_IGNORE_DESC: "\u8F38\u5165\u8CC7\u6599\u593E\u8DEF\u5F91\uFF08\u7528\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1ATemplates Meta/Scripts",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u7C21\u55AE\u6309\u9215\u6587\u5B57",
  FLASHCARD_GOOD_LABEL: "\u8A18\u5F97\u6309\u9215\u6587\u5B57",
  FLASHCARD_HARD_LABEL: "\u8F03\u96E3\u6309\u9215\u6587\u5B57",
  FLASHCARD_EASY_DESC: "\u81EA\u8A02\u300C\u7C21\u55AE\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_GOOD_DESC: "\u81EA\u8A02\u300C\u8A18\u5F97\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_HARD_DESC: "\u81EA\u8A02\u300C\u8F03\u96E3\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_TAGS: "\u5361\u7247\u6A19\u7C64",
  FLASHCARD_TAGS_DESC: "\u8F38\u5165\u6A19\u7C64\uFF08\u7528\u7A7A\u767D\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C07\u8CC7\u6599\u593E\u5167\u5BB9\u8F49\u63DB\u70BA\u724C\u7D44\u548C\u5B50\u724C\u7D44\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9078\u9805\u70BA\u5361\u7247\u6A19\u7C64\u9078\u9805\u7684\u66FF\u4EE3\u9078\u9805\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C07\u8A08\u5283\u91CD\u8907\u6642\u9593\u5132\u5B58\u5728\u5361\u7247\u6700\u5F8C\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u52FE\u9078\u5F8CHTML\u8A3B\u89E3\u4E0D\u6703\u7834\u58DE\u5217\u8868\u683C\u5F0F\u554F\u984C\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C07\u53CD\u8F49\u5361\u7247\u96B1\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u53CD\u8F49\u5361\u7247\u7531\u540C\u4E00\u5361\u7247\u6587\u5B57\u7522\u751F\uFF0C\u4F8B\u5982\uFF1A\u586B\u7A7A\u514B\u6F0F\u5B57",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u986F\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6A19\u984C > \u526F\u6A19\u984C > \u5C0F\u6A19\u984C > ... > \u5C0F\u6A19\u984C",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u5728\u79FB\u52D5\u7AEF\u6216\u9700\u8981\u8F03\u5927\u5716\u7247\u6642\u61C9\u8A2D\u5B9A\u70BA100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u70BA\u9810\u8A2D\u503C",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BEC\u5EA6\u767E\u5206\u6BD4",
  FILENAME_OR_OPEN_FILE: "\u5728\u5FA9\u7FD2\u5361\u7247\u6642\u986F\u793A\u6A94\u540D\u800C\u4E0D\u662F\u300C\u7A0D\u5F8C\u7DE8\u8F2F\u300D\uFF1F",
  RANDOMIZE_CARD_ORDER: "\u5FA9\u7FD2\u6642\u96A8\u6A5F\u986F\u793A\u5361\u7247\uFF1F",
  DISABLE_CLOZE_CARDS: "\u505C\u7528\u586B\u7A7A\u514B\u6F0F\u5B57\u5361\u7247\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C07 ==\u9AD8\u4EAE== \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C07 **\u7C97\u9AD4** \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C07 {{\u5927\u62EC\u865F}} \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  INLINE_CARDS_SEPARATOR: "\u55AE\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9078\u9805\u5F8C\u4F60\u5C07\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u5B57\u5143\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u55AE\u884C\u53CD\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  NOTES: "\u7B46\u8A18",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u5FA9\u7FD2\u6A19\u7C64",
  TAGS_TO_REVIEW_DESC: "\u8F38\u5165\u6A19\u7C64\uFF0C\u7528\u7A7A\u683C\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u5FA9\u7FD2\u96A8\u6A5F\u7B46\u8A18",
  OPEN_RANDOM_NOTE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\uFF0C\u7B46\u8A18\u5C07\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u5FA9\u7FD2\u5F8C\u81EA\u52D5\u6253\u958B\u4E0B\u4E00\u500B\u7B46\u8A18",
  DISABLE_FILE_MENU_REVIEW_OPTIONS: "\u95DC\u9589\u6A94\u6848\u9078\u55AE\u4E2D\u7684\u5FA9\u7FD2\u9078\u9805 \u4F8B\u5982\uFF1A\u5FA9\u7FD2\uFF1A\u7C21\u55AE \u8A18\u5F97 \u8F03\u96E3",
  DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u95DC\u9589\u6A94\u6848\u9078\u55AE\u7684\u5FA9\u7FD2\u9078\u9805\uFF0C\u4F8B\u5982\uFF1A\u5FA9\u7FD2: \u7C21\u55AE \u8A18\u5F97 \u8F03\u96E3\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u908A\u9762\u677F\u986F\u793A\u7684\u6700\u5927\u5929\u6578",
  MIN_ONE_DAY: "\u5929\u6578\u6700\u5C0F\u503C\u70BA1",
  VALID_NUMBER_WARNING: "\u8ACB\u8F38\u5165\u6709\u6548\u7684\u6578\u5B57\u3002",
  UI_PREFERENCES: "\u7528\u6236\u4ECB\u9762\u9996\u9078\u9805",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u724C\u7D44\u6A39\u6700\u521D\u61C9\u986F\u793A\u70BA\u5C55\u958B",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\u53EF\u647A\u758A\u540C\u4E00\u5F35\u5361\u7247\u4E2D\u7684\u5DE2\u72C0\u724C\u7D44\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C6C\u65BC\u540C\u4E00\u6A94\u6848\u4E2D\u7684\u8A31\u591A\u5957\u724C\uFF0C\u5247\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u6F14\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078 <a href="${algo_url}">algorithm implementation</a>.',
  BASE_EASE: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u85A6\u503C\u7D04250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u70BA130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C07\u5FA9\u7FD2\u6642\u6A19\u8A3B\u70BA\u300C\u8F03\u96E3\u300D\u7684\u5361\u7247\u6216\u7B46\u8A18\u5FA9\u7FD2\u9593\u9694\u7E2E\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u5FA9\u7FD2\u9593\u9694 = \u539F\u5FA9\u7FD2\u9593\u9694 * \u9593\u9694\u6539\u8B8A\u4FC2\u6578 / 100.",
  EASY_BONUS: "\u7C21\u55AE\u734E\u52F5",
  EASY_BONUS_DESC: "\u7C21\u55AE\u734E\u52F5\u8A2D\u5B9A\u300C\u8A18\u5F97\u300D\u548C\u300C\u7C21\u55AE\u300D\u5361\u7247\u6216\u7B46\u8A18\u7684\u5FA9\u7FD2\u9593\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7C21\u55AE\u734E\u52F5\u81F3\u5C11\u70BA100\u3002",
  MAX_INTERVAL: "\u6700\u5927\u9593\u9694",
  MAX_INTERVAL_DESC: "\u8A2D\u5B9A\u5FA9\u7FD2\u7684\u6700\u5927\u9593\u9694\u6642\u9593\uFF08\u9810\u8A2D\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u9593\u9694\u81F3\u5C11\u70BA1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u93C8\u63A5\u8CA2\u737B",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "\u8A18\u9304\u4E2D",
  DISPLAY_DEBUG_INFO: "\u5728\u958B\u767C\u8005\u63A7\u5236\u53F0\u4E2D\u986F\u793A\u9664\u932F\u8CC7\u8A0A\uFF1F",
  NOTES_REVIEW_QUEUE: "\u7B46\u8A18\u5FA9\u7FD2\u5E8F\u5217",
  CLOSE: "\u81E8\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9810\u6E2C",
  FORECAST_DESC: "\u5C07\u8981\u5230\u671F\u7684\u5361\u7247\u6578\u91CF",
  SCHEDULED: "\u5DF2\u6392\u7A0B",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6578\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u5FA9\u7FD2${avg} /\u5929",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u5FA9\u7FD2\u7684\u6642\u9593\u9593\u9694",
  COUNT: "\u8A08\u6578",
  INTERVALS_SUMMARY: "\u5E73\u5747\u9593\u9694\u6642\u9593: ${avg}, \u6700\u9577\u9593\u9694\u6642\u9593: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  CARD_TYPES: "\u5361\u7247\u578B\u5225",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C07\u986F\u793A\u96B1\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F03\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u7E3D\u5361\u7247\u6578: ${totalCardsCount}"
};

// src/lang/helpers.ts
var localeMap = {
  af: af_default,
  ar: ar_default,
  bn: bn_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  mr: mr_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  ta: ta_default,
  te: te_default,
  th: th_default,
  tr: tr_default,
  uk: uk_default,
  ur: ur_default,
  vi: vi_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function interpolate(str, params) {
  const names2 = Object.keys(params);
  const vals = Object.values(params);
  return new Function(...names2, `return \`${str}\`;`)(...vals);
}
function t(str, params) {
  if (!locale) {
    console.error(`SRS error: Locale ${import_obsidian.moment.locale()} not found.`);
  }
  const result = locale && locale[str] || en_default[str];
  if (params) {
    return interpolate(result, params);
  }
  return result;
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  flashcardEasyText: t("EASY"),
  flashcardGoodText: t("GOOD"),
  flashcardHardText: t("HARD"),
  flashcardTags: ["#flashcards"],
  convertFoldersToDecks: false,
  cardCommentOnSameLine: false,
  burySiblingCards: false,
  showContextInCards: true,
  flashcardHeightPercentage: import_obsidian2.Platform.isMobile ? 100 : 80,
  flashcardWidthPercentage: import_obsidian2.Platform.isMobile ? 100 : 40,
  showFileNameInFileLink: false,
  randomizeCardOrder: true,
  convertHighlightsToClozes: true,
  convertBoldTextToClozes: false,
  convertCurlyBracketsToClozes: false,
  singleLineCardSeparator: "::",
  singleLineReversedCardSeparator: ":::",
  multilineCardSeparator: "?",
  multilineReversedCardSeparator: "??",
  enableNoteReviewPaneOnStartup: true,
  tagsToReview: ["#review"],
  noteFoldersToIgnore: [],
  openRandomNote: false,
  autoNextNote: false,
  disableFileMenuReviewOptions: false,
  maxNDaysNotesReviewQueue: 365,
  initiallyExpandAllSubdecksInTree: false,
  baseEase: 250,
  lapsesIntervalChange: 0.5,
  easyBonus: 1.3,
  maximumInterval: 36525,
  maxLinkFactor: 1,
  showDebugMessages: false
};
var applyDebounceTimer = 0;
function applySettingsUpdate(callback2) {
  clearTimeout(applyDebounceTimer);
  applyDebounceTimer = window.setTimeout(callback2, 512);
}
var SRSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: `${t("SETTINGS_HEADER")}` });
    containerEl.createDiv().innerHTML = t("CHECK_WIKI", {
      wiki_url: "https://www.stephenmwangi.com/obsidian-spaced-repetition/"
    });
    new import_obsidian2.Setting(containerEl).setName(t("FOLDERS_TO_IGNORE")).setDesc(t("FOLDERS_TO_IGNORE_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.noteFoldersToIgnore.join("\n")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.noteFoldersToIgnore = value.split(/\n+/).map((v) => v.trim()).filter((v) => v);
          await this.plugin.savePluginData();
        });
      })
    );
    containerEl.createEl("h3", { text: `${t("FLASHCARDS")}` });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_TAGS")).setDesc(t("FLASHCARD_TAGS_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.flashcardTags.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardTags = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_FOLDERS_TO_DECKS")).setDesc(t("CONVERT_FOLDERS_TO_DECKS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertFoldersToDecks).onChange(async (value) => {
        this.plugin.data.settings.convertFoldersToDecks = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_SCHEDULING_COMMENTS")).setDesc(t("INLINE_SCHEDULING_COMMENTS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.cardCommentOnSameLine).onChange(async (value) => {
        this.plugin.data.settings.cardCommentOnSameLine = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("BURY_SIBLINGS_TILL_NEXT_DAY")).setDesc(t("BURY_SIBLINGS_TILL_NEXT_DAY_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.burySiblingCards).onChange(async (value) => {
        this.plugin.data.settings.burySiblingCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("SHOW_CARD_CONTEXT")).setDesc(t("SHOW_CARD_CONTEXT_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showContextInCards).onChange(async (value) => {
        this.plugin.data.settings.showContextInCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_HEIGHT_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardHeightPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardHeightPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHeightPercentage = DEFAULT_SETTINGS.flashcardHeightPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("CARD_MODAL_WIDTH_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardWidthPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardWidthPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardWidthPercentage = DEFAULT_SETTINGS.flashcardWidthPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FILENAME_OR_OPEN_FILE")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showFileNameInFileLink).onChange(async (value) => {
        this.plugin.data.settings.showFileNameInFileLink = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("RANDOMIZE_CARD_ORDER")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.randomizeCardOrder).onChange(async (value) => {
        this.plugin.data.settings.randomizeCardOrder = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_HIGHLIGHTS_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertHighlightsToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertHighlightsToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_BOLD_TEXT_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertBoldTextToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertBoldTextToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("CONVERT_CURLY_BRACKETS_TO_CLOZES")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertCurlyBracketsToClozes).onChange(async (value) => {
        this.plugin.data.settings.convertCurlyBracketsToClozes = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineCardSeparator = DEFAULT_SETTINGS.singleLineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("INLINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineReversedCardSeparator = DEFAULT_SETTINGS.singleLineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineCardSeparator = DEFAULT_SETTINGS.multilineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MULTILINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineReversedCardSeparator = DEFAULT_SETTINGS.multilineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_EASY_LABEL")).setDesc(t("FLASHCARD_EASY_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardEasyText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardEasyText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardEasyText = DEFAULT_SETTINGS.flashcardEasyText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_GOOD_LABEL")).setDesc(t("FLASHCARD_GOOD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardGoodText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardGoodText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardGoodText = DEFAULT_SETTINGS.flashcardGoodText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("FLASHCARD_HARD_LABEL")).setDesc(t("FLASHCARD_HARD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardHardText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardHardText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHardText = DEFAULT_SETTINGS.flashcardHardText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("NOTES")}` });
    new import_obsidian2.Setting(containerEl).setName(t("REVIEW_PANE_ON_STARTUP")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.enableNoteReviewPaneOnStartup).onChange(async (value) => {
        this.plugin.data.settings.enableNoteReviewPaneOnStartup = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("TAGS_TO_REVIEW")).setDesc(t("TAGS_TO_REVIEW_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.tagsToReview.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.tagsToReview = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("OPEN_RANDOM_NOTE")).setDesc(t("OPEN_RANDOM_NOTE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.openRandomNote).onChange(async (value) => {
        this.plugin.data.settings.openRandomNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("AUTO_NEXT_NOTE")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.autoNextNote).onChange(async (value) => {
        this.plugin.data.settings.autoNextNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("DISABLE_FILE_MENU_REVIEW_OPTIONS")).setDesc(t("DISABLE_FILE_MENU_REVIEW_OPTIONS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.disableFileMenuReviewOptions).onChange(async (value) => {
        this.plugin.data.settings.disableFileMenuReviewOptions = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(t("MAX_N_DAYS_REVIEW_QUEUE")).addText(
      (text) => text.setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("MIN_ONE_DAY"));
              text.setValue(
                this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()
              );
              return;
            }
            this.plugin.data.settings.maxNDaysNotesReviewQueue = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxNDaysNotesReviewQueue = DEFAULT_SETTINGS.maxNDaysNotesReviewQueue;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("UI_PREFERENCES")}` });
    new import_obsidian2.Setting(containerEl).setName(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE")).setDesc(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.initiallyExpandAllSubdecksInTree).onChange(async (value) => {
        this.plugin.data.settings.initiallyExpandAllSubdecksInTree = value;
        await this.plugin.savePluginData();
      })
    );
    containerEl.createEl("h3", { text: `${t("ALGORITHM")}` });
    containerEl.createDiv().innerHTML = t("CHECK_ALGORITHM_WIKI", {
      algo_url: "https://www.stephenmwangi.com/obsidian-spaced-repetition/algorithms/"
    });
    new import_obsidian2.Setting(containerEl).setName(t("BASE_EASE")).setDesc(t("BASE_EASE_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.baseEase.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 130) {
              new import_obsidian2.Notice(t("BASE_EASE_MIN_WARNING"));
              text.setValue(this.plugin.data.settings.baseEase.toString());
              return;
            }
            this.plugin.data.settings.baseEase = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.baseEase = DEFAULT_SETTINGS.baseEase;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("LAPSE_INTERVAL_CHANGE")).setDesc(t("LAPSE_INTERVAL_CHANGE_DESC")).addSlider(
      (slider) => slider.setLimits(1, 99, 1).setValue(this.plugin.data.settings.lapsesIntervalChange * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.lapsesIntervalChange = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.lapsesIntervalChange = DEFAULT_SETTINGS.lapsesIntervalChange;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("EASY_BONUS")).setDesc(t("EASY_BONUS_DESC")).addText(
      (text) => text.setValue((this.plugin.data.settings.easyBonus * 100).toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value) / 100;
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("EASY_BONUS_MIN_WARNING"));
              text.setValue(
                (this.plugin.data.settings.easyBonus * 100).toString()
              );
              return;
            }
            this.plugin.data.settings.easyBonus = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.easyBonus = DEFAULT_SETTINGS.easyBonus;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_INTERVAL")).setDesc(t("MAX_INTERVAL_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.maximumInterval.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian2.Notice(t("MAX_INTERVAL_MIN_WARNING"));
              text.setValue(
                this.plugin.data.settings.maximumInterval.toString()
              );
              return;
            }
            this.plugin.data.settings.maximumInterval = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian2.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maximumInterval = DEFAULT_SETTINGS.maximumInterval;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("MAX_LINK_CONTRIB")).setDesc(t("MAX_LINK_CONTRIB_DESC")).addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.data.settings.maxLinkFactor * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.maxLinkFactor = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxLinkFactor = DEFAULT_SETTINGS.maxLinkFactor;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: `${t("LOGGING")}` });
    new import_obsidian2.Setting(containerEl).setName(t("DISPLAY_DEBUG_INFO")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showDebugMessages).onChange(async (value) => {
        this.plugin.data.settings.showDebugMessages = value;
        await this.plugin.savePluginData();
      })
    );
  }
};

// src/flashcard-modal.tsx
var import_obsidian3 = require("obsidian");
var import_vhtml = __toESM(require_vhtml());

// src/scheduling.ts
function schedule(response, interval, ease, delayBeforeReview, settingsObj, dueDates) {
  delayBeforeReview = Math.max(0, Math.floor(delayBeforeReview / (24 * 3600 * 1e3)));
  if (response === 0 /* Easy */) {
    ease += 20;
    interval = (interval + delayBeforeReview) * ease / 100;
    interval *= settingsObj.easyBonus;
  } else if (response === 1 /* Good */) {
    interval = (interval + delayBeforeReview / 2) * ease / 100;
  } else if (response === 2 /* Hard */) {
    ease = Math.max(130, ease - 20);
    interval = Math.max(
      1,
      (interval + delayBeforeReview / 4) * settingsObj.lapsesIntervalChange
    );
  }
  if (dueDates !== void 0) {
    interval = Math.round(interval);
    if (!Object.prototype.hasOwnProperty.call(dueDates, interval)) {
      dueDates[interval] = 0;
    } else {
      if (interval > 4) {
        let fuzz = 0;
        if (interval < 7)
          fuzz = 1;
        else if (interval < 30)
          fuzz = Math.max(2, Math.floor(interval * 0.15));
        else
          fuzz = Math.max(4, Math.floor(interval * 0.05));
        const originalInterval = interval;
        outer:
          for (let i = 1; i <= fuzz; i++) {
            for (const ivl of [originalInterval - i, originalInterval + i]) {
              if (!Object.prototype.hasOwnProperty.call(dueDates, ivl)) {
                dueDates[ivl] = 0;
                interval = ivl;
                break outer;
              }
              if (dueDates[ivl] < dueDates[interval])
                interval = ivl;
            }
          }
      }
    }
    dueDates[interval]++;
  }
  interval = Math.min(interval, settingsObj.maximumInterval);
  return { interval: Math.round(interval * 10) / 10, ease };
}
function textInterval(interval, isMobile) {
  const m = Math.round(interval / 3.04375) / 10, y = Math.round(interval / 36.525) / 10;
  if (isMobile) {
    if (m < 1)
      return t("DAYS_STR_IVL_MOBILE", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL_MOBILE", { interval: m });
    else
      return t("YEARS_STR_IVL_MOBILE", { interval: y });
  } else {
    if (m < 1)
      return t("DAYS_STR_IVL", { interval });
    else if (y < 1)
      return t("MONTHS_STR_IVL", { interval: m });
    else
      return t("YEARS_STR_IVL", { interval: y });
  }
}

// src/constants.ts
var SCHEDULING_INFO_REGEX = /^---\n((?:.*\n)*)sr-due: (.+)\nsr-interval: (\d+)\nsr-ease: (\d+)\n((?:.*\n)?)---/;
var YAML_FRONT_MATTER_REGEX = /^---\n((?:.*\n)*?)---/;
var MULTI_SCHEDULING_EXTRACTOR = /!([\d-]+),(\d+),(\d+)/gm;
var LEGACY_SCHEDULING_EXTRACTOR = /<!--SR:([\d-]+),(\d+),(\d+)-->/gm;
var IMAGE_FORMATS = [
  "jpg",
  "jpeg",
  "gif",
  "png",
  "svg",
  "webp",
  "apng",
  "avif",
  "jfif",
  "pjpeg",
  "pjp",
  "bmp"
];
var AUDIO_FORMATS = ["mp3", "webm", "m4a", "wav", "ogg"];
var VIDEO_FORMATS = ["mp4", "mkv", "avi", "mov"];
var COLLAPSE_ICON = '<svg viewBox="0 0 100 100" width="8" height="8" class="right-triangle"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>';

// src/utils.ts
function getTypedObjectEntries(obj) {
  return Object.entries(obj);
}
var getKeysPreserveType = Object.keys;
var escapeRegexString = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
function cyrb53(str, seed = 0) {
  let h12 = 3735928559 ^ seed, h22 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h22 = Math.imul(h22 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h22 ^ h22 >>> 13, 3266489909);
  h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h22) + (h12 >>> 0)).toString(16);
}

// src/flashcard-modal.tsx
var FlashcardModal = class extends import_obsidian3.Modal {
  constructor(app2, plugin, ignoreStats = false) {
    super(app2);
    this.plugin = plugin;
    this.ignoreStats = ignoreStats;
    this.titleEl.setText(t("DECKS"));
    this.titleEl.addClass("sr-centered");
    if (import_obsidian3.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
    this.modalEl.style.height = this.plugin.data.settings.flashcardHeightPercentage + "%";
    this.modalEl.style.width = this.plugin.data.settings.flashcardWidthPercentage + "%";
    this.contentEl.style.position = "relative";
    this.contentEl.style.height = "92%";
    this.contentEl.addClass("sr-modal-content");
    document.body.onkeydown = (e) => {
      if (this.mode !== 0 /* DecksList */) {
        if (this.mode !== 3 /* Closed */ && e.code === "KeyS") {
          this.currentDeck.deleteFlashcardAtIndex(
            this.currentCardIdx,
            this.currentCard.isDue
          );
          this.burySiblingCards(false);
          this.currentDeck.nextCard(this);
        } else if (this.mode === 1 /* Front */ && (e.code === "Space" || e.code === "Enter")) {
          this.showAnswer();
        } else if (this.mode === 2 /* Back */) {
          if (e.code === "Numpad1" || e.code === "Digit1") {
            this.processReview(2 /* Hard */);
          } else if (e.code === "Numpad2" || e.code === "Digit2" || e.code === "Space") {
            this.processReview(1 /* Good */);
          } else if (e.code === "Numpad3" || e.code === "Digit3") {
            this.processReview(0 /* Easy */);
          } else if (e.code === "Numpad0" || e.code === "Digit0") {
            this.processReview(3 /* Reset */);
          }
        }
      }
    };
  }
  onOpen() {
    this.decksList();
  }
  onClose() {
    this.mode = 3 /* Closed */;
  }
  decksList() {
    const aimDeck = this.plugin.deckTree.subdecks.filter(
      (deck) => deck.deckName === this.plugin.data.historyDeck
    );
    if (this.plugin.data.historyDeck && aimDeck.length > 0) {
      const deck = aimDeck[0];
      this.currentDeck = deck;
      this.checkDeck = deck.parent;
      this.setupCardsView();
      deck.nextCard(this);
      return;
    }
    this.mode = 0 /* DecksList */;
    this.titleEl.setText(t("DECKS"));
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("p", { style: "margin:0px;line-height:12px;" }, /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#4caf50;color:#ffffff;",
        "aria-label": t("DUE_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.dueFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#2196f3;",
        "aria-label": t("NEW_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.newFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#ff7043;",
        "aria-label": t("TOTAL_CARDS"),
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.plugin.deckTree.totalFlashcards.toString()
    ));
    this.contentEl.innerHTML = "";
    this.contentEl.setAttribute("id", "sr-flashcard-view");
    for (const deck of this.plugin.deckTree.subdecks) {
      deck.render(this.contentEl, this);
    }
  }
  setupCardsView() {
    this.contentEl.innerHTML = "";
    const historyLinkView = this.contentEl.createEl("button");
    historyLinkView.addClass("sr-back-btn");
    historyLinkView.setAttribute("aria-label", t("BACK"));
    historyLinkView.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewbox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        class: "svg-icon lucide-arrow-left"
      },
      /* @__PURE__ */ (0, import_vhtml.default)("line", { x1: "19", y1: "12", x2: "5", y2: "12" }),
      /* @__PURE__ */ (0, import_vhtml.default)("polyline", { points: "12 19 5 12 12 5" })
    );
    historyLinkView.addEventListener("click", (e) => {
      if (e.pointerType.length > 0) {
        this.plugin.data.historyDeck = "";
        this.decksList();
      }
    });
    this.fileLinkView = this.contentEl.createDiv("sr-link");
    this.fileLinkView.setText(t("EDIT_LATER"));
    if (this.plugin.data.settings.showFileNameInFileLink) {
      this.fileLinkView.setAttribute("aria-label", t("EDIT_LATER"));
    }
    this.fileLinkView.addEventListener("click", async () => {
      const activeLeaf = this.plugin.app.workspace.getLeaf();
      if (this.plugin.app.workspace.getActiveFile() === null)
        await activeLeaf.openFile(this.currentCard.note);
      else {
        const newLeaf = this.plugin.app.workspace.createLeafBySplit(
          activeLeaf,
          "vertical",
          false
        );
        await newLeaf.openFile(this.currentCard.note, { active: true });
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      activeView.editor.setCursor({
        line: this.currentCard.lineNo,
        ch: 0
      });
      this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
      this.burySiblingCards(false);
      this.currentDeck.nextCard(this);
    });
    this.resetLinkView = this.contentEl.createDiv("sr-link");
    this.resetLinkView.setText(t("RESET_CARD_PROGRESS"));
    this.resetLinkView.addEventListener("click", () => {
      this.processReview(3 /* Reset */);
    });
    this.resetLinkView.style.float = "right";
    if (this.plugin.data.settings.showContextInCards) {
      this.contextView = this.contentEl.createDiv();
      this.contextView.setAttribute("id", "sr-context");
    }
    this.flashcardView = this.contentEl.createDiv("div");
    this.flashcardView.setAttribute("id", "sr-flashcard-view");
    this.responseDiv = this.contentEl.createDiv("sr-response");
    this.hardBtn = document.createElement("button");
    this.hardBtn.setAttribute("id", "sr-hard-btn");
    this.hardBtn.setText(this.plugin.data.settings.flashcardHardText);
    this.hardBtn.addEventListener("click", () => {
      this.processReview(2 /* Hard */);
    });
    this.responseDiv.appendChild(this.hardBtn);
    this.goodBtn = document.createElement("button");
    this.goodBtn.setAttribute("id", "sr-good-btn");
    this.goodBtn.setText(this.plugin.data.settings.flashcardGoodText);
    this.goodBtn.addEventListener("click", () => {
      this.processReview(1 /* Good */);
    });
    this.responseDiv.appendChild(this.goodBtn);
    this.easyBtn = document.createElement("button");
    this.easyBtn.setAttribute("id", "sr-easy-btn");
    this.easyBtn.setText(this.plugin.data.settings.flashcardEasyText);
    this.easyBtn.addEventListener("click", () => {
      this.processReview(0 /* Easy */);
    });
    this.responseDiv.appendChild(this.easyBtn);
    this.responseDiv.style.display = "none";
    this.answerBtn = this.contentEl.createDiv();
    this.answerBtn.setAttribute("id", "sr-show-answer");
    this.answerBtn.setText(t("SHOW_ANSWER"));
    this.answerBtn.addEventListener("click", () => {
      this.showAnswer();
    });
    if (this.ignoreStats) {
      this.goodBtn.style.display = "none";
      this.responseDiv.addClass("sr-ignorestats-response");
      this.easyBtn.addClass("sr-ignorestats-btn");
      this.hardBtn.addClass("sr-ignorestats-btn");
    }
  }
  showAnswer() {
    this.mode = 2 /* Back */;
    this.answerBtn.style.display = "none";
    this.responseDiv.style.display = "grid";
    if (this.currentCard.isDue) {
      this.resetLinkView.style.display = "inline-block";
    }
    if (this.currentCard.cardType !== 4 /* Cloze */) {
      const hr = document.createElement("hr");
      hr.setAttribute("id", "sr-hr-card-divide");
      this.flashcardView.appendChild(hr);
    } else {
      this.flashcardView.innerHTML = "";
    }
    this.renderMarkdownWrapper(this.currentCard.back, this.flashcardView);
  }
  async processReview(response) {
    if (this.ignoreStats) {
      if (response == 0 /* Easy */) {
        this.currentDeck.deleteFlashcardAtIndex(
          this.currentCardIdx,
          this.currentCard.isDue
        );
      }
      this.currentDeck.nextCard(this);
      return;
    }
    let interval, ease, due;
    this.currentDeck.deleteFlashcardAtIndex(this.currentCardIdx, this.currentCard.isDue);
    if (response !== 3 /* Reset */) {
      let schedObj;
      if (this.currentCard.isDue) {
        schedObj = schedule(
          response,
          this.currentCard.interval,
          this.currentCard.ease,
          this.currentCard.delayBeforeReview,
          this.plugin.data.settings,
          this.plugin.dueDatesFlashcards
        );
      } else {
        let initial_ease = this.plugin.data.settings.baseEase;
        if (Object.prototype.hasOwnProperty.call(
          this.plugin.easeByPath,
          this.currentCard.note.path
        )) {
          initial_ease = Math.round(this.plugin.easeByPath[this.currentCard.note.path]);
        }
        schedObj = schedule(
          response,
          1,
          initial_ease,
          0,
          this.plugin.data.settings,
          this.plugin.dueDatesFlashcards
        );
        interval = schedObj.interval;
        ease = schedObj.ease;
      }
      interval = schedObj.interval;
      ease = schedObj.ease;
      due = window.moment(Date.now() + interval * 24 * 3600 * 1e3);
    } else {
      this.currentCard.interval = 1;
      this.currentCard.ease = this.plugin.data.settings.baseEase;
      if (this.currentCard.isDue) {
        this.currentDeck.dueFlashcards.push(this.currentCard);
      } else {
        this.currentDeck.newFlashcards.push(this.currentCard);
      }
      due = window.moment(Date.now());
      new import_obsidian3.Notice(t("CARD_PROGRESS_RESET"));
      this.currentDeck.nextCard(this);
      return;
    }
    const dueString = due.format("YYYY-MM-DD");
    let fileText = await this.app.vault.read(this.currentCard.note);
    const replacementRegex = new RegExp(escapeRegexString(this.currentCard.cardText), "gm");
    let sep = this.plugin.data.settings.cardCommentOnSameLine ? " " : "\n";
    if (this.currentCard.cardText.endsWith("```") && sep !== "\n") {
      sep = "\n";
    }
    if (this.currentCard.cardText.lastIndexOf("<!--SR:") === -1) {
      this.currentCard.cardText = this.currentCard.cardText + sep + `<!--SR:!${dueString},${interval},${ease}-->`;
    } else {
      let scheduling = [
        ...this.currentCard.cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)
      ];
      if (scheduling.length === 0) {
        scheduling = [...this.currentCard.cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
      }
      const currCardSched = ["0", dueString, interval.toString(), ease.toString()];
      if (this.currentCard.isDue) {
        scheduling[this.currentCard.siblingIdx] = currCardSched;
      } else {
        scheduling.push(currCardSched);
      }
      this.currentCard.cardText = this.currentCard.cardText.replace(/<!--SR:.+-->/gm, "");
      this.currentCard.cardText += "<!--SR:";
      for (let i = 0; i < scheduling.length; i++) {
        this.currentCard.cardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
      }
      this.currentCard.cardText += "-->";
    }
    fileText = fileText.replace(replacementRegex, () => this.currentCard.cardText);
    for (const sibling of this.currentCard.siblings) {
      sibling.cardText = this.currentCard.cardText;
    }
    if (this.plugin.data.settings.burySiblingCards) {
      this.burySiblingCards(true);
    }
    await this.app.vault.modify(this.currentCard.note, fileText);
    this.currentDeck.nextCard(this);
  }
  async burySiblingCards(tillNextDay) {
    if (tillNextDay) {
      this.plugin.data.buryList.push(cyrb53(this.currentCard.cardText));
      await this.plugin.savePluginData();
    }
    for (const sibling of this.currentCard.siblings) {
      const dueIdx = this.currentDeck.dueFlashcards.indexOf(sibling);
      const newIdx = this.currentDeck.newFlashcards.indexOf(sibling);
      if (dueIdx !== -1) {
        this.currentDeck.deleteFlashcardAtIndex(
          dueIdx,
          this.currentDeck.dueFlashcards[dueIdx].isDue
        );
      } else if (newIdx !== -1) {
        this.currentDeck.deleteFlashcardAtIndex(
          newIdx,
          this.currentDeck.newFlashcards[newIdx].isDue
        );
      }
    }
  }
  async renderMarkdownWrapper(markdownString, containerEl, recursiveDepth = 0) {
    if (recursiveDepth > 4)
      return;
    import_obsidian3.MarkdownRenderer.renderMarkdown(
      markdownString,
      containerEl,
      this.currentCard.note.path,
      this.plugin
    );
    containerEl.findAll(".internal-embed").forEach((el) => {
      const link2 = this.parseLink(el.getAttribute("src"));
      if (!link2.target) {
        el.innerText = link2.text;
      } else if (link2.target instanceof import_obsidian3.TFile) {
        if (link2.target.extension !== "md") {
          this.embedMediaFile(el, link2.target);
        } else {
          el.innerText = "";
          this.renderTransclude(el, link2, recursiveDepth);
        }
      }
    });
  }
  parseLink(src) {
    const linkComponentsRegex = /^(?<file>[^#^]+)?(?:#(?!\^)(?<heading>.+)|#\^(?<blockId>.+)|#)?$/;
    const matched = typeof src === "string" && src.match(linkComponentsRegex);
    const file = matched.groups.file || this.currentCard.note.path;
    const target = this.plugin.app.metadataCache.getFirstLinkpathDest(
      file,
      this.currentCard.note.path
    );
    return {
      text: matched[0],
      file: matched.groups.file,
      heading: matched.groups.heading,
      blockId: matched.groups.blockId,
      target
    };
  }
  embedMediaFile(el, target) {
    el.innerText = "";
    if (IMAGE_FORMATS.includes(target.extension)) {
      el.createEl(
        "img",
        {
          attr: {
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (img) => {
          if (el.hasAttribute("width"))
            img.setAttribute("width", el.getAttribute("width"));
          else
            img.setAttribute("width", "100%");
          if (el.hasAttribute("alt"))
            img.setAttribute("alt", el.getAttribute("alt"));
          el.addEventListener(
            "click",
            (ev) => ev.target.style.minWidth = ev.target.style.minWidth === "100%" ? null : "100%"
          );
        }
      );
      el.addClasses(["image-embed", "is-loaded"]);
    } else if (AUDIO_FORMATS.includes(target.extension) || VIDEO_FORMATS.includes(target.extension)) {
      el.createEl(
        AUDIO_FORMATS.includes(target.extension) ? "audio" : "video",
        {
          attr: {
            controls: "",
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (audio) => {
          if (el.hasAttribute("alt"))
            audio.setAttribute("alt", el.getAttribute("alt"));
        }
      );
      el.addClasses(["media-embed", "is-loaded"]);
    } else {
      el.innerText = target.path;
    }
  }
  async renderTransclude(el, link2, recursiveDepth) {
    var _a, _b, _c, _d;
    const cache = this.app.metadataCache.getCache(link2.target.path);
    const text = await this.app.vault.cachedRead(link2.target);
    let blockText;
    if (link2.heading) {
      const clean = (s) => s.replace(/[\W\s]/g, "");
      const headingIndex = (_a = cache.headings) == null ? void 0 : _a.findIndex(
        (h4) => clean(h4.heading) === clean(link2.heading)
      );
      const heading = cache.headings[headingIndex];
      const startAt = heading.position.start.offset;
      const endAt = ((_d = (_c = (_b = cache.headings.slice(headingIndex + 1).find((h4) => h4.level <= heading.level)) == null ? void 0 : _b.position) == null ? void 0 : _c.start) == null ? void 0 : _d.offset) || text.length;
      blockText = text.substring(startAt, endAt);
    } else if (link2.blockId) {
      const block = cache.blocks[link2.blockId];
      const startAt = block.position.start.offset;
      const endAt = block.position.end.offset;
      blockText = text.substring(startAt, endAt);
    } else {
      blockText = text;
    }
    this.renderMarkdownWrapper(blockText, el, recursiveDepth + 1);
  }
};
var Deck = class {
  constructor(deckName, parent) {
    this.newFlashcardsCount = 0;
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.deckName = deckName;
    this.newFlashcards = [];
    this.newFlashcardsCount = 0;
    this.dueFlashcards = [];
    this.dueFlashcardsCount = 0;
    this.totalFlashcards = 0;
    this.subdecks = [];
    this.parent = parent;
  }
  createDeck(deckPath) {
    if (deckPath.length === 0) {
      return;
    }
    const deckName = deckPath.shift();
    for (const deck2 of this.subdecks) {
      if (deckName === deck2.deckName) {
        deck2.createDeck(deckPath);
        return;
      }
    }
    const deck = new Deck(deckName, this);
    this.subdecks.push(deck);
    deck.createDeck(deckPath);
  }
  insertFlashcard(deckPath, cardObj) {
    if (cardObj.isDue) {
      this.dueFlashcardsCount++;
    } else {
      this.newFlashcardsCount++;
    }
    this.totalFlashcards++;
    if (deckPath.length === 0) {
      if (cardObj.isDue) {
        this.dueFlashcards.push(cardObj);
      } else {
        this.newFlashcards.push(cardObj);
      }
      return;
    }
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.insertFlashcard(deckPath, cardObj);
        return;
      }
    }
  }
  countFlashcard(deckPath, n = 1) {
    this.totalFlashcards += n;
    const deckName = deckPath.shift();
    for (const deck of this.subdecks) {
      if (deckName === deck.deckName) {
        deck.countFlashcard(deckPath, n);
        return;
      }
    }
  }
  deleteFlashcardAtIndex(index, cardIsDue) {
    if (cardIsDue) {
      this.dueFlashcards.splice(index, 1);
      this.dueFlashcardsCount--;
    } else {
      this.newFlashcards.splice(index, 1);
      this.newFlashcardsCount--;
    }
    let deck = this.parent;
    while (deck !== null) {
      if (cardIsDue) {
        deck.dueFlashcardsCount--;
      } else {
        deck.newFlashcardsCount--;
      }
      deck = deck.parent;
    }
  }
  sortSubdecksList() {
    this.subdecks.sort((a, b) => {
      if (a.deckName < b.deckName) {
        return -1;
      } else if (a.deckName > b.deckName) {
        return 1;
      }
      return 0;
    });
    for (const deck of this.subdecks) {
      deck.sortSubdecksList();
    }
  }
  render(containerEl, modal) {
    const deckView = containerEl.createDiv("tree-item");
    const deckViewSelf = deckView.createDiv(
      "tree-item-self tag-pane-tag is-clickable"
    );
    const shouldBeInitiallyExpanded = modal.plugin.data.settings.initiallyExpandAllSubdecksInTree;
    let collapsed = shouldBeInitiallyExpanded;
    let collapseIconEl = null;
    if (this.subdecks.length > 0) {
      collapseIconEl = deckViewSelf.createDiv("tree-item-icon collapse-icon");
      collapseIconEl.innerHTML = COLLAPSE_ICON;
      collapseIconEl.childNodes[0].style.transform = shouldBeInitiallyExpanded ? "" : "rotate(-90deg)";
    }
    const deckViewInner = deckViewSelf.createDiv("tree-item-inner");
    deckViewInner.addEventListener("click", () => {
      modal.plugin.data.historyDeck = this.deckName;
      modal.currentDeck = this;
      modal.checkDeck = this.parent;
      modal.setupCardsView();
      this.nextCard(modal);
    });
    const deckViewInnerText = deckViewInner.createDiv("tag-pane-tag-text");
    deckViewInnerText.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("span", { class: "tag-pane-tag-self" }, this.deckName);
    const deckViewOuter = deckViewSelf.createDiv("tree-item-flair-outer");
    deckViewOuter.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("span", null, /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#4caf50;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.dueFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#2196f3;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.newFlashcardsCount.toString()
    ), /* @__PURE__ */ (0, import_vhtml.default)(
      "span",
      {
        style: "background-color:#ff7043;",
        class: "tag-pane-tag-count tree-item-flair sr-deck-counts"
      },
      this.totalFlashcards.toString()
    ));
    const deckViewChildren = deckView.createDiv("tree-item-children");
    deckViewChildren.style.display = shouldBeInitiallyExpanded ? "block" : "none";
    if (this.subdecks.length > 0) {
      collapseIconEl.addEventListener("click", () => {
        if (collapsed) {
          collapseIconEl.childNodes[0].style.transform = "";
          deckViewChildren.style.display = "block";
        } else {
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deckViewChildren.style.display = "none";
        }
        collapsed = !collapsed;
      });
    }
    for (const deck of this.subdecks) {
      deck.render(deckViewChildren, modal);
    }
  }
  nextCard(modal) {
    if (this.newFlashcards.length + this.dueFlashcards.length === 0) {
      if (this.dueFlashcardsCount + this.newFlashcardsCount > 0) {
        for (const deck of this.subdecks) {
          if (deck.dueFlashcardsCount + deck.newFlashcardsCount > 0) {
            modal.currentDeck = deck;
            deck.nextCard(modal);
            return;
          }
        }
      }
      if (this.parent == modal.checkDeck) {
        modal.plugin.data.historyDeck = "";
        modal.decksList();
      } else {
        this.parent.nextCard(modal);
      }
      return;
    }
    modal.responseDiv.style.display = "none";
    modal.resetLinkView.style.display = "none";
    modal.titleEl.setText(
      `${this.deckName}: ${this.dueFlashcardsCount + this.newFlashcardsCount}`
    );
    modal.answerBtn.style.display = "initial";
    modal.flashcardView.innerHTML = "";
    modal.mode = 1 /* Front */;
    let interval = 1, ease = modal.plugin.data.settings.baseEase, delayBeforeReview = 0;
    if (this.dueFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        modal.currentCardIdx = Math.floor(Math.random() * this.dueFlashcards.length);
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.dueFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      interval = modal.currentCard.interval;
      ease = modal.currentCard.ease;
      delayBeforeReview = modal.currentCard.delayBeforeReview;
    } else if (this.newFlashcards.length > 0) {
      if (modal.plugin.data.settings.randomizeCardOrder) {
        const pickedCardIdx = Math.floor(Math.random() * this.newFlashcards.length);
        modal.currentCardIdx = pickedCardIdx;
        const pickedCard = this.newFlashcards[pickedCardIdx];
        let idx = pickedCardIdx;
        while (idx >= 0 && pickedCard.siblings.includes(this.newFlashcards[idx])) {
          if (!this.newFlashcards[idx].isDue) {
            modal.currentCardIdx = idx;
          }
          idx--;
        }
      } else {
        modal.currentCardIdx = 0;
      }
      modal.currentCard = this.newFlashcards[modal.currentCardIdx];
      modal.renderMarkdownWrapper(modal.currentCard.front, modal.flashcardView);
      if (Object.prototype.hasOwnProperty.call(
        modal.plugin.easeByPath,
        modal.currentCard.note.path
      )) {
        ease = modal.plugin.easeByPath[modal.currentCard.note.path];
      }
    }
    const hardInterval = schedule(
      2 /* Hard */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    const goodInterval = schedule(
      1 /* Good */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    const easyInterval = schedule(
      0 /* Easy */,
      interval,
      ease,
      delayBeforeReview,
      modal.plugin.data.settings
    ).interval;
    if (modal.ignoreStats) {
      modal.hardBtn.setText(`${modal.plugin.data.settings.flashcardHardText}`);
      modal.easyBtn.setText(`${modal.plugin.data.settings.flashcardEasyText}`);
    } else if (import_obsidian3.Platform.isMobile) {
      modal.hardBtn.setText(textInterval(hardInterval, true));
      modal.goodBtn.setText(textInterval(goodInterval, true));
      modal.easyBtn.setText(textInterval(easyInterval, true));
    } else {
      modal.hardBtn.setText(
        `${modal.plugin.data.settings.flashcardHardText} - ${textInterval(
          hardInterval,
          false
        )}`
      );
      modal.goodBtn.setText(
        `${modal.plugin.data.settings.flashcardGoodText} - ${textInterval(
          goodInterval,
          false
        )}`
      );
      modal.easyBtn.setText(
        `${modal.plugin.data.settings.flashcardEasyText} - ${textInterval(
          easyInterval,
          false
        )}`
      );
    }
    if (modal.plugin.data.settings.showContextInCards)
      modal.contextView.setText(modal.currentCard.context);
    if (modal.plugin.data.settings.showFileNameInFileLink)
      modal.fileLinkView.setText(modal.currentCard.note.basename);
  }
};

// src/stats-modal.tsx
var import_obsidian4 = require("obsidian");
var import_vhtml2 = __toESM(require_vhtml());

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h4) => Math.max(Math.min(v, h4), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h4, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h4 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h4, s, v) {
  const f = (n, k = (n + h4 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h4, w, b) {
  const rgb = hsl2rgbn(h4, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h4, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h4 = hueValue(r, g, b, d, max);
    h4 = h4 * 60 + 0.5;
  }
  return [h4 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h4, s, l) {
  return calln(hsl2rgbn, h4, s, l);
}
function hwb2rgb(h4, w, b) {
  return calln(hwb2rgbn, h4, w, b);
}
function hsv2rgb(h4, s, v) {
  return calln(hsv2rgbn, h4, s, v);
}
function hue(h4) {
  return (h4 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h4 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h4, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h4, p1, p2);
  } else {
    v = hsl2rgb(h4, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h4 = rgb2hsl(v);
  h4[0] = hue(h4[0] + deg);
  h4 = hsl2rgb(h4);
  v.r = h4[0];
  v.g = h4[1];
  v.b = h4[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h4 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h4}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h4}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate2(rgb1, rgb2, t2) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t2 * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t2 * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate2(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = /* @__PURE__ */ new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
var atEdge = (t2) => t2 === 0 || t2 === 1;
var elasticIn = (t2, s, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p));
var elasticOut = (t2, s, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p) + 1;
var effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p);
  },
  easeInBack(t2) {
    const s = 1.70158;
    return t2 * t2 * ((s + 1) * t2 - s);
  },
  easeOutBack(t2) {
    const s = 1.70158;
    return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
  },
  easeInOutBack(t2) {
    let s = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m = 7.5625;
    const d = 2.75;
    if (t2 < 1 / d) {
      return m * t2 * t2;
    }
    if (t2 < 2 / d) {
      return m * (t2 -= 1.5 / d) * t2 + 0.75;
    }
    if (t2 < 2.5 / d) {
      return m * (t2 -= 2.25 / d) * t2 + 0.9375;
    }
    return m * (t2 -= 2.625 / d) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash" && name2 !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name2, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name2;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name2],
        writable: true
      },
      [name2]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name2) => !name2.startsWith("on"),
  _indexable: (name2) => name2 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h: h4, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h4 - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h4 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h4);
  ctx.arc(x + w - radius.bottomRight, y + h4 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t2, r, b, l;
  if (isObject(value)) {
    t2 = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t2 = r = b = l = value;
  }
  return {
    top: t2,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset2 = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name2, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset2) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset2 = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset2 && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset2);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset2);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name2) => name2 !== "spacing",
  _indexable: (name2) => name2 !== "spacing"
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  constructor(options) {
    this.options = options || {};
  }
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height1 = chartArea.h * weight;
      const width1 = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);
      }
      stack.start = x;
      stack.placed += height1;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "active", false);
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID1 = Object.keys(position)[0];
      const value1 = position[positionAxisID1];
      titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name2) {
    this.chart.notifyPlugins(name2, this.getContext());
    callback(this.options[name2], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h4 * cos > w * sin ? w / cos : h4 / sin : h4 * sin < w * cos ? h4 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret1 = this._getYAxisLabelAlignment(tl);
      textAlign = ret1.textAlign;
      x = ret1.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t2) => t2.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i1 = 0; i1 < local.length; i1++) {
    const plugin = local[i1];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
  id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);
  if (id) {
    return id;
  }
  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.1.1";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getDatasetArea(meta) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset2);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
      this._updateDataset(i1, isFunction(mode) ? mode({
        datasetIndex: i1
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h4,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox1 of hitboxes) {
        if (hitbox1.col !== col) {
          col = hitbox1.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox1.top = top;
        hitbox1.left += this.left + padding;
        hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
        top += hitbox1.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name2) => !name2.startsWith("on"),
    labels: {
      _scriptable: (name2) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name2)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name2, ctx, arg) {
  const result = callbacks[name2].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name2].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({
      index,
      label: raw
    });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({
      value: Math.round((niceMin + j * spacing) * factor) / factor
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h4, angle) {
  if (angle === 90 || angle === 270) {
    y -= h4 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h4;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h4 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h4) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate3(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate3(table, this.min);
    this._tableRange = interpolate3(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

// src/stats-modal.tsx
Chart.register(
  BarElement,
  BarController,
  plugin_legend,
  plugin_title,
  plugin_tooltip,
  plugin_subtitle,
  CategoryScale,
  LinearScale,
  PieController,
  ArcElement
);
var StatsModal = class extends import_obsidian4.Modal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
    this.titleEl.setText(`${t("STATS_TITLE")} `);
    this.titleEl.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("select", { id: "chartPeriod" }, /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "month", selected: true }, t("MONTH")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "quarter" }, t("QUARTER")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "year" }, t("YEAR")), /* @__PURE__ */ (0, import_vhtml2.default)("option", { value: "lifetime" }, t("LIFETIME")));
    this.modalEl.style.height = "100%";
    this.modalEl.style.width = "100%";
    if (import_obsidian4.Platform.isMobile) {
      this.contentEl.style.display = "block";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.style.textAlign = "center";
    let maxN = Math.max(...getKeysPreserveType(this.plugin.dueDatesFlashcards));
    for (let dueOffset = 0; dueOffset <= maxN; dueOffset++) {
      if (!Object.prototype.hasOwnProperty.call(this.plugin.dueDatesFlashcards, dueOffset)) {
        this.plugin.dueDatesFlashcards[dueOffset] = 0;
      }
    }
    const dueDatesFlashcardsCopy = { 0: 0 };
    for (const [dueOffset, dueCount] of getTypedObjectEntries(this.plugin.dueDatesFlashcards)) {
      if (dueOffset <= 0) {
        dueDatesFlashcardsCopy[0] += dueCount;
      } else {
        dueDatesFlashcardsCopy[dueOffset] = dueCount;
      }
    }
    const cardStats = this.plugin.cardStats;
    const scheduledCount = cardStats.youngCount + cardStats.matureCount;
    maxN = Math.max(maxN, 1);
    contentEl.innerHTML += /* @__PURE__ */ (0, import_vhtml2.default)("div", null, /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "forecastChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "forecastChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "intervalsChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "intervalsChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "easesChart" }), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "easesChartSummary" }), /* @__PURE__ */ (0, import_vhtml2.default)("p", null), /* @__PURE__ */ (0, import_vhtml2.default)("div", { style: "width: 50%; margin: auto;" }, /* @__PURE__ */ (0, import_vhtml2.default)("canvas", { id: "cardTypesChart" })), /* @__PURE__ */ (0, import_vhtml2.default)("span", { id: "cardTypesChartSummary" }));
    createStatsChart(
      "bar",
      "forecastChart",
      t("FORECAST"),
      t("FORECAST_DESC"),
      Object.keys(dueDatesFlashcardsCopy),
      Object.values(dueDatesFlashcardsCopy),
      t("REVIEWS_PER_DAY", { avg: (scheduledCount / maxN).toFixed(1) }),
      t("SCHEDULED"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    maxN = Math.max(...getKeysPreserveType(cardStats.intervals));
    for (let interval = 0; interval <= maxN; interval++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.intervals, interval)) {
        cardStats.intervals[interval] = 0;
      }
    }
    const average_interval = textInterval(
      Math.round(
        getTypedObjectEntries(cardStats.intervals).map(([interval, count]) => interval * count).reduce((a, b) => a + b, 0) / scheduledCount * 10
      ) / 10 || 0,
      false
    ), longest_interval = textInterval(
      Math.max(...getKeysPreserveType(cardStats.intervals)) || 0,
      false
    );
    createStatsChart(
      "bar",
      "intervalsChart",
      t("INTERVALS"),
      t("INTERVALS_DESC"),
      Object.keys(cardStats.intervals),
      Object.values(cardStats.intervals),
      t("INTERVALS_SUMMARY", { avg: average_interval, longest: longest_interval }),
      t("COUNT"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    const eases = getKeysPreserveType(cardStats.eases);
    for (let ease = Math.min(...eases); ease <= Math.max(...eases); ease++) {
      if (!Object.prototype.hasOwnProperty.call(cardStats.eases, ease)) {
        cardStats.eases[ease] = 0;
      }
    }
    const average_ease = Math.round(
      getTypedObjectEntries(cardStats.eases).map(([ease, count]) => ease * count).reduce((a, b) => a + b, 0) / scheduledCount
    ) || 0;
    createStatsChart(
      "bar",
      "easesChart",
      t("EASES"),
      "",
      Object.keys(cardStats.eases),
      Object.values(cardStats.eases),
      t("EASES_SUMMARY", { avgEase: average_ease }),
      t("COUNT"),
      t("EASES"),
      t("NUMBER_OF_CARDS")
    );
    const totalCardsCount = this.plugin.deckTree.totalFlashcards;
    createStatsChart(
      "pie",
      "cardTypesChart",
      t("CARD_TYPES"),
      t("CARD_TYPES_DESC"),
      [
        `${t("CARD_TYPE_NEW")} - ${Math.round(
          cardStats.newCount / totalCardsCount * 100
        )}%`,
        `${t("CARD_TYPE_YOUNG")} - ${Math.round(
          cardStats.youngCount / totalCardsCount * 100
        )}%`,
        `${t("CARD_TYPE_MATURE")} - ${Math.round(
          cardStats.matureCount / totalCardsCount * 100
        )}%`
      ],
      [cardStats.newCount, cardStats.youngCount, cardStats.matureCount],
      t("CARD_TYPES_SUMMARY", { totalCardsCount })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function createStatsChart(type, canvasId, title, subtitle, labels, data, summary, seriesTitle = "", xAxisTitle = "", yAxisTitle = "") {
  let scales = {}, backgroundColor = ["#2196f3"];
  if (type !== "pie") {
    scales = {
      x: {
        title: {
          display: true,
          text: xAxisTitle
        }
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle
        }
      }
    };
  } else {
    backgroundColor = ["#2196f3", "#4caf50", "green"];
  }
  const shouldFilter = canvasId === "forecastChart" || canvasId === "intervalsChart";
  const statsChart = new Chart(document.getElementById(canvasId), {
    type,
    data: {
      labels: shouldFilter ? labels.slice(0, 31) : labels,
      datasets: [
        {
          label: seriesTitle,
          backgroundColor,
          data: shouldFilter ? data.slice(0, 31) : data
        }
      ]
    },
    options: {
      scales,
      plugins: {
        title: {
          display: true,
          text: title,
          font: {
            size: 22
          }
        },
        subtitle: {
          display: true,
          text: subtitle,
          font: {
            size: 16
          }
        },
        legend: {
          display: false
        }
      }
    }
  });
  if (shouldFilter) {
    const chartPeriodEl = document.getElementById("chartPeriod");
    chartPeriodEl.addEventListener("click", () => {
      let filteredLabels, filteredData;
      const chartPeriod = chartPeriodEl.value;
      if (chartPeriod === "month") {
        filteredLabels = labels.slice(0, 31);
        filteredData = data.slice(0, 31);
      } else if (chartPeriod === "quarter") {
        filteredLabels = labels.slice(0, 91);
        filteredData = data.slice(0, 91);
      } else if (chartPeriod === "year") {
        filteredLabels = labels.slice(0, 366);
        filteredData = data.slice(0, 366);
      } else {
        filteredLabels = labels;
        filteredData = data;
      }
      statsChart.data.labels = filteredLabels;
      statsChart.data.datasets[0] = {
        label: seriesTitle,
        backgroundColor,
        data: filteredData
      };
      statsChart.update();
    });
  }
  document.getElementById(`${canvasId}Summary`).innerText = summary;
}

// src/sidebar.ts
var import_obsidian5 = require("obsidian");
var REVIEW_QUEUE_VIEW_TYPE = "review-queue-list-view";
var ReviewQueueListView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.registerEvent(this.app.workspace.on("file-open", () => this.redraw()));
    this.registerEvent(this.app.vault.on("rename", () => this.redraw()));
  }
  getViewType() {
    return REVIEW_QUEUE_VIEW_TYPE;
  }
  getDisplayText() {
    return t("NOTES_REVIEW_QUEUE");
  }
  getIcon() {
    return "SpacedRepIcon";
  }
  onHeaderMenu(menu) {
    menu.addItem((item) => {
      item.setTitle(t("CLOSE")).setIcon("cross").onClick(() => {
        this.app.workspace.detachLeavesOfType(REVIEW_QUEUE_VIEW_TYPE);
      });
    });
  }
  redraw() {
    const activeFile = this.app.workspace.getActiveFile();
    const rootEl = createDiv("nav-folder mod-root");
    const childrenEl = rootEl.createDiv("nav-folder-children");
    for (const deckKey in this.plugin.reviewDecks) {
      const deck = this.plugin.reviewDecks[deckKey];
      const deckCollapsed = !deck.activeFolders.has(deck.deckName);
      const deckFolderEl = this.createRightPaneFolder(
        childrenEl,
        deckKey,
        deckCollapsed,
        false,
        deck
      ).getElementsByClassName("nav-folder-children")[0];
      if (deck.newNotes.length > 0) {
        const newNotesFolderEl = this.createRightPaneFolder(
          deckFolderEl,
          t("NEW"),
          !deck.activeFolders.has(t("NEW")),
          deckCollapsed,
          deck
        );
        for (const newFile of deck.newNotes) {
          const fileIsOpen = activeFile && newFile.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(t("NEW"));
            this.changeFolderIconToExpanded(newNotesFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(
            newNotesFolderEl,
            newFile,
            fileIsOpen,
            !deck.activeFolders.has(t("NEW")),
            deck,
            this.plugin
          );
        }
      }
      if (deck.scheduledNotes.length > 0) {
        const now = Date.now();
        let currUnix = -1;
        let schedFolderEl = null, folderTitle = "";
        const maxDaysToRender = this.plugin.data.settings.maxNDaysNotesReviewQueue;
        for (const sNote of deck.scheduledNotes) {
          if (sNote.dueUnix != currUnix) {
            const nDays = Math.ceil((sNote.dueUnix - now) / (24 * 3600 * 1e3));
            if (nDays > maxDaysToRender) {
              break;
            }
            if (nDays === -1) {
              folderTitle = t("YESTERDAY");
            } else if (nDays === 0) {
              folderTitle = t("TODAY");
            } else if (nDays === 1) {
              folderTitle = t("TOMORROW");
            } else {
              folderTitle = new Date(sNote.dueUnix).toDateString();
            }
            schedFolderEl = this.createRightPaneFolder(
              deckFolderEl,
              folderTitle,
              !deck.activeFolders.has(folderTitle),
              deckCollapsed,
              deck
            );
            currUnix = sNote.dueUnix;
          }
          const fileIsOpen = activeFile && sNote.note.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(folderTitle);
            this.changeFolderIconToExpanded(schedFolderEl);
            this.changeFolderIconToExpanded(deckFolderEl);
          }
          this.createRightPaneFile(
            schedFolderEl,
            sNote.note,
            fileIsOpen,
            !deck.activeFolders.has(folderTitle),
            deck,
            this.plugin
          );
        }
      }
    }
    const contentEl = this.containerEl.children[1];
    contentEl.empty();
    contentEl.appendChild(rootEl);
  }
  createRightPaneFolder(parentEl, folderTitle, collapsed, hidden, deck) {
    const folderEl = parentEl.createDiv("nav-folder");
    const folderTitleEl = folderEl.createDiv("nav-folder-title");
    const childrenEl = folderEl.createDiv("nav-folder-children");
    const collapseIconEl = folderTitleEl.createDiv(
      "nav-folder-collapse-indicator collapse-icon"
    );
    collapseIconEl.innerHTML = COLLAPSE_ICON;
    if (collapsed) {
      collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
    }
    folderTitleEl.createDiv("nav-folder-title-content").setText(folderTitle);
    if (hidden) {
      folderEl.style.display = "none";
    }
    folderTitleEl.onClickEvent(() => {
      for (const child of childrenEl.childNodes) {
        if (child.style.display === "block" || child.style.display === "") {
          child.style.display = "none";
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deck.activeFolders.delete(folderTitle);
        } else {
          child.style.display = "block";
          collapseIconEl.childNodes[0].style.transform = "";
          deck.activeFolders.add(folderTitle);
        }
      }
    });
    return folderEl;
  }
  createRightPaneFile(folderEl, file, fileElActive, hidden, deck, plugin) {
    const navFileEl = folderEl.getElementsByClassName("nav-folder-children")[0].createDiv("nav-file");
    if (hidden) {
      navFileEl.style.display = "none";
    }
    const navFileTitle = navFileEl.createDiv("nav-file-title");
    if (fileElActive) {
      navFileTitle.addClass("is-active");
    }
    navFileTitle.createDiv("nav-file-title-content").setText(file.basename);
    navFileTitle.addEventListener(
      "click",
      async (event) => {
        event.preventDefault();
        plugin.lastSelectedReviewDeck = deck.deckName;
        await this.app.workspace.getLeaf().openFile(file);
        return false;
      },
      false
    );
    navFileTitle.addEventListener(
      "contextmenu",
      (event) => {
        event.preventDefault();
        const fileMenu = new import_obsidian5.Menu();
        this.app.workspace.trigger("file-menu", fileMenu, file, "my-context-menu", null);
        fileMenu.showAtPosition({
          x: event.pageX,
          y: event.pageY
        });
        return false;
      },
      false
    );
  }
  changeFolderIconToExpanded(folderEl) {
    const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
    collapseIconEl.childNodes[0].style.transform = "";
  }
};

// src/review-deck.ts
var import_obsidian6 = require("obsidian");
var ReviewDeck = class {
  constructor(name2) {
    this.newNotes = [];
    this.scheduledNotes = [];
    this.dueNotesCount = 0;
    this.deckName = name2;
    this.activeFolders = /* @__PURE__ */ new Set([this.deckName, t("TODAY")]);
  }
  sortNotes(pageranks) {
    this.newNotes = this.newNotes.sort(
      (a, b) => (pageranks[b.path] || 0) - (pageranks[a.path] || 0)
    );
    this.scheduledNotes = this.scheduledNotes.sort((a, b) => {
      const result = a.dueUnix - b.dueUnix;
      if (result != 0) {
        return result;
      }
      return (pageranks[b.note.path] || 0) - (pageranks[a.note.path] || 0);
    });
  }
};
var ReviewDeckSelectionModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, deckKeys) {
    super(app2);
    this.deckKeys = [];
    this.deckKeys = deckKeys;
  }
  getItems() {
    return this.deckKeys;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(deckKey, _) {
    this.close();
    this.submitCallback(deckKey);
  }
};

// src/parser.ts
function parse2(text, singlelineCardSeparator, singlelineReversedCardSeparator, multilineCardSeparator, multilineReversedCardSeparator, convertHighlightsToClozes, convertBoldTextToClozes, convertCurlyBracketsToClozes) {
  let cardText = "";
  const cards = [];
  let cardType = null;
  let lineNo = 0;
  const lines = text.replaceAll("\r\n", "\n").split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length === 0) {
      if (cardType) {
        cards.push([cardType, cardText, lineNo]);
        cardType = null;
      }
      cardText = "";
      continue;
    } else if (lines[i].startsWith("<!--") && !lines[i].startsWith("<!--SR:")) {
      while (i + 1 < lines.length && !lines[i].includes("-->"))
        i++;
      i++;
      continue;
    }
    if (cardText.length > 0) {
      cardText += "\n";
    }
    cardText += lines[i];
    if (lines[i].includes(singlelineReversedCardSeparator) || lines[i].includes(singlelineCardSeparator)) {
      cardType = lines[i].includes(singlelineReversedCardSeparator) ? 1 /* SingleLineReversed */ : 0 /* SingleLineBasic */;
      cardText = lines[i];
      lineNo = i;
      if (i + 1 < lines.length && lines[i + 1].startsWith("<!--SR:")) {
        cardText += "\n" + lines[i + 1];
        i++;
      }
      cards.push([cardType, cardText, lineNo]);
      cardType = null;
      cardText = "";
    } else if (cardType === null && (convertHighlightsToClozes && /==.*?==/gm.test(lines[i]) || convertBoldTextToClozes && /\*\*.*?\*\*/gm.test(lines[i]) || convertCurlyBracketsToClozes && /{{.*?}}/gm.test(lines[i]))) {
      cardType = 4 /* Cloze */;
      lineNo = i;
    } else if (lines[i] === multilineCardSeparator) {
      cardType = 2 /* MultiLineBasic */;
      lineNo = i;
    } else if (lines[i] === multilineReversedCardSeparator) {
      cardType = 3 /* MultiLineReversed */;
      lineNo = i;
    } else if (lines[i].startsWith("```") || lines[i].startsWith("~~~")) {
      const codeBlockClose = lines[i].match(/`+|~+/)[0];
      while (i + 1 < lines.length && !lines[i + 1].startsWith(codeBlockClose)) {
        i++;
        cardText += "\n" + lines[i];
      }
      cardText += "\n" + codeBlockClose;
      i++;
    }
  }
  if (cardType && cardText) {
    cards.push([cardType, cardText, lineNo]);
  }
  return cards;
}

// src/icons/appicon.ts
var import_obsidian7 = require("obsidian");
function appIcon() {
  (0, import_obsidian7.addIcon)(
    "SpacedRepIcon",
    `<path fill="currentColor" stroke="currentColor" d="M 88.960938 17.257812 L 47.457031 17.257812 C 45.679688 17.257812 44.230469 18.703125 44.230469 20.484375 L 44.230469 86.558594 C 44.230469 88.335938 45.679688 89.785156 47.457031 89.785156 L 88.960938 89.785156 C 90.738281 89.785156 92.1875 88.335938 92.1875 86.558594 L 92.1875 20.484375 C 92.1875 18.703125 90.738281 17.257812 88.960938 17.257812 Z M 88.28125 85.878906 L 48.136719 85.878906 L 48.136719 21.164062 L 88.28125 21.164062 Z M 88.28125 85.878906 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 88.960938 9.445312 L 61.667969 9.445312 C 59.925781 3.816406 54.011719 0.515625 48.269531 2.054688 L 8.183594 12.796875 C 2.304688 14.371094 -1.199219 20.4375 0.378906 26.316406 L 17.476562 90.140625 C 18.796875 95.066406 23.269531 98.324219 28.144531 98.324219 C 29.085938 98.324219 30.046875 98.199219 31 97.945312 L 40.765625 95.328125 C 42.625 96.75 44.941406 97.597656 47.457031 97.597656 L 88.960938 97.597656 C 95.046875 97.597656 100 92.644531 100 86.558594 L 100 20.484375 C 100 14.398438 95.046875 9.445312 88.960938 9.445312 Z M 29.988281 94.171875 C 26.1875 95.191406 22.269531 92.925781 21.25 89.128906 L 4.152344 25.304688 C 3.132812 21.507812 5.394531 17.585938 9.195312 16.570312 L 49.28125 5.828125 C 52.578125 4.945312 55.960938 6.53125 57.464844 9.445312 L 47.457031 9.445312 C 41.371094 9.445312 36.417969 14.398438 36.417969 20.484375 L 36.417969 86.558594 C 36.417969 88.558594 36.957031 90.433594 37.890625 92.054688 Z M 96.09375 86.558594 C 96.09375 90.492188 92.894531 93.691406 88.960938 93.691406 L 47.457031 93.691406 C 43.523438 93.691406 40.324219 90.492188 40.324219 86.558594 L 40.324219 20.484375 C 40.324219 16.550781 43.523438 13.351562 47.457031 13.351562 L 88.960938 13.351562 C 92.894531 13.351562 96.09375 16.550781 96.09375 20.484375 Z M 96.09375 86.558594 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 54.101562 53.09375 L 60.070312 57.410156 L 57.789062 64.378906 C 56.90625 67.074219 59.996094 69.320312 62.285156 67.648438 L 68.210938 63.324219 L 74.132812 67.648438 C 76.421875 69.320312 79.511719 67.074219 78.628906 64.378906 L 76.347656 57.410156 L 82.320312 53.09375 C 84.613281 51.433594 83.441406 47.804688 80.605469 47.804688 L 73.242188 47.804688 L 70.988281 40.839844 C 70.117188 38.144531 66.300781 38.144531 65.429688 40.839844 L 63.179688 47.804688 L 55.8125 47.804688 C 52.980469 47.804688 51.804688 51.433594 54.101562 53.09375 Z M 54.101562 53.09375 "/>
        `
  );
}

// src/main.ts
var DEFAULT_DATA = {
  settings: DEFAULT_SETTINGS,
  buryDate: "",
  buryList: [],
  historyDeck: null
};
var SRPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.syncLock = false;
    this.reviewDecks = {};
    this.newNotes = [];
    this.scheduledNotes = [];
    this.easeByPath = {};
    this.incomingLinks = {};
    this.pageranks = {};
    this.dueNotesCount = 0;
    this.dueDatesNotes = {};
    this.deckTree = new Deck("root", null);
    this.dueDatesFlashcards = {};
  }
  async onload() {
    await this.loadPluginData();
    appIcon();
    this.statusBar = this.addStatusBarItem();
    this.statusBar.classList.add("mod-clickable");
    this.statusBar.setAttribute("aria-label", t("OPEN_NOTE_FOR_REVIEW"));
    this.statusBar.setAttribute("aria-label-position", "top");
    this.statusBar.addEventListener("click", async () => {
      if (!this.syncLock) {
        await this.sync();
        this.reviewNextNoteModal();
      }
    });
    this.addRibbonIcon("SpacedRepIcon", t("REVIEW_CARDS"), async () => {
      if (!this.syncLock) {
        await this.sync();
        new FlashcardModal(this.app, this).open();
      }
    });
    if (!this.data.settings.disableFileMenuReviewOptions) {
      this.registerEvent(
        this.app.workspace.on("file-menu", (menu, fileish) => {
          if (fileish instanceof import_obsidian8.TFile && fileish.extension === "md") {
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_EASY_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 0 /* Easy */);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_GOOD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 1 /* Good */);
              });
            });
            menu.addItem((item) => {
              item.setTitle(t("REVIEW_HARD_FILE_MENU")).setIcon("SpacedRepIcon").onClick(() => {
                this.saveReviewResponse(fileish, 2 /* Hard */);
              });
            });
          }
        })
      );
    }
    this.addCommand({
      id: "srs-note-review-open-note",
      name: t("OPEN_NOTE_FOR_REVIEW"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          this.reviewNextNoteModal();
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-easy",
      name: t("REVIEW_NOTE_EASY_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 0 /* Easy */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-good",
      name: t("REVIEW_NOTE_GOOD_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 1 /* Good */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-hard",
      name: t("REVIEW_NOTE_HARD_CMD"),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveReviewResponse(openFile, 2 /* Hard */);
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards",
      name: t("REVIEW_ALL_CARDS"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          new FlashcardModal(this.app, this).open();
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards-in-note",
      name: t("REVIEW_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.deckTree = new Deck("root", null);
          const deckPath = this.findDeckPath(openFile);
          await this.findFlashcardsInNote(openFile, deckPath);
          new FlashcardModal(this.app, this).open();
        }
      }
    });
    this.addCommand({
      id: "srs-cram-flashcards-in-note",
      name: t("CRAM_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.deckTree = new Deck("root", null);
          const deckPath = this.findDeckPath(openFile);
          await this.findFlashcardsInNote(openFile, deckPath, false, true);
          new FlashcardModal(this.app, this, true).open();
        }
      }
    });
    this.addCommand({
      id: "srs-view-stats",
      name: t("VIEW_STATS"),
      callback: async () => {
        if (!this.syncLock) {
          await this.sync();
          new StatsModal(this.app, this).open();
        }
      }
    });
    this.addSettingTab(new SRSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.initView();
      setTimeout(async () => {
        if (!this.syncLock) {
          await this.sync();
        }
      }, 2e3);
    });
  }
  onunload() {
    this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).forEach((leaf) => leaf.detach());
  }
  async sync() {
    if (this.syncLock) {
      return;
    }
    this.syncLock = true;
    graph.reset();
    this.easeByPath = {};
    this.incomingLinks = {};
    this.pageranks = {};
    this.dueNotesCount = 0;
    this.dueDatesNotes = {};
    this.reviewDecks = {};
    this.deckTree = new Deck("root", null);
    this.dueDatesFlashcards = {};
    this.cardStats = {
      eases: {},
      intervals: {},
      newCount: 0,
      youngCount: 0,
      matureCount: 0
    };
    const now = window.moment(Date.now());
    const todayDate = now.format("YYYY-MM-DD");
    if (todayDate !== this.data.buryDate) {
      this.data.buryDate = todayDate;
      this.data.buryList = [];
    }
    const notes = this.app.vault.getMarkdownFiles();
    for (const note of notes) {
      if (this.data.settings.noteFoldersToIgnore.some(
        (folder) => note.path.startsWith(folder)
      )) {
        continue;
      }
      if (this.incomingLinks[note.path] === void 0) {
        this.incomingLinks[note.path] = [];
      }
      const links = this.app.metadataCache.resolvedLinks[note.path] || {};
      for (const targetPath in links) {
        if (this.incomingLinks[targetPath] === void 0)
          this.incomingLinks[targetPath] = [];
        if (targetPath.split(".").pop().toLowerCase() === "md") {
          this.incomingLinks[targetPath].push({
            sourcePath: note.path,
            linkCount: links[targetPath]
          });
          graph.link(note.path, targetPath, links[targetPath]);
        }
      }
      const deckPath = this.findDeckPath(note);
      if (deckPath.length !== 0) {
        const flashcardsInNoteAvgEase = await this.findFlashcardsInNote(
          note,
          deckPath
        );
        if (flashcardsInNoteAvgEase > 0) {
          this.easeByPath[note.path] = flashcardsInNoteAvgEase;
        }
      }
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const frontmatter = fileCachedData.frontmatter || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      let shouldIgnore = true;
      const matchedNoteTags = [];
      for (const tagToReview of this.data.settings.tagsToReview) {
        if (tags.some((tag) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
          if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, tagToReview)) {
            this.reviewDecks[tagToReview] = new ReviewDeck(tagToReview);
          }
          matchedNoteTags.push(tagToReview);
          shouldIgnore = false;
          break;
        }
      }
      if (shouldIgnore) {
        continue;
      }
      if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
        for (const matchedNoteTag of matchedNoteTags) {
          this.reviewDecks[matchedNoteTag].newNotes.push(note);
        }
        continue;
      }
      const dueUnix = window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
      for (const matchedNoteTag of matchedNoteTags) {
        this.reviewDecks[matchedNoteTag].scheduledNotes.push({ note, dueUnix });
        if (dueUnix <= now.valueOf()) {
          this.reviewDecks[matchedNoteTag].dueNotesCount++;
        }
      }
      if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
        this.easeByPath[note.path] = (this.easeByPath[note.path] + frontmatter["sr-ease"]) / 2;
      } else {
        this.easeByPath[note.path] = frontmatter["sr-ease"];
      }
      if (dueUnix <= now.valueOf()) {
        this.dueNotesCount++;
      }
      const nDays = Math.ceil((dueUnix - now.valueOf()) / (24 * 3600 * 1e3));
      if (!Object.prototype.hasOwnProperty.call(this.dueDatesNotes, nDays)) {
        this.dueDatesNotes[nDays] = 0;
      }
      this.dueDatesNotes[nDays]++;
    }
    graph.rank(0.85, 1e-6, (node, rank2) => {
      this.pageranks[node] = rank2 * 1e4;
    });
    this.deckTree.sortSubdecksList();
    if (this.data.settings.showDebugMessages) {
      console.log(`SR: ${t("EASES")}`, this.easeByPath);
      console.log(`SR: ${t("DECKS")}`, this.deckTree);
    }
    for (const deckKey in this.reviewDecks) {
      this.reviewDecks[deckKey].sortNotes(this.pageranks);
    }
    if (this.data.settings.showDebugMessages) {
      console.log(
        "SR: " + t("SYNC_TIME_TAKEN", {
          t: Date.now() - now.valueOf()
        })
      );
    }
    this.statusBar.setText(
      t("STATUS_BAR", {
        dueNotesCount: this.dueNotesCount,
        dueFlashcardsCount: this.deckTree.dueFlashcardsCount
      })
    );
    if (this.data.settings.enableNoteReviewPaneOnStartup)
      this.reviewQueueView.redraw();
    this.syncLock = false;
  }
  async saveReviewResponse(note, response) {
    const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
    const frontmatter = fileCachedData.frontmatter || {};
    const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
    if (this.data.settings.noteFoldersToIgnore.some((folder) => note.path.startsWith(folder))) {
      new import_obsidian8.Notice(t("NOTE_IN_IGNORED_FOLDER"));
      return;
    }
    let shouldIgnore = true;
    for (const tag of tags) {
      if (this.data.settings.tagsToReview.some(
        (tagToReview) => tag === tagToReview || tag.startsWith(tagToReview + "/")
      )) {
        shouldIgnore = false;
        break;
      }
    }
    if (shouldIgnore) {
      new import_obsidian8.Notice(t("PLEASE_TAG_NOTE"));
      return;
    }
    let fileText = await this.app.vault.read(note);
    let ease, interval, delayBeforeReview;
    const now = Date.now();
    if (!(Object.prototype.hasOwnProperty.call(frontmatter, "sr-due") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-interval") && Object.prototype.hasOwnProperty.call(frontmatter, "sr-ease"))) {
      let linkTotal = 0, linkPGTotal = 0, totalLinkCount = 0;
      for (const statObj of this.incomingLinks[note.path] || []) {
        const ease2 = this.easeByPath[statObj.sourcePath];
        if (ease2) {
          linkTotal += statObj.linkCount * this.pageranks[statObj.sourcePath] * ease2;
          linkPGTotal += this.pageranks[statObj.sourcePath] * statObj.linkCount;
          totalLinkCount += statObj.linkCount;
        }
      }
      const outgoingLinks = this.app.metadataCache.resolvedLinks[note.path] || {};
      for (const linkedFilePath in outgoingLinks) {
        const ease2 = this.easeByPath[linkedFilePath];
        if (ease2) {
          linkTotal += outgoingLinks[linkedFilePath] * this.pageranks[linkedFilePath] * ease2;
          linkPGTotal += this.pageranks[linkedFilePath] * outgoingLinks[linkedFilePath];
          totalLinkCount += outgoingLinks[linkedFilePath];
        }
      }
      const linkContribution = this.data.settings.maxLinkFactor * Math.min(1, Math.log(totalLinkCount + 0.5) / Math.log(64));
      ease = (1 - linkContribution) * this.data.settings.baseEase + (totalLinkCount > 0 ? linkContribution * linkTotal / linkPGTotal : linkContribution * this.data.settings.baseEase);
      if (Object.prototype.hasOwnProperty.call(this.easeByPath, note.path)) {
        ease = (ease + this.easeByPath[note.path]) / 2;
      }
      ease = Math.round(ease);
      interval = 1;
      delayBeforeReview = 0;
    } else {
      interval = frontmatter["sr-interval"];
      ease = frontmatter["sr-ease"];
      delayBeforeReview = now - window.moment(frontmatter["sr-due"], ["YYYY-MM-DD", "DD-MM-YYYY", "ddd MMM DD YYYY"]).valueOf();
    }
    const schedObj = schedule(
      response,
      interval,
      ease,
      delayBeforeReview,
      this.data.settings,
      this.dueDatesNotes
    );
    interval = schedObj.interval;
    ease = schedObj.ease;
    const due = window.moment(now + interval * 24 * 3600 * 1e3);
    const dueString = due.format("YYYY-MM-DD");
    if (SCHEDULING_INFO_REGEX.test(fileText)) {
      const schedulingInfo = SCHEDULING_INFO_REGEX.exec(fileText);
      fileText = fileText.replace(
        SCHEDULING_INFO_REGEX,
        `---
${schedulingInfo[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
${schedulingInfo[5]}---`
      );
    } else if (YAML_FRONT_MATTER_REGEX.test(fileText)) {
      const existingYaml = YAML_FRONT_MATTER_REGEX.exec(fileText);
      fileText = fileText.replace(
        YAML_FRONT_MATTER_REGEX,
        `---
${existingYaml[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---`
      );
    } else {
      fileText = `---
sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---

${fileText}`;
    }
    if (this.data.settings.burySiblingCards) {
      await this.findFlashcardsInNote(note, [], true);
      await this.savePluginData();
    }
    await this.app.vault.modify(note, fileText);
    new import_obsidian8.Notice(t("RESPONSE_RECEIVED"));
    await this.sync();
    if (this.data.settings.autoNextNote) {
      this.reviewNextNote(this.lastSelectedReviewDeck);
    }
  }
  async reviewNextNoteModal() {
    const reviewDeckNames = Object.keys(this.reviewDecks);
    if (reviewDeckNames.length === 1) {
      this.reviewNextNote(reviewDeckNames[0]);
    } else {
      const deckSelectionModal = new ReviewDeckSelectionModal(this.app, reviewDeckNames);
      deckSelectionModal.submitCallback = (deckKey) => this.reviewNextNote(deckKey);
      deckSelectionModal.open();
    }
  }
  async reviewNextNote(deckKey) {
    if (!Object.prototype.hasOwnProperty.call(this.reviewDecks, deckKey)) {
      new import_obsidian8.Notice(t("NO_DECK_EXISTS", { deckName: deckKey }));
      return;
    }
    this.lastSelectedReviewDeck = deckKey;
    const deck = this.reviewDecks[deckKey];
    if (deck.dueNotesCount > 0) {
      const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.dueNotesCount) : 0;
      await this.app.workspace.getLeaf().openFile(deck.scheduledNotes[index].note);
      return;
    }
    if (deck.newNotes.length > 0) {
      const index = this.data.settings.openRandomNote ? Math.floor(Math.random() * deck.newNotes.length) : 0;
      this.app.workspace.getLeaf().openFile(deck.newNotes[index]);
      return;
    }
    new import_obsidian8.Notice(t("ALL_CAUGHT_UP"));
  }
  findDeckPath(note) {
    let deckPath = [];
    if (this.data.settings.convertFoldersToDecks) {
      deckPath = note.path.split("/");
      deckPath.pop();
      if (deckPath.length === 0) {
        deckPath = ["/"];
      }
    } else {
      const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
      const tags = (0, import_obsidian8.getAllTags)(fileCachedData) || [];
      outer:
        for (const tagToReview of this.data.settings.flashcardTags) {
          for (const tag of tags) {
            if (tag === tagToReview || tag.startsWith(tagToReview + "/")) {
              deckPath = tag.substring(1).split("/");
              break outer;
            }
          }
        }
    }
    return deckPath;
  }
  async findFlashcardsInNote(note, deckPath, buryOnly = false, ignoreStats = false) {
    var _a;
    let fileText = await this.app.vault.read(note);
    const fileCachedData = this.app.metadataCache.getFileCache(note) || {};
    const headings = fileCachedData.headings || [];
    let fileChanged = false, totalNoteEase = 0, scheduledCount = 0;
    const settings = this.data.settings;
    const noteDeckPath = deckPath;
    const now = Date.now();
    const parsedCards = parse2(
      fileText,
      settings.singleLineCardSeparator,
      settings.singleLineReversedCardSeparator,
      settings.multilineCardSeparator,
      settings.multilineReversedCardSeparator,
      settings.convertHighlightsToClozes,
      settings.convertBoldTextToClozes,
      settings.convertCurlyBracketsToClozes
    );
    for (const parsedCard of parsedCards) {
      deckPath = noteDeckPath;
      const cardType = parsedCard[0], lineNo = parsedCard[2];
      let cardText = parsedCard[1];
      if (!settings.convertFoldersToDecks) {
        const tagInCardRegEx = /^#[^\s#]+/gi;
        const cardDeckPath = (_a = cardText.match(tagInCardRegEx)) == null ? void 0 : _a.slice(-1)[0].replace("#", "").split("/");
        if (cardDeckPath) {
          deckPath = cardDeckPath;
          cardText = cardText.replaceAll(tagInCardRegEx, "");
        }
      }
      this.deckTree.createDeck([...deckPath]);
      const cardTextHash = cyrb53(cardText);
      if (buryOnly) {
        this.data.buryList.push(cardTextHash);
        continue;
      }
      const siblingMatches = [];
      if (cardType === 4 /* Cloze */) {
        const siblings2 = [];
        if (settings.convertHighlightsToClozes) {
          siblings2.push(...cardText.matchAll(/==(.*?)==/gm));
        }
        if (settings.convertBoldTextToClozes) {
          siblings2.push(...cardText.matchAll(/\*\*(.*?)\*\*/gm));
        }
        if (settings.convertCurlyBracketsToClozes) {
          siblings2.push(...cardText.matchAll(/{{(.*?)}}/gm));
        }
        siblings2.sort((a, b) => {
          if (a.index < b.index) {
            return -1;
          }
          if (a.index > b.index) {
            return 1;
          }
          return 0;
        });
        let front, back;
        for (const m of siblings2) {
          const deletionStart = m.index, deletionEnd = deletionStart + m[0].length;
          front = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>[...]</span>" + cardText.substring(deletionEnd);
          front = front.replace(/==/gm, "").replace(/\*\*/gm, "").replace(/{{/gm, "").replace(/}}/gm, "");
          back = cardText.substring(0, deletionStart) + "<span style='color:#2196f3'>" + cardText.substring(deletionStart, deletionEnd) + "</span>" + cardText.substring(deletionEnd);
          back = back.replace(/==/gm, "").replace(/\*\*/gm, "").replace(/{{/gm, "").replace(/}}/gm, "");
          siblingMatches.push([front, back]);
        }
      } else {
        let idx;
        if (cardType === 0 /* SingleLineBasic */) {
          idx = cardText.indexOf(settings.singleLineCardSeparator);
          siblingMatches.push([
            cardText.substring(0, idx),
            cardText.substring(idx + settings.singleLineCardSeparator.length)
          ]);
        } else if (cardType === 1 /* SingleLineReversed */) {
          idx = cardText.indexOf(settings.singleLineReversedCardSeparator);
          const side1 = cardText.substring(0, idx), side2 = cardText.substring(
            idx + settings.singleLineReversedCardSeparator.length
          );
          siblingMatches.push([side1, side2]);
          siblingMatches.push([side2, side1]);
        } else if (cardType === 2 /* MultiLineBasic */) {
          idx = cardText.indexOf("\n" + settings.multilineCardSeparator + "\n");
          siblingMatches.push([
            cardText.substring(0, idx),
            cardText.substring(idx + 2 + settings.multilineCardSeparator.length)
          ]);
        } else if (cardType === 3 /* MultiLineReversed */) {
          idx = cardText.indexOf("\n" + settings.multilineReversedCardSeparator + "\n");
          const side1 = cardText.substring(0, idx), side2 = cardText.substring(
            idx + 2 + settings.multilineReversedCardSeparator.length
          );
          siblingMatches.push([side1, side2]);
          siblingMatches.push([side2, side1]);
        }
      }
      let scheduling = [...cardText.matchAll(MULTI_SCHEDULING_EXTRACTOR)];
      if (scheduling.length === 0)
        scheduling = [...cardText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
      if (scheduling.length > siblingMatches.length) {
        const idxSched = cardText.lastIndexOf("<!--SR:") + 7;
        let newCardText = cardText.substring(0, idxSched);
        for (let i = 0; i < siblingMatches.length; i++)
          newCardText += `!${scheduling[i][1]},${scheduling[i][2]},${scheduling[i][3]}`;
        newCardText += "-->";
        const replacementRegex = new RegExp(escapeRegexString(cardText), "gm");
        fileText = fileText.replace(replacementRegex, () => newCardText);
        fileChanged = true;
      }
      const context = settings.showContextInCards ? getCardContext(lineNo, headings) : "";
      const siblings = [];
      for (let i = 0; i < siblingMatches.length; i++) {
        const front = siblingMatches[i][0].trim(), back = siblingMatches[i][1].trim();
        const cardObj = {
          isDue: i < scheduling.length,
          note,
          lineNo,
          front,
          back,
          cardText,
          context,
          cardType,
          siblingIdx: i,
          siblings
        };
        if (ignoreStats) {
          this.cardStats.newCount++;
          cardObj.isDue = true;
          this.deckTree.insertFlashcard([...deckPath], cardObj);
        } else if (i < scheduling.length) {
          const dueUnix = window.moment(scheduling[i][1], ["YYYY-MM-DD", "DD-MM-YYYY"]).valueOf();
          const nDays = Math.ceil((dueUnix - now) / (24 * 3600 * 1e3));
          if (!Object.prototype.hasOwnProperty.call(this.dueDatesFlashcards, nDays)) {
            this.dueDatesFlashcards[nDays] = 0;
          }
          this.dueDatesFlashcards[nDays]++;
          const interval = parseInt(scheduling[i][2]), ease = parseInt(scheduling[i][3]);
          if (!Object.prototype.hasOwnProperty.call(this.cardStats.intervals, interval)) {
            this.cardStats.intervals[interval] = 0;
          }
          this.cardStats.intervals[interval]++;
          if (!Object.prototype.hasOwnProperty.call(this.cardStats.eases, ease)) {
            this.cardStats.eases[ease] = 0;
          }
          this.cardStats.eases[ease]++;
          totalNoteEase += ease;
          scheduledCount++;
          if (interval >= 32) {
            this.cardStats.matureCount++;
          } else {
            this.cardStats.youngCount++;
          }
          if (this.data.buryList.includes(cardTextHash)) {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
          if (dueUnix <= now) {
            cardObj.interval = interval;
            cardObj.ease = ease;
            cardObj.delayBeforeReview = now - dueUnix;
            this.deckTree.insertFlashcard([...deckPath], cardObj);
          } else {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
        } else {
          this.cardStats.newCount++;
          if (this.data.buryList.includes(cyrb53(cardText))) {
            this.deckTree.countFlashcard([...deckPath]);
            continue;
          }
          this.deckTree.insertFlashcard([...deckPath], cardObj);
        }
        siblings.push(cardObj);
      }
    }
    if (fileChanged) {
      await this.app.vault.modify(note, fileText);
    }
    if (scheduledCount > 0) {
      const flashcardsInNoteAvgEase = totalNoteEase / scheduledCount;
      const flashcardContribution = Math.min(
        1,
        Math.log(scheduledCount + 0.5) / Math.log(64)
      );
      return flashcardsInNoteAvgEase * flashcardContribution + settings.baseEase * (1 - flashcardContribution);
    }
    return 0;
  }
  async loadPluginData() {
    this.data = Object.assign({}, DEFAULT_DATA, await this.loadData());
    this.data.settings = Object.assign({}, DEFAULT_SETTINGS, this.data.settings);
  }
  async savePluginData() {
    await this.saveData(this.data);
  }
  initView() {
    this.registerView(
      REVIEW_QUEUE_VIEW_TYPE,
      (leaf) => this.reviewQueueView = new ReviewQueueListView(leaf, this)
    );
    if (this.data.settings.enableNoteReviewPaneOnStartup && app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).length == 0) {
      this.app.workspace.getRightLeaf(false).setViewState({
        type: REVIEW_QUEUE_VIEW_TYPE,
        active: true
      });
    }
  }
};
function getCardContext(cardLine, headings) {
  const stack = [];
  for (const heading of headings) {
    if (heading.position.start.line > cardLine) {
      break;
    }
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop();
    }
    stack.push(heading);
  }
  let context = "";
  for (const headingObj of stack) {
    headingObj.heading = headingObj.heading.replace(/\[\^\d+\]/gm, "").trim();
    context += headingObj.heading + " > ";
  }
  return context.slice(0, -3);
}
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.1.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.1.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3BhZ2VyYW5rLmpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvdmh0bWwvc3JjL2VtcHR5LXRhZ3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ZodG1sL3NyYy92aHRtbC5qcyIsICIuLi9zcmMvbWFpbi50cyIsICIuLi9zcmMvc2V0dGluZ3MudHMiLCAiLi4vc3JjL2xhbmcvaGVscGVycy50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvYWYudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2FyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9jei50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvYm4udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2RhLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9kZS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZW4udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2VuLWdiLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9lcy50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZnIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2hpLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9pZC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvaXQudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2phLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9rby50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvbXIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL25sLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9uby50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcGwudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3B0LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9wdC1ici50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcm8udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3J1LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS90YS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdGUudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3RoLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS90ci50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdWsudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3VyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS92aS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvemgtY24udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3poLXR3LnRzIiwgIi4uL3NyYy9mbGFzaGNhcmQtbW9kYWwudHN4IiwgIi4uL3NyYy9zY2hlZHVsaW5nLnRzIiwgIi4uL3NyYy9jb25zdGFudHMudHMiLCAiLi4vc3JjL3V0aWxzLnRzIiwgIi4uL3NyYy9zdGF0cy1tb2RhbC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYnViYmxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucG9sYXJBcmVhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5zY2F0dGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5kb20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmF1dG9za2lwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucmVnaXN0cnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb25maWcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5wb2ludC50cyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZGVjaW1hdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5vcHRpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5sZWdlbmQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaW5kZXgudHMiLCAiLi4vc3JjL3NpZGViYXIudHMiLCAiLi4vc3JjL3Jldmlldy1kZWNrLnRzIiwgIi4uL3NyYy9wYXJzZXIudHMiLCAiLi4vc3JjL2ljb25zL2FwcGljb24udHMiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsbURBQUFBLFNBQUE7QUFBQTtBQUVBLGFBQVMsT0FBTyxRQUFRQyxXQUFVO0FBQzlCLFVBQUssT0FBTyxXQUFXLFlBQWMsT0FBT0EsY0FBYSxZQUFhO0FBQ2xFLGlCQUFTLE9BQU8sUUFBUTtBQUNwQixjQUFJLE9BQU8sZUFBZSxHQUFHLE1BQU0sTUFBTTtBQUNyQyxnQkFBSUEsVUFBUyxLQUFLLE9BQU8sSUFBSSxNQUFNLE9BQU87QUFDdEM7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQUFELFFBQU8sVUFBVyxXQUFZO0FBQzFCLFVBQUksT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsT0FBTyxDQUFDO0FBQUEsUUFDUixPQUFPLENBQUM7QUFBQSxNQUNaO0FBRUEsV0FBSyxPQUFPLFNBQVUsUUFBUSxRQUFRLFFBQVE7QUFDMUMsWUFBSyxTQUFTLE1BQU0sTUFBTSxRQUFVLFdBQVcsTUFBTztBQUNsRCxtQkFBUztBQUFBLFFBQ2I7QUFFQSxpQkFBUyxXQUFXLE1BQU07QUFFMUIsWUFBSSxLQUFLLE1BQU0sZUFBZSxNQUFNLE1BQU0sTUFBTTtBQUM1QyxlQUFLO0FB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Q0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUNMO0FBQ0EsSUFBTSxVQUFVO0FBQUEsRUFDZCxRQUFRO0FBQUEsRUFDUixhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FB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O0FBQzVCLFFBQUksUUFBUSxTQUFTLE1BQU0sT0FBTyxVQUFVO0FBQ3hDO0FBQUEsSUFDSjtBQUVBLFdBQU8sTUFBTSxTQUFTLEtBQUssTUFBTSxNQUFNLFNBQVMsR0FBRyxTQUFTLFFBQVEsT0FBTztBQUN2RSxZQUFNLElBQUk7QUFBQSxJQUNkO0FBRUEsVUFBTSxLQUFLLE9BQU87QUFBQSxFQUN0QjtBQUVBLE1BQUksVUFBVTtBQUNkLGFBQVcsY0FBYyxPQUFPO0FBQzVCLGVBQVcsVUFBVSxXQUFXLFFBQVEsUUFBUSxlQUFlLEVBQUUsRUFBRSxLQUFLO0FBQ3hFLGVBQVcsV0FBVyxVQUFVO0FBQUEsRUFDcEM7QUFDQSxTQUFPLFFBQVEsTUFBTSxHQUFHLEVBQUU7QUFDOUI7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJjYWxsYmFjayIsICJhbHBoYSIsICJlc2MiLCAiU3RyaW5nIiwgInN0ciIsICJyZXBsYWNlIiwgIm1hcCIsICJzIiwgInNldElubmVySFRNTEF0dHIiLCAiRE9NQXR0cmlidXRlTmFtZXMiLCAic2FuaXRpemVkIiwgImgiLCAibmFtZSIsICJhdHRycyIsICJzdGFjayIsICJpIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAicHVzaCIsICJjaGlsZHJlbiIsICJyZXZlcnNlIiwgImVtcHR5VGFncyIsICJpbmRleE9mIiwgIl9faHRtbCIsICJjaGlsZCIsICJwb3AiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJuYW1lcyIsICJjYWxsYmFjayIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImgxIiwgImgyIiwgImFwcCIsICJoIiwgImxpbmsiLCAiZGVjayIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X3ZodG1sIiwgImgiLCAiaCIsICJpbnRlcnBvbGF0ZSIsICJ0IiwgImNvbG9yIiwgIm5vb3AiLCAidWlkIiwgImlkIiwgImlzTnVsbE9yVW5kZWYiLCAidmFsdWUiLCAiaXNBcnJheSIsICJBcnJheSIsICJ0eXBlIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzbGljZSIsICJpc09iamVjdCIsICJpc051bWJlckZpbml0ZSIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiZmluaXRlT3JEZWZhdWx0IiwgImRlZmF1bHRWYWx1ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1BlcmNlbnRhZ2UiLCAiZGltZW5zaW9uIiwgImVuZHNXaXRoIiwgInBhcnNlRmxvYXQiLCAidG9EaW1lbnNpb24iLCAiY2FsbGJhY2siLCAiZm4iLCAiYXJncyIsICJ0aGlzQXJnIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImxlbmd0aCIsICJfZWxlbWVudHNFcXVhbCIsICJhMCIsICJhMSIsICJpbGVuIiwgInYwIiwgInYxIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJjbG9uZSIsICJzb3VyY2UiLCAibWFwIiwgInRhcmdldCIsICJjcmVhdGUiLCAia2xlbiIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgIm1lcmdlciIsICJjdXJyZW50IiwgIm1lcmdlSWYiLCAiX21lcmdlcklmIiwgImhhc093blByb3BlcnR5IiwgImtleVJlc29sdmVycyIsICJ2IiwgIngiLCAibyIsICJ5IiwgIl9zcGxpdEtleSIsICJrZXkiLCAicGFydHMiLCAic3BsaXQiLCAia2V5cyIsICJ0bXAiLCAicGFydCIsICJlbmRzV2l0aCIsICJzbGljZSIsICJwdXNoIiwgIl9nZXRLZXlSZXNvbHZlciIsICJvYmoiLCAiayIsICJyZXNvbHZlT2JqZWN0S2V5IiwgInJlc29sdmVyIiwgIl9jYXBpdGFsaXplIiwgInN0ciIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiZGVmaW5lZCIsICJ2YWx1ZSIsICJpc0Z1bmN0aW9uIiwgInNldHNFcXVhbCIsICJhIiwgImIiLCAic2l6ZSIsICJpdGVtIiwgImhhcyIsICJfaXNDbGlja0V2ZW50IiwgImUiLCAidHlwZSIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAiZXBzaWxvbiIsICJhYnMiLCAibmljZU51bSIsICJyYW5nZSIsICJyb3VuZGVkUmFuZ2UiLCAicm91bmQiLCAibmljZVJhbmdlIiwgInBvdyIsICJmbG9vciIsICJmcmFjdGlvbiIsICJuaWNlRnJhY3Rpb24iLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAic3FydCIsICJpIiwgInNvcnQiLCAicG9wIiwgImlzTnVtYmVyIiwgIm4iLCAiaXNOYU4iLCAicGFyc2VGbG9hdCIsICJpc0Zpbml0ZSIsICJhbG1vc3RXaG9sZSIsICJyb3VuZGVkIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJhcnJheSIsICJ0YXJnZXQiLCAicHJvcGVydHkiLCAiaWxlbiIsICJsZW5ndGgiLCAibWluIiwgIm1heCIsICJ0b1JhZGlhbnMiLCAiZGVncmVlcyIsICJ0b0RlZ3JlZXMiLCAicmFkaWFucyIsICJfZGVjaW1hbFBsYWNlcyIsICJpc0Zpbml0ZU51bWJlciIsICJwIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImNlbnRyZVBvaW50IiwgImFuZ2xlUG9pbnQiLCAiZGlzdGFuY2VGcm9tWENlbnRlciIsICJkaXN0YW5jZUZyb21ZQ2VudGVyIiwgInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsICJhbmdsZSIsICJhdGFuMiIsICJkaXN0YW5jZSIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAicHQxIiwgInB0MiIsICJfbm9ybWFsaXplQW5nbGUiLCAiYSIsICJUQVUiLCAiX2FuZ2xlQmV0d2VlbiIsICJhbmdsZSIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiZSIsICJhbmdsZVRvU3RhcnQiLCAiYW5nbGVUb0VuZCIsICJzdGFydFRvQW5nbGUiLCAiZW5kVG9BbmdsZSIsICJfbGltaXRWYWx1ZSIsICJ2YWx1ZSIsICJtaW4iLCAibWF4IiwgIk1hdGgiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJlcHNpbG9uIiwgIl9sb29rdXAiLCAidGFibGUiLCAiY21wIiwgImluZGV4IiwgImhpIiwgImxlbmd0aCIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgInNsaWNlIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImFycmF5IiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJwdXNoIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAiaSIsICJpbGVuIiwgImFkZCIsICJzaXplIiwgIkFycmF5IiwgImZyb20iLCAicmVxdWVzdEFuaW1GcmFtZSIsICJ3aW5kb3ciLCAiY2FsbGJhY2siLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgInRocm90dGxlZCIsICJmbiIsICJ0aGlzQXJnIiwgImFyZ3NUb1VzZSIsICJ0aWNraW5nIiwgImFyZ3MiLCAiY2FsbCIsICJhcHBseSIsICJkZWJvdW5jZSIsICJkZWxheSIsICJ0aW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgIl90b0xlZnRSaWdodENlbnRlciIsICJhbGlnbiIsICJfYWxpZ25TdGFydEVuZCIsICJzdGFydCIsICJlbmQiLCAiX3RleHRYIiwgImxlZnQiLCAicmlnaHQiLCAicnRsIiwgImNoZWNrIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAiTWF0aCIsICJwb3ciLCAic2luIiwgIlRBVSIsICJlbGFzdGljT3V0IiwgImVmZmVjdHMiLCAibGluZWFyIiwgImVhc2VJblF1YWQiLCAiZWFzZU91dFF1YWQiLCAiZWFzZUluT3V0UXVhZCIsICJlYXNlSW5DdWJpYyIsICJlYXNlT3V0Q3ViaWMiLCAiZWFzZUluT3V0Q3ViaWMiLCAiZWFzZUluUXVhcnQiLCAiZWFzZU91dFF1YXJ0IiwgImVhc2VJbk91dFF1YXJ0IiwgImVhc2VJblF1aW50IiwgImVhc2VPdXRRdWludCIsICJlYXNlSW5PdXRRdWludCIsICJlYXNlSW5TaW5lIiwgImNvcyIsICJIQUxGX1BJIiwgImVhc2VPdXRTaW5lIiwgImVhc2VJbk91dFNpbmUiLCAiUEkiLCAiZWFzZUluRXhwbyIsICJlYXNlT3V0RXhwbyIsICJlYXNlSW5PdXRFeHBvIiwgImVhc2VJbkNpcmMiLCAic3FydCIsICJlYXNlT3V0Q2lyYyIsICJlYXNlSW5PdXRDaXJjIiwgImVhc2VJbkVsYXN0aWMiLCAiZWFzZU91dEVsYXN0aWMiLCAiZWFzZUluT3V0RWxhc3RpYyIsICJlYXNlSW5CYWNrIiwgImVhc2VPdXRCYWNrIiwgImVhc2VJbk91dEJhY2siLCAiZWFzZUluQm91bmNlIiwgImVhc2VPdXRCb3VuY2UiLCAibSIsICJkIiwgImVhc2VJbk91dEJvdW5jZSIsICJpc1BhdHRlcm5PckdyYWRpZW50IiwgInZhbHVlIiwgInR5cGUiLCAidG9TdHJpbmciLCAiY29sb3IiLCAiQ29sb3IiLCAiZ2V0SG92ZXJDb2xvciIsICJzYXR1cmF0ZSIsICJkYXJrZW4iLCAiaGV4U3RyaW5nIiwgIm51bWJlcnMiLCAiY29sb3JzIiwgImFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzIiwgImRlZmF1bHRzIiwgInNldCIsICJkZWxheSIsICJ1bmRlZmluZWQiLCAiZHVyYXRpb24iLCAiZWFzaW5nIiwgImZuIiwgImZyb20iLCAibG9vcCIsICJ0byIsICJkZXNjcmliZSIsICJfZmFsbGJhY2siLCAiX2luZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInByb3BlcnRpZXMiLCAiYWN0aXZlIiwgImFuaW1hdGlvbiIsICJyZXNpemUiLCAic2hvdyIsICJhbmltYXRpb25zIiwgInZpc2libGUiLCAiaGlkZSIsICJ2IiwgImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwgImF1dG9QYWRkaW5nIiwgInBhZGRpbmciLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJvcHRpb25zIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJsZW5ndGgiLCAibWF4VGljayIsICJtYXgiLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAibWluIiwgImZsb29yIiwgIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsICJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiY2FsbCIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAicmV2ZXJzZSIsICJiZWdpbkF0WmVybyIsICJib3VuZHMiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgImNhbGxiYWNrIiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImFsaWduIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJhcHBseSIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiaXNOYU4iLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAiY2xpcCIsICJ1bmNsaXBBcmVhIiwgInJlbmRlclRleHQiLCAiY3R4IiwgInRleHQiLCAieCIsICJ5IiwgImZvbnQiLCAib3B0cyIsICJsaW5lcyIsICJpc0FycmF5IiwgInN0cm9rZSIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJpIiwgImxpbmUiLCAic2F2ZSIsICJzdHJpbmciLCAic2V0UmVuZGVyT3B0cyIsICJsZW5ndGgiLCAiYmFja2Ryb3AiLCAiZHJhd0JhY2tkcm9wIiwgInN0cm9rZVN0eWxlIiwgImlzTnVsbE9yVW5kZWYiLCAibGluZVdpZHRoIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmVIZWlnaHQiLCAicmVzdG9yZSIsICJ0cmFuc2xhdGlvbiIsICJ0cmFuc2xhdGUiLCAicm90YXRpb24iLCAicm90YXRlIiwgImNvbG9yIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAibWVhc3VyZVRleHQiLCAibGVmdCIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAicmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJ0b3AiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYm90dG9tIiwgImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsICJ5RGVjb3JhdGlvbiIsICJiZWdpblBhdGgiLCAiZGVjb3JhdGlvbldpZHRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAid2lkdGgiLCAiaGVpZ2h0IiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJyZWN0IiwgInciLCAiaCIsICJyYWRpdXMiLCAiYXJjIiwgInRvcExlZnQiLCAiSEFMRl9QSSIsICJQSSIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgInRvcFJpZ2h0IiwgIkxJTkVfSEVJR0hUIiwgIkZPTlRfU1RZTEUiLCAidG9MaW5lSGVpZ2h0IiwgInZhbHVlIiwgInNpemUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAidiIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAiaXNPYmplY3QiLCAia2V5cyIsICJPYmplY3QiLCAicmVhZCIsICJwcm9wIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgIm9wdGlvbnMiLCAiZmFsbGJhY2siLCAiZGVmYXVsdHMiLCAicGFyc2VJbnQiLCAic3R5bGUiLCAiY29uc29sZSIsICJ3YXJuIiwgInVuZGVmaW5lZCIsICJmYW1pbHkiLCAid2VpZ2h0IiwgInRvRm9udFN0cmluZyIsICJyZXNvbHZlIiwgImlucHV0cyIsICJjb250ZXh0IiwgImluZGV4IiwgImluZm8iLCAiY2FjaGVhYmxlIiwgImlsZW4iLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJncmFjZSIsICJiZWdpbkF0WmVybyIsICJtaW4iLCAibWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiTWF0aCIsICJhYnMiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgImFzc2lnbiIsICJjcmVhdGUiLCAiX2NyZWF0ZVJlc29sdmVyIiwgInNjb3BlcyIsICJwcmVmaXhlcyIsICJyb290U2NvcGVzIiwgImdldFRhcmdldCIsICJkZWZpbmVkIiwgIl9yZXNvbHZlIiwgImNhY2hlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2ZhbGxiYWNrIiwgIl9nZXRUYXJnZXQiLCAib3ZlcnJpZGUiLCAic2NvcGUiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAidGFyZ2V0IiwgIl9rZXlzIiwgImdldCIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJpbmNsdWRlcyIsICJvd25LZXlzIiwgInNldCIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAiX2Rlc2NyaXB0b3JzIiwgInNldENvbnRleHQiLCAicmVjZWl2ZXIiLCAiX3Jlc29sdmVXaXRoQ29udGV4dCIsICJhbGxLZXlzIiwgImVudW1lcmFibGUiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAibmFtZSIsICJfY2FwaXRhbGl6ZSIsICJuZWVkc1N1YlJlc29sdmVyIiwgImNvbnN0cnVjdG9yIiwgInByb3RvdHlwZSIsICJoYXNPd25Qcm9wZXJ0eSIsICJjYWxsIiwgImRlc2NyaXB0b3JzIiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgIkVycm9yIiwgIkFycmF5IiwgImZyb20iLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJzIiwgIml0ZW0iLCAicmVzb2x2ZXIiLCAicHVzaCIsICJyZXNvbHZlRmFsbGJhY2siLCAiZ2V0U2NvcGUiLCAia2V5IiwgInBhcmVudCIsICJyZXNvbHZlT2JqZWN0S2V5IiwgImFkZFNjb3BlcyIsICJwYXJlbnRTY29wZXMiLCAicGFyZW50RmFsbGJhY2siLCAiYWxsU2NvcGVzIiwgImFkZFNjb3Blc0Zyb21LZXkiLCAic3ViR2V0VGFyZ2V0IiwgInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsICJrIiwgInN0YXJ0c1dpdGgiLCAiRVBTSUxPTiIsICJOdW1iZXIiLCAiX2lzRG9tU3VwcG9ydGVkIiwgIndpbmRvdyIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudCIsICJwYXJlbnROb2RlIiwgInRvU3RyaW5nIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgIm5vZGUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJwYXJzZUludCIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3R5bGUiLCAic3VmZml4IiwgInJlc3VsdCIsICJpIiwgInBvcyIsICJwYXJzZUZsb2F0IiwgIndpZHRoIiwgImxlZnQiLCAicmlnaHQiLCAiaGVpZ2h0IiwgInRvcCIsICJib3R0b20iLCAidXNlT2Zmc2V0UG9zIiwgIngiLCAieSIsICJ0YXJnZXQiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgImNhbnZhcyIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJsZW5ndGgiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgImJveCIsICJyZWN0IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJjaGFydCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgIk1hdGgiLCAicm91bmQiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAidW5kZWZpbmVkIiwgImNvbnRhaW5lciIsICJjbGllbnRXaWR0aCIsICJjbGllbnRIZWlnaHQiLCAiY29udGFpbmVyU3R5bGUiLCAiY29udGFpbmVyQm9yZGVyIiwgImNvbnRhaW5lclBhZGRpbmciLCAiSU5GSU5JVFkiLCAicm91bmQxIiwgInYiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWF4IiwgIm1pbiIsICJtYWludGFpbkhlaWdodCIsICJmbG9vciIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAiY3R4IiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAib3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAidmFsdWUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAid2lkdGgiLCAieCIsICJzZXRXaWR0aCIsICJ3IiwgInRleHRBbGlnbiIsICJhbGlnbiIsICJ4UGx1cyIsICJ2YWx1ZSIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgInJ0bCIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiY3R4IiwgImRpcmVjdGlvbiIsICJzdHlsZSIsICJvcmlnaW5hbCIsICJjYW52YXMiLCAiZ2V0UHJvcGVydHlWYWx1ZSIsICJnZXRQcm9wZXJ0eVByaW9yaXR5IiwgInNldFByb3BlcnR5IiwgInByZXZUZXh0RGlyZWN0aW9uIiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInVuZGVmaW5lZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAibWV0YSIsICJzdGFja2VkIiwgImdldFN0YWNrS2V5IiwgImluZGV4U2NhbGUiLCAidmFsdWVTY2FsZSIsICJpZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJOdW1iZXIiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiZ2V0T3JDcmVhdGVTdGFjayIsICJzdGFja3MiLCAic3RhY2tLZXkiLCAiaW5kZXhWYWx1ZSIsICJzdWJTdGFjayIsICJnZXRMYXN0SW5kZXhJblN0YWNrIiwgInZTY2FsZSIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpU2NhbGUiLCAiaUF4aXMiLCAiYXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAiaUF4aXNLZXkiLCAidkF4aXNLZXkiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAic2tpcE51bGwiLCAidmFsIiwgImlzTmFOIiwgImluZGV4T2YiLCAiX2dldFN0YWNrQ291bnQiLCAiX2dldFN0YWNrSW5kZXgiLCAibmFtZSIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiYmFzZVZhbHVlIiwgIm1pbkJhckxlbmd0aCIsICJmbG9hdGluZyIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJzdGFydFBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJlbmRQaXhlbCIsICJnZXRWYWx1ZUZvclBpeGVsIiwgImhhbGZHcmlkIiwgImdldExpbmVXaWR0aEZvclZhbHVlIiwgIm1heEJhclRoaWNrbmVzcyIsICJJbmZpbml0eSIsICJzdGFja0luZGV4IiwgInJlY3RzIiwgIm51bWJlcnMiLCAib3ZlcnJpZGVzIiwgIl9pbmRleF8iLCAib2Zmc2V0IiwgImdyaWQiLCAiX3ZhbHVlXyIsICJiZWdpbkF0WmVybyIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiTWF0aCIsICJjb3MiLCAic3RhcnRZIiwgInNpbiIsICJlbmRYIiwgImVuZFkiLCAiY2FsY01heCIsICJhbmdsZSIsICJhIiwgImIiLCAiX2FuZ2xlQmV0d2VlbiIsICJtYXgiLCAiY2FsY01pbiIsICJtaW4iLCAibWF4WCIsICJtYXhZIiwgIkhBTEZfUEkiLCAibWluWCIsICJQSSIsICJtaW5ZIiwgIkRvdWdobnV0Q29udHJvbGxlciIsICJEYXRhc2V0Q29udHJvbGxlciIsICJjb25zdHJ1Y3RvciIsICJjaGFydCIsICJkYXRhc2V0SW5kZXgiLCAiZW5hYmxlT3B0aW9uU2hhcmluZyIsICJpbm5lclJhZGl1cyIsICJ1bmRlZmluZWQiLCAib3V0ZXJSYWRpdXMiLCAibGlua1NjYWxlcyIsICJwYXJzZSIsICJzdGFydCIsICJjb3VudCIsICJkYXRhIiwgImdldERhdGFzZXQiLCAibWV0YSIsICJfY2FjaGVkTWV0YSIsICJfcGFyc2luZyIsICJfcGFyc2VkIiwgImdldHRlciIsICJpIiwgImlzT2JqZWN0IiwgImtleSIsICJyZXNvbHZlT2JqZWN0S2V5IiwgImlsZW4iLCAiX2dldFJvdGF0aW9uIiwgInRvUmFkaWFucyIsICJvcHRpb25zIiwgIl9nZXRDaXJjdW1mZXJlbmNlIiwgIl9nZXRSb3RhdGlvbkV4dGVudHMiLCAiZGF0YXNldHMiLCAibGVuZ3RoIiwgImlzRGF0YXNldFZpc2libGUiLCAiZ2V0RGF0YXNldE1ldGEiLCAidHlwZSIsICJfdHlwZSIsICJjb250cm9sbGVyIiwgInVwZGF0ZSIsICJtb2RlIiwgImNoYXJ0QXJlYSIsICJhcmNzIiwgInNwYWNpbmciLCAiZ2V0TWF4Qm9yZGVyV2lkdGgiLCAiZ2V0TWF4T2Zmc2V0IiwgIm1heFNpemUiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInRvUGVyY2VudGFnZSIsICJjaGFydFdlaWdodCIsICJfZ2V0UmluZ1dlaWdodCIsICJpbmRleCIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAibWF4UmFkaXVzIiwgInRvRGltZW5zaW9uIiwgInJhZGl1cyIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAidXBkYXRlRWxlbWVudHMiLCAiX2NpcmN1bWZlcmVuY2UiLCAicmVzZXQiLCAib3B0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZVJvdGF0ZSIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJoaWRkZW4iLCAiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsICJhbmltYXRpb25PcHRzIiwgImNlbnRlclgiLCAibGVmdCIsICJyaWdodCIsICJjZW50ZXJZIiwgInRvcCIsICJib3R0b20iLCAiYW5pbWF0ZVNjYWxlIiwgInNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAiX2dldFNoYXJlZE9wdGlvbnMiLCAiYXJjIiwgInByb3BlcnRpZXMiLCAieCIsICJ5IiwgInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCAiYWN0aXZlIiwgInVwZGF0ZUVsZW1lbnQiLCAibWV0YURhdGEiLCAidmFsdWUiLCAiaXNOYU4iLCAiYWJzIiwgImdldExhYmVsQW5kVmFsdWUiLCAibGFiZWxzIiwgImZvcm1hdE51bWJlciIsICJsb2NhbGUiLCAibGFiZWwiLCAiYm9yZGVyQWxpZ24iLCAiYm9yZGVyV2lkdGgiLCAiaG92ZXJCb3JkZXJXaWR0aCIsICJvZmZzZXQiLCAiaG92ZXJPZmZzZXQiLCAicmluZ1dlaWdodE9mZnNldCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ3ZWlnaHQiLCAiaWQiLCAiZGVmYXVsdHMiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJhbmltYXRpb25zIiwgIm51bWJlcnMiLCAiaW5kZXhBeGlzIiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAiX2luZGV4YWJsZSIsICJvdmVycmlkZXMiLCAiYXNwZWN0UmF0aW8iLCAicGx1Z2lucyIsICJsZWdlbmQiLCAiZ2VuZXJhdGVMYWJlbHMiLCAicG9pbnRTdHlsZSIsICJjb2xvciIsICJtYXAiLCAic3R5bGUiLCAiZ2V0U3R5bGUiLCAidGV4dCIsICJmaWxsU3R5bGUiLCAiYmFja2dyb3VuZENvbG9yIiwgInN0cm9rZVN0eWxlIiwgImJvcmRlckNvbG9yIiwgImZvbnRDb2xvciIsICJsaW5lV2lkdGgiLCAib25DbGljayIsICJlIiwgImxlZ2VuZEl0ZW0iLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiUGllQ29udHJvbGxlciIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaWQiLCAiZGVmYXVsdHMiLCAiY3V0b3V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAicmFkaXVzIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAicHJvdG90eXBlIiwgImNvbnN0cnVjdG9yIiwgIm9wdGlvbnMiLCAiaW5pdCIsICJmb3JtYXRzIiwgInBhcnNlIiwgImZvcm1hdCIsICJhZGQiLCAiZGlmZiIsICJzdGFydE9mIiwgImVuZE9mIiwgIl9kYXRlIiwgImJpbmFyeVNlYXJjaCIsICJtZXRhc2V0IiwgImF4aXMiLCAidmFsdWUiLCAiaW50ZXJzZWN0IiwgImNvbnRyb2xsZXIiLCAiZGF0YSIsICJfc29ydGVkIiwgImlTY2FsZSIsICJfY2FjaGVkTWV0YSIsICJsZW5ndGgiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgIl9zaGFyZWRPcHRpb25zIiwgImVsIiwgInJhbmdlIiwgImdldFJhbmdlIiwgInN0YXJ0IiwgImVuZCIsICJsbyIsICJoaSIsICJldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMiLCAiY2hhcnQiLCAicG9zaXRpb24iLCAiaGFuZGxlciIsICJtZXRhc2V0cyIsICJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwgImkiLCAiaWxlbiIsICJpbmRleCIsICJqIiwgImVsZW1lbnQiLCAic2tpcCIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJpbmRleE9mIiwgInVzZVkiLCAicHQxIiwgInB0MiIsICJkZWx0YVgiLCAiTWF0aCIsICJhYnMiLCAieCIsICJkZWx0YVkiLCAieSIsICJzcXJ0IiwgInBvdyIsICJnZXRJbnRlcnNlY3RJdGVtcyIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImluY2x1ZGVJbnZpc2libGUiLCAiaXRlbXMiLCAiaXNQb2ludEluQXJlYSIsICJldmFsdWF0aW9uRnVuYyIsICJkYXRhc2V0SW5kZXgiLCAiX2lzUG9pbnRJbkFyZWEiLCAiY2hhcnRBcmVhIiwgImluUmFuZ2UiLCAicHVzaCIsICJnZXROZWFyZXN0UmFkaWFsSXRlbXMiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJnZXRQcm9wcyIsICJhbmdsZSIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJfYW5nbGVCZXR3ZWVuIiwgImdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyIsICJkaXN0YW5jZU1ldHJpYyIsICJtaW5EaXN0YW5jZSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiY2VudGVyIiwgImdldENlbnRlclBvaW50IiwgInBvaW50SW5BcmVhIiwgImRpc3RhbmNlIiwgImdldE5lYXJlc3RJdGVtcyIsICJnZXRBeGlzSXRlbXMiLCAicmFuZ2VNZXRob2QiLCAiaW50ZXJzZWN0c0l0ZW0iLCAibW9kZXMiLCAiZSIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgImVsZW1lbnRzIiwgImZvckVhY2giLCAibWV0YSIsICJkYXRhc2V0IiwgImdldERhdGFzZXRNZXRhIiwgInBvaW50IiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgImZpbHRlciIsICJ2IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJyZXZlcnNlIiwgInNvcnQiLCAiYSIsICJiIiwgInYwIiwgInYxIiwgIndlaWdodCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2siLCAic3RhY2tXZWlnaHQiLCAiaG9yaXpvbnRhbCIsICJpc0hvcml6b250YWwiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJzdGFja3MiLCAid3JhcCIsICJpbmNsdWRlcyIsICJfc3RhY2siLCAiY291bnQiLCAicGxhY2VkIiwgInNpemUiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImZhY3RvciIsICJ3aWR0aCIsICJhdmFpbGFibGVXaWR0aCIsICJoZWlnaHQiLCAiYXZhaWxhYmxlSGVpZ2h0IiwgImJ1aWxkTGF5b3V0Qm94ZXMiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJjb25jYXQiLCAicmlnaHRBbmRCb3R0b20iLCAidmVydGljYWwiLCAiZ2V0Q29tYmluZWRNYXgiLCAibWF4UGFkZGluZyIsICJtYXgiLCAidXBkYXRlTWF4UGFkZGluZyIsICJib3hQYWRkaW5nIiwgInVwZGF0ZURpbXMiLCAiaXNPYmplY3QiLCAiZ2V0UGFkZGluZyIsICJuZXdXaWR0aCIsICJvdXRlcldpZHRoIiwgIm5ld0hlaWdodCIsICJvdXRlckhlaWdodCIsICJ3aWR0aENoYW5nZWQiLCAidyIsICJoZWlnaHRDaGFuZ2VkIiwgImgiLCAic2FtZSIsICJvdGhlciIsICJoYW5kbGVNYXhQYWRkaW5nIiwgInVwZGF0ZVBvcyIsICJjaGFuZ2UiLCAiZ2V0TWFyZ2lucyIsICJtYXJnaW5Gb3JQb3NpdGlvbnMiLCAicG9zaXRpb25zIiwgIm1hcmdpbiIsICJmaXRCb3hlcyIsICJyZWZpdEJveGVzIiwgInJlZml0IiwgImNoYW5nZWQiLCAidXBkYXRlIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImRlZmluZWQiLCAiYWRkQm94IiwgIml0ZW0iLCAiX2xheWVycyIsICJ6IiwgImRyYXciLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAic3BsaWNlIiwgImNvbmZpZ3VyZSIsICJtaW5QYWRkaW5nIiwgInRvUGFkZGluZyIsICJ2ZXJ0aWNhbEJveGVzIiwgImhvcml6b250YWxCb3hlcyIsICJlYWNoIiwgImJlZm9yZUxheW91dCIsICJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsICJyZWR1Y2UiLCAidG90YWwiLCAiZGlzcGxheSIsICJmcmVlemUiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJhc3BlY3RSYXRpbyIsICJyZWxlYXNlQ29udGV4dCIsICJjb250ZXh0IiwgImFkZEV2ZW50TGlzdGVuZXIiLCAidHlwZSIsICJsaXN0ZW5lciIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImdldERldmljZVBpeGVsUmF0aW8iLCAiZ2V0TWF4aW11bVNpemUiLCAiZmxvb3IiLCAiaXNBdHRhY2hlZCIsICJ1cGRhdGVDb25maWciLCAiY29uZmlnIiwgIkJhc2ljUGxhdGZvcm0iLCAiZ2V0Q29udGV4dCIsICJhbmltYXRpb24iLCAiRVhQQU5ET19LRVkiLCAiRVZFTlRfVFlQRVMiLCAidG91Y2hzdGFydCIsICJ0b3VjaG1vdmUiLCAidG91Y2hlbmQiLCAicG9pbnRlcmVudGVyIiwgInBvaW50ZXJkb3duIiwgInBvaW50ZXJtb3ZlIiwgInBvaW50ZXJ1cCIsICJwb2ludGVybGVhdmUiLCAicG9pbnRlcm91dCIsICJpc051bGxPckVtcHR5IiwgImluaXRDYW52YXMiLCAic3R5bGUiLCAicmVuZGVySGVpZ2h0IiwgImdldEF0dHJpYnV0ZSIsICJyZW5kZXJXaWR0aCIsICJpbml0aWFsIiwgImJveFNpemluZyIsICJkaXNwbGF5V2lkdGgiLCAicmVhZFVzZWRTaXplIiwgInVuZGVmaW5lZCIsICJkaXNwbGF5SGVpZ2h0IiwgImV2ZW50TGlzdGVuZXJPcHRpb25zIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRMaXN0ZW5lciIsICJub2RlIiwgInJlbW92ZUxpc3RlbmVyIiwgImZyb21OYXRpdmVFdmVudCIsICJldmVudCIsICJuYXRpdmUiLCAibm9kZUxpc3RDb250YWlucyIsICJub2RlTGlzdCIsICJjb250YWlucyIsICJjcmVhdGVBdHRhY2hPYnNlcnZlciIsICJvYnNlcnZlciIsICJNdXRhdGlvbk9ic2VydmVyIiwgImVudHJpZXMiLCAidHJpZ2dlciIsICJlbnRyeSIsICJhZGRlZE5vZGVzIiwgInJlbW92ZWROb2RlcyIsICJvYnNlcnZlIiwgImRvY3VtZW50IiwgImNoaWxkTGlzdCIsICJzdWJ0cmVlIiwgImNyZWF0ZURldGFjaE9ic2VydmVyIiwgImRycExpc3RlbmluZ0NoYXJ0cyIsICJNYXAiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAid2luZG93IiwgImRldmljZVBpeGVsUmF0aW8iLCAicmVzaXplIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgInNldCIsICJ1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgImRlbGV0ZSIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgImN0eCIsICJEb21QbGF0Zm9ybSIsICJwcm9wIiwgImlzTnVsbE9yVW5kZWYiLCAicmVtb3ZlQXR0cmlidXRlIiwgInNldEF0dHJpYnV0ZSIsICJrZXlzIiwgImtleSIsICJwcm94aWVzIiwgIiRwcm94aWVzIiwgImhhbmRsZXJzIiwgImF0dGFjaCIsICJkZXRhY2giLCAiaXNDb25uZWN0ZWQiLCAiX2RldGVjdFBsYXRmb3JtIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJPZmZzY3JlZW5DYW52YXMiLCAiRWxlbWVudCIsICJhY3RpdmUiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImlzTnVtYmVyIiwgInByb3BzIiwgImZpbmFsIiwgImFuaW1zIiwgIiRhbmltYXRpb25zIiwgInJldCIsICJfdG8iLCAiZGVmYXVsdHMiLCAiZGVmYXVsdFJvdXRlcyIsICJhdXRvU2tpcCIsICJzY2FsZSIsICJ0aWNrcyIsICJ0aWNrT3B0cyIsICJkZXRlcm1pbmVkTWF4VGlja3MiLCAiZGV0ZXJtaW5lTWF4VGlja3MiLCAidGlja3NMaW1pdCIsICJtaW4iLCAibWF4VGlja3NMaW1pdCIsICJtYWpvckluZGljZXMiLCAibWFqb3IiLCAiZW5hYmxlZCIsICJnZXRNYWpvckluZGljZXMiLCAibnVtTWFqb3JJbmRpY2VzIiwgImZpcnN0IiwgImxhc3QiLCAibmV3VGlja3MiLCAic2tpcE1ham9ycyIsICJzcGFjaW5nIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgIm9mZnNldCIsICJ0aWNrTGVuZ3RoIiwgIl90aWNrU2l6ZSIsICJtYXhTY2FsZSIsICJfbGVuZ3RoIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAicmVzdWx0IiwgIm5leHQiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgInZhbHVlT3JEZWZhdWx0IiwgImFyciIsICJsZW4iLCAicmV2ZXJzZUFsaWduIiwgImFsaWduIiwgIm9mZnNldEZyb21FZGdlIiwgImVkZ2UiLCAic2FtcGxlIiwgIm51bUl0ZW1zIiwgImluY3JlbWVudCIsICJnZXRQaXhlbEZvckdyaWRMaW5lIiwgIm9mZnNldEdyaWRMaW5lcyIsICJ2YWxpZEluZGV4IiwgIl9zdGFydFBpeGVsIiwgIl9lbmRQaXhlbCIsICJlcHNpbG9uIiwgImxpbmVWYWx1ZSIsICJnZXRQaXhlbEZvclRpY2siLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImNhY2hlIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJpc0FycmF5IiwgInRleHQiLCAibGluZUhlaWdodCIsICJjcmVhdGVTY2FsZUNvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAiY3JlYXRlVGlja0NvbnRleHQiLCAidGljayIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAic2NhbGVzIiwgInJvdGF0aW9uIiwgIm1heFdpZHRoIiwgInRpdGxlWCIsICJ0aXRsZVkiLCAiX2FsaWduU3RhcnRFbmQiLCAicG9zaXRpb25BeGlzSUQiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJIQUxGX1BJIiwgIlNjYWxlIiwgImNmZyIsICJpZCIsICJfbWFyZ2lucyIsICJtYXhIZWlnaHQiLCAicGFkZGluZ1RvcCIsICJwYWRkaW5nQm90dG9tIiwgInBhZGRpbmdMZWZ0IiwgInBhZGRpbmdSaWdodCIsICJsYWJlbFJvdGF0aW9uIiwgIl9yYW5nZSIsICJfZ3JpZExpbmVJdGVtcyIsICJfbGFiZWxJdGVtcyIsICJfbGFiZWxTaXplcyIsICJfbG9uZ2VzdFRleHRDYWNoZSIsICJfdXNlck1heCIsICJfdXNlck1pbiIsICJfc3VnZ2VzdGVkTWF4IiwgIl9zdWdnZXN0ZWRNaW4iLCAiX3RpY2tzTGVuZ3RoIiwgIl9ib3JkZXJWYWx1ZSIsICJfY2FjaGUiLCAiX2RhdGFMaW1pdHNDYWNoZWQiLCAiJGNvbnRleHQiLCAic2V0Q29udGV4dCIsICJzdWdnZXN0ZWRNaW4iLCAic3VnZ2VzdGVkTWF4IiwgInJhdyIsICJnZXRVc2VyQm91bmRzIiwgImZpbml0ZU9yRGVmYXVsdCIsICJORUdBVElWRV9JTkZJTklUWSIsICJtaW5EZWZpbmVkIiwgImlzRmluaXRlIiwgIm1heERlZmluZWQiLCAiZ2V0TWluTWF4IiwgImNhblN0YWNrIiwgIm1ldGFzIiwgImdldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwgImdldFRpY2tzIiwgImdldExhYmVscyIsICJsYWJlbHMiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJjYWxsIiwgIm1hcmdpbnMiLCAiYmVnaW5BdFplcm8iLCAiZ3JhY2UiLCAic2FtcGxlU2l6ZSIsICJiZWZvcmVTZXREaW1lbnNpb25zIiwgInNldERpbWVuc2lvbnMiLCAiYWZ0ZXJTZXREaW1lbnNpb25zIiwgImJlZm9yZURhdGFMaW1pdHMiLCAiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsICJhZnRlckRhdGFMaW1pdHMiLCAiX2FkZEdyYWNlIiwgImJlZm9yZUJ1aWxkVGlja3MiLCAiYnVpbGRUaWNrcyIsICJhZnRlckJ1aWxkVGlja3MiLCAic2FtcGxpbmdFbmFibGVkIiwgIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsICJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgInNvdXJjZSIsICJhZnRlckF1dG9Ta2lwIiwgImJlZm9yZUZpdCIsICJmaXQiLCAiYWZ0ZXJGaXQiLCAiYWZ0ZXJVcGRhdGUiLCAicmV2ZXJzZVBpeGVscyIsICJzdGFydFBpeGVsIiwgImVuZFBpeGVsIiwgIl9hbGlnblRvUGl4ZWxzIiwgImFsaWduVG9QaXhlbHMiLCAiX2NhbGxIb29rcyIsICJuYW1lIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJsYWJlbCIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJncmlkIiwgInRpdGxlIiwgInRvRGVncmVlcyIsICJhc2luIiwgIm1pblNpemUiLCAidGl0bGVPcHRzIiwgImdyaWRPcHRzIiwgInRpdGxlSGVpZ2h0IiwgInRpY2tQYWRkaW5nIiwgImFuZ2xlUmFkaWFucyIsICJ0b1JhZGlhbnMiLCAiY29zIiwgInNpbiIsICJsYWJlbEhlaWdodCIsICJtaXJyb3IiLCAibGFiZWxXaWR0aCIsICJfY2FsY3VsYXRlUGFkZGluZyIsICJfaGFuZGxlTWFyZ2lucyIsICJpc1JvdGF0ZWQiLCAibGFiZWxzQmVsb3dUaWNrcyIsICJvZmZzZXRMZWZ0IiwgIm9mZnNldFJpZ2h0IiwgImlzRnVsbFNpemUiLCAiX2NvbXB1dGVMYWJlbFNpemVzIiwgIndpZHRocyIsICJoZWlnaHRzIiwgIndpZGVzdExhYmVsU2l6ZSIsICJoaWdoZXN0TGFiZWxTaXplIiwgImpsZW4iLCAidGlja0ZvbnQiLCAiZm9udFN0cmluZyIsICJuZXN0ZWRMYWJlbCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJzdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgInZhbHVlQXQiLCAiaWR4IiwgImdldExhYmVsRm9yVmFsdWUiLCAiTmFOIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAicGl4ZWwiLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImRlY2ltYWwiLCAiX2ludDE2UmFuZ2UiLCAiX2FsaWduUGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VQaXhlbCIsICJnZXRCYXNlVmFsdWUiLCAib3B0aW9uVGlja3MiLCAicm90IiwgImF1dG9Ta2lwUGFkZGluZyIsICJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCAiYm9yZGVyIiwgInRpY2tzTGVuZ3RoIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVXaWR0aCIsICJsaW5lQ29sb3IiLCAiY29sb3IiLCAiYm9yZGVyRGFzaCIsICJkYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZGFzaE9mZnNldCIsICJ0aWNrQ29sb3IiLCAidGlja0JvcmRlckRhc2giLCAidGlja0JvcmRlckRhc2hPZmZzZXQiLCAiY3Jvc3NBbGlnbiIsICJ0aWNrQW5kUGFkZGluZyIsICJoVGlja0FuZFBhZGRpbmciLCAidGV4dEFsaWduIiwgImxpbmVDb3VudCIsICJ0ZXh0T2Zmc2V0IiwgInRleHRCYXNlbGluZSIsICJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsICJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsICJsYWJlbE9mZnNldCIsICJoYWxmQ291bnQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJ0aWNrVGV4dEFsaWduIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgImJhY2tkcm9wIiwgImxhYmVsUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiYmFja2Ryb3BDb2xvciIsICJ0cmFuc2xhdGlvbiIsICJfY29tcHV0ZUxhYmVsQXJlYSIsICJkcmF3QmFja2dyb3VuZCIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic2F2ZSIsICJmaWxsU3R5bGUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJmaW5kSW5kZXgiLCAidCIsICJvcHRzIiwgImRyYXdHcmlkIiwgImRyYXdMaW5lIiwgInAxIiwgInAyIiwgInN0cm9rZVN0eWxlIiwgInNldExpbmVEYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImJlZ2luUGF0aCIsICJtb3ZlVG8iLCAibGluZVRvIiwgInN0cm9rZSIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd0JvcmRlciIsICJsYXN0TGluZVdpZHRoIiwgImRyYXdMYWJlbHMiLCAiYXJlYSIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgImF4aXNJRCIsICJfbWF4RGlnaXRzIiwgImZvbnRTaXplIiwgIlR5cGVkUmVnaXN0cnkiLCAic2NvcGUiLCAiY3JlYXRlIiwgImlzRm9yVHlwZSIsICJpc1Byb3RvdHlwZU9mIiwgInJlZ2lzdGVyIiwgInByb3RvIiwgImdldFByb3RvdHlwZU9mIiwgInBhcmVudFNjb3BlIiwgImlzSUNoYXJ0Q29tcG9uZW50IiwgInJlZ2lzdGVyRGVmYXVsdHMiLCAib3ZlcnJpZGVzIiwgImdldCIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaXB0b3JzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAicG9wIiwgInNvdXJjZVNjb3BlIiwgImpvaW4iLCAicGFydHMiLCAidGFyZ2V0TmFtZSIsICJ0YXJnZXRTY29wZSIsICJyb3V0ZSIsICJSZWdpc3RyeSIsICJjb250cm9sbGVycyIsICJEYXRhc2V0Q29udHJvbGxlciIsICJwbHVnaW5zIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiYXJncyIsICJfZWFjaCIsICJyZW1vdmUiLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkRWxlbWVudHMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldEVsZW1lbnQiLCAiZ2V0UGx1Z2luIiwgImdldFNjYWxlIiwgInJlbW92ZUNvbnRyb2xsZXJzIiwgInJlbW92ZUVsZW1lbnRzIiwgInJlbW92ZVBsdWdpbnMiLCAicmVtb3ZlU2NhbGVzIiwgIm1ldGhvZCIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgInJlZ2lzdHJ5IiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfbm90aWZ5IiwgIl9kZXNjcmlwdG9ycyIsICJkZXNjcmlwdG9yIiwgInBsdWdpbiIsICJjYWxsQ2FsbGJhY2siLCAiY2FuY2VsYWJsZSIsICJpbnZhbGlkYXRlIiwgIl9vbGRDYWNoZSIsICJfbm90aWZ5U3RhdGVDaGFuZ2VzIiwgImFsbCIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjb3BlcyIsICJnZXRPcHRpb25TY29wZXMiLCAiY3JlYXRlUmVzb2x2ZXIiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiYWxsS2V5cyIsICJnZXRJbmRleEF4aXMiLCAiZGF0YXNldERlZmF1bHRzIiwgImRhdGFzZXRzIiwgImRhdGFzZXRPcHRpb25zIiwgImluZGV4QXhpcyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiYXhpc0Zyb21Qb3NpdGlvbiIsICJkZXRlcm1pbmVBeGlzIiwgInNjYWxlT3B0aW9ucyIsICJ0b0xvd2VyQ2FzZSIsICJtZXJnZVNjYWxlQ29uZmlnIiwgImNoYXJ0RGVmYXVsdHMiLCAiY29uZmlnU2NhbGVzIiwgImNoYXJ0SW5kZXhBeGlzIiwgInNjYWxlQ29uZiIsICJjb25zb2xlIiwgImVycm9yIiwgIl9wcm94eSIsICJ3YXJuIiwgImRlZmF1bHRJZCIsICJkZWZhdWx0U2NhbGVPcHRpb25zIiwgIm1lcmdlSWYiLCAiZGVmYXVsdElEIiwgImluaXRPcHRpb25zIiwgImluaXREYXRhIiwgImluaXRDb25maWciLCAia2V5Q2FjaGUiLCAia2V5c0NhY2hlZCIsICJTZXQiLCAiY2FjaGVkS2V5cyIsICJjYWNoZUtleSIsICJnZW5lcmF0ZSIsICJhZGRJZkZvdW5kIiwgIm9iaiIsICJyZXNvbHZlT2JqZWN0S2V5IiwgIkNvbmZpZyIsICJfY29uZmlnIiwgIl9zY29wZUNhY2hlIiwgIl9yZXNvbHZlckNhY2hlIiwgInBsYXRmb3JtIiwgImNsZWFyQ2FjaGUiLCAiY2xlYXIiLCAiZGF0YXNldFNjb3BlS2V5cyIsICJkYXRhc2V0VHlwZSIsICJkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAiZWxlbWVudFR5cGUiLCAiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsICJfY2FjaGVkU2NvcGVzIiwgIm1haW5TY29wZSIsICJyZXNldENhY2hlIiwgImtleUxpc3RzIiwgImNhY2hlZCIsICJBcnJheSIsICJmcm9tIiwgImhhcyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlTmFtZWRPcHRpb25zIiwgIm5hbWVzIiwgInByZWZpeGVzIiwgIiRzaGFyZWQiLCAicmVzb2x2ZXIiLCAic3ViUHJlZml4ZXMiLCAiZ2V0UmVzb2x2ZXIiLCAibmVlZENvbnRleHQiLCAiaXNGdW5jdGlvbiIsICJzdWJSZXNvbHZlciIsICJfYXR0YWNoQ29udGV4dCIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAicmVzb2x2ZXJDYWNoZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAicCIsICJoYXNGdW5jdGlvbiIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImFjYyIsICJpc1NjcmlwdGFibGUiLCAiaXNJbmRleGFibGUiLCAiS05PV05fUE9TSVRJT05TIiwgInBvc2l0aW9uSXNIb3Jpem9udGFsIiwgImNvbXBhcmUyTGV2ZWwiLCAibDEiLCAibDIiLCAib25BbmltYXRpb25zQ29tcGxldGUiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgInZhbHVlcyIsICJjIiwgIm1vdmVOdW1lcmljS2V5cyIsICJtb3ZlIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiZ2V0RGF0YXNldEFyZWEiLCAieFNjYWxlIiwgInlTY2FsZSIsICJDaGFydCIsICJpbnZhbGlkYXRlUGx1Z2lucyIsICJ1c2VyQ29uZmlnIiwgImluaXRpYWxDYW52YXMiLCAiZXhpc3RpbmdDaGFydCIsICJ1aWQiLCAiX29wdGlvbnMiLCAiX2FzcGVjdFJhdGlvIiwgIl9tZXRhc2V0cyIsICJfc3RhY2tzIiwgIl9hY3RpdmUiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9kb1Jlc2l6ZSIsICJkZWJvdW5jZSIsICJtb2RlIiwgInJlc2l6ZURlbGF5IiwgIl9kYXRhQ2hhbmdlcyIsICJhbmltYXRvciIsICJsaXN0ZW4iLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAic3RvcCIsICJydW5uaW5nIiwgIl9yZXNpemUiLCAiX3Jlc2l6ZUJlZm9yZURyYXciLCAibmV3U2l6ZSIsICJuZXdSYXRpbyIsICJvblJlc2l6ZSIsICJyZW5kZXIiLCAiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsICJzY2FsZXNPcHRpb25zIiwgImF4aXNPcHRpb25zIiwgImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCAic2NhbGVPcHRzIiwgInVwZGF0ZWQiLCAibWFwIiwgImlzUmFkaWFsIiwgImRwb3NpdGlvbiIsICJkdHlwZSIsICJzY2FsZVR5cGUiLCAic2NhbGVDbGFzcyIsICJoYXNVcGRhdGVkIiwgIl91cGRhdGVNZXRhc2V0cyIsICJudW1EYXRhIiwgIm51bU1ldGEiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJzbGljZSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiX2RhdGFzZXQiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJ1cGRhdGVJbmRleCIsICJsaW5rU2NhbGVzIiwgIkNvbnRyb2xsZXJDbGFzcyIsICJkYXRhc2V0RWxlbWVudFR5cGUiLCAiZGF0YUVsZW1lbnRUeXBlIiwgIl9yZXNldEVsZW1lbnRzIiwgInJlc2V0IiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsICJnZXRNYXhPdmVyZmxvdyIsICJfbWluUGFkZGluZyIsICJhdXRvUGFkZGluZyIsICJfdXBkYXRlTGF5b3V0IiwgIl91cGRhdGVEYXRhc2V0cyIsICJfZXZlbnRIYW5kbGVyIiwgIl91cGRhdGVIb3ZlclN0eWxlcyIsICJleGlzdGluZ0V2ZW50cyIsICJuZXdFdmVudHMiLCAiZXZlbnRzIiwgInNldHNFcXVhbCIsICJ1bmJpbmRFdmVudHMiLCAiY2hhbmdlcyIsICJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwgImRhdGFzZXRDb3VudCIsICJtYWtlU2V0IiwgImNoYW5nZVNldCIsICJub0FyZWEiLCAiX2lkeCIsICJfdXBkYXRlRGF0YXNldCIsICJfdXBkYXRlIiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCAiZmlsdGVyVmlzaWJsZSIsICJfZHJhd0RhdGFzZXQiLCAiY2xpcCIsICJfY2xpcCIsICJ1c2VDbGlwIiwgImRpc2FibGVkIiwgImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCAiSW50ZXJhY3Rpb24iLCAiaGlkZGVuIiwgInhBeGlzSUQiLCAieUF4aXNJRCIsICJfcGFyc2VkIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAic2V0RGF0YXNldFZpc2liaWxpdHkiLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAiX3VwZGF0ZVZpc2liaWxpdHkiLCAiZGF0YUluZGV4IiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJoaWRlIiwgInNob3ciLCAiX2Rlc3Ryb3kiLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJsaXN0ZW5lcnMiLCAiX2FkZCIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiX3JlbW92ZSIsICJkZXRhY2hlZCIsICJ1cGRhdGVIb3ZlclN0eWxlIiwgInByZWZpeCIsICJnZXRBY3RpdmVFbGVtZW50cyIsICJzZXRBY3RpdmVFbGVtZW50cyIsICJhY3RpdmVFbGVtZW50cyIsICJsYXN0QWN0aXZlIiwgIl9lbGVtZW50c0VxdWFsIiwgImlzUGx1Z2luRW5hYmxlZCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInZlcnNpb24iLCAiY2xpcEFyYyIsICJwaXhlbE1hcmdpbiIsICJvdXRlclJhZGl1cyIsICJpbm5lclJhZGl1cyIsICJhbmdsZU1hcmdpbiIsICJhcmMiLCAiY2xvc2VQYXRoIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJ2YWwiLCAib3V0ZXJBcmNMaW1pdCIsICJvdXRlclN0YXJ0IiwgIm91dGVyRW5kIiwgImlubmVyU3RhcnQiLCAiaW5uZXJFbmQiLCAiclRoZXRhVG9YWSIsICJyIiwgInRoZXRhIiwgInBhdGhBcmMiLCAiY2lyY3VsYXIiLCAiaW5uZXJSIiwgInNwYWNpbmdPZmZzZXQiLCAiYWxwaGEiLCAibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCAibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCAiYXZOb2dTcGFjaW5nUmFkaXVzIiwgImFkanVzdGVkQW5nbGUiLCAiYmV0YSIsICJQSSIsICJhbmdsZU9mZnNldCIsICJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCAiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCAiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwQ2VudGVyIiwgInA0IiwgImlubmVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwOCIsICJvdXRlclN0YXJ0WCIsICJvdXRlclN0YXJ0WSIsICJvdXRlckVuZFgiLCAib3V0ZXJFbmRZIiwgImRyYXdBcmMiLCAiZnVsbENpcmNsZXMiLCAiY2lyY3VtZmVyZW5jZSIsICJmaWxsIiwgImlzTmFOIiwgIlRBVSIsICJib3JkZXJXaWR0aCIsICJib3JkZXJKb2luU3R5bGUiLCAiaW5uZXIiLCAiYm9yZGVyQWxpZ24iLCAibGluZUpvaW4iLCAiQXJjRWxlbWVudCIsICJjaGFydFgiLCAiY2hhcnRZIiwgInJBZGp1c3QiLCAiX2NpcmN1bWZlcmVuY2UiLCAiYmV0d2VlbkFuZ2xlcyIsICJ3aXRoaW5SYWRpdXMiLCAiX2lzQmV0d2VlbiIsICJoYWxmQW5nbGUiLCAiaGFsZlJhZGl1cyIsICJ0cmFuc2xhdGUiLCAiZml4IiwgInJhZGl1c09mZnNldCIsICJib3JkZXJDb2xvciIsICJnZXRCYXJCb3VuZHMiLCAiYmFyIiwgInVzZUZpbmFsUG9zaXRpb24iLCAieCIsICJ5IiwgImJhc2UiLCAid2lkdGgiLCAiaGVpZ2h0IiwgImdldFByb3BzIiwgImxlZnQiLCAicmlnaHQiLCAidG9wIiwgImJvdHRvbSIsICJoYWxmIiwgImhvcml6b250YWwiLCAiTWF0aCIsICJtaW4iLCAibWF4IiwgInNraXBPckxpbWl0IiwgInNraXAiLCAidmFsdWUiLCAiX2xpbWl0VmFsdWUiLCAicGFyc2VCb3JkZXJXaWR0aCIsICJtYXhXIiwgIm1heEgiLCAib3B0aW9ucyIsICJib3JkZXJXaWR0aCIsICJib3JkZXJTa2lwcGVkIiwgIm8iLCAidG9UUkJMIiwgInQiLCAiciIsICJiIiwgImwiLCAicGFyc2VCb3JkZXJSYWRpdXMiLCAiZW5hYmxlQm9yZGVyUmFkaXVzIiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgIm1heFIiLCAiZW5hYmxlQm9yZGVyIiwgImlzT2JqZWN0IiwgInRvcExlZnQiLCAidG9wUmlnaHQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJib3VuZGluZ1JlY3RzIiwgImJvdW5kcyIsICJib3JkZXIiLCAicmFkaXVzIiwgIm91dGVyIiwgInciLCAiaCIsICJpbm5lciIsICJpblJhbmdlIiwgInNraXBYIiwgInNraXBZIiwgInNraXBCb3RoIiwgIl9pc0JldHdlZW4iLCAiaGFzUmFkaXVzIiwgImFkZE5vcm1hbFJlY3RQYXRoIiwgImN0eCIsICJyZWN0IiwgImluZmxhdGVSZWN0IiwgImFtb3VudCIsICJyZWZSZWN0IiwgIkJhckVsZW1lbnQiLCAiRWxlbWVudCIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAidW5kZWZpbmVkIiwgImluZmxhdGVBbW91bnQiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJkcmF3IiwgImJvcmRlckNvbG9yIiwgImJhY2tncm91bmRDb2xvciIsICJhZGRSZWN0UGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAic2F2ZSIsICJiZWdpblBhdGgiLCAiY2xpcCIsICJmaWxsU3R5bGUiLCAiZmlsbCIsICJyZXN0b3JlIiwgIm1vdXNlWCIsICJtb3VzZVkiLCAiaW5YUmFuZ2UiLCAiaW5ZUmFuZ2UiLCAiZ2V0Q2VudGVyUG9pbnQiLCAiZ2V0UmFuZ2UiLCAiYXhpcyIsICJpZCIsICJkZWZhdWx0cyIsICJwb2ludFN0eWxlIiwgImRlZmF1bHRSb3V0ZXMiLCAiZ2V0Qm94U2l6ZSIsICJsYWJlbE9wdHMiLCAiZm9udFNpemUiLCAiYm94SGVpZ2h0IiwgImJveFdpZHRoIiwgInVzZVBvaW50U3R5bGUiLCAiTWF0aCIsICJtaW4iLCAicG9pbnRTdHlsZVdpZHRoIiwgIml0ZW1IZWlnaHQiLCAibWF4IiwgIml0ZW1zRXF1YWwiLCAiYSIsICJiIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJMZWdlbmQiLCAiRWxlbWVudCIsICJjb25zdHJ1Y3RvciIsICJjb25maWciLCAiX2FkZGVkIiwgImxlZ2VuZEhpdEJveGVzIiwgIl9ob3ZlcmVkSXRlbSIsICJkb3VnaG51dE1vZGUiLCAiY2hhcnQiLCAib3B0aW9ucyIsICJjdHgiLCAibGVnZW5kSXRlbXMiLCAidW5kZWZpbmVkIiwgImNvbHVtblNpemVzIiwgImxpbmVXaWR0aHMiLCAibWF4SGVpZ2h0IiwgIm1heFdpZHRoIiwgInRvcCIsICJib3R0b20iLCAibGVmdCIsICJyaWdodCIsICJoZWlnaHQiLCAid2lkdGgiLCAiX21hcmdpbnMiLCAicG9zaXRpb24iLCAid2VpZ2h0IiwgImZ1bGxTaXplIiwgInVwZGF0ZSIsICJtYXJnaW5zIiwgInNldERpbWVuc2lvbnMiLCAiYnVpbGRMYWJlbHMiLCAiZml0IiwgImlzSG9yaXpvbnRhbCIsICJsYWJlbHMiLCAiY2FsbCIsICJnZW5lcmF0ZUxhYmVscyIsICJmaWx0ZXIiLCAiaXRlbSIsICJkYXRhIiwgInNvcnQiLCAicmV2ZXJzZSIsICJkaXNwbGF5IiwgImxhYmVsRm9udCIsICJ0b0ZvbnQiLCAiZm9udCIsICJzaXplIiwgInRpdGxlSGVpZ2h0IiwgIl9jb21wdXRlVGl0bGVIZWlnaHQiLCAic3RyaW5nIiwgIl9maXRSb3dzIiwgIl9maXRDb2xzIiwgInBhZGRpbmciLCAiaGl0Ym94ZXMiLCAibGluZUhlaWdodCIsICJ0b3RhbEhlaWdodCIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgInJvdyIsICJmb3JFYWNoIiwgImxlZ2VuZEl0ZW0iLCAiaSIsICJpdGVtV2lkdGgiLCAibWVhc3VyZVRleHQiLCAidGV4dCIsICJsZW5ndGgiLCAiX2l0ZW1IZWlnaHQiLCAiaGVpZ2h0TGltaXQiLCAidG90YWxXaWR0aCIsICJjdXJyZW50Q29sV2lkdGgiLCAiY3VycmVudENvbEhlaWdodCIsICJjb2wiLCAiY2FsY3VsYXRlSXRlbVNpemUiLCAicHVzaCIsICJhZGp1c3RIaXRCb3hlcyIsICJhbGlnbiIsICJydGwiLCAicnRsSGVscGVyIiwgImdldFJ0bEFkYXB0ZXIiLCAiX2FsaWduU3RhcnRFbmQiLCAiaGl0Ym94IiwgImxlZnRGb3JMdHIiLCAieCIsICJkcmF3IiwgImNsaXBBcmVhIiwgIl9kcmF3IiwgInVuY2xpcEFyZWEiLCAib3B0cyIsICJkZWZhdWx0Q29sb3IiLCAiZGVmYXVsdHMiLCAiY29sb3IiLCAiaGFsZkZvbnRTaXplIiwgImN1cnNvciIsICJkcmF3VGl0bGUiLCAibGluZVdpZHRoIiwgImRyYXdMZWdlbmRCb3giLCAieSIsICJpc05hTiIsICJzYXZlIiwgInZhbHVlT3JEZWZhdWx0IiwgImZpbGxTdHlsZSIsICJsaW5lQ2FwIiwgImxpbmVEYXNoT2Zmc2V0IiwgImxpbmVKb2luIiwgInN0cm9rZVN0eWxlIiwgInNldExpbmVEYXNoIiwgImxpbmVEYXNoIiwgImRyYXdPcHRpb25zIiwgInJhZGl1cyIsICJTUVJUMiIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgImJvcmRlcldpZHRoIiwgImNlbnRlclgiLCAieFBsdXMiLCAiY2VudGVyWSIsICJkcmF3UG9pbnRMZWdlbmQiLCAieUJveFRvcCIsICJ4Qm94TGVmdCIsICJib3JkZXJSYWRpdXMiLCAidG9UUkJMQ29ybmVycyIsICJiZWdpblBhdGgiLCAiT2JqZWN0IiwgInZhbHVlcyIsICJzb21lIiwgInYiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInciLCAiaCIsICJyZWN0IiwgImZpbGwiLCAic3Ryb2tlIiwgInJlc3RvcmUiLCAiZmlsbFRleHQiLCAicmVuZGVyVGV4dCIsICJzdHJpa2V0aHJvdWdoIiwgImhpZGRlbiIsICJsaW5lIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJ0ZXh0RGlyZWN0aW9uIiwgImZvbnRDb2xvciIsICJ0ZXh0V2lkdGgiLCAic2V0V2lkdGgiLCAicmVhbFgiLCAiX3RleHRYIiwgImZvbnRMaW5lSGVpZ2h0IiwgImNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAidGl0bGVPcHRzIiwgInRpdGxlIiwgInRpdGxlRm9udCIsICJ0aXRsZVBhZGRpbmciLCAidG9QYWRkaW5nIiwgInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwgInJlZHVjZSIsICJhY2MiLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgIl9nZXRMZWdlbmRJdGVtQXQiLCAiaGl0Qm94IiwgImxoIiwgIl9pc0JldHdlZW4iLCAiaGFuZGxlRXZlbnQiLCAiZSIsICJpc0xpc3RlbmVkIiwgInR5cGUiLCAiaG92ZXJlZEl0ZW0iLCAicHJldmlvdXMiLCAic2FtZUl0ZW0iLCAib25MZWF2ZSIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAiY2FsY3VsYXRlSXRlbVdpZHRoIiwgImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCAibGVnZW5kSXRlbVRleHQiLCAibGFiZWxIZWlnaHQiLCAiaWQiLCAiX2VsZW1lbnQiLCAic3RhcnQiLCAiX2FyZ3MiLCAibGVnZW5kIiwgImxheW91dHMiLCAiY29uZmlndXJlIiwgImFkZEJveCIsICJzdG9wIiwgInJlbW92ZUJveCIsICJiZWZvcmVVcGRhdGUiLCAiYWZ0ZXJVcGRhdGUiLCAiYWZ0ZXJFdmVudCIsICJhcmdzIiwgInJlcGxheSIsICJldmVudCIsICJjaSIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImhpZGUiLCAic2hvdyIsICJkYXRhc2V0cyIsICJ1c2VCb3JkZXJSYWRpdXMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJtYXAiLCAibWV0YSIsICJzdHlsZSIsICJjb250cm9sbGVyIiwgImdldFN0eWxlIiwgImxhYmVsIiwgImJhY2tncm91bmRDb2xvciIsICJ2aXNpYmxlIiwgImJvcmRlckNhcFN0eWxlIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJib3JkZXJKb2luU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJzdGFydHNXaXRoIiwgImluY2x1ZGVzIiwgIlRpdGxlIiwgIl9wYWRkaW5nIiwgImxpbmVDb3VudCIsICJpc0FycmF5IiwgInRleHRTaXplIiwgInBvcyIsICJfZHJhd0FyZ3MiLCAib2Zmc2V0IiwgInRpdGxlWCIsICJ0aXRsZVkiLCAiUEkiLCAiZm9udE9wdHMiLCAidHJhbnNsYXRpb24iLCAiY3JlYXRlVGl0bGUiLCAidGl0bGVCbG9jayIsICJkZWZhdWx0Um91dGVzIiwgIl9pbmRleGFibGUiLCAiV2Vha01hcCIsICJzZXQiLCAiZ2V0IiwgImRlbGV0ZSIsICJwb3NpdGlvbmVycyIsICJhdmVyYWdlIiwgIml0ZW1zIiwgImxlbiIsICJjb3VudCIsICJlbCIsICJlbGVtZW50IiwgImhhc1ZhbHVlIiwgInRvb2x0aXBQb3NpdGlvbiIsICJuZWFyZXN0IiwgImV2ZW50UG9zaXRpb24iLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgIm5lYXJlc3RFbGVtZW50IiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJkIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAiYmFzZSIsICJ0b1B1c2giLCAiQXJyYXkiLCAicHJvdG90eXBlIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJpbmRleE9mIiwgInNwbGl0IiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImdldERhdGFzZXRNZXRhIiwgInZhbHVlIiwgImdldExhYmVsQW5kVmFsdWUiLCAicGFyc2VkIiwgImdldFBhcnNlZCIsICJyYXciLCAiZm9ybWF0dGVkVmFsdWUiLCAiZGF0YXNldCIsICJnZXREYXRhc2V0IiwgImRhdGFJbmRleCIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAibGluZXMiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJlYWNoIiwgImNvbmNhdCIsICJib3hQYWRkaW5nIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJjaGFydEFyZWEiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgIl9saW1pdFZhbHVlIiwgImdldEFsaWduZWRYIiwgImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwgImNhbGxiYWNrIiwgImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwgInBhcmVudCIsICJ0b29sdGlwSXRlbXMiLCAiY3JlYXRlQ29udGV4dCIsICJvdmVycmlkZUNhbGxiYWNrcyIsICJjYWxsYmFja3MiLCAiY29udGV4dCIsICJvdmVycmlkZSIsICJkZWZhdWx0Q2FsbGJhY2tzIiwgImJlZm9yZVRpdGxlIiwgIm5vb3AiLCAibGFiZWxDb3VudCIsICJtb2RlIiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAiaXNOdWxsT3JVbmRlZiIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiYXJnIiwgInJlc3VsdCIsICJUb29sdGlwIiwgIm9wYWNpdHkiLCAiX2FjdGl2ZSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgIiRhbmltYXRpb25zIiwgIiRjb250ZXh0IiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJpbml0aWFsaXplIiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJjYWNoZWQiLCAic2V0Q29udGV4dCIsICJnZXRDb250ZXh0IiwgImVuYWJsZWQiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGlvbnMiLCAiQW5pbWF0aW9ucyIsICJfY2FjaGVhYmxlIiwgImZyZWV6ZSIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJhY3RpdmUiLCAiYXJyYXkiLCAiaXRlbVNvcnQiLCAiY2hhbmdlZCIsICJwcm9wZXJ0aWVzIiwgInBvc2l0aW9uQW5kU2l6ZSIsICJhc3NpZ24iLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgImxpbmVUbyIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJ4MyIsICJ5MyIsICJwdFgiLCAicHRZIiwgInB0IiwgInRpdGxlQWxpZ24iLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgImRyYXdQb2ludCIsICJpc09iamVjdCIsICJvdXRlclgiLCAiaW5uZXJYIiwgImZpbGxSZWN0IiwgInN0cm9rZVJlY3QiLCAiZHJhd0JvZHkiLCAiYm9keUFsaWduIiwgInhMaW5lUGFkZGluZyIsICJmaWxsTGluZU9mVGV4dCIsICJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsICJ0ZXh0Q29sb3IiLCAiaiIsICJpbGVuIiwgImpsZW4iLCAiZHJhd0Zvb3RlciIsICJmb290ZXJBbGlnbiIsICJmb290ZXJDb2xvciIsICJkcmF3QmFja2dyb3VuZCIsICJ0b29sdGlwU2l6ZSIsICJtb3ZlVG8iLCAicXVhZHJhdGljQ3VydmVUbyIsICJjbG9zZVBhdGgiLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltcyIsICJhbmltWCIsICJhbmltWSIsICJwb2ludCIsICJfdG8iLCAiX3dpbGxSZW5kZXIiLCAiYWJzIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiRXJyb3IiLCAiX2VsZW1lbnRzRXF1YWwiLCAicG9zaXRpb25DaGFuZ2VkIiwgIl9wb3NpdGlvbkNoYW5nZWQiLCAiX2lnbm9yZVJlcGxheUV2ZW50cyIsICJpbkNoYXJ0QXJlYSIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJhZnRlckluaXQiLCAicmVzZXQiLCAiYWZ0ZXJEcmF3IiwgIm5vdGlmeVBsdWdpbnMiLCAiY2FuY2VsYWJsZSIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJudW1iZXJzIiwgIl9mYWxsYmFjayIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgImFkZElmU3RyaW5nIiwgImxhYmVscyIsICJyYXciLCAiaW5kZXgiLCAiYWRkZWRMYWJlbHMiLCAicHVzaCIsICJ1bnNoaWZ0IiwgImxhYmVsIiwgImlzTmFOIiwgImZpbmRPckFkZExhYmVsIiwgImZpcnN0IiwgImluZGV4T2YiLCAibGFzdCIsICJsYXN0SW5kZXhPZiIsICJ2YWxpZEluZGV4IiwgIm1heCIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgInJvdW5kIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgInZhbHVlIiwgImdldExhYmVscyIsICJsZW5ndGgiLCAiQ2F0ZWdvcnlTY2FsZSIsICJTY2FsZSIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAiX3N0YXJ0VmFsdWUiLCAidW5kZWZpbmVkIiwgIl92YWx1ZVJhbmdlIiwgIl9hZGRlZExhYmVscyIsICJpbml0IiwgInNjYWxlT3B0aW9ucyIsICJhZGRlZCIsICJzcGxpY2UiLCAicGFyc2UiLCAiaXNOdWxsT3JVbmRlZiIsICJpc0Zpbml0ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbiIsICJnZXRNaW5NYXgiLCAib3B0aW9ucyIsICJib3VuZHMiLCAiYnVpbGRUaWNrcyIsICJvZmZzZXQiLCAidGlja3MiLCAic2xpY2UiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJjYWxsIiwgImNvbmZpZ3VyZSIsICJpc0hvcml6b250YWwiLCAiX3JldmVyc2VQaXhlbHMiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJOYU4iLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImdldFBpeGVsRm9yVGljayIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlUGl4ZWwiLCAiYm90dG9tIiwgImlkIiwgImRlZmF1bHRzIiwgImNhbGxiYWNrIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInN0ZXAiLCAicHJlY2lzaW9uIiwgImNvdW50IiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJzcGFjaW5nIiwgIm5pY2VOdW0iLCAiZmFjdG9yIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiY2VpbCIsICJmbG9vciIsICJwb3ciLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaiIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJob3Jpem9udGFsIiwgIm1pblJvdGF0aW9uIiwgInJhZCIsICJ0b1JhZGlhbnMiLCAicmF0aW8iLCAic2luIiwgImNvcyIsICJMaW5lYXJTY2FsZUJhc2UiLCAic3RhcnQiLCAiZW5kIiwgIl9lbmRWYWx1ZSIsICJOdW1iZXIiLCAiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsICJiZWdpbkF0WmVybyIsICJzZXRNaW4iLCAidiIsICJzZXRNYXgiLCAibWluU2lnbiIsICJzaWduIiwgIm1heFNpZ24iLCAiYWJzIiwgImdldFRpY2tMaW1pdCIsICJ0aWNrT3B0cyIsICJtYXhUaWNrc0xpbWl0IiwgInN0ZXBTaXplIiwgImNvbnNvbGUiLCAid2FybiIsICJjb21wdXRlVGlja0xpbWl0IiwgIlBPU0lUSVZFX0lORklOSVRZIiwgIm9wdHMiLCAibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCAiX21heERpZ2l0cyIsICJfcmFuZ2UiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgInJldmVyc2UiLCAiZm9ybWF0TnVtYmVyIiwgImNoYXJ0IiwgImxvY2FsZSIsICJmb3JtYXQiLCAiTGluZWFyU2NhbGUiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInRpY2tGb250IiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgImxpbmVIZWlnaHQiLCAiVGlja3MiLCAiZm9ybWF0dGVycyIsICJudW1lcmljIiwgImxvZzEwRmxvb3IiLCAibG9nMTAiLCAiY2hhbmdlRXhwb25lbnQiLCAibSIsICJpc01ham9yIiwgInRpY2tWYWwiLCAicmVtYWluIiwgInN0ZXBzIiwgInJhbmdlRXhwIiwgInJhbmdlU3RlcCIsICJzdGFydEV4cCIsICJyYW5nZSIsICJmaW5pdGVPckRlZmF1bHQiLCAibWluRXhwIiwgImV4cCIsICJiYXNlIiwgInNpZ25pZmljYW5kIiwgIm1ham9yIiwgImxhc3RUaWNrIiwgIkxvZ2FyaXRobWljU2NhbGUiLCAicHJvdG90eXBlIiwgImFwcGx5IiwgIl96ZXJvIiwgIl9zdWdnZXN0ZWRNaW4iLCAiX3VzZXJNaW4iLCAiX3VzZXJNYXgiLCAiZGVjaW1hbCIsICJsb2dhcml0aG1pYyIsICJlbmFibGVkIiwgImdldFRpY2tCYWNrZHJvcEhlaWdodCIsICJkaXNwbGF5IiwgInBhZGRpbmciLCAidG9QYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJmb250IiwgInNpemUiLCAibWVhc3VyZUxhYmVsU2l6ZSIsICJjdHgiLCAiaXNBcnJheSIsICJ3IiwgIl9sb25nZXN0VGV4dCIsICJzdHJpbmciLCAiaCIsICJkZXRlcm1pbmVMaW1pdHMiLCAiYW5nbGUiLCAicG9zIiwgImZpdFdpdGhQb2ludExhYmVscyIsICJzY2FsZSIsICJvcmlnIiwgImwiLCAibGVmdCIsICJfcGFkZGluZyIsICJyIiwgInJpZ2h0IiwgInQiLCAidG9wIiwgImIiLCAibGltaXRzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAibGFiZWxTaXplcyIsICJ2YWx1ZUNvdW50IiwgIl9wb2ludExhYmVscyIsICJwb2ludExhYmVsT3B0cyIsICJwb2ludExhYmVscyIsICJhZGRpdGlvbmFsQW5nbGUiLCAiY2VudGVyUG9pbnRMYWJlbHMiLCAiUEkiLCAiaSIsICJzZXRDb250ZXh0IiwgImdldFBvaW50TGFiZWxDb250ZXh0IiwgInBvaW50UG9zaXRpb24iLCAiZ2V0UG9pbnRQb3NpdGlvbiIsICJkcmF3aW5nQXJlYSIsICJwbEZvbnQiLCAidG9Gb250IiwgInRleHRTaXplIiwgImFuZ2xlUmFkaWFucyIsICJfbm9ybWFsaXplQW5nbGUiLCAiZ2V0SW5kZXhBbmdsZSIsICJ0b0RlZ3JlZXMiLCAiaExpbWl0cyIsICJ4IiwgInZMaW1pdHMiLCAieSIsICJ1cGRhdGVMaW1pdHMiLCAic2V0Q2VudGVyUG9pbnQiLCAiX3BvaW50TGFiZWxJdGVtcyIsICJidWlsZFBvaW50TGFiZWxJdGVtcyIsICJpdGVtcyIsICJleHRyYSIsICJvdXRlckRpc3RhbmNlIiwgInBvaW50TGFiZWxQb3NpdGlvbiIsICJIQUxGX1BJIiwgInlGb3JBbmdsZSIsICJ0ZXh0QWxpZ24iLCAiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCAibGVmdEZvclRleHRBbGlnbiIsICJhbGlnbiIsICJkcmF3UG9pbnRMYWJlbHMiLCAibGFiZWxDb3VudCIsICJvcHRzQXRJbmRleCIsICJiYWNrZHJvcENvbG9yIiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImZpbGxTdHlsZSIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJ2YWx1ZXMiLCAic29tZSIsICJiZWdpblBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInJhZGl1cyIsICJmaWxsIiwgImZpbGxSZWN0IiwgInJlbmRlclRleHQiLCAiY29sb3IiLCAidGV4dEJhc2VsaW5lIiwgInBhdGhSYWRpdXNMaW5lIiwgImNpcmN1bGFyIiwgImFyYyIsICJ4Q2VudGVyIiwgInlDZW50ZXIiLCAiVEFVIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImJvcmRlck9wdHMiLCAibGluZVdpZHRoIiwgInNhdmUiLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAiZGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgImNsb3NlUGF0aCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJ0eXBlIiwgIlJhZGlhbExpbmVhclNjYWxlIiwgInNldERpbWVuc2lvbnMiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJtYXAiLCAiY2FsbENhbGxiYWNrIiwgImZpbHRlciIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJmaXQiLCAibGVmdE1vdmVtZW50IiwgInJpZ2h0TW92ZW1lbnQiLCAidG9wTW92ZW1lbnQiLCAiYm90dG9tTW92ZW1lbnQiLCAiYW5nbGVNdWx0aXBsaWVyIiwgInN0YXJ0QW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJkaXN0YW5jZSIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImdldENvbnRleHQiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0QmFzZVZhbHVlIiwgImdldFBvaW50TGFiZWxQb3NpdGlvbiIsICJkcmF3QmFja2dyb3VuZCIsICJiYWNrZ3JvdW5kQ29sb3IiLCAiZ3JpZCIsICJkcmF3R3JpZCIsICJhbmdsZUxpbmVzIiwgImJvcmRlciIsICJwb3NpdGlvbiIsICJmb3JFYWNoIiwgInRpY2siLCAiY29udGV4dCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJib3JkZXJEYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZHJhd0JvcmRlciIsICJkcmF3TGFiZWxzIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAibWVhc3VyZVRleHQiLCAiZHJhd1RpdGxlIiwgImFuaW1hdGUiLCAiZGVmYXVsdFJvdXRlcyIsICJkZXNjcmlwdG9ycyIsICJfZmFsbGJhY2siLCAiSU5URVJWQUxTIiwgIm1pbGxpc2Vjb25kIiwgImNvbW1vbiIsICJzZWNvbmQiLCAibWludXRlIiwgImhvdXIiLCAiZGF5IiwgIndlZWsiLCAibW9udGgiLCAicXVhcnRlciIsICJ5ZWFyIiwgIlVOSVRTIiwgImtleXMiLCAic29ydGVyIiwgImEiLCAiaW5wdXQiLCAiYWRhcHRlciIsICJfYWRhcHRlciIsICJwYXJzZXIiLCAiaXNvV2Vla2RheSIsICJfcGFyc2VPcHRzIiwgImlzTnVtYmVyIiwgInN0YXJ0T2YiLCAiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsICJtaW5Vbml0IiwgImNhcGFjaXR5IiwgImlsZW4iLCAiaW50ZXJ2YWwiLCAiTUFYX1NBRkVfSU5URUdFUiIsICJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsICJudW1UaWNrcyIsICJkaWZmIiwgImRldGVybWluZU1ham9yVW5pdCIsICJhZGRUaWNrIiwgInRpbWUiLCAidGltZXN0YW1wcyIsICJsbyIsICJoaSIsICJfbG9va3VwIiwgInRpbWVzdGFtcCIsICJzZXRNYWpvclRpY2tzIiwgIm1ham9yVW5pdCIsICJhZGQiLCAidGlja3NGcm9tVGltZXN0YW1wcyIsICJUaW1lU2NhbGUiLCAicHJvcHMiLCAiX2NhY2hlIiwgImRhdGEiLCAiYWxsIiwgIl91bml0IiwgIl9tYWpvclVuaXQiLCAiX29mZnNldHMiLCAiX25vcm1hbGl6ZWQiLCAic2NhbGVPcHRzIiwgImFkYXB0ZXJzIiwgIl9kYXRlIiwgImRhdGUiLCAibWVyZ2VJZiIsICJkaXNwbGF5Rm9ybWF0cyIsICJmb3JtYXRzIiwgIm5vcm1hbGl6ZWQiLCAiYmVmb3JlTGF5b3V0IiwgIl9hcHBseUJvdW5kcyIsICJfZ2V0TGFiZWxCb3VuZHMiLCAic291cmNlIiwgIkRhdGUiLCAibm93IiwgImVuZE9mIiwgImFyciIsICJnZXRMYWJlbFRpbWVzdGFtcHMiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAidGltZU9wdHMiLCAiX2dlbmVyYXRlIiwgIl9maWx0ZXJCZXR3ZWVuIiwgImF1dG9Ta2lwIiwgIl9nZXRMYWJlbENhcGFjaXR5IiwgImluaXRPZmZzZXRzIiwgImFmdGVyQXV0b1NraXAiLCAib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsICJnZXREZWNpbWFsRm9yVmFsdWUiLCAibGltaXQiLCAibWlub3IiLCAid2Vla2RheSIsICJoYXNXZWVrZGF5IiwgIkVycm9yIiwgImdldERhdGFUaW1lc3RhbXBzIiwgInNvcnQiLCAidG9vbHRpcEZvcm1hdCIsICJkYXRldGltZSIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgIm1heFJvdGF0aW9uIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibWV0YXMiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAiY29udHJvbGxlciIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiY29uY2F0IiwgIm5vcm1hbGl6ZSIsICJfYXJyYXlVbmlxdWUiLCAiaW50ZXJwb2xhdGUiLCAidGFibGUiLCAidmFsIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAiX2xvb2t1cEJ5S2V5IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJwcmV2IiwgImN1cnIiLCAibmV4dCIsICJhcHAiLCAiaCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm5hbWUiLCAiYXBwIiwgInBhcnNlIiwgImltcG9ydF9vYnNpZGlhbiIsICJyYW5rIiwgImVhc2UiLCAicGFyc2UiLCAic2libGluZ3MiXQp9Cg==
