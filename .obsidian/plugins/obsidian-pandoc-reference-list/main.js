/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function checkPathExt(path4, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path4.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path4, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path4, options);
    }
    function isexe(path4, options, cb) {
      fs.stat(path4, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path4, options));
      });
    }
    function sync(path4, options) {
      return checkStat(fs.statSync(path4), path4, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function isexe(path4, options, cb) {
      fs.stat(path4, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path4, options) {
      return checkStat(fs.statSync(path4), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path4, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path4, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path4, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path4, options) {
      try {
        return core.sync(path4, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path4 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which4 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path4.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path4.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which4;
    which4.sync = whichSync;
  }
});

// node_modules/cross-spawn/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/cross-spawn/node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    var pathKey2 = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var which4 = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which4.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path4.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path4.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path4.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path4.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse(command, args2, options) {
      if (args2 && !Array.isArray(args2)) {
        options = args2;
        args2 = null;
      }
      args2 = args2 ? args2.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args: args2,
        options,
        file: void 0,
        original: {
          command,
          args: args2
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    function spawn(command, args2, options) {
      const parsed = parse(command, args2, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args2, options) {
      const parsed = parse(command, args2, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});

// node_modules/shell-env/node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS({
  "node_modules/shell-env/node_modules/strip-final-newline/index.js"(exports, module2) {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  }
});

// node_modules/shell-env/node_modules/path-key/index.js
var require_path_key2 = __commonJS({
  "node_modules/shell-env/node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    var pathKey2 = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/shell-env/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "node_modules/shell-env/node_modules/npm-run-path/index.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var pathKey2 = require_path_key2();
    var npmRunPath2 = (options) => {
      options = __spreadValues({
        cwd: process.cwd(),
        path: process.env[pathKey2()],
        execPath: process.execPath
      }, options);
      let previous;
      let cwdPath = path4.resolve(options.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path4.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path4.resolve(cwdPath, "..");
      }
      const execPathDir = path4.resolve(options.cwd, options.execPath, "..");
      result.push(execPathDir);
      return result.concat(options.path).join(path4.delimiter);
    };
    module2.exports = npmRunPath2;
    module2.exports.default = npmRunPath2;
    module2.exports.env = (options) => {
      options = __spreadValues({
        env: process.env
      }, options);
      const env2 = __spreadValues({}, options.env);
      const path5 = pathKey2({ env: env2 });
      options.path = env2[path5];
      env2[path5] = module2.exports(options);
      return env2;
    };
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/shell-env/node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/shell-env/node_modules/onetime/index.js"(exports, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions2 = new WeakMap();
    var onetime2 = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime3 = function(...arguments_) {
        calledFunctions2.set(onetime3, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime3, function_);
      calledFunctions2.set(onetime3, callCount);
      return onetime3;
    };
    module2.exports = onetime2;
    module2.exports.default = onetime2;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions2.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions2.get(function_);
    };
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/core.js
var require_core = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SIGNALS = void 0;
    var SIGNALS2 = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports.SIGNALS = SIGNALS2;
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SIGRTMAX = exports.getRealtimeSignals = void 0;
    var getRealtimeSignals2 = function() {
      const length = SIGRTMAX2 - SIGRTMIN2 + 1;
      return Array.from({ length }, getRealtimeSignal2);
    };
    exports.getRealtimeSignals = getRealtimeSignals2;
    var getRealtimeSignal2 = function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN2 + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN2 = 34;
    var SIGRTMAX2 = 64;
    exports.SIGRTMAX = SIGRTMAX2;
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/signals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSignals = void 0;
    var _os = require("os");
    var _core = require_core();
    var _realtime = require_realtime();
    var getSignals2 = function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal2);
      return signals;
    };
    exports.getSignals = getSignals2;
    var normalizeSignal2 = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: { [name]: constantSignal }
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    };
  }
});

// node_modules/shell-env/node_modules/human-signals/build/src/main.js
var require_main = __commonJS({
  "node_modules/shell-env/node_modules/human-signals/build/src/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signalsByNumber = exports.signalsByName = void 0;
    var _os = require("os");
    var _signals = require_signals();
    var _realtime = require_realtime();
    var getSignalsByName2 = function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName2, {});
    };
    var getSignalByName2 = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
      return __spreadProps(__spreadValues({}, signalByNameMemo), {
        [name]: { name, number, description, supported, action, forced, standard }
      });
    };
    var signalsByName2 = getSignalsByName2();
    exports.signalsByName = signalsByName2;
    var getSignalsByNumber2 = function() {
      const signals = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber2(number, signals));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber2 = function(number, signals) {
      const signal = findSignalByNumber2(number, signals);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    var findSignalByNumber2 = function(number, signals) {
      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    };
    var signalsByNumber2 = getSignalsByNumber2();
    exports.signalsByNumber = signalsByNumber2;
  }
});

// node_modules/shell-env/node_modules/execa/lib/error.js
var require_error = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/error.js"(exports, module2) {
    "use strict";
    var { signalsByName: signalsByName2 } = require_main();
    var getErrorPrefix2 = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError2 = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName2[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix2({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
    module2.exports = makeError2;
  }
});

// node_modules/shell-env/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/stdio.js"(exports, module2) {
    "use strict";
    var aliases2 = ["stdin", "stdout", "stderr"];
    var hasAlias2 = (options) => aliases2.some((alias) => options[alias] !== void 0);
    var normalizeStdio2 = (options) => {
      if (!options) {
        return;
      }
      const { stdio } = options;
      if (stdio === void 0) {
        return aliases2.map((alias) => options[alias]);
      }
      if (hasAlias2(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases2.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases2.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    };
    module2.exports = normalizeStdio2;
    module2.exports.node = (options) => {
      const stdio = normalizeStdio2(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals2 = __commonJS({
  "node_modules/signal-exit/signals.js"(exports, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports, module2) {
    var process6 = global.process;
    var processOk = function(process7) {
      return process7 && typeof process7 === "object" && typeof process7.removeListener === "function" && typeof process7.emit === "function" && typeof process7.reallyExit === "function" && typeof process7.listeners === "function" && typeof process7.kill === "function" && typeof process7.pid === "number" && typeof process7.on === "function";
    };
    if (!processOk(process6)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals2();
      isWin = /^win/i.test(process6.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process6.__signal_exit_emitter__) {
        emitter = process6.__signal_exit_emitter__;
      } else {
        emitter = process6.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process6.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process6.emit = originalProcessEmit;
        process6.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process6.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process6.kill(process6.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process6.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process6.emit = processEmit;
        process6.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process6.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process6.exitCode = code || 0;
        emit("exit", process6.exitCode, null);
        emit("afterexit", process6.exitCode, null);
        originalProcessReallyExit.call(process6, process6.exitCode);
      };
      originalProcessEmit = process6.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process6.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process6.exitCode, null);
          emit("afterexit", process6.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/shell-env/node_modules/execa/lib/kill.js
var require_kill = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/kill.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var onExit2 = require_signal_exit();
    var DEFAULT_FORCE_KILL_TIMEOUT2 = 1e3 * 5;
    var spawnedKill2 = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout2(kill, signal, options, killResult);
      return killResult;
    };
    var setKillTimeout2 = (kill, signal, options, killResult) => {
      if (!shouldForceKill2(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout2(options);
      const t2 = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t2.unref) {
        t2.unref();
      }
    };
    var shouldForceKill2 = (signal, { forceKillAfterTimeout }, killResult) => {
      return isSigterm2(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm2 = (signal) => {
      return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout2 = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT2;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel2 = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    var timeoutKill2 = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    var setupTimeout2 = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill2(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var validateTimeout2 = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    var setExitHandler2 = (_0, _1, _2) => __async(exports, [_0, _1, _2], function* (spawned, { cleanup, detached }, timedPromise) {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit2(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    });
    module2.exports = {
      spawnedKill: spawnedKill2,
      spawnedCancel: spawnedCancel2,
      setupTimeout: setupTimeout2,
      validateTimeout: validateTimeout2,
      setExitHandler: setExitHandler2
    };
  }
});

// node_modules/shell-env/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/shell-env/node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream2 = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream2.writable = (stream) => isStream2(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream2.readable = (stream) => isStream2(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream2.duplex = (stream) => isStream2.writable(stream) && isStream2.readable(stream);
    isStream2.transform = (stream) => isStream2.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream2;
  }
});

// node_modules/shell-env/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/shell-env/node_modules/get-stream/buffer-stream.js"(exports, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/shell-env/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/shell-env/node_modules/get-stream/index.js"(exports, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream = require("stream");
    var { promisify } = require("util");
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream2(inputStream, options) {
      return __async(this, null, function* () {
        if (!inputStream) {
          throw new Error("Expected a stream");
        }
        options = __spreadValues({
          maxBuffer: Infinity
        }, options);
        const { maxBuffer } = options;
        const stream2 = bufferStream(options);
        yield new Promise((resolve, reject) => {
          const rejectPromise = (error) => {
            if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream2.getBufferedValue();
            }
            reject(error);
          };
          (() => __async(this, null, function* () {
            try {
              yield streamPipelinePromisified(inputStream, stream2);
              resolve();
            } catch (error) {
              rejectPromise(error);
            }
          }))();
          stream2.on("data", () => {
            if (stream2.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream2.getBufferedValue();
      });
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream2, options) => getStream2(stream2, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream2, options) => getStream2(stream2, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "node_modules/merge-stream/index.js"(exports, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source) {
        if (Array.isArray(source)) {
          source.forEach(add);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/stream.js
var require_stream = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/stream.js"(exports, module2) {
    "use strict";
    var isStream2 = require_is_stream();
    var getStream2 = require_get_stream();
    var mergeStream2 = require_merge_stream();
    var handleInput2 = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream2(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream2 = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream2();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData2 = (stream, streamPromise) => __async(exports, null, function* () {
      if (!stream) {
        return;
      }
      stream.destroy();
      try {
        return yield streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    });
    var getStreamPromise2 = (stream, { encoding, buffer, maxBuffer }) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding) {
        return getStream2(stream, { encoding, maxBuffer });
      }
      return getStream2.buffer(stream, { maxBuffer });
    };
    var getSpawnedResult2 = (_0, _1, _2) => __async(exports, [_0, _1, _2], function* ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) {
      const stdoutPromise = getStreamPromise2(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise2(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise2(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return yield Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData2(stdout, stdoutPromise),
          getBufferedData2(stderr, stderrPromise),
          getBufferedData2(all, allPromise)
        ]);
      }
    });
    var validateInputSync2 = ({ input }) => {
      if (isStream2(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    module2.exports = {
      handleInput: handleInput2,
      makeAllStream: makeAllStream2,
      getSpawnedResult: getSpawnedResult2,
      validateInputSync: validateInputSync2
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/promise.js
var require_promise = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/promise.js"(exports, module2) {
    "use strict";
    var nativePromisePrototype2 = (() => __async(exports, null, function* () {
    }))().constructor.prototype;
    var descriptors2 = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype2, property)
    ]);
    var mergePromise2 = (spawned, promise) => {
      for (const [property, descriptor] of descriptors2) {
        const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, __spreadProps(__spreadValues({}, descriptor), { value }));
      }
      return spawned;
    };
    var getSpawnedPromise2 = (spawned) => {
      return new Promise((resolve, reject) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve({ exitCode, signal });
        });
        spawned.on("error", (error) => {
          reject(error);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error) => {
            reject(error);
          });
        }
      });
    };
    module2.exports = {
      mergePromise: mergePromise2,
      getSpawnedPromise: getSpawnedPromise2
    };
  }
});

// node_modules/shell-env/node_modules/execa/lib/command.js
var require_command = __commonJS({
  "node_modules/shell-env/node_modules/execa/lib/command.js"(exports, module2) {
    "use strict";
    var normalizeArgs2 = (file, args2 = []) => {
      if (!Array.isArray(args2)) {
        return [file];
      }
      return [file, ...args2];
    };
    var NO_ESCAPE_REGEXP2 = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP2 = /"/g;
    var escapeArg2 = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP2.test(arg)) {
        return arg;
      }
      return `"${arg.replace(DOUBLE_QUOTES_REGEXP2, '\\"')}"`;
    };
    var joinCommand2 = (file, args2) => {
      return normalizeArgs2(file, args2).join(" ");
    };
    var getEscapedCommand2 = (file, args2) => {
      return normalizeArgs2(file, args2).map((arg) => escapeArg2(arg)).join(" ");
    };
    var SPACES_REGEXP = / +/g;
    var parseCommand2 = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand: joinCommand2,
      getEscapedCommand: getEscapedCommand2,
      parseCommand: parseCommand2
    };
  }
});

// node_modules/shell-env/node_modules/execa/index.js
var require_execa = __commonJS({
  "node_modules/shell-env/node_modules/execa/index.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var childProcess2 = require("child_process");
    var crossSpawn2 = require_cross_spawn();
    var stripFinalNewline2 = require_strip_final_newline();
    var npmRunPath2 = require_npm_run_path();
    var onetime2 = require_onetime();
    var makeError2 = require_error();
    var normalizeStdio2 = require_stdio();
    var { spawnedKill: spawnedKill2, spawnedCancel: spawnedCancel2, setupTimeout: setupTimeout2, validateTimeout: validateTimeout2, setExitHandler: setExitHandler2 } = require_kill();
    var { handleInput: handleInput2, getSpawnedResult: getSpawnedResult2, makeAllStream: makeAllStream2, validateInputSync: validateInputSync2 } = require_stream();
    var { mergePromise: mergePromise2, getSpawnedPromise: getSpawnedPromise2 } = require_promise();
    var { joinCommand: joinCommand2, parseCommand: parseCommand2, getEscapedCommand: getEscapedCommand2 } = require_command();
    var DEFAULT_MAX_BUFFER2 = 1e3 * 1e3 * 100;
    var getEnv2 = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env2 = extendEnv ? __spreadValues(__spreadValues({}, process.env), envOption) : envOption;
      if (preferLocal) {
        return npmRunPath2.env({ env: env2, cwd: localDir, execPath });
      }
      return env2;
    };
    var handleArguments2 = (file, args2, options = {}) => {
      const parsed = crossSpawn2._parse(file, args2, options);
      file = parsed.command;
      args2 = parsed.args;
      options = parsed.options;
      options = __spreadValues({
        maxBuffer: DEFAULT_MAX_BUFFER2,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true
      }, options);
      options.env = getEnv2(options);
      options.stdio = normalizeStdio2(options);
      if (process.platform === "win32" && path4.basename(file, ".exe") === "cmd") {
        args2.unshift("/q");
      }
      return { file, args: args2, options, parsed };
    };
    var handleOutput2 = (options, value, error) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline2(value);
      }
      return value;
    };
    var execa3 = (file, args2, options) => {
      const parsed = handleArguments2(file, args2, options);
      const command = joinCommand2(file, args2);
      const escapedCommand = getEscapedCommand2(file, args2);
      validateTimeout2(parsed.options);
      let spawned;
      try {
        spawned = childProcess2.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        const dummySpawned = new childProcess2.ChildProcess();
        const errorPromise = Promise.reject(makeError2({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise2(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise2(spawned);
      const timedPromise = setupTimeout2(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler2(spawned, parsed.options, timedPromise);
      const context = { isCanceled: false };
      spawned.kill = spawnedKill2.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel2.bind(null, spawned, context);
      const handlePromise = () => __async(exports, null, function* () {
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = yield getSpawnedResult2(spawned, parsed.options, processDone);
        const stdout = handleOutput2(parsed.options, stdoutResult);
        const stderr = handleOutput2(parsed.options, stderrResult);
        const all = handleOutput2(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          const returnedError = makeError2({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      });
      const handlePromiseOnce = onetime2(handlePromise);
      handleInput2(spawned, parsed.options.input);
      spawned.all = makeAllStream2(spawned, parsed.options);
      return mergePromise2(spawned, handlePromiseOnce);
    };
    module2.exports = execa3;
    module2.exports.sync = (file, args2, options) => {
      const parsed = handleArguments2(file, args2, options);
      const command = joinCommand2(file, args2);
      const escapedCommand = getEscapedCommand2(file, args2);
      validateInputSync2(parsed.options);
      let result;
      try {
        result = childProcess2.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError2({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput2(parsed.options, result.stdout, result.error);
      const stderr = handleOutput2(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError2({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error;
        }
        throw error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options) => {
      const [file, ...args2] = parseCommand2(command);
      return execa3(file, args2, options);
    };
    module2.exports.commandSync = (command, options) => {
      const [file, ...args2] = parseCommand2(command);
      return execa3.sync(file, args2, options);
    };
    module2.exports.node = (scriptPath, args2, options = {}) => {
      if (args2 && !Array.isArray(args2) && typeof args2 === "object") {
        options = args2;
        args2 = [];
      }
      const stdio = normalizeStdio2.node(options);
      const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options;
      return execa3(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args2) ? args2 : []
      ], __spreadProps(__spreadValues({}, options), {
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio,
        shell: false
      }));
    };
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController !== "undefined";
    var AC = hasAbortController ? AbortController : Object.assign(class AbortController {
      constructor() {
        this.signal = new AC.AbortSignal();
      }
      abort() {
        this.signal.aborted = true;
      }
    }, { AbortSignal: class AbortSignal {
      constructor() {
        this.aborted = false;
      }
    } });
    var warned = new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache2);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache2 = class {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod
        } = options;
        const {
          length,
          maxAge,
          stale
        } = options instanceof LRUCache2 ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.keyMap = new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, LRUCache2);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl) => {
          this.starts[index] = ttl !== 0 ? perf.now() : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t2 = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t2.unref) {
              t2.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t2.unref) {
              t2.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer)");
            }
          }
          return size;
        };
        this.addItemSize = (index, v, k, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
        this.delete = (k) => {
          if (this.size !== 0) {
            const index = this.keyMap.get(k);
            if (index !== void 0) {
              this.calculatedSize -= this.sizes[index];
            }
          }
          return LRUCache2.prototype.delete.call(this, k);
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v, k, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize on cache");
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes()) {
          const key = this.keyList[i];
          const value = this.valList[i];
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v, k, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, v, k, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k, index, options) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options
        };
        const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then((v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        });
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching");
      }
      fetch(_0) {
        return __async(this, arguments, function* (k, {
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL
        } = {}) {
          if (!this.fetchMethod) {
            return this.get(k, { allowStale, updateAgeOnGet });
          }
          const options = {
            allowStale,
            updateAgeOnGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL
          };
          let index = this.keyMap.get(k);
          if (index === void 0) {
            return this.backgroundFetch(k, index, options);
          } else {
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
              return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v;
            }
            if (!this.isStale(index)) {
              this.moveToTail(index);
              if (updateAgeOnGet) {
                this.updateItemAge(index);
              }
              return v;
            }
            const p = this.backgroundFetch(k, index, options);
            return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p;
          }
        });
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              this.delete(k);
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
    };
    module2.exports = LRUCache2;
  }
});

// node_modules/execa/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS({
  "node_modules/execa/node_modules/get-stream/buffer-stream.js"(exports, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/execa/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS({
  "node_modules/execa/node_modules/get-stream/index.js"(exports, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream = require("stream");
    var { promisify } = require("util");
    var bufferStream = require_buffer_stream2();
    var streamPipelinePromisified = promisify(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream2(inputStream, options) {
      return __async(this, null, function* () {
        if (!inputStream) {
          throw new Error("Expected a stream");
        }
        options = __spreadValues({
          maxBuffer: Infinity
        }, options);
        const { maxBuffer } = options;
        const stream2 = bufferStream(options);
        yield new Promise((resolve, reject) => {
          const rejectPromise = (error) => {
            if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream2.getBufferedValue();
            }
            reject(error);
          };
          (() => __async(this, null, function* () {
            try {
              yield streamPipelinePromisified(inputStream, stream2);
              resolve();
            } catch (error) {
              rejectPromise(error);
            }
          }))();
          stream2.on("data", () => {
            if (stream2.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream2.getBufferedValue();
      });
    }
    module2.exports = getStream2;
    module2.exports.buffer = (stream2, options) => getStream2(stream2, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream2, options) => getStream2(stream2, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// src/main.ts
__export(exports, {
  default: () => ReferenceList
});
var import_obsidian7 = __toModule(require("obsidian"));

// node_modules/shell-env/index.js
var import_node_process2 = __toModule(require("node:process"));
var import_execa = __toModule(require_execa());

// node_modules/shell-env/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// node_modules/shell-env/node_modules/strip-ansi/index.js
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(ansiRegex(), "");
}

// node_modules/default-shell/index.js
var import_node_process = __toModule(require("node:process"));
var import_node_os = __toModule(require("node:os"));
var detectDefaultShell = () => {
  const { env: env2 } = import_node_process.default;
  if (import_node_process.default.platform === "win32") {
    return env2.COMSPEC || "cmd.exe";
  }
  try {
    const { shell } = (0, import_node_os.userInfo)();
    if (shell) {
      return shell;
    }
  } catch (e) {
  }
  if (import_node_process.default.platform === "darwin") {
    return env2.SHELL || "/bin/zsh";
  }
  return env2.SHELL || "/bin/sh";
};
var defaultShell = detectDefaultShell();
var default_shell_default = defaultShell;

// node_modules/shell-env/index.js
var args = [
  "-ilc",
  'echo -n "_SHELL_ENV_DELIMITER_"; env; echo -n "_SHELL_ENV_DELIMITER_"; exit'
];
var env = {
  DISABLE_AUTO_UPDATE: "true"
};
var parseEnv = (env2) => {
  env2 = env2.split("_SHELL_ENV_DELIMITER_")[1];
  const returnValue = {};
  for (const line of stripAnsi(env2).split("\n").filter((line2) => Boolean(line2))) {
    const [key, ...values] = line.split("=");
    returnValue[key] = values.join("=");
  }
  return returnValue;
};
function shellEnv(shell) {
  return __async(this, null, function* () {
    if (import_node_process2.default.platform === "win32") {
      return import_node_process2.default.env;
    }
    try {
      const { stdout } = yield (0, import_execa.default)(shell || default_shell_default, args, { env });
      return parseEnv(stdout);
    } catch (error) {
      if (shell) {
        throw error;
      } else {
        return import_node_process2.default.env;
      }
    }
  });
}

// node_modules/shell-path/index.js
function shellPath() {
  return __async(this, null, function* () {
    const { PATH } = yield shellEnv();
    return PATH;
  });
}

// src/main.ts
var import_which3 = __toModule(require_which());

// src/editorExtension.ts
var import_language = __toModule(require("@codemirror/language"));
var import_rangeset = __toModule(require("@codemirror/rangeset"));
var import_state = __toModule(require("@codemirror/state"));
var import_stream_parser = __toModule(require("@codemirror/stream-parser"));
var import_view = __toModule(require("@codemirror/view"));
var import_obsidian = __toModule(require("obsidian"));

// src/regExps.ts
var citeRegExp = /(?<=^|[.;\s-[])(?:(\[)([^[\]@\n\r]*)((?:@[^@\s[\];,'"]+(?:; *)?)+)([^;[\]]*)(\])|(@[^@\s[\];,'"]+)(?:( *)(\[)([^[\]]+)(\]))?)/g;
var multiCiteRegExp = /(@[^@\s[\];,'"]+)(; *)?/g;
var citekeyRegExp = /(@[^@\s[\];,'"]+)/g;

// src/editorExtension.ts
var ignoreListRegEx = /code|math|templater|hashtag/;
var citeMark = (citekey, sourceFile, isPrefix, isResolved, isUnresolved) => {
  const cls = ["cm-pandoc-citation", "pandoc-citation"];
  if (isPrefix)
    cls.push("pandoc-citation-at");
  if (isResolved)
    cls.push("is-resolved");
  if (isUnresolved)
    cls.push("is-unresolved");
  return import_view.Decoration.mark({
    class: cls.join(" "),
    attributes: {
      "data-citekey": citekey,
      "data-source": sourceFile
    }
  });
};
var citeMarkFormatting = import_view.Decoration.mark({
  class: "cm-pandoc-citation-formatting"
});
var citeMarkExtra = import_view.Decoration.mark({
  class: "cm-pandoc-citation-extra"
});
var citeKeyPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.mkDeco(view);
  }
  update(update) {
    if (update.viewportChanged || update.docChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(setCiteKeyCache)))) {
      this.decorations = this.mkDeco(update.view);
    }
  }
  mkDeco(view) {
    const b = new import_rangeset.RangeSetBuilder();
    const obsView = view.state.field(import_obsidian.editorViewField);
    const citekeyCache = view.state.field(citeKeyCacheField);
    let tree;
    for (const { from, to } of view.visibleRanges) {
      const range = view.state.sliceDoc(from, to);
      let match;
      while (match = citeRegExp.exec(range)) {
        let pos = from + match.index;
        if (!tree)
          tree = (0, import_language.syntaxTree)(view.state);
        const nodeProps = tree.resolveInner(pos, 1).type.prop(import_stream_parser.tokenClassNodeProp);
        if (nodeProps && ignoreListRegEx.test(nodeProps)) {
          continue;
        }
        for (let i = 1; i <= 10; i++) {
          switch (i) {
            case 3:
              if (match[i]) {
                const multiCite = match[i];
                let m2;
                while (m2 = multiCiteRegExp.exec(multiCite)) {
                  const isUnresolved = citekeyCache == null ? void 0 : citekeyCache.unresolvedKeys.has(m2[1]);
                  const isResolved = citekeyCache == null ? void 0 : citekeyCache.resolvedKeys.has(m2[1]);
                  b.add(pos, pos + 1, citeMark(m2[1], obsView.file.path, true, isResolved, isUnresolved));
                  const withoutPrefix = m2[1].slice(1);
                  b.add(pos + 1, pos + 1 + withoutPrefix.length, citeMark(m2[1], obsView.file.path, false, isResolved, isUnresolved));
                  pos += m2[1].length;
                  if (m2[2]) {
                    b.add(pos, pos + m2[2].length, citeMarkFormatting);
                    pos += m2[2].length;
                  }
                }
              }
              continue;
            case 6:
              if (match[i]) {
                const isUnresolved = citekeyCache == null ? void 0 : citekeyCache.unresolvedKeys.has(match[i]);
                const isResolved = citekeyCache == null ? void 0 : citekeyCache.resolvedKeys.has(match[i]);
                b.add(pos, pos + 1, citeMark(match[i], obsView.file.path, true, isResolved, isUnresolved));
                const withoutPrefix = match[i].slice(1);
                b.add(pos + 1, pos + 1 + withoutPrefix.length, citeMark(match[i], obsView.file.path, false, isResolved, isUnresolved));
                pos += match[i].length;
              }
              continue;
            case 1:
            case 5:
            case 8:
            case 10:
              if (match[i]) {
                b.add(pos, pos + match[i].length, citeMarkFormatting);
                pos += match[i].length;
              }
              continue;
            case 2:
            case 4:
            case 7:
            case 9:
              if (match[i]) {
                b.add(pos, pos + match[i].length, citeMarkExtra);
                pos += match[i].length;
              }
              continue;
          }
        }
      }
    }
    return b.finish();
  }
}, {
  decorations: (v) => v.decorations
});
var setCiteKeyCache = import_state.StateEffect.define();
var citeKeyCacheField = import_state.StateField.define({
  create(state) {
    const obsView = state.field(import_obsidian.editorViewField);
    const viewManager = state.field(viewManagerField);
    if (viewManager == null ? void 0 : viewManager.cache.has(obsView.file)) {
      return viewManager.cache.get(obsView.file);
    }
    return null;
  },
  update(state, tr) {
    for (const e of tr.effects) {
      if (e.is(setCiteKeyCache)) {
        state = e.value;
      }
    }
    return state;
  }
});
var viewManagerField = import_state.StateField.define({
  create() {
    return null;
  },
  update(state) {
    return state;
  }
});

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {};

// src/lang/locale/en.ts
var en_default = {
  "Path to Bibliography File": "Path to Bibliography File",
  "The absolute path to your desired bibliography file.": "The absolute path to your desired bibliography file.",
  'Select a bibliography file. This can be overridden on a per-file basis by setting "bibliography" in the file\'s frontmatter.': `Select a bibliography file. This can be overridden on a per-file basis by setting "bibliography" in the file's frontmatter.`,
  'Path or URL to CSL File. This can be overridden on a per-file basis by setting "csl" or "citation-style" in the file\'s frontmatter.': `Path or URL to CSL File. This can be overridden on a per-file basis by setting "csl" or "citation-style" in the file's frontmatter.`,
  "The absolute path or URL your desired citation style file. Pandoc will default to Chicago Manual of Style if this is not set.": "The absolute path or URL your desired citation style file. Pandoc will default to Chicago Manual of Style if this is not set.",
  "Select a CSL file located on your computer": "Select a CSL file located on your computer",
  "Fallback Path to Pandoc": "Fallback Path to Pandoc",
  "The absolute path to the pandoc executable. This plugin will attempt to locate pandoc for you and will use this path if it fails to do so. To find pandoc, use the output of 'which pandoc' in a terminal on Mac/Linux or 'Get-Command pandoc' in powershell on Windows.": "The absolute path to the pandoc executable. This plugin will attempt to locate pandoc for you and will use this path if it fails to do so. To find pandoc, use the output of 'which pandoc' in a terminal on Mac/Linux or 'Get-Command pandoc' in powershell on Windows.",
  "Attempt to find pandoc automatically": "Attempt to find pandoc automatically",
  "Unable to find pandoc on your system. If it is installed, please manually enter a path.": "Unable to find pandoc on your system. If it is installed, please manually enter a path.",
  "Hide Links": "Hide Links",
  "Replace links with link icons to save space.": "Replace links with link icons to save space.",
  "Show Citekey Tooltips": "Show Citekey Tooltips",
  "When enabled, hovering over citekeys will open a tooltip containing a formatted citation.": "When enabled, hovering over citekeys will open a tooltip containing a formatted citation.",
  "Tooltip Delay": "Tooltip Delay",
  "Set the amount of time (in milliseconds) to wait before displaying tooltips.": "Set the amount of time (in milliseconds) to wait before displaying tooltips.",
  "Please provide the path to pandoc in the Pandoc Reference List plugin settings.": "Please provide the path to pandoc in the Pandoc Reference List plugin settings.",
  "Click to copy": "Click to copy",
  "Copy list": "Copy list",
  "No citations found in the active document.": "No citations found in the active document.",
  References: "References",
  "No citation found for ": "No citation found for ",
  "Open view": "Open view"
};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {};

// src/lang/locale/ko.ts
var ko_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {};

// src/lang/locale/sq.ts
var sq_default = {};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {};

// src/lang/helpers.ts
var localeMap = {
  ar: ar_default,
  cz: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  nl: nl_default,
  no: no_default,
  pl: pl_default,
  "pt-BR": pt_br_default,
  pt: pt_default,
  ro: ro_default,
  ru: ru_default,
  sq: sq_default,
  tr: tr_default,
  uk: tr_default,
  "zh-TW": zh_tw_default,
  zh: zh_cn_default
};
var lang = window.localStorage.getItem("language");
var locale = localeMap[lang || "en"];
function t(str) {
  if (!locale) {
    console.error("Error: locale not found", lang);
  }
  return locale && locale[str] || en_default[str];
}

// src/markdownPostprocessor.ts
function getCiteClass(isPrefix, isResolved, isUnresolved) {
  const cls = ["pandoc-citation"];
  if (isPrefix)
    cls.push("pandoc-citation-at");
  if (isResolved)
    cls.push("is-resolved");
  if (isUnresolved)
    cls.push("is-unresolved");
  return cls.join(" ");
}
function processCiteKeys(plugin) {
  return (el, ctx) => {
    var _a, _b;
    const walker = document.createNodeIterator(el, NodeFilter.SHOW_TEXT);
    const toRemove = [];
    let node;
    while (node = walker.nextNode()) {
      const content = node.nodeValue;
      if (node.parentElement && node.parentElement.tagName === "CODE") {
        continue;
      }
      let frag = createFragment();
      let match;
      let pos = 0;
      let didMatch = false;
      while (match = citeRegExp.exec(content)) {
        if (!didMatch)
          didMatch = true;
        frag.appendText(content.substring(pos, match.index));
        pos = match.index;
        for (let i = 1; i <= 10; i++) {
          switch (i) {
            case 3:
              if (match[i]) {
                const multiCite = match[i];
                let m2;
                while (m2 = multiCiteRegExp.exec(multiCite)) {
                  const { isResolved, isUnresolved } = ((_a = plugin.view) == null ? void 0 : _a.viewManager.getResolution(ctx.sourcePath, m2[1])) || { isResolved: false, isUnresolved: false };
                  frag.createSpan({
                    cls: getCiteClass(true, isResolved, isUnresolved),
                    text: m2[1][0],
                    attr: {
                      "data-citekey": m2[1],
                      "data-source": ctx.sourcePath
                    }
                  });
                  frag.createSpan({
                    cls: getCiteClass(false, isResolved, isUnresolved),
                    text: m2[1].slice(1),
                    attr: {
                      "data-citekey": m2[1],
                      "data-source": ctx.sourcePath
                    }
                  });
                  pos += m2[1].length;
                  if (m2[2]) {
                    frag.createSpan({
                      cls: "pandoc-citation-formatting",
                      text: m2[2]
                    });
                    pos += m2[2].length;
                  }
                }
              }
              continue;
            case 6:
              if (match[i]) {
                const { isResolved, isUnresolved } = ((_b = plugin.view) == null ? void 0 : _b.viewManager.getResolution(ctx.sourcePath, match[i])) || { isResolved: false, isUnresolved: false };
                frag.createSpan({
                  cls: getCiteClass(true, isResolved, isUnresolved),
                  text: match[i][0],
                  attr: {
                    "data-citekey": match[i],
                    "data-source": ctx.sourcePath
                  }
                });
                frag.createSpan({
                  cls: getCiteClass(false, isResolved, isUnresolved),
                  text: match[i].slice(1),
                  attr: {
                    "data-citekey": match[i],
                    "data-source": ctx.sourcePath
                  }
                });
                pos += match[i].length;
              }
              continue;
            case 1:
            case 5:
            case 8:
            case 10:
              if (match[i]) {
                frag.createSpan({
                  cls: "pandoc-citation-formatting",
                  text: match[i]
                });
                pos += match[i].length;
              }
              continue;
            case 2:
            case 4:
            case 7:
            case 9:
              if (match[i]) {
                frag.createSpan({
                  cls: "pandoc-citation-extra",
                  text: match[i]
                });
                pos += match[i].length;
              }
              continue;
          }
        }
      }
      if (didMatch) {
        frag.appendText(content.substring(frag.textContent.length));
        toRemove.push(node);
        node.parentNode.insertBefore(frag, node);
        frag = null;
      }
    }
    toRemove.forEach((n) => n.parentNode.removeChild(n));
  };
}

// src/settings.ts
var import_obsidian2 = __toModule(require("obsidian"));
var import_which = __toModule(require_which());
var ReferenceListSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName(t("Path to Bibliography File")).setDesc(t("The absolute path to your desired bibliography file.")).then((setting) => {
      let input;
      setting.addText((text) => {
        input = text;
        text.setValue(this.plugin.settings.pathToBibliography).onChange((value) => {
          this.plugin.settings.pathToBibliography = value;
          this.plugin.saveSettings();
        });
      });
      setting.addExtraButton((b) => {
        b.setIcon("folder");
        b.setTooltip(t(`Select a bibliography file. This can be overridden on a per-file basis by setting "bibliography" in the file's frontmatter.`));
        b.onClick(() => {
          const path4 = require("electron").remote.dialog.showOpenDialogSync({
            properties: ["openFile"]
          });
          if (path4 && path4.length) {
            input.setValue(path4[0]);
            this.plugin.settings.pathToBibliography = path4[0];
            this.plugin.saveSettings();
          }
        });
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t(`Path or URL to CSL File. This can be overridden on a per-file basis by setting "csl" or "citation-style" in the file's frontmatter.`)).setDesc(t("The absolute path or URL your desired citation style file. Pandoc will default to Chicago Manual of Style if this is not set.")).then((setting) => {
      let input;
      setting.addText((text) => {
        input = text;
        text.setValue(this.plugin.settings.cslStyle).onChange((value) => {
          this.plugin.settings.cslStyle = value;
          this.plugin.saveSettings();
        });
      });
      setting.addExtraButton((b) => {
        b.setIcon("folder");
        b.setTooltip(t("Select a CSL file located on your computer"));
        b.onClick(() => {
          const path4 = require("electron").remote.dialog.showOpenDialogSync({
            properties: ["openFile"]
          });
          if (path4 && path4.length) {
            input.setValue(path4[0]);
            this.plugin.settings.cslStyle = path4[0];
            this.plugin.saveSettings();
          }
        });
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("Fallback Path to Pandoc")).setDesc(t("The absolute path to the pandoc executable. This plugin will attempt to locate pandoc for you and will use this path if it fails to do so. To find pandoc, use the output of 'which pandoc' in a terminal on Mac/Linux or 'Get-Command pandoc' in powershell on Windows.")).then((setting) => {
      let input;
      setting.addText((text) => {
        input = text;
        text.setValue(this.plugin.settings.pathToPandoc).onChange((value) => {
          this.plugin.settings.pathToPandoc = value;
          this.plugin.saveSettings();
        });
      });
      setting.addExtraButton((b) => {
        b.setIcon("magnifying-glass");
        b.setTooltip(t("Attempt to find pandoc automatically"));
        b.onClick(() => {
          (0, import_which.default)("pandoc").then((pathToPandoc) => {
            if (pathToPandoc) {
              input.setValue(pathToPandoc);
              this.plugin.settings.pathToPandoc = pathToPandoc;
              this.plugin.saveSettings();
            } else {
              new import_obsidian2.Notice(t("Unable to find pandoc on your system. If it is installed, please manually enter a path."));
            }
          }).catch((e) => {
            new import_obsidian2.Notice(t("Unable to find pandoc on your system. If it is installed, please manually enter a path."));
            console.error(e);
          });
        });
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("Hide Links")).setDesc(t("Replace links with link icons to save space.")).addToggle((text) => text.setValue(!!this.plugin.settings.hideLinks).onChange((value) => {
      this.plugin.settings.hideLinks = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName(t("Show Citekey Tooltips")).setDesc(t("When enabled, hovering over citekeys will open a tooltip containing a formatted citation.")).addToggle((text) => text.setValue(!!this.plugin.settings.showCitekeyTooltips).onChange((value) => {
      this.plugin.settings.showCitekeyTooltips = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName(t("Tooltip Delay")).setDesc(t("Set the amount of time (in milliseconds) to wait before displaying tooltips.")).addSlider((slider) => {
      slider.setDynamicTooltip().setLimits(0, 7e3, 100).setValue(this.plugin.settings.tooltipDelay).onChange((value) => {
        this.plugin.settings.tooltipDelay = value;
        this.plugin.saveSettings();
      });
    });
  }
};

// src/tooltip.ts
var import_obsidian3 = __toModule(require("obsidian"));
var TooltipManager = class {
  constructor(plugin) {
    this.tooltipDb = 0;
    this.isScrollBound = false;
    this.scrollHandler = () => {
      if (this.isScrollBound) {
        this.hideTooltip();
        this.unbindScroll();
      }
    };
    this.plugin = plugin;
    plugin.register(this.initDelegatedEvents());
    plugin.register(() => {
      this.unbindScroll();
      this.hideTooltip();
    });
  }
  initDelegatedEvents() {
    const over = (e) => {
      if (!this.plugin.settings.showCitekeyTooltips)
        return;
      if (e.target instanceof HTMLElement) {
        const target = e.target;
        clearTimeout(this.tooltipDb);
        this.tooltipDb = window.setTimeout(() => {
          this.showTooltip(target);
        }, this.plugin.settings.tooltipDelay);
      }
    };
    const out = () => {
      if (!this.plugin.settings.showCitekeyTooltips)
        return;
      this.hideTooltip();
    };
    document.body.on("pointerover", ".pandoc-citation", over);
    document.body.on("pointerout", ".pandoc-citation", out);
    return () => {
      document.body.off("pointerover", ".pandoc-citation", over);
      document.body.off("pointerout", ".pandoc-citation", out);
    };
  }
  showTooltip(el) {
    var _a;
    if (this.tooltip) {
      this.hideTooltip();
    }
    const file = app.vault.getAbstractFileByPath(el.dataset.source);
    if (!file && !(file instanceof import_obsidian3.TFile)) {
      return;
    }
    const content = (_a = this.plugin.view) == null ? void 0 : _a.viewManager.getBibForCiteKey(file, el.dataset.citekey);
    const modClasses = this.plugin.settings.hideLinks ? " collapsed-links" : "";
    this.tooltip = document.body.createDiv({ cls: `pwc-tooltip${modClasses}` }, (div) => {
      const prev = el.previousElementSibling;
      const rect = (prev == null ? void 0 : prev.hasClass("pandoc-citation")) ? prev.getBoundingClientRect() : el.getBoundingClientRect();
      if (this.plugin.settings.hideLinks) {
        div.addClass("collapsed-links");
      }
      if (content) {
        div.append(content);
      } else {
        div.addClass("is-missing");
        div.createEl("em", {
          text: t("No citation found for ") + el.dataset.citekey
        });
      }
      setTimeout(() => {
        const viewport = window.visualViewport;
        const divRect = div.getBoundingClientRect();
        div.style.left = rect.x + divRect.width + 10 > viewport.width ? `${rect.x - (rect.x + divRect.width + 10 - viewport.width)}px` : `${rect.x}px`;
        div.style.top = rect.bottom + divRect.height + 10 > viewport.height ? `${rect.y - divRect.height - 5}px` : `${rect.bottom + 5}px`;
      });
    });
    window.addEventListener("scroll", this.scrollHandler, {
      capture: true
    });
    this.isScrollBound = true;
  }
  unbindScroll() {
    if (this.isScrollBound) {
      window.removeEventListener("scroll", this.scrollHandler, {
        capture: true
      });
      this.isScrollBound = false;
    }
  }
  hideTooltip() {
    var _a;
    clearTimeout(this.tooltipDb);
    if (this.tooltip) {
      (_a = this.tooltip) == null ? void 0 : _a.remove();
      this.tooltip = null;
    }
  }
};

// src/view.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/helpers.ts
var import_obsidian4 = __toModule(require("obsidian"));
function copyElToClipboard(el) {
  require("electron").clipboard.write({
    html: el.outerHTML,
    text: (0, import_obsidian4.htmlToMarkdown)(el.outerHTML)
  });
}

// src/viewManager.ts
var import_lru_cache = __toModule(require_lru_cache());
var import_obsidian5 = __toModule(require("obsidian"));

// src/mdToReferenceList.ts
var import_path = __toModule(require("path"));

// node_modules/execa/index.js
var import_node_buffer = __toModule(require("node:buffer"));
var import_node_path2 = __toModule(require("node:path"));
var import_node_child_process = __toModule(require("node:child_process"));
var import_node_process4 = __toModule(require("node:process"));
var import_cross_spawn = __toModule(require_cross_spawn());

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
  const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
  if (input[input.length - 1] === LF) {
    input = input.slice(0, -1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, -1);
  }
  return input;
}

// node_modules/npm-run-path/index.js
var import_node_process3 = __toModule(require("node:process"));
var import_node_path = __toModule(require("node:path"));
var import_node_url = __toModule(require("node:url"));

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env2 = process.env,
    platform = process.platform
  } = options;
  if (platform !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/npm-run-path/index.js
function npmRunPath(options = {}) {
  const {
    cwd = import_node_process3.default.cwd(),
    path: path_ = import_node_process3.default.env[pathKey()],
    execPath = import_node_process3.default.execPath
  } = options;
  let previous;
  const cwdString = cwd instanceof URL ? import_node_url.default.fileURLToPath(cwd) : cwd;
  let cwdPath = import_node_path.default.resolve(cwdString);
  const result = [];
  while (previous !== cwdPath) {
    result.push(import_node_path.default.join(cwdPath, "node_modules/.bin"));
    previous = cwdPath;
    cwdPath = import_node_path.default.resolve(cwdPath, "..");
  }
  result.push(import_node_path.default.resolve(cwdString, execPath, ".."));
  return [...result, path_].join(import_node_path.default.delimiter);
}
function npmRunPathEnv(_a = {}) {
  var _b = _a, { env: env2 = import_node_process3.default.env } = _b, options = __objRest(_b, ["env"]);
  env2 = __spreadValues({}, env2);
  const path4 = pathKey({ env: env2 });
  options.path = env2[path4];
  env2[path4] = npmRunPath(options);
  return env2;
}

// node_modules/onetime/node_modules/mimic-fn/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/onetime/index.js
var calledFunctions = new WeakMap();
var onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/human-signals/build/src/main.js
var import_os2 = __toModule(require("os"));

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = function() {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = function(value, index) {
  return {
    name: `SIGRT${index + 1}`,
    number: SIGRTMIN + index,
    action: "terminate",
    description: "Application-specific signal (realtime)",
    standard: "posix"
  };
};
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
var import_os = __toModule(require("os"));

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = function() {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
};
var normalizeSignal = function({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) {
  const {
    signals: { [name]: constantSignal }
  } = import_os.constants;
  const supported = constantSignal !== void 0;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = function() {
  const signals = getSignals();
  return signals.reduce(getSignalByName, {});
};
var getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
  return __spreadProps(__spreadValues({}, signalByNameMemo), {
    [name]: { name, number, description, supported, action, forced, standard }
  });
};
var signalsByName = getSignalsByName();
var getSignalsByNumber = function() {
  const signals = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = function(number, signals) {
  const signal = findSignalByNumber(number, signals);
  if (signal === void 0) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = function(number, signals) {
  const signal = signals.find(({ name }) => import_os2.constants.signals[name] === number);
  if (signal !== void 0) {
    return signal;
  }
  return signals.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/error.js
var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
  if (timedOut) {
    return `timed out after ${timeout} milliseconds`;
  }
  if (isCanceled) {
    return "was canceled";
  }
  if (errorCode !== void 0) {
    return `failed with ${errorCode}`;
  }
  if (signal !== void 0) {
    return `was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== void 0) {
    return `failed with exit code ${exitCode}`;
  }
  return "failed";
};
var makeError = ({
  stdout,
  stderr,
  all,
  error,
  signal,
  exitCode,
  command,
  escapedCommand,
  timedOut,
  isCanceled,
  killed,
  parsed: { options: { timeout } }
}) => {
  exitCode = exitCode === null ? void 0 : exitCode;
  signal = signal === null ? void 0 : signal;
  const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
  const errorCode = error && error.code;
  const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
  const execaMessage = `Command ${prefix}: ${command}`;
  const isError = Object.prototype.toString.call(error) === "[object Error]";
  const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
  const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
  if (isError) {
    error.originalMessage = error.message;
    error.message = message;
  } else {
    error = new Error(message);
  }
  error.shortMessage = shortMessage;
  error.command = command;
  error.escapedCommand = escapedCommand;
  error.exitCode = exitCode;
  error.signal = signal;
  error.signalDescription = signalDescription;
  error.stdout = stdout;
  error.stderr = stderr;
  if (all !== void 0) {
    error.all = all;
  }
  if ("bufferedData" in error) {
    delete error.bufferedData;
  }
  error.failed = true;
  error.timedOut = Boolean(timedOut);
  error.isCanceled = isCanceled;
  error.killed = killed && !timedOut;
  return error;
};

// node_modules/execa/lib/stdio.js
var aliases = ["stdin", "stdout", "stderr"];
var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
var normalizeStdio = (options) => {
  if (!options) {
    return;
  }
  const { stdio } = options;
  if (stdio === void 0) {
    return aliases.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return stdio;
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, aliases.length);
  return Array.from({ length }, (value, index) => stdio[index]);
};

// node_modules/execa/lib/kill.js
var import_node_os2 = __toModule(require("node:os"));
var import_signal_exit = __toModule(require_signal_exit());
var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
  const killResult = kill(signal);
  setKillTimeout(kill, signal, options, killResult);
  return killResult;
};
var setKillTimeout = (kill, signal, options, killResult) => {
  if (!shouldForceKill(signal, options, killResult)) {
    return;
  }
  const timeout = getForceKillAfterTimeout(options);
  const t2 = setTimeout(() => {
    kill("SIGKILL");
  }, timeout);
  if (t2.unref) {
    t2.unref();
  }
};
var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
var isSigterm = (signal) => signal === import_node_os2.default.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
  }
  return forceKillAfterTimeout;
};
var spawnedCancel = (spawned, context) => {
  const killResult = spawned.kill();
  if (killResult) {
    context.isCanceled = true;
  }
};
var timeoutKill = (spawned, signal, reject) => {
  spawned.kill(signal);
  reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
};
var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
  if (timeout === 0 || timeout === void 0) {
    return spawnedPromise;
  }
  let timeoutId;
  const timeoutPromise = new Promise((resolve, reject) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  });
  const safeSpawnedPromise = spawnedPromise.finally(() => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
};
var validateTimeout = ({ timeout }) => {
  if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var setExitHandler = (_0, _1, _2) => __async(void 0, [_0, _1, _2], function* (spawned, { cleanup, detached }, timedPromise) {
  if (!cleanup || detached) {
    return timedPromise;
  }
  const removeExitHandler = (0, import_signal_exit.default)(() => {
    spawned.kill();
  });
  return timedPromise.finally(() => {
    removeExitHandler();
  });
});

// node_modules/is-stream/index.js
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}

// node_modules/execa/lib/stream.js
var import_get_stream = __toModule(require_get_stream2());
var import_merge_stream = __toModule(require_merge_stream());
var handleInput = (spawned, input) => {
  if (input === void 0 || spawned.stdin === void 0) {
    return;
  }
  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
};
var makeAllStream = (spawned, { all }) => {
  if (!all || !spawned.stdout && !spawned.stderr) {
    return;
  }
  const mixed = (0, import_merge_stream.default)();
  if (spawned.stdout) {
    mixed.add(spawned.stdout);
  }
  if (spawned.stderr) {
    mixed.add(spawned.stderr);
  }
  return mixed;
};
var getBufferedData = (stream, streamPromise) => __async(void 0, null, function* () {
  if (!stream) {
    return;
  }
  stream.destroy();
  try {
    return yield streamPromise;
  } catch (error) {
    return error.bufferedData;
  }
});
var getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
  if (!stream || !buffer) {
    return;
  }
  if (encoding) {
    return (0, import_get_stream.default)(stream, { encoding, maxBuffer });
  }
  return import_get_stream.default.buffer(stream, { maxBuffer });
};
var getSpawnedResult = (_0, _1, _2) => __async(void 0, [_0, _1, _2], function* ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) {
  const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
  const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
  const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
  try {
    return yield Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error) {
    return Promise.all([
      { error, signal: error.signal, timedOut: error.timedOut },
      getBufferedData(stdout, stdoutPromise),
      getBufferedData(stderr, stderrPromise),
      getBufferedData(all, allPromise)
    ]);
  }
});

// node_modules/execa/lib/promise.js
var nativePromisePrototype = (() => __async(void 0, null, function* () {
}))().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);
var mergePromise = (spawned, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
    Reflect.defineProperty(spawned, property, __spreadProps(__spreadValues({}, descriptor), { value }));
  }
  return spawned;
};
var getSpawnedPromise = (spawned) => new Promise((resolve, reject) => {
  spawned.on("exit", (exitCode, signal) => {
    resolve({ exitCode, signal });
  });
  spawned.on("error", (error) => {
    reject(error);
  });
  if (spawned.stdin) {
    spawned.stdin.on("error", (error) => {
      reject(error);
    });
  }
});

// node_modules/execa/lib/command.js
var normalizeArgs = (file, args2 = []) => {
  if (!Array.isArray(args2)) {
    return [file];
  }
  return [file, ...args2];
};
var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
var DOUBLE_QUOTES_REGEXP = /"/g;
var escapeArg = (arg) => {
  if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
    return arg;
  }
  return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};
var joinCommand = (file, args2) => normalizeArgs(file, args2).join(" ");
var getEscapedCommand = (file, args2) => normalizeArgs(file, args2).map((arg) => escapeArg(arg)).join(" ");

// node_modules/execa/index.js
var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
  const env2 = extendEnv ? __spreadValues(__spreadValues({}, import_node_process4.default.env), envOption) : envOption;
  if (preferLocal) {
    return npmRunPathEnv({ env: env2, cwd: localDir, execPath });
  }
  return env2;
};
var handleArguments = (file, args2, options = {}) => {
  const parsed = import_cross_spawn.default._parse(file, args2, options);
  file = parsed.command;
  args2 = parsed.args;
  options = parsed.options;
  options = __spreadValues({
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: true,
    stripFinalNewline: true,
    extendEnv: true,
    preferLocal: false,
    localDir: options.cwd || import_node_process4.default.cwd(),
    execPath: import_node_process4.default.execPath,
    encoding: "utf8",
    reject: true,
    cleanup: true,
    all: false,
    windowsHide: true
  }, options);
  options.env = getEnv(options);
  options.stdio = normalizeStdio(options);
  if (import_node_process4.default.platform === "win32" && import_node_path2.default.basename(file, ".exe") === "cmd") {
    args2.unshift("/q");
  }
  return { file, args: args2, options, parsed };
};
var handleOutput = (options, value, error) => {
  if (typeof value !== "string" && !import_node_buffer.Buffer.isBuffer(value)) {
    return error === void 0 ? void 0 : "";
  }
  if (options.stripFinalNewline) {
    return stripFinalNewline(value);
  }
  return value;
};
function execa2(file, args2, options) {
  const parsed = handleArguments(file, args2, options);
  const command = joinCommand(file, args2);
  const escapedCommand = getEscapedCommand(file, args2);
  validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = import_node_child_process.default.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    const dummySpawned = new import_node_child_process.default.ChildProcess();
    const errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    return mergePromise(dummySpawned, errorPromise);
  }
  const spawnedPromise = getSpawnedPromise(spawned);
  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromise = () => __async(this, null, function* () {
    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = yield getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      const returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  });
  const handlePromiseOnce = onetime_default(handlePromise);
  handleInput(spawned, parsed.options.input);
  spawned.all = makeAllStream(spawned, parsed.options);
  return mergePromise(spawned, handlePromiseOnce);
}

// src/mdToReferenceList.ts
var import_which2 = __toModule(require_which());
function areSetsEqual(as, bs) {
  if (as.size !== bs.size)
    return false;
  for (const a of as)
    if (!bs.has(a))
      return false;
  return true;
}
function resolveHome(filepath) {
  if (filepath[0] === "~" && process.env.HOME) {
    return import_path.default.join(process.env.HOME, filepath.slice(1));
  }
  return filepath;
}
function extractCiteKeys(md) {
  const matches = md.matchAll(citekeyRegExp);
  const output = new Set();
  for (const match of matches) {
    if (!output.has(match[1])) {
      output.add(match[1]);
    }
  }
  return output;
}
function pandocMarkdownToHTML(settings, keys) {
  return __async(this, null, function* () {
    if (!settings.pathToPandoc) {
      throw new Error("pandocMarkdownToHTML path to pandoc is required");
    }
    if (!settings.pathToBibliography) {
      throw new Error("pandocMarkdownToHTML bibliography file is required");
    }
    const args2 = [
      "-f",
      "markdown",
      "-t",
      "html",
      "--citeproc",
      "--quiet",
      `--bibliography=${resolveHome(settings.pathToBibliography)}`
    ];
    if (settings.cslStyle) {
      args2.push(`--csl=${resolveHome(settings.cslStyle)}`);
    }
    try {
      const pathToPandoc = yield (0, import_which2.default)("pandoc");
      const result = yield execa2(pathToPandoc || settings.pathToPandoc, args2, {
        input: `---
nocite: "${Array.from(keys).join(", ")}"
---
`
      });
      if (result.stderr) {
        throw new Error(`pandocMarkdownToHTML ${result.stderr}`);
      }
      return result.stdout;
    } catch (e) {
      throw new Error(`pandocMarkdownToHTML ${e.message}`);
    }
  });
}
function pandocHTMLToBibFragment(html) {
  if (!html) {
    throw new Error("pandocHTMLToBibFragment received empty HTML string");
  }
  let parsed = new DOMParser().parseFromString(html, "text/html");
  const refs = parsed.getElementById("refs");
  if (!refs) {
    throw new Error("pandocHTMLToBibFragment references container not found");
  }
  parsed = null;
  return refs;
}

// src/viewManager.ts
function getCSLStyle(file, settings) {
  const metadata = app.metadataCache.getFileCache(file);
  if (!(metadata == null ? void 0 : metadata.frontmatter)) {
    return settings.cslStyle;
  }
  if (metadata.frontmatter.csl) {
    return metadata.frontmatter.csl;
  }
  if (metadata.frontmatter["citation-style"]) {
    return metadata.frontmatter.csl;
  }
  return settings.cslStyle;
}
function getBibliography(file, settings) {
  var _a;
  const metadata = app.metadataCache.getFileCache(file);
  if ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.bibliography) {
    return metadata.frontmatter.bibliography;
  }
  return settings.pathToBibliography;
}
var ViewManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.cache = new import_lru_cache.default({ max: 20 });
  }
  getBibForCiteKey(file, key) {
    if (!this.cache.has(file)) {
      return null;
    }
    const cache = this.cache.get(file);
    if (!cache.keys.has(key)) {
      return null;
    }
    const html = cache.bib.querySelector(`[id="ref-${key.slice(1)}"]`);
    if (!html) {
      return null;
    }
    return html.cloneNode(true);
  }
  getReferenceList(file, content) {
    return __async(this, null, function* () {
      const citeKeys = extractCiteKeys(content);
      if (citeKeys.size === 0) {
        return null;
      }
      const cachedDoc = this.cache.has(file) ? this.cache.get(file) : null;
      const cslStyle = getCSLStyle(file, this.plugin.settings);
      const pathToBibliography = getBibliography(file, this.plugin.settings);
      if (!cachedDoc || !areSetsEqual(cachedDoc.keys, citeKeys) || cachedDoc.cslStyle !== cslStyle || cachedDoc.pathToBibliography !== pathToBibliography) {
        try {
          const htmlStr = yield pandocMarkdownToHTML(__spreadProps(__spreadValues({}, this.plugin.settings), {
            cslStyle,
            pathToBibliography
          }), citeKeys);
          const setNull = () => {
            const resolvedKeys2 = new Set();
            const result2 = {
              keys: citeKeys,
              resolvedKeys: resolvedKeys2,
              unresolvedKeys: this.getUnresolvedKeys(citeKeys, resolvedKeys2),
              bib: null,
              cslStyle,
              pathToBibliography
            };
            this.cache.set(file, result2);
            this.dispatchResult(file, result2);
            return null;
          };
          if (!htmlStr) {
            return setNull();
          }
          const bib = pandocHTMLToBibFragment(htmlStr);
          if (!bib) {
            return setNull();
          }
          const resolvedKeys = this.getResolvedKeys(bib);
          const result = {
            keys: citeKeys,
            resolvedKeys,
            unresolvedKeys: this.getUnresolvedKeys(citeKeys, resolvedKeys),
            bib,
            cslStyle,
            pathToBibliography
          };
          this.cache.set(file, result);
          this.dispatchResult(file, result);
          return result.bib;
        } catch (e) {
          if (!e.message.includes("references container not found")) {
            console.error(e);
          }
          return null;
        }
      }
      return cachedDoc.bib;
    });
  }
  dispatchResult(file, result) {
    app.workspace.getLeavesOfType("markdown").find((l) => {
      const view = l.view;
      if (view.file === file) {
        view.previewMode.rerender(true);
        const cm = view.editor.cm;
        if (cm.dispatch) {
          cm.dispatch({
            effects: [setCiteKeyCache.of(result)]
          });
        }
      }
    });
  }
  getResolvedKeys(bib) {
    return new Set(new Set(bib.findAll(".csl-entry").map((e) => e.getAttr("id").replace(/^ref-/, "@"))));
  }
  getUnresolvedKeys(citekeys, resolved) {
    const unresolved = new Set();
    citekeys.forEach((k) => {
      if (!resolved.has(k)) {
        unresolved.add(k);
      }
    });
    return unresolved;
  }
  getReferenceListForSource(filePath) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian5.TFile && this.cache.has(file)) {
      return this.cache.get(file).bib;
    }
  }
  getResolution(filePath, key) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian5.TFile && this.cache.has(file)) {
      const cache = this.cache.get(file);
      return {
        isResolved: cache.resolvedKeys.has(key),
        isUnresolved: cache.unresolvedKeys.has(key)
      };
    }
    return {
      isResolved: false,
      isUnresolved: false
    };
  }
};

// src/view.ts
var viewType = "ReferenceListView";
var ReferenceListView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.handleSettingsUpdate = () => {
      if (this.plugin.isReady) {
        this.contentEl.toggleClass("collapsed-links", !!this.plugin.settings.hideLinks);
        this.processReferences();
      }
    };
    this.processReferences = () => __async(this, null, function* () {
      if (!this.plugin.settings.pathToPandoc) {
        return this.setMessage(t("Please provide the path to pandoc in the Pandoc Reference List plugin settings."));
      }
      if (!this.plugin.settings.pathToBibliography) {
        return this.setMessage("Please provide the path to your pandoc compatible bibliography file in the Pandoc Reference List plugin settings.");
      }
      const activeView = app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (activeView) {
        try {
          const fileContent = yield app.vault.cachedRead(activeView.file);
          const bib = yield this.viewManager.getReferenceList(activeView.file, fileContent);
          this.setViewContent(activeView.file, bib);
        } catch (e) {
          console.error(e);
        }
      } else {
        this.setNoContentMessage();
      }
    });
    this.plugin = plugin;
    this.viewManager = new ViewManager(plugin);
    this.registerEvent(app.metadataCache.on("changed", (file) => {
      if (this.plugin.isReady) {
        const activeView = app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (activeView && file === activeView.file) {
          this.processReferences();
        }
      }
    }));
    this.registerEvent(app.workspace.on("active-leaf-change", (leaf2) => {
      if (this.plugin.isReady) {
        if (leaf2 && leaf2.view instanceof import_obsidian6.MarkdownView) {
          this.processReferences();
        } else {
          this.setNoContentMessage();
        }
      }
    }));
    if (this.plugin.isReady) {
      this.processReferences();
    }
    this.plugin.emitter.on("ready", this.processReferences);
    this.plugin.emitter.on("settingsUpdated", this.handleSettingsUpdate);
    this.contentEl.addClass("pwc-reference-list");
    this.contentEl.toggleClass("collapsed-links", !!this.plugin.settings.hideLinks);
  }
  onClose() {
    var __superGet = (key) => super[key];
    return __async(this, null, function* () {
      this.viewManager.cache.clear();
      this.plugin.emitter.off("ready", this.processReferences);
      this.plugin.emitter.off("settingsUpdated", this.handleSettingsUpdate);
      return __superGet("onClose").call(this);
    });
  }
  setViewContent(file, bib) {
    if (bib && this.contentEl.firstChild !== bib) {
      if (this.plugin.settings.hideLinks) {
        bib.findAll("a").forEach((l) => {
          l.setAttribute("aria-label", l.innerText);
        });
      }
      bib.findAll(".csl-entry").forEach((e) => {
        e.setAttribute("aria-label", t("Click to copy"));
        e.onClickEvent(() => copyElToClipboard(e));
        const leafRoot = this.leaf.getRoot();
        if (leafRoot) {
          const tooltipPos = leafRoot.side === "right" ? "left" : "right";
          e.setAttribute("aria-label-position", tooltipPos);
        }
      });
      this.contentEl.empty();
      this.contentEl.createDiv({
        cls: "pwc-reference-list__title"
      }, (div) => {
        div.createDiv({ text: this.getDisplayText() });
        div.createDiv({
          cls: "pwc-copy-list",
          attr: {
            "aria-label": t("Copy list")
          }
        }, (btn) => {
          (0, import_obsidian6.setIcon)(btn, "select-all-text");
          btn.onClickEvent(() => copyElToClipboard(bib));
        });
      });
      this.contentEl.append(bib);
    } else if (!bib) {
      this.setNoContentMessage();
    }
  }
  setNoContentMessage() {
    this.setMessage(t("No citations found in the active document."));
  }
  setMessage(message) {
    this.contentEl.empty();
    this.contentEl.createDiv({
      cls: "pwc-no-content",
      text: message
    });
  }
  getViewType() {
    return viewType;
  }
  getDisplayText() {
    return t("References");
  }
  getIcon() {
    return "quote-glyph";
  }
};

// src/main.ts
function fixPath() {
  return __async(this, null, function* () {
    if (process.platform === "win32") {
      return;
    }
    try {
      const path4 = yield shellPath();
      process.env.PATH = path4 || [
        "./node_modules/.bin",
        "/.nodebrew/current/bin",
        "/usr/local/bin",
        process.env.PATH
      ].join(":");
    } catch (e) {
      console.error(e);
    }
  });
}
var DEFAULT_SETTINGS = {
  pathToPandoc: "",
  tooltipDelay: 800
};
var ReferenceList = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.isReady = false;
    this.emitSettingsUpdate = (0, import_obsidian7.debounce)(() => this.emitter.trigger("settingsUpdated"), 5e3, true);
  }
  get view() {
    const leaves = app.workspace.getLeavesOfType(viewType);
    if (!(leaves == null ? void 0 : leaves.length)) {
      return null;
    }
    return leaves[0].view;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.emitter = new import_obsidian7.Events();
      this.addSettingTab(new ReferenceListSettingsTab(this));
      this.registerView(viewType, (leaf) => {
        return new ReferenceListView(leaf, this);
      });
      document.body.toggleClass("pwc-tooltips", !!this.settings.showCitekeyTooltips);
      this.app.workspace.onLayoutReady(() => {
        this.initLeaf();
      });
      this.registerEditorExtension([
        viewManagerField.init(() => {
          var _a;
          return ((_a = this.view) == null ? void 0 : _a.viewManager) || null;
        }),
        citeKeyCacheField,
        citeKeyPlugin
      ]);
      this.registerMarkdownPostProcessor(processCiteKeys(this));
      this.tooltipManager = new TooltipManager(this);
      this.addCommand({
        id: "show-reference-list-view",
        name: t("Open view"),
        checkCallback: (checking) => {
          if (checking) {
            return this.view === null;
          }
          this.initLeaf();
        }
      });
      app.workspace.trigger("parse-style-settings");
      fixPath().then(() => __async(this, null, function* () {
        if (!this.settings.pathToPandoc) {
          try {
            const pathToPandoc = yield (0, import_which3.default)("pandoc");
            this.settings.pathToPandoc = pathToPandoc;
            this.saveSettings();
          } catch (e) {
          }
        }
        this.isReady = true;
        this.emitter.trigger("ready");
      }));
    });
  }
  onunload() {
    document.body.removeClass("pwc-tooltips");
    this.app.workspace.getLeavesOfType(viewType).forEach((leaf) => leaf.detach());
  }
  initLeaf() {
    if (this.view) {
      return;
    }
    this.app.workspace.getRightLeaf(false).setViewState({
      type: viewType
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      document.body.toggleClass("pwc-tooltips", !!this.settings.showCitekeyTooltips);
      this.emitSettingsUpdate();
      yield this.saveData(this.settings);
    });
  }
};
