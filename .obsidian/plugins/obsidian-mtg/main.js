/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianPluginMtg
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/csv.ts
var parseCsvCells = (str) => {
  const arr = [];
  var quote = false;
  for (var row = 0, col = 0, c = 0; c < str.length; c++) {
    var cc = str[c], nc = str[c + 1];
    arr[row] = arr[row] || [];
    arr[row][col] = arr[row][col] || "";
    if (cc == '"' && quote && nc == '"') {
      arr[row][col] += cc;
      ++c;
      continue;
    }
    if (cc == '"') {
      quote = !quote;
      continue;
    }
    if (cc == "," && !quote) {
      ++col;
      continue;
    }
    if (cc == "\r" && nc == "\n" && !quote) {
      ++row;
      col = 0;
      ++c;
      continue;
    }
    if (cc == "\n" && !quote) {
      ++row;
      col = 0;
      continue;
    }
    if (cc == "\r" && !quote) {
      ++row;
      col = 0;
      continue;
    }
    arr[row][col] += cc;
  }
  return arr;
};
var parseCsvFile = (fileContent, opts) => {
  const lines = fileContent.split("\n");
  const headerRow = lines[0];
  const columnNames = headerRow.split(",");
  const linesOfCells = parseCsvCells(fileContent);
  return linesOfCells.splice(1).map((cells) => {
    const obj = {};
    if (cells.length !== 0 || cells.length !== 0) {
      columnNames.forEach((columnName, idx) => {
        obj[columnName] = cells[idx];
      });
    }
    return obj;
  });
};

// src/collection.ts
var DEFAULT_COLLECTION_FILE_EXTENSION = "mtg.collection.csv";
var DEFAULT_COLLECTION_NAME_COLUMN = "Name";
var DEFAULT_COLLECTION_COUNT_COLUMN = "Count";
var DEFAULT_COLLECTION_SYNC_INTERVAL = 5e3;
var UNKNOWN_CARD = "UNKNOWN_CARD";
var nameToId = (rawName) => {
  return (rawName || "").split("//")[0].trim().toLowerCase();
};
var createCardCountsMapping = async (fileContents, settings) => {
  const counts = {};
  const countsColumnName = settings.collection.countColumn;
  const nameColumnName = settings.collection.nameColumn;
  const recordsList = fileContents.map((fileContent) => {
    const records = parseCsvFile(fileContent, {
      skip_empty_lines: true
    });
    return records;
  });
  recordsList.forEach((records) => {
    records.forEach((record) => {
      const count = parseInt(record[countsColumnName] || "0");
      const cardName = nameToId(record[nameColumnName]) || UNKNOWN_CARD;
      if (!counts[cardName]) {
        counts[cardName] = count;
      } else {
        counts[cardName] = counts[cardName] + count;
      }
    });
  });
  return counts;
};
var processCollectionFiles = async (vault, settings) => {
  return (await Promise.all(vault.getFiles().filter((f) => {
    if (f.extension === "csv") {
      return f.name.endsWith(`${settings.collection.fileExtension}`);
    } else {
      return false;
    }
  }).map((fileContents) => {
    try {
      return vault.cachedRead(fileContents);
    } catch (err) {
      return "";
    }
  }))).filter((s) => s.length);
};
var syncCounts = async (vault, settings) => {
  const collectionContents = await processCollectionFiles(vault, settings);
  return createCardCountsMapping(collectionContents, settings);
};

// src/http.ts
var import_obsidian = require("obsidian");
function promiseWrappedRequest(options) {
  return new Promise(async (resolve, reject) => {
    const response = await (0, import_obsidian.requestUrl)(options);
    if (response.status < 400) {
      const scryfallData = response.json;
      resolve(scryfallData);
    } else {
      reject(new Error(`RequestError: ${response.status}: ${response.text}`));
    }
  });
}

// src/scryfall.ts
var querystring = require("querystring");
var MAX_SCRYFALL_BATCH_SIZE = 75;
var getMultipleCardData = async (cardNames, request = promiseWrappedRequest) => {
  const cardIdentifiers = cardNames.map((cardName) => ({
    name: cardName
  }));
  const postData = JSON.stringify({
    identifiers: cardIdentifiers
  });
  const params = {
    url: "https://api.scryfall.com/cards/collection",
    method: "POST",
    body: postData,
    contentType: "application/json"
  };
  return request(params);
};

// src/dom-utils.ts
function createSpan(root, params) {
  if (root.createSpan) {
    return root.createSpan(params);
  }
  const el = document.createElement("span");
  if (!params || Object.keys(params).length === 0) {
    return el;
  }
  const { cls, text } = params;
  if (Array.isArray(cls)) {
    cls.forEach((c) => el.classList.add(c));
  } else {
    if (cls) {
      el.classList.add(cls);
    }
  }
  if (text) {
    el.textContent = text;
  }
  root.appendChild(el);
  return el;
}
function createDiv(root, params) {
  if (root.createDiv) {
    return root.createDiv(params);
  }
  const el = document.createElement("div");
  if (!params || Object.keys(params).length === 0) {
    return el;
  }
  const { cls, text } = params;
  if (Array.isArray(cls)) {
    cls.forEach((c) => el.classList.add(c));
  } else {
    if (cls) {
      el.classList.add(cls);
    }
  }
  if (text) {
    el.textContent = text;
  }
  root.appendChild(el);
  return el;
}

// src/renderer.ts
var DEFAULT_SECTION_NAME = "Deck:";
var COMMENT_DELIMITER = "#";
var lineMatchRE = /(\d+)\s(.*)/;
var setCodesRE = /(\([A-Za-z0-9]{3}\)\s\d+)/;
var lineWithSetCodes = /(\d+)\s+([\w| ,']*)\s+(\([A-Za-z0-9]{3}\)\s\d+)/;
var blankLineRE = /^\s+$/;
var headingMatchRE = new RegExp("^[^[0-9|" + COMMENT_DELIMITER + "]");
var currencyMapping = {
  usd: "$",
  eur: "\u20AC",
  tix: "Tx"
};
var getCardPrice = (cardName, cardDataById, settings) => {
  var _a, _b, _c;
  const cardId = nameToId(cardName);
  const cardData = cardDataById[cardId];
  const preferredCurrency = settings.decklist.preferredCurrency;
  if (!cardData) {
    return null;
  } else {
    if (preferredCurrency === "eur") {
      return ((_a = cardData.prices) == null ? void 0 : _a.eur) || null;
    } else if (preferredCurrency === "tix") {
      return ((_b = cardData.prices) == null ? void 0 : _b.tix) || null;
    } else {
      return ((_c = cardData.prices) == null ? void 0 : _c.usd) || null;
    }
  }
};
var parseLines = (rawLines, cardCounts) => {
  let shouldSkipGlobalCounts = !Object.keys(cardCounts).length;
  return rawLines.map((line) => {
    if (!line.length || line.match(blankLineRE)) {
      return {
        lineType: "blank"
      };
    }
    if (line.match(headingMatchRE)) {
      return {
        lineType: "section",
        text: line
      };
    }
    if (line.startsWith(COMMENT_DELIMITER + " ")) {
      return {
        lineType: "comment",
        comments: [line]
      };
    }
    let lineWithoutComments = line;
    const comments = [];
    if (lineWithoutComments.match(lineWithSetCodes)) {
      lineWithoutComments = lineWithoutComments.replace(setCodesRE, "").trim();
    }
    if (line.includes(COMMENT_DELIMITER)) {
      const lineAndComments = line.split(COMMENT_DELIMITER);
      lineAndComments.slice(1).forEach((comment) => comments.push(comment));
      lineWithoutComments = lineAndComments[0];
    }
    let lineParts = lineWithoutComments.match(lineMatchRE);
    if (lineParts == null) {
      return {
        lineType: "error",
        errors: [`invalid line: ${line}`]
      };
    } else {
      const cardCount = parseInt(lineParts[1] || "0");
      const cardName = lineParts[2];
      const cardId = nameToId(cardName);
      const errors = [];
      let globalCount = null;
      if (!shouldSkipGlobalCounts) {
        globalCount = cardCounts[cardId] || 0;
      }
      if (cardName.length === 0) {
        errors.push(`Unable to parse card name from: ${line}`);
      }
      return {
        lineType: "card",
        cardCount,
        globalCount,
        cardName,
        comments,
        errors
      };
    }
  });
};
var buildDistinctCardNamesList = (lines) => {
  return Array.from(new Set(lines.map((line) => line.cardName || "").filter((line) => line !== "")));
};
var fetchCardDataFromScryfall = async (distinctCardNames) => {
  const batches = [];
  let currentBatch = [];
  batches.push(currentBatch);
  distinctCardNames.forEach((cardName) => {
    if (currentBatch.length === MAX_SCRYFALL_BATCH_SIZE) {
      batches.push(currentBatch);
      currentBatch = [];
    }
    currentBatch.push(nameToId(cardName));
  });
  const cardDataInBatches = await Promise.all(batches.map((batch) => getMultipleCardData(batch)));
  const cardDataByCardId = {};
  const cards = [];
  cardDataInBatches.forEach((batch) => {
    batch.data.forEach((card) => {
      cards.push(card);
      if (card.name) {
        const cardId = nameToId(card.name);
        cardDataByCardId[cardId] = card;
      }
    });
  });
  return cardDataByCardId;
};
var renderDecklist = async (root, source, cardCounts, settings, dataFetcher = fetchCardDataFromScryfall) => {
  const containerEl = createDiv(root, {});
  containerEl.classList.add("decklist");
  const lines = source.split("\n");
  const parsedLines = parseLines(lines, cardCounts);
  const linesBySection = {};
  let currentSection = DEFAULT_SECTION_NAME;
  let sections = [];
  const idsToNames = {};
  parsedLines.forEach((line, idx) => {
    if (idx == 0 && line.lineType !== "section") {
      currentSection = `${currentSection}`;
      sections.push(`${currentSection}`);
    }
    if (line.lineType === "section") {
      currentSection = line.text || DEFAULT_SECTION_NAME;
      sections.push(`${currentSection}`);
    } else {
      if (!linesBySection[currentSection]) {
        linesBySection[currentSection] = [];
      }
      linesBySection[currentSection].push(line);
    }
  });
  const distinctCardNames = buildDistinctCardNamesList(parsedLines);
  let cardDataByCardId = {};
  try {
    cardDataByCardId = await dataFetcher(distinctCardNames);
  } catch (err) {
    console.log("Error fetching card data: ", err);
  }
  const hasCardInfo = Object.keys(cardDataByCardId).length > 0;
  const sectionContainers = [];
  const header = createDiv(containerEl, {
    cls: "header"
  });
  const imgElContainer = document.createElement("div");
  imgElContainer.classList.add("card-image-container");
  const imgEl = document.createElement("img");
  imgEl.classList.add("card-image");
  imgElContainer.appendChild(imgEl);
  header.appendChild(imgElContainer);
  const footer = document.createElement("div");
  footer.classList.add("footer");
  const sectionTotalCounts = sections.reduce((acc, curr) => ({ ...acc, [curr]: 0 }), {});
  const sectionTotalCost = sections.reduce((acc, curr) => ({ ...acc, [curr]: 0 }), {});
  const missingCardCounts = {};
  sections.forEach((section) => {
    const sectionContainer = document.createElement("div");
    sectionContainer.classList.add("decklist__section-container");
    const sectionHedingEl = document.createElement("h3");
    sectionHedingEl.classList.add("decklist__section-heading");
    sectionContainer.appendChild(sectionHedingEl);
    const sectionList = document.createElement("ul");
    sectionList.classList.add("decklist__section-list");
    const sectionMissingCardCounts = {};
    linesBySection[section].forEach((line) => {
      var _a, _b, _c;
      const lineEl = document.createElement("li");
      lineEl.classList.add("decklist__section-list-item");
      if (line.lineType === "card") {
        const cardCountEl = createSpan(lineEl, {
          cls: "count"
        });
        const cardNameEl = createSpan(lineEl, {
          cls: "card-name"
        });
        if (line.cardName) {
          const cardId = nameToId(line.cardName);
          const cardInfo = cardDataByCardId[cardId];
          if (settings.decklist.showCardNamesAsHyperlinks && cardInfo && cardInfo.scryfall_uri) {
            const cardLinkEl = document.createElement("a");
            const purchaseUri = cardInfo.scryfall_uri;
            cardLinkEl.href = purchaseUri;
            cardLinkEl.textContent = `${cardInfo.name}`;
            cardNameEl.appendChild(cardLinkEl);
          } else {
            cardNameEl.textContent = `${cardInfo && cardInfo.name || line.cardName || UNKNOWN_CARD}`;
          }
        }
        let cardErrorsEl = null;
        if (line.errors && line.errors.length) {
          cardErrorsEl = createSpan(lineEl, {
            cls: "error",
            text: ((_a = line.errors) == null ? void 0 : _a.join(",")) || ""
          });
        }
        const cardCommentsEl = createSpan(lineEl, {
          cls: "comment",
          text: ((_b = line.comments) == null ? void 0 : _b.join("#")) || ""
        });
        const cardPriceEl = createSpan(lineEl, {
          cls: "card-price"
        });
        let cardPrice;
        if (line.cardName) {
          cardPrice = getCardPrice(line.cardName, cardDataByCardId, settings);
        }
        const lineCardCount = line.cardCount || 0;
        const lineGlobalCount = line.globalCount === null ? -1 : line.globalCount || 0;
        if (lineGlobalCount !== -1 && lineCardCount > lineGlobalCount) {
          const counts = createSpan(cardCountEl);
          createSpan(counts, {
            cls: "error",
            text: `${lineGlobalCount}`
          });
          createSpan(counts, {
            text: ` / ${lineCardCount}`
          });
          lineEl.classList.add("insufficient-count");
          const cardId = nameToId(line.cardName);
          missingCardCounts[cardId] = (missingCardCounts[cardId] || 0) + (lineCardCount - lineGlobalCount);
          sectionMissingCardCounts[cardId] = (sectionMissingCardCounts[cardId] || 0) + (lineCardCount - lineGlobalCount);
          if (cardPrice) {
            cardPriceEl.classList.add("insufficient-count");
            const totalPrice = lineCardCount * parseFloat(cardPrice);
            const amountOwned = lineGlobalCount * parseFloat(cardPrice);
            const amountOwnedEl = createSpan(cardPriceEl, {
              cls: "error",
              text: `${currencyMapping[settings.decklist.preferredCurrency]}${amountOwned.toFixed(2)}`
            });
            createSpan(cardPriceEl, {
              text: ` / ${currencyMapping[settings.decklist.preferredCurrency]}${totalPrice.toFixed(2)}`
            });
            sectionTotalCost[section] = sectionTotalCost[section] + (totalPrice || 0);
          }
        } else {
          cardCountEl.textContent = `${lineCardCount}`;
          if (cardPrice) {
            const totalPrice = lineCardCount * parseFloat(cardPrice);
            const displayPrice = `${currencyMapping[settings.decklist.preferredCurrency]}${totalPrice.toFixed(2)}`;
            cardPriceEl.textContent = displayPrice;
            sectionTotalCost[section] = sectionTotalCost[section] + (totalPrice || 0);
          }
        }
        sectionTotalCounts[section] = sectionTotalCounts[section] + (line.cardCount || 0);
        if (cardErrorsEl) {
          lineEl.appendChild(cardErrorsEl);
        }
        if (settings.decklist.showCardPreviews) {
          lineEl.addEventListener("mouseenter", () => {
            var _a2, _b2;
            const cardId = nameToId(line.cardName);
            const cardInfo = cardDataByCardId[cardId];
            let imgUri;
            if (cardInfo) {
              if (cardInfo.image_uris) {
                imgUri = (_a2 = cardInfo.image_uris) == null ? void 0 : _a2.large;
              } else if (cardInfo.card_faces && cardInfo.card_faces.length > 1) {
                imgUri = (_b2 = cardInfo.card_faces[0].image_uris) == null ? void 0 : _b2.large;
              }
              const offsetPaddingTop = 16;
              imgElContainer.style.top = `${lineEl.offsetTop + offsetPaddingTop}px`;
              imgElContainer.style.left = `${cardCommentsEl.offsetLeft}px`;
            }
            if (typeof imgUri !== "undefined") {
              imgEl.src = imgUri;
            }
          });
          lineEl.addEventListener("mouseleave", () => {
            imgEl.src = "";
          });
        }
        sectionList.appendChild(lineEl);
      } else if (line.lineType === "comment") {
        createSpan(lineEl, {
          cls: "comment",
          text: ((_c = line.comments) == null ? void 0 : _c.join(" ")) || ""
        });
        sectionList.appendChild(lineEl);
      }
    });
    sectionHedingEl.textContent = `${section}`;
    sectionContainer.appendChild(sectionList);
    const horizontalDividorEl = document.createElement("hr");
    sectionContainer.appendChild(horizontalDividorEl);
    const totalsEl = createDiv(sectionContainer, {
      cls: "decklist__section-totals"
    });
    const sectionMissingCardIds = Object.keys(sectionMissingCardCounts);
    const totalCardsEl = createSpan(sectionContainer);
    const totalCostEl = createSpan(sectionContainer);
    if (sectionMissingCardIds.length) {
      const totalMissingCountInSection = Object.values(sectionMissingCardCounts).reduce((acc, v) => acc + v, 0);
      const totalCardsOwned = sectionTotalCounts[section] - totalMissingCountInSection;
      createSpan(totalCardsEl, {
        cls: "error",
        text: `${totalCardsOwned}`
      });
      createSpan(totalCardsEl, {
        cls: "insufficient-count",
        text: ` / ${sectionTotalCounts[section]}`
      });
      totalCardsEl.classList.add("decklist__section-totals__count");
      const totalMissingCostInSection = Object.keys(sectionMissingCardCounts).reduce((acc, cardId) => {
        const countNeeded = sectionMissingCardCounts[cardId];
        const cardPrice = parseFloat(getCardPrice(cardId, cardDataByCardId, settings) || "0.00");
        return acc + cardPrice * countNeeded;
      }, 0);
      if (hasCardInfo) {
        const totalValueOwned = sectionTotalCost[section] - totalMissingCostInSection;
        const totalValueOwnedEl = createSpan(totalCostEl, {
          cls: "error",
          text: `${currencyMapping[settings.decklist.preferredCurrency]}${totalValueOwned.toFixed(2)}`
        });
        createSpan(totalCostEl, {
          cls: "insufficient-count",
          text: ` / ${currencyMapping[settings.decklist.preferredCurrency]}${sectionTotalCost[section].toFixed(2)}`
        });
      }
    } else {
      totalCardsEl.classList.add("decklist__section-totals__count");
      totalCardsEl.textContent = `${sectionTotalCounts[section]}`;
      totalCostEl.textContent = `${currencyMapping[settings.decklist.preferredCurrency]}${sectionTotalCost[section].toFixed(2)}`;
    }
    totalsEl.appendChild(totalCardsEl);
    const totalCardsUnitEl = createSpan(totalsEl, {
      cls: "card-name",
      text: "cards"
    });
    if (hasCardInfo) {
      totalsEl.appendChild(totalCostEl);
    }
    sectionContainer.appendChild(totalsEl);
    sectionContainers.push(sectionContainer);
  });
  sectionContainers.forEach((sectionContainer) => containerEl.appendChild(sectionContainer));
  const buylistCardIds = Object.keys(missingCardCounts);
  const buylistCardCounts = Object.values(missingCardCounts).reduce((acc, val) => acc + val, 0);
  if (buylistCardIds.length && settings.decklist.showBuylist) {
    const buylist = document.createElement("div");
    buylist.classList.add("buylist-container");
    const buylistHeader = document.createElement("h3");
    buylistHeader.classList.add("decklist__section-heading");
    buylistHeader.textContent = "Buylist: ";
    buylist.appendChild(buylistHeader);
    let totalCostOfBuylist = 0;
    buylistCardIds.forEach((cardId) => {
      var _a, _b;
      const cardInfo = cardDataByCardId[cardId];
      const buylistLineEl2 = document.createElement("div");
      buylistLineEl2.classList.add("buylist-line");
      const countNeeded = missingCardCounts[cardId];
      const countEl = createSpan(buylistLineEl2, {
        cls: "decklist__section-totals__count",
        text: `${countNeeded}`
      });
      if (cardInfo) {
        const cardName = cardInfo.name || "";
        const cardNameEl = createSpan(buylistLineEl2, {
          cls: "card-name"
        });
        if (settings.decklist.showCardNamesAsHyperlinks && cardInfo && ((_a = cardInfo.purchase_uris) == null ? void 0 : _a.tcgplayer)) {
          const cardLinkEl = document.createElement("a");
          const purchaseUri = (_b = cardInfo.purchase_uris) == null ? void 0 : _b.tcgplayer;
          cardLinkEl.href = purchaseUri;
          cardLinkEl.textContent = `${cardName}`;
          cardNameEl.appendChild(cardLinkEl);
        } else {
          cardNameEl.textContent = `${cardName}`;
        }
        const cardPrice = parseFloat(getCardPrice(cardName, cardDataByCardId, settings) || "0.00");
        totalCostOfBuylist = totalCostOfBuylist + cardPrice * countNeeded;
        createSpan(buylistLineEl2, {
          text: " "
        });
        if (settings.decklist.showCardPreviews) {
          buylistLineEl2.addEventListener("mouseenter", () => {
            var _a2, _b2;
            const cardId2 = nameToId(cardName);
            const cardInfo2 = cardDataByCardId[cardId2];
            let imgUri;
            if (cardInfo2) {
              if (cardInfo2.image_uris) {
                imgUri = (_a2 = cardInfo2.image_uris) == null ? void 0 : _a2.large;
              } else if (cardInfo2.card_faces && cardInfo2.card_faces.length > 1) {
                imgUri = (_b2 = cardInfo2.card_faces[0].image_uris) == null ? void 0 : _b2.large;
              }
              const offsetPaddingTop = 16;
              imgElContainer.style.top = `${buylistLineEl2.offsetTop + offsetPaddingTop}px`;
              imgElContainer.style.left = `${cardNameEl.offsetLeft + Math.round(cardNameEl.innerWidth / 2)}px`;
            }
            if (typeof imgUri !== "undefined") {
              imgEl.src = imgUri;
            }
          });
          buylistLineEl2.addEventListener("mouseleave", () => {
            imgEl.src = "";
          });
        }
        buylist.appendChild(buylistLineEl2);
      } else {
        createSpan(buylistLineEl2, {
          cls: "card-name",
          text: cardId || UNKNOWN_CARD
        });
        buylist.appendChild(buylistLineEl2);
      }
    });
    const horizontalDividorEl = document.createElement("hr");
    buylist.appendChild(horizontalDividorEl);
    const buylistLineEl = document.createElement("div");
    buylistLineEl.classList.add("buylist-line");
    createSpan(buylistLineEl, {
      cls: "decklist__section-totals__count",
      text: `${buylistCardCounts} `
    });
    createSpan(buylistLineEl, {
      cls: "card-name",
      text: "cards"
    });
    let totalPriceEl = null;
    if (hasCardInfo) {
      totalPriceEl = createSpan(buylistLineEl, {
        cls: "decklist__section-totals",
        text: `${currencyMapping[settings.decklist.preferredCurrency]}${totalCostOfBuylist.toFixed(2)}`
      });
    }
    buylist.appendChild(buylistLineEl);
    footer.appendChild(buylist);
  }
  containerEl.appendChild(footer);
  return containerEl;
};

// main.ts
var DEFAULT_SETTINGS = {
  collection: {
    fileExtension: DEFAULT_COLLECTION_FILE_EXTENSION,
    nameColumn: DEFAULT_COLLECTION_NAME_COLUMN,
    countColumn: DEFAULT_COLLECTION_COUNT_COLUMN,
    syncIntervalMs: DEFAULT_COLLECTION_SYNC_INTERVAL
  },
  decklist: {
    preferredCurrency: "usd",
    showCardNamesAsHyperlinks: true,
    showCardPreviews: true,
    showBuylist: true
  }
};
var ObsidianPluginMtg = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ObsidianPluginMtgSettingsTab(this.app, this));
    const { vault } = this.app;
    vault.on("modify", async (f) => {
      var _a;
      if (f.name.endsWith("csv")) {
        const settings = this.settings;
        const collectionFileExt = ((_a = settings.collection) == null ? void 0 : _a.fileExtension) || "";
        if (f.name.endsWith(collectionFileExt)) {
          this.cardCounts = await syncCounts(vault, settings);
        }
      }
    });
    this.app.workspace.onLayoutReady(async () => {
      this.cardCounts = await syncCounts(vault, this.settings);
    });
    this.registerMarkdownCodeBlockProcessor("mtg-deck", async (source, el, ctx) => {
      let error = null;
      if (!this.cardCounts) {
        this.cardCounts = await syncCounts(vault, this.settings);
      }
      try {
        await renderDecklist(el, source, this.cardCounts, this.settings);
      } catch (err) {
        error = err;
        console.log(err);
        const errorNode = document.createDiv({
          text: error,
          cls: "obsidian-plugin-mtg-error"
        });
        el.appendChild(errorNode);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ObsidianPluginMtgSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Settings for Obsidian MtG Plugin."
    });
    new import_obsidian2.Setting(containerEl).setName("Collection CSV").setDesc("Path to your collection as a CSV file").addText((text) => text.setPlaceholder(".mtg.collection.csv").setValue(this.plugin.settings.collection.fileExtension).onChange(async (value) => {
      this.plugin.settings.collection.fileExtension = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Card name column name").setDesc("The name of the CSV column used for card names").addText((text) => text.setPlaceholder("Name").setValue(this.plugin.settings.collection.nameColumn).onChange(async (value) => {
      this.plugin.settings.collection.nameColumn = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Card count column name").setDesc("The name of the CSV column used for card counts/quantity").addText((text) => text.setPlaceholder("Count").setValue(this.plugin.settings.collection.nameColumn).onChange(async (value) => {
      this.plugin.settings.collection.countColumn = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Preferred Currency").setDesc("The currency you prefer when viewing card prices in your decklist").addDropdown((dropdown) => dropdown.addOption("usd", "USD").addOption("eur", "EUR").addOption("tix", "Tix").onChange(async (value) => {
      this.plugin.settings.decklist.preferredCurrency = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Card Name Hyperlinks").setDesc("Enables card names that link to Scryfall or purchasing sites when possible").addToggle((toggle) => toggle.setValue(this.plugin.settings.decklist.showCardNamesAsHyperlinks).onChange(async (value) => {
      this.plugin.settings.decklist.showCardNamesAsHyperlinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Card Images").setDesc("Enables card previews when hovering with the mouse on desktop").addToggle((toggle) => toggle.setValue(this.plugin.settings.decklist.showCardPreviews).onChange(async (value) => {
      this.plugin.settings.decklist.showCardPreviews = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Buylist").setDesc("Enables a buylist below your decklist with buylinks for each card").addToggle((toggle) => toggle.setValue(this.plugin.settings.decklist.showBuylist).onChange(async (value) => {
      this.plugin.settings.decklist.showBuylist = value;
      await this.plugin.saveSettings();
    }));
  }
};
