/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getAPI2 = (app2) => {
      var _a;
      if (app2)
        return (_a = app2.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled3 = (app2) => app2.plugins.enabledPlugins.has("dataview");
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled3;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t3, e) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e() : typeof define == "function" && define.amd ? define(e) : (t3 = typeof globalThis != "undefined" ? globalThis : t3 || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t3 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $ = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t4, e2, n3) {
        var r3 = String(t4);
        return !r3 || r3.length >= e2 ? t4 : "" + Array(e2 + 1 - r3.length).join(n3) + t4;
      }, g2 = { s: m, z: function(t4) {
        var e2 = -t4.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i3, 2, "0");
      }, m: function t4(e2, n3) {
        if (e2.date() < n3.date())
          return -t4(n3, e2);
        var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), f2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(t4) {
        return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return t4 === void 0;
      } }, v2 = "en", D2 = {};
      D2[v2] = M2;
      var p2 = function(t4) {
        return t4 instanceof _24;
      }, S2 = function t4(e2, n3, r3) {
        var i3;
        if (!e2)
          return v2;
        if (typeof e2 == "string") {
          var s3 = e2.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1)
            return t4(u3[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i3 = a3;
        }
        return !r3 && i3 && (v2 = i3), i3 || !r3 && v2;
      }, w2 = function(t4, e2) {
        if (p2(t4))
          return t4.clone();
        var n3 = typeof e2 == "object" ? e2 : {};
        return n3.date = t4, n3.args = arguments, new _24(n3);
      }, O2 = g2;
      O2.l = S2, O2.i = p2, O2.w = function(t4, e2) {
        return w2(t4, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _24 = function() {
        function M3(t4) {
          this.$L = S2(t4.locale, null, true), this.parse(t4);
        }
        var m2 = M3.prototype;
        return m2.parse = function(t4) {
          this.$d = function(t5) {
            var e2 = t5.date, n3 = t5.utc;
            if (e2 === null)
              return new Date(NaN);
            if (O2.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if (typeof e2 == "string" && !/Z$/i.test(e2)) {
              var r3 = e2.match(l2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t4), this.$x = t4.x || {}, this.init();
        }, m2.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, m2.$utils = function() {
          return O2;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t4, e2) {
          var n3 = w2(t4);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m2.isAfter = function(t4, e2) {
          return w2(t4) < this.startOf(e2);
        }, m2.isBefore = function(t4, e2) {
          return this.endOf(e2) < w2(t4);
        }, m2.$g = function(t4, e2, n3) {
          return O2.u(t4) ? this[e2] : this.set(n3, t4);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t4, e2) {
          var n3 = this, r3 = !!O2.u(e2) || e2, h3 = O2.p(t4), $2 = function(t5, e3) {
            var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e3, t5) : new Date(n3.$y, e3, t5), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, l3 = function(t5, e3) {
            return O2.w(n3.toDate()[t5].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m3 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
          switch (h3) {
            case c2:
              return r3 ? $2(1, 0) : $2(31, 11);
            case f2:
              return r3 ? $2(1, M4) : $2(0, M4 + 1);
            case o2:
              var v3 = this.$locale().weekStart || 0, D3 = (y3 < v3 ? y3 + 7 : y3) - v3;
              return $2(r3 ? m3 - D3 : m3 + (6 - D3), M4);
            case a2:
            case d2:
              return l3(g3 + "Hours", 0);
            case u2:
              return l3(g3 + "Minutes", 1);
            case s2:
              return l3(g3 + "Seconds", 2);
            case i2:
              return l3(g3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t4) {
          return this.startOf(t4, false);
        }, m2.$set = function(t4, e2) {
          var n3, o3 = O2.p(t4), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === f2 || o3 === c2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[$2](l3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l3);
          return this.init(), this;
        }, m2.set = function(t4, e2) {
          return this.clone().$set(t4, e2);
        }, m2.get = function(t4) {
          return this[O2.p(t4)]();
        }, m2.add = function(r3, h3) {
          var d3, $2 = this;
          r3 = Number(r3);
          var l3 = O2.p(h3), y3 = function(t4) {
            var e2 = w2($2);
            return O2.w(e2.date(e2.date() + Math.round(t4 * r3)), $2);
          };
          if (l3 === f2)
            return this.set(f2, this.$M + r3);
          if (l3 === c2)
            return this.set(c2, this.$y + r3);
          if (l3 === a2)
            return y3(1);
          if (l3 === o2)
            return y3(7);
          var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t3, d3)[l3] || 1, m3 = this.$d.getTime() + r3 * M4;
          return O2.w(m3, this);
        }, m2.subtract = function(t4, e2) {
          return this.add(-1 * t4, e2);
        }, m2.format = function(t4) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || $;
          var r3 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t5, n4, i4, s4) {
            return t5 && (t5[n4] || t5(e2, r3)) || i4[n4].slice(0, s4);
          }, c3 = function(t5) {
            return O2.s(s3 % 12 || 12, t5, "0");
          }, d3 = n3.meridiem || function(t5, e3, n4) {
            var r4 = t5 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
          return r3.replace(y2, function(t5, e3) {
            return e3 || l3[t5] || i3.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d3, $2) {
          var l3, y3 = O2.p(d3), M4 = w2(r3), m3 = (M4.utcOffset() - this.utcOffset()) * e, g3 = this - M4, v3 = O2.m(this, M4);
          return v3 = (l3 = {}, l3[c2] = v3 / 12, l3[f2] = v3, l3[h2] = v3 / 3, l3[o2] = (g3 - m3) / 6048e5, l3[a2] = (g3 - m3) / 864e5, l3[u2] = g3 / n2, l3[s2] = g3 / e, l3[i2] = g3 / t3, l3)[y3] || g3, $2 ? v3 : O2.a(v3);
        }, m2.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m2.$locale = function() {
          return D2[this.$L];
        }, m2.locale = function(t4, e2) {
          if (!t4)
            return this.$L;
          var n3 = this.clone(), r3 = S2(t4, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return O2.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), T = _24.prototype;
      return w2.prototype = T, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t4) {
        T[t4[1]] = function(e2) {
          return this.$g(e2, t4[0], t4[1]);
        };
      }), w2.extend = function(t4, e2) {
        return t4.$i || (t4(e2, _24, w2), t4.$i = true), w2;
      }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t4) {
        return w2(1e3 * t4);
      }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
    });
  }
});

// node_modules/dayjs/plugin/isoWeek.js
var require_isoWeek = __commonJS({
  "node_modules/dayjs/plugin/isoWeek.js"(exports, module2) {
    !function(e, t3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = t3() : typeof define == "function" && define.amd ? define(t3) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_isoWeek = t3();
    }(exports, function() {
      "use strict";
      var e = "day";
      return function(t3, i2, s2) {
        var a2 = function(t4) {
          return t4.add(4 - t4.isoWeekday(), e);
        }, d2 = i2.prototype;
        d2.isoWeekYear = function() {
          return a2(this).year();
        }, d2.isoWeek = function(t4) {
          if (!this.$utils().u(t4))
            return this.add(7 * (t4 - this.isoWeek()), e);
          var i3, d3, n3, o2, r2 = a2(this), u2 = (i3 = this.isoWeekYear(), d3 = this.$u, n3 = (d3 ? s2.utc : s2)().year(i3).startOf("year"), o2 = 4 - n3.isoWeekday(), n3.isoWeekday() > 4 && (o2 += 7), n3.add(o2, e));
          return r2.diff(u2, "week") + 1;
        }, d2.isoWeekday = function(e2) {
          return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
        };
        var n2 = d2.startOf;
        d2.startOf = function(e2, t4) {
          var i3 = this.$utils(), s3 = !!i3.u(t4) || t4;
          return i3.p(e2) === "isoweek" ? s3 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n2.bind(this)(e2, t4);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = __commonJS({
  "node_modules/dayjs/plugin/localizedFormat.js"(exports, module2) {
    !function(e, t3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = t3() : typeof define == "function" && define.amd ? define(t3) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_localizedFormat = t3();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t3, o2, n2) {
        var r2 = o2.prototype, i2 = r2.format;
        n2.en.formats = e, r2.format = function(t4) {
          t4 === void 0 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
          var o3 = this.$locale().formats, n3 = function(t5, o4) {
            return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n4, r3) {
              var i3 = r3 && r3.toUpperCase();
              return n4 || o4[r3] || e[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t7, o5) {
                return t7 || o5.slice(1);
              });
            });
          }(t4, o3 === void 0 ? {} : o3);
          return i2.call(this, n3);
        };
      };
    });
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t3[p2] = s2[p2];
        }
        return t3;
      };
      __rest2 = function(s2, e) {
        var t3 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
            t3[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t3[p2[i2]] = s2[p2[i2]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _24 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f2, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_24)
            try {
              if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _24.label++;
                  return { value: op[1], done: false };
                case 5:
                  _24.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _24.ops.pop();
                  _24.trys.pop();
                  continue;
                default:
                  if (!(t3 = _24.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _24 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _24.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _24.label < t3[1]) {
                    _24.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _24.label < t3[2]) {
                    _24.label = t3[2];
                    _24.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _24.ops.pop();
                  _24.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _24);
            } catch (e) {
              op = [6, e];
              y2 = 0;
            } finally {
              f2 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o2) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
            __createBinding2(o2, m, p2);
      };
      __createBinding2 = Object.create ? function(o2, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m[k2];
        } });
      } : function(o2, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m[k2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
        if (m)
          return m.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o2, n2) {
        var m = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m)
          return o2;
        var i2 = m.call(o2), r2, ar = [], e;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m = i2["return"]))
              m.call(i2);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read2(arguments[i2]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e) {
            settle(q2[0][3], e);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator2 = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues2 = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o2[Symbol.asyncIterator], i2;
        return m ? m.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// node_modules/svelte/internal/index.js
var require_internal = __commonJS({
  "node_modules/svelte/internal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noop3() {
    }
    var identity = (x2) => x2;
    function assign2(tar, src) {
      for (const k2 in src)
        tar[k2] = src[k2];
      return tar;
    }
    function is_promise2(value) {
      return value && typeof value === "object" && typeof value.then === "function";
    }
    function add_location(element3, file, line, column, char) {
      element3.__svelte_meta = {
        loc: { file, line, column, char }
      };
    }
    function run2(fn3) {
      return fn3();
    }
    function blank_object2() {
      return Object.create(null);
    }
    function run_all2(fns) {
      fns.forEach(run2);
    }
    function is_function2(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal2(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
    }
    var src_url_equal_anchor;
    function src_url_equal(element_src, url) {
      if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement("a");
      }
      src_url_equal_anchor.href = url;
      return element_src === src_url_equal_anchor.href;
    }
    function not_equal(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2;
    }
    function is_empty2(obj) {
      return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== "function") {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }
    function subscribe2(store, ...callbacks) {
      if (store == null) {
        return noop3;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value2(store) {
      let value;
      subscribe2(store, (_24) => value = _24)();
      return value;
    }
    function component_subscribe2(component, store, callback) {
      component.$$.on_destroy.push(subscribe2(store, callback));
    }
    function create_slot2(definition, ctx, $$scope, fn3) {
      if (definition) {
        const slot_ctx = get_slot_context2(definition, ctx, $$scope, fn3);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context2(definition, ctx, $$scope, fn3) {
      return definition[1] && fn3 ? assign2($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
    }
    function get_slot_changes2(definition, $$scope, dirty, fn3) {
      if (definition[2] && fn3) {
        const lets = definition[2](fn3(dirty));
        if ($$scope.dirty === void 0) {
          return lets;
        }
        if (typeof lets === "object") {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i2 = 0; i2 < len; i2 += 1) {
            merged[i2] = $$scope.dirty[i2] | lets[i2];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context2(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes2(slot_definition, $$scope, dirty, get_slot_changes_fn);
      update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }
    function get_all_dirty_from_scope2($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i2 = 0; i2 < length; i2++) {
          dirty[i2] = -1;
        }
        return dirty;
      }
      return -1;
    }
    function exclude_internal_props(props) {
      const result = {};
      for (const k2 in props)
        if (k2[0] !== "$")
          result[k2] = props[k2];
      return result;
    }
    function compute_rest_props(props, keys) {
      const rest = {};
      keys = new Set(keys);
      for (const k2 in props)
        if (!keys.has(k2) && k2[0] !== "$")
          rest[k2] = props[k2];
      return rest;
    }
    function compute_slots2(slots) {
      const result = {};
      for (const key in slots) {
        result[key] = true;
      }
      return result;
    }
    function once(fn3) {
      let ran = false;
      return function(...args) {
        if (ran)
          return;
        ran = true;
        fn3.call(this, ...args);
      };
    }
    function null_to_empty2(value) {
      return value == null ? "" : value;
    }
    function set_store_value(store, ret, value) {
      store.set(value);
      return ret;
    }
    var has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    function action_destroyer2(action_result) {
      return action_result && is_function2(action_result.destroy) ? action_result.destroy : noop3;
    }
    var is_client = typeof window !== "undefined";
    exports.now = is_client ? () => window.performance.now() : () => Date.now();
    exports.raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
    function set_now(fn3) {
      exports.now = fn3;
    }
    function set_raf(fn3) {
      exports.raf = fn3;
    }
    var tasks2 = new Set();
    function run_tasks(now) {
      tasks2.forEach((task) => {
        if (!task.c(now)) {
          tasks2.delete(task);
          task.f();
        }
      });
      if (tasks2.size !== 0)
        exports.raf(run_tasks);
    }
    function clear_loops() {
      tasks2.clear();
    }
    function loop(callback) {
      let task;
      if (tasks2.size === 0)
        exports.raf(run_tasks);
      return {
        promise: new Promise((fulfill) => {
          tasks2.add(task = { c: callback, f: fulfill });
        }),
        abort() {
          tasks2.delete(task);
        }
      };
    }
    var is_hydrating2 = false;
    function start_hydrating2() {
      is_hydrating2 = true;
    }
    function end_hydrating2() {
      is_hydrating2 = false;
    }
    function upper_bound(low, high, key, value) {
      while (low < high) {
        const mid = low + (high - low >> 1);
        if (key(mid) <= value) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }
    function init_hydrate(target) {
      if (target.hydrate_init)
        return;
      target.hydrate_init = true;
      let children3 = target.childNodes;
      if (target.nodeName === "HEAD") {
        const myChildren = [];
        for (let i2 = 0; i2 < children3.length; i2++) {
          const node = children3[i2];
          if (node.claim_order !== void 0) {
            myChildren.push(node);
          }
        }
        children3 = myChildren;
      }
      const m = new Int32Array(children3.length + 1);
      const p2 = new Int32Array(children3.length);
      m[0] = -1;
      let longest = 0;
      for (let i2 = 0; i2 < children3.length; i2++) {
        const current = children3[i2].claim_order;
        const seqLen = (longest > 0 && children3[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, (idx) => children3[m[idx]].claim_order, current)) - 1;
        p2[i2] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        m[newLen] = i2;
        longest = Math.max(newLen, longest);
      }
      const lis = [];
      const toMove = [];
      let last = children3.length - 1;
      for (let cur = m[longest] + 1; cur != 0; cur = p2[cur - 1]) {
        lis.push(children3[cur - 1]);
        for (; last >= cur; last--) {
          toMove.push(children3[last]);
        }
        last--;
      }
      for (; last >= 0; last--) {
        toMove.push(children3[last]);
      }
      lis.reverse();
      toMove.sort((a2, b2) => a2.claim_order - b2.claim_order);
      for (let i2 = 0, j2 = 0; i2 < toMove.length; i2++) {
        while (j2 < lis.length && toMove[i2].claim_order >= lis[j2].claim_order) {
          j2++;
        }
        const anchor = j2 < lis.length ? lis[j2] : null;
        target.insertBefore(toMove[i2], anchor);
      }
    }
    function append2(target, node) {
      target.appendChild(node);
    }
    function append_styles2(target, style_sheet_id, styles) {
      const append_styles_to = get_root_for_style2(target);
      if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element2("style");
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet2(append_styles_to, style);
      }
    }
    function get_root_for_style2(node) {
      if (!node)
        return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      if (root && root.host) {
        return root;
      }
      return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
      const style_element = element2("style");
      append_stylesheet2(get_root_for_style2(node), style_element);
      return style_element.sheet;
    }
    function append_stylesheet2(node, style) {
      append2(node.head || node, style);
      return style.sheet;
    }
    function append_hydration(target, node) {
      if (is_hydrating2) {
        init_hydrate(target);
        if (target.actual_end_child === void 0 || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {
          target.actual_end_child = target.firstChild;
        }
        while (target.actual_end_child !== null && target.actual_end_child.claim_order === void 0) {
          target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
          if (node.claim_order !== void 0 || node.parentNode !== target) {
            target.insertBefore(node, target.actual_end_child);
          }
        } else {
          target.actual_end_child = node.nextSibling;
        }
      } else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
      }
    }
    function insert2(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }
    function insert_hydration(target, node, anchor) {
      if (is_hydrating2 && !anchor) {
        append_hydration(target, node);
      } else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
      }
    }
    function detach2(node) {
      node.parentNode.removeChild(node);
    }
    function destroy_each2(iterations, detaching) {
      for (let i2 = 0; i2 < iterations.length; i2 += 1) {
        if (iterations[i2])
          iterations[i2].d(detaching);
      }
    }
    function element2(name) {
      return document.createElement(name);
    }
    function element_is(name, is) {
      return document.createElement(name, { is });
    }
    function object_without_properties(obj, exclude) {
      const target = {};
      for (const k2 in obj) {
        if (has_prop(obj, k2) && exclude.indexOf(k2) === -1) {
          target[k2] = obj[k2];
        }
      }
      return target;
    }
    function svg_element(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function text2(data) {
      return document.createTextNode(data);
    }
    function space2() {
      return text2(" ");
    }
    function empty2() {
      return text2("");
    }
    function listen2(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn3) {
      return function(event) {
        event.preventDefault();
        return fn3.call(this, event);
      };
    }
    function stop_propagation2(fn3) {
      return function(event) {
        event.stopPropagation();
        return fn3.call(this, event);
      };
    }
    function self2(fn3) {
      return function(event) {
        if (event.target === this)
          fn3.call(this, event);
      };
    }
    function trusted(fn3) {
      return function(event) {
        if (event.isTrusted)
          fn3.call(this, event);
      };
    }
    function attr2(node, attribute, value) {
      if (value == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
    }
    function set_attributes2(node, attributes) {
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === "style") {
          node.style.cssText = attributes[key];
        } else if (key === "__value") {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr2(node, key, attributes[key]);
        }
      }
    }
    function set_svg_attributes(node, attributes) {
      for (const key in attributes) {
        attr2(node, key, attributes[key]);
      }
    }
    function set_custom_element_data(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
      } else {
        attr2(node, prop, value);
      }
    }
    function xlink_attr(node, attribute, value) {
      node.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
      const value = new Set();
      for (let i2 = 0; i2 < group.length; i2 += 1) {
        if (group[i2].checked)
          value.add(group[i2].__value);
      }
      if (!checked) {
        value.delete(__value);
      }
      return Array.from(value);
    }
    function to_number2(value) {
      return value === "" ? null : +value;
    }
    function time_ranges_to_array(ranges) {
      const array = [];
      for (let i2 = 0; i2 < ranges.length; i2 += 1) {
        array.push({ start: ranges.start(i2), end: ranges.end(i2) });
      }
      return array;
    }
    function children2(element3) {
      return Array.from(element3.childNodes);
    }
    function init_claim_info(nodes) {
      if (nodes.claim_info === void 0) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
      }
    }
    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
      init_claim_info(nodes);
      const resultNode = (() => {
        for (let i2 = nodes.claim_info.last_index; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            }
            return node;
          }
        }
        for (let i2 = nodes.claim_info.last_index - 1; i2 >= 0; i2--) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            } else if (replacement === void 0) {
              nodes.claim_info.last_index--;
            }
            return node;
          }
        }
        return createNode();
      })();
      resultNode.claim_order = nodes.claim_info.total_claimed;
      nodes.claim_info.total_claimed += 1;
      return resultNode;
    }
    function claim_element_base(nodes, name, attributes, create_element) {
      return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j2 = 0; j2 < node.attributes.length; j2++) {
          const attribute = node.attributes[j2];
          if (!attributes[attribute.name]) {
            remove.push(attribute.name);
          }
        }
        remove.forEach((v2) => node.removeAttribute(v2));
        return void 0;
      }, () => create_element(name));
    }
    function claim_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, element2);
    }
    function claim_svg_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, svg_element);
    }
    function claim_text(nodes, data) {
      return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        const dataStr = "" + data;
        if (node.data.startsWith(dataStr)) {
          if (node.data.length !== dataStr.length) {
            return node.splitText(dataStr.length);
          }
        } else {
          node.data = dataStr;
        }
      }, () => text2(data), true);
    }
    function claim_space(nodes) {
      return claim_text(nodes, " ");
    }
    function find_comment(nodes, text3, start2) {
      for (let i2 = start2; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        if (node.nodeType === 8 && node.textContent.trim() === text3) {
          return i2;
        }
      }
      return nodes.length;
    }
    function claim_html_tag(nodes, is_svg) {
      const start_index = find_comment(nodes, "HTML_TAG_START", 0);
      const end_index = find_comment(nodes, "HTML_TAG_END", start_index);
      if (start_index === end_index) {
        return new HtmlTagHydration(void 0, is_svg);
      }
      init_claim_info(nodes);
      const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
      detach2(html_tag_nodes[0]);
      detach2(html_tag_nodes[html_tag_nodes.length - 1]);
      const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
      for (const n2 of claimed_nodes) {
        n2.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
      }
      return new HtmlTagHydration(claimed_nodes, is_svg);
    }
    function set_data2(text3, data) {
      data = "" + data;
      if (text3.wholeText !== data)
        text3.data = data;
    }
    function set_input_value2(input, value) {
      input.value = value == null ? "" : value;
    }
    function set_input_type(input, type) {
      try {
        input.type = type;
      } catch (e) {
      }
    }
    function set_style2(node, key, value, important) {
      if (value === null) {
        node.style.removeProperty(key);
      } else {
        node.style.setProperty(key, value, important ? "important" : "");
      }
    }
    function select_option2(select, value) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option = select.options[i2];
        if (option.__value === value) {
          option.selected = true;
          return;
        }
      }
      select.selectedIndex = -1;
    }
    function select_options(select, value) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option = select.options[i2];
        option.selected = ~value.indexOf(option.__value);
      }
    }
    function select_value(select) {
      const selected_option = select.querySelector(":checked") || select.options[0];
      return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
      return [].map.call(select.querySelectorAll(":checked"), (option) => option.__value);
    }
    var crossorigin;
    function is_crossorigin() {
      if (crossorigin === void 0) {
        crossorigin = false;
        try {
          if (typeof window !== "undefined" && window.parent) {
            void window.parent.document;
          }
        } catch (error2) {
          crossorigin = true;
        }
      }
      return crossorigin;
    }
    function add_resize_listener(node, fn3) {
      const computed_style = getComputedStyle(node);
      if (computed_style.position === "static") {
        node.style.position = "relative";
      }
      const iframe = element2("iframe");
      iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
      iframe.setAttribute("aria-hidden", "true");
      iframe.tabIndex = -1;
      const crossorigin2 = is_crossorigin();
      let unsubscribe;
      if (crossorigin2) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
        unsubscribe = listen2(window, "message", (event) => {
          if (event.source === iframe.contentWindow)
            fn3();
        });
      } else {
        iframe.src = "about:blank";
        iframe.onload = () => {
          unsubscribe = listen2(iframe.contentWindow, "resize", fn3);
        };
      }
      append2(node, iframe);
      return () => {
        if (crossorigin2) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }
        detach2(iframe);
      };
    }
    function toggle_class2(element3, name, toggle) {
      element3.classList[toggle ? "add" : "remove"](name);
    }
    function custom_event2(type, detail, { bubbles = false, cancelable = false } = {}) {
      const e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, bubbles, cancelable, detail);
      return e;
    }
    function query_selector_all(selector, parent = document.body) {
      return Array.from(parent.querySelectorAll(selector));
    }
    var HtmlTag = class {
      constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
      }
      c(html) {
        this.h(html);
      }
      m(html, target, anchor = null) {
        if (!this.e) {
          if (this.is_svg)
            this.e = svg_element(target.nodeName);
          else
            this.e = element2(target.nodeName);
          this.t = target;
          this.c(html);
        }
        this.i(anchor);
      }
      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert2(this.t, this.n[i2], anchor);
        }
      }
      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
      d() {
        this.n.forEach(detach2);
      }
    };
    var HtmlTagHydration = class extends HtmlTag {
      constructor(claimed_nodes, is_svg = false) {
        super(is_svg);
        this.e = this.n = null;
        this.l = claimed_nodes;
      }
      c(html) {
        if (this.l) {
          this.n = this.l;
        } else {
          super.c(html);
        }
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert_hydration(this.t, this.n[i2], anchor);
        }
      }
    };
    function attribute_to_object(attributes) {
      const result = {};
      for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
      }
      return result;
    }
    function get_custom_elements_slots(element3) {
      const result = {};
      element3.childNodes.forEach((node) => {
        result[node.slot || "default"] = true;
      });
      return result;
    }
    var managed_styles2 = new Map();
    var active = 0;
    function hash3(str) {
      let hash4 = 5381;
      let i2 = str.length;
      while (i2--)
        hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i2);
      return hash4 >>> 0;
    }
    function create_style_information(doc, node) {
      const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
      managed_styles2.set(doc, info);
      return info;
    }
    function create_rule(node, a2, b2, duration, delay, ease, fn3, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = "{\n";
      for (let p2 = 0; p2 <= 1; p2 += step) {
        const t3 = a2 + (b2 - a2) * ease(p2);
        keyframes += p2 * 100 + `%{${fn3(t3, 1 - t3)}}
`;
      }
      const rule = keyframes + `100% {${fn3(b2, 1 - b2)}}
}`;
      const name = `__svelte_${hash3(rule)}_${uid}`;
      const doc = get_root_for_style2(node);
      const { stylesheet, rules } = managed_styles2.get(doc) || create_style_information(doc, node);
      if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }
      const animation = node.style.animation || "";
      node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }
    function delete_rule(node, name) {
      const previous = (node.style.animation || "").split(", ");
      const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
      const deleted = previous.length - next.length;
      if (deleted) {
        node.style.animation = next.join(", ");
        active -= deleted;
        if (!active)
          clear_rules();
      }
    }
    function clear_rules() {
      exports.raf(() => {
        if (active)
          return;
        managed_styles2.forEach((info) => {
          const { ownerNode } = info.stylesheet;
          if (ownerNode)
            detach2(ownerNode);
        });
        managed_styles2.clear();
      });
    }
    function create_animation(node, from, fn3, params) {
      if (!from)
        return noop3;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop3;
      const {
        delay = 0,
        duration = 300,
        easing = identity,
        start: start_time = exports.now() + delay,
        end: end2 = start_time + duration,
        tick: tick3 = noop3,
        css
      } = fn3(node, { from, to }, params);
      let running = true;
      let started = false;
      let name;
      function start2() {
        if (css) {
          name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
          started = true;
        }
      }
      function stop() {
        if (css)
          delete_rule(node, name);
        running = false;
      }
      loop((now) => {
        if (!started && now >= start_time) {
          started = true;
        }
        if (started && now >= end2) {
          tick3(1, 0);
          stop();
        }
        if (!running) {
          return false;
        }
        if (started) {
          const p2 = now - start_time;
          const t3 = 0 + 1 * easing(p2 / duration);
          tick3(t3, 1 - t3);
        }
        return true;
      });
      start2();
      tick3(0, 1);
      return stop;
    }
    function fix_position(node) {
      const style = getComputedStyle(node);
      if (style.position !== "absolute" && style.position !== "fixed") {
        const { width, height } = style;
        const a2 = node.getBoundingClientRect();
        node.style.position = "absolute";
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a2);
      }
    }
    function add_transform(node, a2) {
      const b2 = node.getBoundingClientRect();
      if (a2.left !== b2.left || a2.top !== b2.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === "none" ? "" : style.transform;
        node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
      }
    }
    function set_current_component2(component) {
      exports.current_component = component;
    }
    function get_current_component2() {
      if (!exports.current_component)
        throw new Error("Function called outside component initialization");
      return exports.current_component;
    }
    function beforeUpdate2(fn3) {
      get_current_component2().$$.before_update.push(fn3);
    }
    function onMount2(fn3) {
      get_current_component2().$$.on_mount.push(fn3);
    }
    function afterUpdate2(fn3) {
      get_current_component2().$$.after_update.push(fn3);
    }
    function onDestroy2(fn3) {
      get_current_component2().$$.on_destroy.push(fn3);
    }
    function createEventDispatcher2() {
      const component = get_current_component2();
      return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          const event = custom_event2(type, detail, { cancelable });
          callbacks.slice().forEach((fn3) => {
            fn3.call(component, event);
          });
          return !event.defaultPrevented;
        }
        return true;
      };
    }
    function setContext2(key, context) {
      get_current_component2().$$.context.set(key, context);
      return context;
    }
    function getContext2(key) {
      return get_current_component2().$$.context.get(key);
    }
    function getAllContexts2() {
      return get_current_component2().$$.context;
    }
    function hasContext2(key) {
      return get_current_component2().$$.context.has(key);
    }
    function bubble2(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
        callbacks.slice().forEach((fn3) => fn3.call(this, event));
      }
    }
    var dirty_components2 = [];
    var intros = { enabled: false };
    var binding_callbacks2 = [];
    var render_callbacks2 = [];
    var flush_callbacks2 = [];
    var resolved_promise2 = Promise.resolve();
    var update_scheduled2 = false;
    function schedule_update2() {
      if (!update_scheduled2) {
        update_scheduled2 = true;
        resolved_promise2.then(flush2);
      }
    }
    function tick2() {
      schedule_update2();
      return resolved_promise2;
    }
    function add_render_callback2(fn3) {
      render_callbacks2.push(fn3);
    }
    function add_flush_callback2(fn3) {
      flush_callbacks2.push(fn3);
    }
    var seen_callbacks2 = new Set();
    var flushidx2 = 0;
    function flush2() {
      const saved_component = exports.current_component;
      do {
        while (flushidx2 < dirty_components2.length) {
          const component = dirty_components2[flushidx2];
          flushidx2++;
          set_current_component2(component);
          update2(component.$$);
        }
        set_current_component2(null);
        dirty_components2.length = 0;
        flushidx2 = 0;
        while (binding_callbacks2.length)
          binding_callbacks2.pop()();
        for (let i2 = 0; i2 < render_callbacks2.length; i2 += 1) {
          const callback = render_callbacks2[i2];
          if (!seen_callbacks2.has(callback)) {
            seen_callbacks2.add(callback);
            callback();
          }
        }
        render_callbacks2.length = 0;
      } while (dirty_components2.length);
      while (flush_callbacks2.length) {
        flush_callbacks2.pop()();
      }
      update_scheduled2 = false;
      seen_callbacks2.clear();
      set_current_component2(saved_component);
    }
    function update2($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all2($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback2);
      }
    }
    var promise;
    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }
      return promise;
    }
    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event2(`${direction ? "intro" : "outro"}${kind}`));
    }
    var outroing2 = new Set();
    var outros2;
    function group_outros2() {
      outros2 = {
        r: 0,
        c: [],
        p: outros2
      };
    }
    function check_outros2() {
      if (!outros2.r) {
        run_all2(outros2.c);
      }
      outros2 = outros2.p;
    }
    function transition_in2(block, local) {
      if (block && block.i) {
        outroing2.delete(block);
        block.i(local);
      }
    }
    function transition_out2(block, local, detach3, callback) {
      if (block && block.o) {
        if (outroing2.has(block))
          return;
        outroing2.add(block);
        outros2.c.push(() => {
          outroing2.delete(block);
          if (callback) {
            if (detach3)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      } else if (callback) {
        callback();
      }
    }
    var null_transition = { duration: 0 };
    function create_in_transition(node, fn3, params) {
      let config = fn3(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;
      function cleanup() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function go() {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css } = config || null_transition;
        if (css)
          animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick3(0, 1);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        if (task)
          task.abort();
        running = true;
        add_render_callback2(() => dispatch(node, true, "start"));
        task = loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(1, 0);
              dispatch(node, true, "end");
              cleanup();
              return running = false;
            }
            if (now >= start_time) {
              const t3 = easing((now - start_time) / duration);
              tick3(t3, 1 - t3);
            }
          }
          return running;
        });
      }
      let started = false;
      return {
        start() {
          if (started)
            return;
          started = true;
          delete_rule(node);
          if (is_function2(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },
        invalidate() {
          started = false;
        },
        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }
      };
    }
    function create_out_transition(node, fn3, params) {
      let config = fn3(node, params);
      let running = true;
      let animation_name;
      const group = outros2;
      group.r += 1;
      function go() {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css } = config || null_transition;
        if (css)
          animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        add_render_callback2(() => dispatch(node, false, "start"));
        loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(0, 1);
              dispatch(node, false, "end");
              if (!--group.r) {
                run_all2(group.c);
              }
              return false;
            }
            if (now >= start_time) {
              const t3 = easing((now - start_time) / duration);
              tick3(1 - t3, t3);
            }
          }
          return running;
        });
      }
      if (is_function2(config)) {
        wait().then(() => {
          config = config();
          go();
        });
      } else {
        go();
      }
      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }
          if (running) {
            if (animation_name)
              delete_rule(node, animation_name);
            running = false;
          }
        }
      };
    }
    function create_bidirectional_transition(node, fn3, params, intro) {
      let config = fn3(node, params);
      let t3 = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;
      function clear_animation() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function init4(program, duration) {
        const d2 = program.b - t3;
        duration *= Math.abs(d2);
        return {
          a: t3,
          b: program.b,
          d: d2,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }
      function go(b2) {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css } = config || null_transition;
        const program = {
          start: exports.now() + delay,
          b: b2
        };
        if (!b2) {
          program.group = outros2;
          outros2.r += 1;
        }
        if (running_program || pending_program) {
          pending_program = program;
        } else {
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t3, b2, duration, delay, easing, css);
          }
          if (b2)
            tick3(0, 1);
          running_program = init4(program, duration);
          add_render_callback2(() => dispatch(node, b2, "start"));
          loop((now) => {
            if (pending_program && now > pending_program.start) {
              running_program = init4(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, "start");
              if (css) {
                clear_animation();
                animation_name = create_rule(node, t3, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }
            if (running_program) {
              if (now >= running_program.end) {
                tick3(t3 = running_program.b, 1 - t3);
                dispatch(node, running_program.b, "end");
                if (!pending_program) {
                  if (running_program.b) {
                    clear_animation();
                  } else {
                    if (!--running_program.group.r)
                      run_all2(running_program.group.c);
                  }
                }
                running_program = null;
              } else if (now >= running_program.start) {
                const p2 = now - running_program.start;
                t3 = running_program.a + running_program.d * easing(p2 / running_program.duration);
                tick3(t3, 1 - t3);
              }
            }
            return !!(running_program || pending_program);
          });
        }
      }
      return {
        run(b2) {
          if (is_function2(config)) {
            wait().then(() => {
              config = config();
              go(b2);
            });
          } else {
            go(b2);
          }
        },
        end() {
          clear_animation();
          running_program = pending_program = null;
        }
      };
    }
    function handle_promise2(promise2, info) {
      const token = info.token = {};
      function update3(type, index, key, value) {
        if (info.token !== token)
          return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== void 0) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block2, i2) => {
              if (i2 !== index && block2) {
                group_outros2();
                transition_out2(block2, 1, 1, () => {
                  if (info.blocks[i2] === block2) {
                    info.blocks[i2] = null;
                  }
                });
                check_outros2();
              }
            });
          } else {
            info.block.d(1);
          }
          block.c();
          transition_in2(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
          info.blocks[index] = block;
        if (needs_flush) {
          flush2();
        }
      }
      if (is_promise2(promise2)) {
        const current_component2 = get_current_component2();
        promise2.then((value) => {
          set_current_component2(current_component2);
          update3(info.then, 1, info.value, value);
          set_current_component2(null);
        }, (error2) => {
          set_current_component2(current_component2);
          update3(info.catch, 2, info.error, error2);
          set_current_component2(null);
          if (!info.hasCatch) {
            throw error2;
          }
        });
        if (info.current !== info.pending) {
          update3(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update3(info.then, 1, info.value, promise2);
          return true;
        }
        info.resolved = promise2;
      }
    }
    function update_await_block_branch2(info, ctx, dirty) {
      const child_ctx = ctx.slice();
      const { resolved } = info;
      if (info.current === info.then) {
        child_ctx[info.value] = resolved;
      }
      if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
      }
      info.block.p(child_ctx, dirty);
    }
    var globals2 = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
    function destroy_block(block, lookup) {
      block.d(1);
      lookup.delete(block.key);
    }
    function outro_and_destroy_block2(block, lookup) {
      transition_out2(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }
    function fix_and_destroy_block(block, lookup) {
      block.f();
      destroy_block(block, lookup);
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
      block.f();
      outro_and_destroy_block2(block, lookup);
    }
    function update_keyed_each2(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block16, next, get_context) {
      let o2 = old_blocks.length;
      let n2 = list.length;
      let i2 = o2;
      const old_indexes = {};
      while (i2--)
        old_indexes[old_blocks[i2].key] = i2;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i2 = n2;
      while (i2--) {
        const child_ctx = get_context(ctx, list, i2);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
          block = create_each_block16(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i2] = block);
        if (key in old_indexes)
          deltas.set(key, Math.abs(i2 - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      function insert3(block) {
        transition_in2(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n2--;
      }
      while (o2 && n2) {
        const new_block = new_blocks[n2 - 1];
        const old_block = old_blocks[o2 - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          next = new_block.first;
          o2--;
          n2--;
        } else if (!new_lookup.has(old_key)) {
          destroy(old_block, lookup);
          o2--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert3(new_block);
        } else if (did_move.has(old_key)) {
          o2--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert3(new_block);
        } else {
          will_move.add(old_key);
          o2--;
        }
      }
      while (o2--) {
        const old_block = old_blocks[o2];
        if (!new_lookup.has(old_block.key))
          destroy(old_block, lookup);
      }
      while (n2)
        insert3(new_blocks[n2 - 1]);
      return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();
      for (let i2 = 0; i2 < list.length; i2++) {
        const key = get_key(get_context(ctx, list, i2));
        if (keys.has(key)) {
          throw new Error("Cannot have duplicate keys in a keyed each");
        }
        keys.add(key);
      }
    }
    function get_spread_update2(levels, updates) {
      const update3 = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i2 = levels.length;
      while (i2--) {
        const o2 = levels[i2];
        const n2 = updates[i2];
        if (n2) {
          for (const key in o2) {
            if (!(key in n2))
              to_null_out[key] = 1;
          }
          for (const key in n2) {
            if (!accounted_for[key]) {
              update3[key] = n2[key];
              accounted_for[key] = 1;
            }
          }
          levels[i2] = n2;
        } else {
          for (const key in o2) {
            accounted_for[key] = 1;
          }
        }
      }
      for (const key in to_null_out) {
        if (!(key in update3))
          update3[key] = void 0;
      }
      return update3;
    }
    function get_spread_object(spread_props) {
      return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
    }
    var boolean_attributes2 = new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    function is_void(name) {
      return void_element_names.test(name) || name.toLowerCase() === "!doctype";
    }
    var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    function spread(args, attrs_to_add) {
      const attributes = Object.assign({}, ...args);
      if (attrs_to_add) {
        const classes_to_add = attrs_to_add.classes;
        const styles_to_add = attrs_to_add.styles;
        if (classes_to_add) {
          if (attributes.class == null) {
            attributes.class = classes_to_add;
          } else {
            attributes.class += " " + classes_to_add;
          }
        }
        if (styles_to_add) {
          if (attributes.style == null) {
            attributes.style = style_object_to_string(styles_to_add);
          } else {
            attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
          }
        }
      }
      let str = "";
      Object.keys(attributes).forEach((name) => {
        if (invalid_attribute_name_character.test(name))
          return;
        const value = attributes[name];
        if (value === true)
          str += " " + name;
        else if (boolean_attributes2.has(name.toLowerCase())) {
          if (value)
            str += " " + name;
        } else if (value != null) {
          str += ` ${name}="${value}"`;
        }
      });
      return str;
    }
    function merge_ssr_styles(style_attribute, style_directive) {
      const style_object = {};
      for (const individual_style of style_attribute.split(";")) {
        const colon_index = individual_style.indexOf(":");
        const name = individual_style.slice(0, colon_index).trim();
        const value = individual_style.slice(colon_index + 1).trim();
        if (!name)
          continue;
        style_object[name] = value;
      }
      for (const name in style_directive) {
        const value = style_directive[name];
        if (value) {
          style_object[name] = value;
        } else {
          delete style_object[name];
        }
      }
      return style_object;
    }
    var ATTR_REGEX = /[&"]/g;
    var CONTENT_REGEX = /[&<]/g;
    function escape2(value, is_attr = false) {
      const str = String(value);
      const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
      pattern.lastIndex = 0;
      let escaped = "";
      let last = 0;
      while (pattern.test(str)) {
        const i2 = pattern.lastIndex - 1;
        const ch = str[i2];
        escaped += str.substring(last, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
        last = i2 + 1;
      }
      return escaped + str.substring(last);
    }
    function escape_attribute_value(value) {
      const should_escape = typeof value === "string" || value && typeof value === "object";
      return should_escape ? escape2(value, true) : value;
    }
    function escape_object(obj) {
      const result = {};
      for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
      }
      return result;
    }
    function each(items, fn3) {
      let str = "";
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        str += fn3(items[i2], i2);
      }
      return str;
    }
    var missing_component = {
      $$render: () => ""
    };
    function validate_component(component, name) {
      if (!component || !component.$$render) {
        if (name === "svelte:component")
          name += " this={...}";
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
      }
      return component;
    }
    function debug(file, line, column, values) {
      console.log(`{@debug} ${file ? file + " " : ""}(${line}:${column})`);
      console.log(values);
      return "";
    }
    var on_destroy;
    function create_ssr_component(fn3) {
      function $$render(result, props, bindings, slots, context) {
        const parent_component = exports.current_component;
        const $$ = {
          on_destroy,
          context: new Map(context || (parent_component ? parent_component.$$.context : [])),
          on_mount: [],
          before_update: [],
          after_update: [],
          callbacks: blank_object2()
        };
        set_current_component2({ $$ });
        const html = fn3(result, props, bindings, slots);
        set_current_component2(parent_component);
        return html;
      }
      return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
          on_destroy = [];
          const result = { title: "", head: "", css: new Set() };
          const html = $$render(result, props, {}, $$slots, context);
          run_all2(on_destroy);
          return {
            html,
            css: {
              code: Array.from(result.css).map((css) => css.code).join("\n"),
              map: null
            },
            head: result.title + result.head
          };
        },
        $$render
      };
    }
    function add_attribute(name, value, boolean) {
      if (value == null || boolean && !value)
        return "";
      const assignment = boolean && value === true ? "" : `="${escape2(value, true)}"`;
      return ` ${name}${assignment}`;
    }
    function add_classes(classes) {
      return classes ? ` class="${classes}"` : "";
    }
    function style_object_to_string(style_object) {
      return Object.keys(style_object).filter((key) => style_object[key]).map((key) => `${key}: ${style_object[key]};`).join(" ");
    }
    function add_styles(style_object) {
      const styles = style_object_to_string(style_object);
      return styles ? ` style="${styles}"` : "";
    }
    function bind2(component, name, callback) {
      const index = component.$$.props[name];
      if (index !== void 0) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }
    function create_component2(block) {
      block && block.c();
    }
    function claim_component(block, parent_nodes) {
      block && block.l(parent_nodes);
    }
    function mount_component2(component, target, anchor, customElement) {
      const { fragment, on_mount, on_destroy: on_destroy2, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      if (!customElement) {
        add_render_callback2(() => {
          const new_on_destroy = on_mount.map(run2).filter(is_function2);
          if (on_destroy2) {
            on_destroy2.push(...new_on_destroy);
          } else {
            run_all2(new_on_destroy);
          }
          component.$$.on_mount = [];
        });
      }
      after_update.forEach(add_render_callback2);
    }
    function destroy_component2(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        run_all2($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty2(component, i2) {
      if (component.$$.dirty[0] === -1) {
        dirty_components2.push(component);
        schedule_update2();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
    }
    function init3(component, options, instance90, create_fragment90, not_equal2, props, append_styles3, dirty = [-1]) {
      const parent_component = exports.current_component;
      set_current_component2(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        props,
        update: noop3,
        not_equal: not_equal2,
        bound: blank_object2(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        callbacks: blank_object2(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles3 && append_styles3($$.root);
      let ready = false;
      $$.ctx = instance90 ? instance90(component, options.props || {}, (i2, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal2($$.ctx[i2], $$.ctx[i2] = value)) {
          if (!$$.skip_bound && $$.bound[i2])
            $$.bound[i2](value);
          if (ready)
            make_dirty2(component, i2);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all2($$.before_update);
      $$.fragment = create_fragment90 ? create_fragment90($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          start_hydrating2();
          const nodes = children2(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach2);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in2(component.$$.fragment);
        mount_component2(component, options.target, options.anchor, options.customElement);
        end_hydrating2();
        flush2();
      }
      set_current_component2(parent_component);
    }
    if (typeof HTMLElement === "function") {
      exports.SvelteElement = class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { on_mount } = this.$$;
          this.$$.on_disconnect = on_mount.map(run2).filter(is_function2);
          for (const key in this.$$.slotted) {
            this.appendChild(this.$$.slotted[key]);
          }
        }
        attributeChangedCallback(attr3, _oldValue, newValue) {
          this[attr3] = newValue;
        }
        disconnectedCallback() {
          run_all2(this.$$.on_disconnect);
        }
        $destroy() {
          destroy_component2(this, 1);
          this.$destroy = noop3;
        }
        $on(type, callback) {
          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
              callbacks.splice(index, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty2($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      };
    }
    var SvelteComponent2 = class {
      $destroy() {
        destroy_component2(this, 1);
        this.$destroy = noop3;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty2($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event2(type, Object.assign({ version: "3.50.1" }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append2(target, node);
    }
    function append_hydration_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append_hydration(target, node);
    }
    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert2(target, node, anchor);
    }
    function insert_hydration_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert_hydration(target, node, anchor);
    }
    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach2(node);
    }
    function detach_between_dev(before, after) {
      while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
      }
    }
    function detach_before_dev(after) {
      while (after.previousSibling) {
        detach_dev(after.previousSibling);
      }
    }
    function detach_after_dev(before) {
      while (before.nextSibling) {
        detach_dev(before.nextSibling);
      }
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
        modifiers.push("preventDefault");
      if (has_stop_propagation)
        modifiers.push("stopPropagation");
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen2(node, event, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
      };
    }
    function attr_dev(node, attribute, value) {
      attr2(node, attribute, value);
      if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function dataset_dev(node, property, value) {
      node.dataset[property] = value;
      dispatch_dev("SvelteDOMSetDataset", { node, property, value });
    }
    function set_data_dev(text3, data) {
      data = "" + data;
      if (text3.wholeText === data)
        return;
      dispatch_dev("SvelteDOMSetData", { node: text3, data });
      text3.data = data;
    }
    function validate_each_argument(arg) {
      if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
        let msg = "{#each} only iterates over array-like objects.";
        if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
          msg += " You can use a spread to convert this iterable into an array.";
        }
        throw new Error(msg);
      }
    }
    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    function validate_dynamic_element(tag) {
      const is_string = typeof tag === "string";
      if (tag && !is_string) {
        throw new Error('<svelte:element> expects "this" attribute to be a string.');
      }
    }
    function validate_void_dynamic_element(tag) {
      if (tag && is_void(tag)) {
        throw new Error(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
      }
    }
    var SvelteComponentDev2 = class extends SvelteComponent2 {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error("'target' is a required option");
        }
        super();
      }
      $destroy() {
        super.$destroy();
        this.$destroy = () => {
          console.warn("Component was already destroyed");
        };
      }
      $capture_state() {
      }
      $inject_state() {
      }
    };
    var SvelteComponentTyped2 = class extends SvelteComponentDev2 {
      constructor(options) {
        super(options);
      }
    };
    function loop_guard(timeout) {
      const start2 = Date.now();
      return () => {
        if (Date.now() - start2 > timeout) {
          throw new Error("Infinite loop detected");
        }
      };
    }
    exports.HtmlTag = HtmlTag;
    exports.HtmlTagHydration = HtmlTagHydration;
    exports.SvelteComponent = SvelteComponent2;
    exports.SvelteComponentDev = SvelteComponentDev2;
    exports.SvelteComponentTyped = SvelteComponentTyped2;
    exports.action_destroyer = action_destroyer2;
    exports.add_attribute = add_attribute;
    exports.add_classes = add_classes;
    exports.add_flush_callback = add_flush_callback2;
    exports.add_location = add_location;
    exports.add_render_callback = add_render_callback2;
    exports.add_resize_listener = add_resize_listener;
    exports.add_styles = add_styles;
    exports.add_transform = add_transform;
    exports.afterUpdate = afterUpdate2;
    exports.append = append2;
    exports.append_dev = append_dev;
    exports.append_empty_stylesheet = append_empty_stylesheet;
    exports.append_hydration = append_hydration;
    exports.append_hydration_dev = append_hydration_dev;
    exports.append_styles = append_styles2;
    exports.assign = assign2;
    exports.attr = attr2;
    exports.attr_dev = attr_dev;
    exports.attribute_to_object = attribute_to_object;
    exports.beforeUpdate = beforeUpdate2;
    exports.bind = bind2;
    exports.binding_callbacks = binding_callbacks2;
    exports.blank_object = blank_object2;
    exports.bubble = bubble2;
    exports.check_outros = check_outros2;
    exports.children = children2;
    exports.claim_component = claim_component;
    exports.claim_element = claim_element;
    exports.claim_html_tag = claim_html_tag;
    exports.claim_space = claim_space;
    exports.claim_svg_element = claim_svg_element;
    exports.claim_text = claim_text;
    exports.clear_loops = clear_loops;
    exports.component_subscribe = component_subscribe2;
    exports.compute_rest_props = compute_rest_props;
    exports.compute_slots = compute_slots2;
    exports.createEventDispatcher = createEventDispatcher2;
    exports.create_animation = create_animation;
    exports.create_bidirectional_transition = create_bidirectional_transition;
    exports.create_component = create_component2;
    exports.create_in_transition = create_in_transition;
    exports.create_out_transition = create_out_transition;
    exports.create_slot = create_slot2;
    exports.create_ssr_component = create_ssr_component;
    exports.custom_event = custom_event2;
    exports.dataset_dev = dataset_dev;
    exports.debug = debug;
    exports.destroy_block = destroy_block;
    exports.destroy_component = destroy_component2;
    exports.destroy_each = destroy_each2;
    exports.detach = detach2;
    exports.detach_after_dev = detach_after_dev;
    exports.detach_before_dev = detach_before_dev;
    exports.detach_between_dev = detach_between_dev;
    exports.detach_dev = detach_dev;
    exports.dirty_components = dirty_components2;
    exports.dispatch_dev = dispatch_dev;
    exports.each = each;
    exports.element = element2;
    exports.element_is = element_is;
    exports.empty = empty2;
    exports.end_hydrating = end_hydrating2;
    exports.escape = escape2;
    exports.escape_attribute_value = escape_attribute_value;
    exports.escape_object = escape_object;
    exports.exclude_internal_props = exclude_internal_props;
    exports.fix_and_destroy_block = fix_and_destroy_block;
    exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
    exports.fix_position = fix_position;
    exports.flush = flush2;
    exports.getAllContexts = getAllContexts2;
    exports.getContext = getContext2;
    exports.get_all_dirty_from_scope = get_all_dirty_from_scope2;
    exports.get_binding_group_value = get_binding_group_value;
    exports.get_current_component = get_current_component2;
    exports.get_custom_elements_slots = get_custom_elements_slots;
    exports.get_root_for_style = get_root_for_style2;
    exports.get_slot_changes = get_slot_changes2;
    exports.get_spread_object = get_spread_object;
    exports.get_spread_update = get_spread_update2;
    exports.get_store_value = get_store_value2;
    exports.globals = globals2;
    exports.group_outros = group_outros2;
    exports.handle_promise = handle_promise2;
    exports.hasContext = hasContext2;
    exports.has_prop = has_prop;
    exports.identity = identity;
    exports.init = init3;
    exports.insert = insert2;
    exports.insert_dev = insert_dev;
    exports.insert_hydration = insert_hydration;
    exports.insert_hydration_dev = insert_hydration_dev;
    exports.intros = intros;
    exports.invalid_attribute_name_character = invalid_attribute_name_character;
    exports.is_client = is_client;
    exports.is_crossorigin = is_crossorigin;
    exports.is_empty = is_empty2;
    exports.is_function = is_function2;
    exports.is_promise = is_promise2;
    exports.is_void = is_void;
    exports.listen = listen2;
    exports.listen_dev = listen_dev;
    exports.loop = loop;
    exports.loop_guard = loop_guard;
    exports.merge_ssr_styles = merge_ssr_styles;
    exports.missing_component = missing_component;
    exports.mount_component = mount_component2;
    exports.noop = noop3;
    exports.not_equal = not_equal;
    exports.null_to_empty = null_to_empty2;
    exports.object_without_properties = object_without_properties;
    exports.onDestroy = onDestroy2;
    exports.onMount = onMount2;
    exports.once = once;
    exports.outro_and_destroy_block = outro_and_destroy_block2;
    exports.prevent_default = prevent_default;
    exports.prop_dev = prop_dev;
    exports.query_selector_all = query_selector_all;
    exports.run = run2;
    exports.run_all = run_all2;
    exports.safe_not_equal = safe_not_equal2;
    exports.schedule_update = schedule_update2;
    exports.select_multiple_value = select_multiple_value;
    exports.select_option = select_option2;
    exports.select_options = select_options;
    exports.select_value = select_value;
    exports.self = self2;
    exports.setContext = setContext2;
    exports.set_attributes = set_attributes2;
    exports.set_current_component = set_current_component2;
    exports.set_custom_element_data = set_custom_element_data;
    exports.set_data = set_data2;
    exports.set_data_dev = set_data_dev;
    exports.set_input_type = set_input_type;
    exports.set_input_value = set_input_value2;
    exports.set_now = set_now;
    exports.set_raf = set_raf;
    exports.set_store_value = set_store_value;
    exports.set_style = set_style2;
    exports.set_svg_attributes = set_svg_attributes;
    exports.space = space2;
    exports.spread = spread;
    exports.src_url_equal = src_url_equal;
    exports.start_hydrating = start_hydrating2;
    exports.stop_propagation = stop_propagation2;
    exports.subscribe = subscribe2;
    exports.svg_element = svg_element;
    exports.text = text2;
    exports.tick = tick2;
    exports.time_ranges_to_array = time_ranges_to_array;
    exports.to_number = to_number2;
    exports.toggle_class = toggle_class2;
    exports.transition_in = transition_in2;
    exports.transition_out = transition_out2;
    exports.trusted = trusted;
    exports.update_await_block_branch = update_await_block_branch2;
    exports.update_keyed_each = update_keyed_each2;
    exports.update_slot = update_slot;
    exports.update_slot_base = update_slot_base2;
    exports.validate_component = validate_component;
    exports.validate_dynamic_element = validate_dynamic_element;
    exports.validate_each_argument = validate_each_argument;
    exports.validate_each_keys = validate_each_keys;
    exports.validate_slots = validate_slots;
    exports.validate_store = validate_store;
    exports.validate_void_dynamic_element = validate_void_dynamic_element;
    exports.xlink_attr = xlink_attr;
  }
});

// node_modules/svelte/store/index.js
var require_store = __commonJS({
  "node_modules/svelte/store/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal = require_internal();
    var subscriber_queue2 = [];
    function readable2(value, start2) {
      return {
        subscribe: writable2(value, start2).subscribe
      };
    }
    function writable2(value, start2 = internal.noop) {
      let stop;
      const subscribers = new Set();
      function set(new_value) {
        if (internal.safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue2.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue2.push(subscriber, value);
            }
            if (run_queue) {
              for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
                subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
              }
              subscriber_queue2.length = 0;
            }
          }
        }
      }
      function update2(fn3) {
        set(fn3(value));
      }
      function subscribe2(run2, invalidate = internal.noop) {
        const subscriber = [run2, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start2(set) || internal.noop;
        }
        run2(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }
      return { set, update: update2, subscribe: subscribe2 };
    }
    function derived2(stores, fn3, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto2 = fn3.length < 2;
      return readable2(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = internal.noop;
        const sync = () => {
          if (pending) {
            return;
          }
          cleanup();
          const result = fn3(single ? values[0] : values, set);
          if (auto2) {
            set(result);
          } else {
            cleanup = internal.is_function(result) ? result : internal.noop;
          }
        };
        const unsubscribers = stores_array.map((store, i2) => internal.subscribe(store, (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (inited) {
            sync();
          }
        }, () => {
          pending |= 1 << i2;
        }));
        inited = true;
        sync();
        return function stop() {
          internal.run_all(unsubscribers);
          cleanup();
        };
      });
    }
    Object.defineProperty(exports, "get", {
      enumerable: true,
      get: function() {
        return internal.get_store_value;
      }
    });
    exports.derived = derived2;
    exports.readable = readable2;
    exports.writable = writable2;
  }
});

// node_modules/svelte-i18next/translation-store.js
var require_translation_store = __commonJS({
  "node_modules/svelte-i18next/translation-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.I18NextTranslationStore = exports.isLoading = void 0;
    var store_1 = require_store();
    exports.isLoading = (0, store_1.writable)(true);
    var I18NextTranslationStore = class {
      constructor(i18n2) {
        this.i18n = this.createInstance(i18n2);
        this.isLoading = this.createLoadingInstance(i18n2);
      }
      createInstance(i18n2) {
        const i18nWritable = (0, store_1.writable)(i18n2);
        i18n2.on("initialized", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("loaded", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("added", () => i18nWritable.set(i18n2));
        i18n2.on("languageChanged", () => {
          i18nWritable.set(i18n2);
        });
        return i18nWritable;
      }
      createLoadingInstance(i18n2) {
        i18n2.on("loaded", (resources) => {
          Object.keys(resources).length !== 0 && exports.isLoading.set(false);
        });
        i18n2.on("failedLoading", () => {
          exports.isLoading.set(true);
        });
        return exports.isLoading;
      }
    };
    exports.I18NextTranslationStore = I18NextTranslationStore;
  }
});

// node_modules/svelte-i18next/i18n.js
var require_i18n = __commonJS({
  "node_modules/svelte-i18next/i18n.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createI18nStore = void 0;
    var translation_store_1 = require_translation_store();
    var createI18nStore2 = (i18n2) => {
      const i18nStore = new translation_store_1.I18NextTranslationStore(i18n2);
      return i18nStore.i18n;
    };
    exports.createI18nStore = createI18nStore2;
  }
});

// node_modules/svelte-i18next/index.js
var require_svelte_i18next = __commonJS({
  "node_modules/svelte-i18next/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding2(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_i18n(), exports);
    __exportStar2(require_translation_store(), exports);
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a2, b2) {
        return Object.prototype.hasOwnProperty.call(a2, b2);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k2;
          for (k2 in obj) {
            if (hasOwnProp(obj, k2)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn3) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn3(arr[i2], i2));
        }
        return res;
      }
      function extend(a2, b2) {
        for (var i2 in b2) {
          if (hasOwnProp(b2, i2)) {
            a2[i2] = b2[i2];
          }
        }
        if (hasOwnProp(b2, "toString")) {
          a2.toString = b2.toString;
        }
        if (hasOwnProp(b2, "valueOf")) {
          a2.valueOf = b2.valueOf;
        }
        return a2;
      }
      function createUTC(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t3 = Object(this), len = t3.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t3 && fun.call(this, t3[i2], i2, t3)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i2) {
            return i2 != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn3) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args.push(arg);
            }
            warn2(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn3.apply(this, arguments);
        }, fn3);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output2 = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output2) ? output2.call(mom, now2) : output2;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func7 = callback;
        if (typeof callback === "string") {
          func7 = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func7;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func7.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func7.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array = format3.match(formattingTokens), i2, length;
        for (i2 = 0, length = array.length; i2 < length; i2++) {
          if (formatTokenFunctions[array[i2]]) {
            array[i2] = formatTokenFunctions[array[i2]];
          } else {
            array[i2] = removeFormattingTokens(array[i2]);
          }
        }
        return function(mom) {
          var output2 = "", i3;
          for (i3 = 0; i3 < length; i3++) {
            output2 += isFunction(array[i3]) ? array[i3].call(mom, format3) : array[i3];
          }
          return output2;
        };
      }
      function formatMoment(m, format3) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m);
      }
      function expandFormat(format3, locale2) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output2 = this._relativeTime[string];
        return isFunction(output2) ? output2(number, withoutSuffix, string, isFuture) : output2.replace(/%d/i, number);
      }
      function pastFuture(diff2, output2) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format3) ? format3(output2) : format3.replace(/%s/i, output2);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units.sort(function(a2, b2) {
          return a2.priority - b2.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape2(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape2(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i2, func7 = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func7 = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func7;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n2, x2) {
        return (n2 % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o2) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o2) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format3) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format3) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i2] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i2 = 0; i2 < 12; i2++) {
          shortPieces[i2] = regexEscape2(shortPieces[i2]);
          longPieces[i2] = regexEscape2(longPieces[i2]);
        }
        for (i2 = 0; i2 < 24; i2++) {
          mixedPieces[i2] = regexEscape2(mixedPieces[i2]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y2 = this.year();
        return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y2, m, d2, h2, M2, s2, ms) {
        var date;
        if (y2 < 100 && y2 >= 0) {
          date = new Date(y2 + 400, m, d2, h2, M2, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y2);
          }
        } else {
          date = new Date(y2, m, d2, h2, M2, s2, ms);
        }
        return date;
      }
      function createUTCDate(y2) {
        var date, args;
        if (y2 < 100 && y2 >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y2 + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y2);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format3) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i2] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i2] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape2(this.weekdaysMin(mom, ""));
          shortp = regexEscape2(this.weekdaysShort(mom, ""));
          longp = regexEscape2(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i2 = 0, j2, next, locale2, split;
        while (i2 < names.length) {
          split = normalizeLocale(names[i2]).split("-");
          j2 = split.length;
          next = normalizeLocale(names[i2 + 1]);
          next = next ? next.split("-") : null;
          while (j2 > 0) {
            locale2 = loadLocale(split.slice(0, j2).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
              break;
            }
            j2--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a2 = m._a;
        if (a2 && getParsingFlags(m).overflow === -2) {
          overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
            if (isoDates[i2][1].exec(match[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
              if (isoTimes[i2][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
          return h2 * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults(a2, b2, c2) {
        if (a2 != null) {
          return a2;
        }
        if (b2 != null) {
          return b2;
        }
        return c2;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w2 = config._w;
        if (w2.GG != null || w2.W != null || w2.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w2.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w2.W, 1);
          weekday = defaults(w2.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
          week = defaults(w2.w, curWeek.week);
          if (w2.d != null) {
            weekday = w2.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w2.e != null) {
            weekday = w2.e + dow;
            if (w2.e < 0 || w2.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map([i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
        var c2 = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c2._isAMomentObject = true;
        c2._useUTC = c2._isUTC = isUTC;
        c2._l = locale2;
        c2._i = input;
        c2._f = format3;
        c2._strict = strict;
        return createFromConfig(c2);
      }
      function createLocal(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn3, moments) {
        var res, i2;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn3](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset2(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset3 = this.utcOffset(), sign2 = "+";
          if (offset3 < 0) {
            offset3 = -offset3;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
        });
      }
      offset2("Z", ":");
      offset2("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset3 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset3 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset3, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset3 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c2 = {}, other;
        copyConfig(c2, this);
        c2 = prepareConfig(c2);
        if (c2._a) {
          other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
          this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output2 = formats && (isFunction(formats[format3]) ? formats[format3].call(this, now2) : formats[format3]);
        return this.format(output2 || this.localeData().calendar(format3, this, createLocal(now2)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output2;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output2 = monthDiff(this, that) / 12;
            break;
          case "month":
            output2 = monthDiff(this, that);
            break;
          case "quarter":
            output2 = monthDiff(this, that) / 3;
            break;
          case "second":
            output2 = (this - that) / 1e3;
            break;
          case "minute":
            output2 = (this - that) / 6e4;
            break;
          case "hour":
            output2 = (this - that) / 36e5;
            break;
          case "day":
            output2 = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output2 = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output2 = this - that;
        }
        return asFloat ? output2 : absFloor(output2);
      }
      function monthDiff(a2, b2) {
        if (a2.date() < b2.date()) {
          return -monthDiff(b2, a2);
        }
        var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b2 - anchor < 0) {
          anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b2 - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b2 - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func7 = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func7 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func7 + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output2 = formatMoment(this, inputString);
        return this.localeData().postformat(output2);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return new Date(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return new Date(y2, m, d2).valueOf();
        }
      }
      function utcStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return Date.UTC(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y2, m, d2);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format3) {
        var i2, l2, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i2, l2, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l2, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          namePieces.push(regexEscape2(eras[i2].name));
          abbrPieces.push(regexEscape2(eras[i2].abbr));
          narrowPieces.push(regexEscape2(eras[i2].narrow));
          mixedPieces.push(regexEscape2(eras[i2].name));
          mixedPieces.push(regexEscape2(eras[i2].abbr));
          mixedPieces.push(regexEscape2(eras[i2].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format3, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format3);
      }
      function listMonthsImpl(format3, index, field) {
        if (isNumber2(format3)) {
          index = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index != null) {
          return get$1(format3, index, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format3, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index = format3;
          localeSorted = false;
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
        if (index != null) {
          return get$1(format3, (index + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format3, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index) {
        return listMonthsImpl(format3, index, "months");
      }
      function listMonthsShort(format3, index) {
        return listMonthsImpl(format3, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b2 = number % 10, output2 = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
          return number + output2;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble2() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a2[2] = withoutSuffix;
        a2[3] = +posNegDuration > 0;
        a2[4] = locale2;
        return substituteTimeAgo.apply(null, a2);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output2;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output2 = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output2 = locale2.pastFuture(+this, output2);
        }
        return locale2.postformat(output2);
      }
      var abs$1 = Math.abs;
      function sign(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble2;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min2;
      hooks.max = max2;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// src/main.ts
__export(exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => ProjectsPlugin
});

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn3) {
  return fn3();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_24) => value = _24)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn3) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn3);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn3) {
  return definition[1] && fn3 ? assign($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn3) {
  if (definition[2] && fn3) {
    const lets = definition[2](fn3(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn3) {
  return function(event) {
    event.stopPropagation();
    return fn3.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option = select.options[i2];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn3) {
  get_current_component().$$.on_mount.push(fn3);
}
function onDestroy(fn3) {
  get_current_component().$$.on_destroy.push(fn3);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn3) => {
        fn3.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn3) => fn3.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn3) {
  render_callbacks.push(fn3);
}
function add_flush_callback(fn3) {
  flush_callbacks.push(fn3);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then((value) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error2) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error2);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error2;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block16, next, get_context) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = new Map();
  const deltas = new Map();
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block16(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = new Set();
  const did_move = new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o2--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o2) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o2) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance90, create_fragment90, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance90 ? instance90(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment90 ? create_fragment90($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn3) {
    set(fn3(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn3, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto2 = fn3.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn3(single ? values[0] : values, set);
      if (auto2) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// src/main.ts
var import_obsidian48 = __toModule(require("obsidian"));
var import_obsidian_dataview4 = __toModule(require_lib());
var import_dayjs8 = __toModule(require_dayjs_min());
var import_isoWeek = __toModule(require_isoWeek());
var import_localizedFormat = __toModule(require_localizedFormat());

// src/view.ts
var import_obsidian45 = __toModule(require("obsidian"));

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance90 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance90.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance90.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance90.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance90.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element2),
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c2) {
    return p2.replace(/%s/, c2);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
            return '"' + s2 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn3) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance90 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance90.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance: instance90
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance90.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance90;
    }
    instance90.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance90,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance90;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-portal/src/Portal.svelte
function create_fragment(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      div.hidden = true;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(null, div, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & 1)
        portal_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function portal(el, target = "body") {
  let targetEl;
  function update2(newTarget) {
    return __async(this, null, function* () {
      target = newTarget;
      if (typeof target === "string") {
        targetEl = document.querySelector(target);
        if (targetEl === null) {
          yield tick();
          targetEl = document.querySelector(target);
        }
        if (targetEl === null) {
          throw new Error(`No element found matching css selector: "${target}"`);
        }
      } else if (target instanceof HTMLElement) {
        targetEl = target;
      } else {
        throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
      }
      targetEl.appendChild(el);
      el.hidden = false;
    });
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update2(target);
  return { update: update2, destroy };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { target = "body" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { target: 0 });
  }
};
var Portal_default = Portal;

// node_modules/svelte-portal/src/main.es.js
var main_es_default = Portal_default;

// node_modules/obsidian-svelte/Popover/useClickOutside.js
function useClickOutside(element2, { onClickOutside, anchorEl, open }) {
  function onClick(event) {
    if (open && !anchorEl.contains(event.target) && !element2.contains(event.target)) {
      onClickOutside();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(props) {
      onClickOutside = props.onClickOutside;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// node_modules/obsidian-svelte/Popover/Popover.svelte
function add_css(target) {
  append_styles(target, "svelte-1xg3ic1", ".layer.svelte-1xg3ic1{z-index:var(--layer-popover)}");
}
function create_if_block(ctx) {
  let portal2;
  let current;
  portal2 = new main_es_default({
    props: {
      target: document.body,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & 527) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal2, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div;
  let div_class_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "" + (null_to_empty(ctx[2]) + " svelte-1xg3ic1"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useClickOutside_action = useClickOutside.call(null, div, {
          open: ctx[0],
          anchorEl: ctx[1],
          onClickOutside: ctx[8]
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[9], !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null), null);
        }
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "" + (null_to_empty(ctx2[2]) + " svelte-1xg3ic1"))) {
        attr(div, "class", div_class_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 3)
        useClickOutside_action.update.call(null, {
          open: ctx2[0],
          anchorEl: ctx2[1],
          onClickOutside: ctx2[8]
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { className = "popover layer" } = $$props;
  let { onClose } = $$props;
  let { placement = "bottom-start" } = $$props;
  let popperEl;
  let popper2 = null;
  const params = {
    placement,
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 4] }
      }
    ]
  };
  onDestroy(() => {
    if (popper2) {
      popper2.destroy();
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popperEl = $$value;
      $$invalidate(3, popperEl);
    });
  }
  const useClickOutside_function = () => $$invalidate(0, open = false);
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(1, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("onClose" in $$props2)
      $$invalidate(4, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(5, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      $: {
        if (anchorEl && popperEl) {
          popper2 = createPopper(anchorEl, popperEl, params);
        }
      }
    }
    if ($$self.$$.dirty & 17) {
      $:
        if (!open) {
          onClose();
        }
    }
  };
  return [
    open,
    anchorEl,
    className,
    popperEl,
    onClose,
    placement,
    slots,
    div_binding,
    useClickOutside_function,
    $$scope
  ];
}
var Popover = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      anchorEl: 1,
      open: 0,
      className: 2,
      onClose: 4,
      placement: 5
    }, add_css);
  }
};
var Popover_default = Popover;

// node_modules/obsidian-svelte/Popover/Menu.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: ctx[3],
      className: "menu",
      onClose: ctx[2],
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 8)
        popover_changes.placement = ctx2[3];
      if (dirty & 4)
        popover_changes.onClose = ctx2[2];
      if (dirty & 32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Menu = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Menu_default = Menu;

// node_modules/obsidian-svelte/Switch/Switch.svelte
function add_css2(target) {
  append_styles(target, "svelte-1i6m2hn", ".disabled.svelte-1i6m2hn{opacity:0.6}");
}
function create_fragment4(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<input type="checkbox"/>`;
      attr(div, "class", "checkbox-container svelte-1i6m2hn");
      toggle_class(div, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[5]),
          listen(div, "keypress", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        toggle_class(div, "disabled", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  let { disabled = false } = $$props;
  let ref;
  const dispatch = createEventDispatcher();
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const click_handler = () => {
    if (!disabled) {
      $$invalidate(0, checked = !checked);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
    if ($$self.$$.dirty & 5) {
      $: {
        if (ref) {
          if (checked) {
            ref.classList.add("is-enabled");
          } else {
            ref.classList.remove("is-enabled");
          }
        }
      }
    }
  };
  return [checked, disabled, ref, keypress_handler, div_binding, click_handler];
}
var Switch = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { checked: 0, disabled: 1 }, add_css2);
  }
};
var Switch_default = Switch;

// node_modules/obsidian-svelte/Icon/Icon.svelte
function add_css3(target) {
  append_styles(target, "svelte-s7qdhh", "span.svelte-s7qdhh{color:var(--icon-color);fill:var(--icon-color);opacity:var(--icon-opacity);display:flex;flex:0 1 auto}.icon-xs.svelte-s7qdhh{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-s7qdhh{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-s7qdhh{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-s7qdhh{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}.accent.svelte-s7qdhh{color:var(--text-on-accent);fill:var(--text-on-accent)}");
}
function create_fragment5(ctx) {
  let span;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "aria-label", ctx[3]);
      attr(span, "class", "svelte-s7qdhh");
      toggle_class(span, "accent", ctx[2]);
      toggle_class(span, "icon-xs", ctx[1] === "xs");
      toggle_class(span, "icon-sm", ctx[1] === "sm");
      toggle_class(span, "icon-md", ctx[1] === "md");
      toggle_class(span, "icon-lg", ctx[1] === "lg");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, span, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(span, "aria-label", ctx2[3]);
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 1)
        useIcon_action.update.call(null, ctx2[0]);
      if (dirty & 4) {
        toggle_class(span, "accent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(span, "icon-xs", ctx2[1] === "xs");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-sm", ctx2[1] === "sm");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-md", ctx2[1] === "md");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-lg", ctx2[1] === "lg");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { size = "md" } = $$props;
  let { accent = false } = $$props;
  let { tooltip = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("accent" in $$props2)
      $$invalidate(2, accent = $$props2.accent);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
  };
  return [name, size, accent, tooltip];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0, size: 1, accent: 2, tooltip: 3 }, add_css3);
  }
};
var Icon_default = Icon;

// node_modules/obsidian-svelte/Icon/IconButton.svelte
function add_css4(target) {
  append_styles(target, "svelte-r9r5oc", ".nopadding.svelte-r9r5oc{padding:0}.icon-xs.svelte-r9r5oc{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-r9r5oc{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-r9r5oc{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-r9r5oc{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}");
}
function create_fragment6(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "clickable-icon svelte-r9r5oc");
      attr(div, "aria-label", ctx[3]);
      toggle_class(div, "nopadding", ctx[4]);
      toggle_class(div, "is-active", ctx[2]);
      toggle_class(div, "icon-xs", ctx[1] === "xs");
      toggle_class(div, "icon-sm", ctx[1] === "sm");
      toggle_class(div, "icon-md", ctx[1] === "md");
      toggle_class(div, "icon-lg", ctx[1] === "lg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useIcon_action = useIcon.call(null, div, ctx[0])),
          listen(div, "click", ctx[5]),
          listen(div, "keypress", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(div, "aria-label", ctx2[3]);
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 1)
        useIcon_action.update.call(null, ctx2[0]);
      if (dirty & 16) {
        toggle_class(div, "nopadding", ctx2[4]);
      }
      if (dirty & 4) {
        toggle_class(div, "is-active", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(div, "icon-xs", ctx2[1] === "xs");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-sm", ctx2[1] === "sm");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-md", ctx2[1] === "md");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-lg", ctx2[1] === "lg");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { size = "md" } = $$props;
  let { active = false } = $$props;
  let { tooltip = "" } = $$props;
  let { nopadding = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("nopadding" in $$props2)
      $$invalidate(4, nopadding = $$props2.nopadding);
  };
  return [icon, size, active, tooltip, nopadding, click_handler, keypress_handler];
}
var IconButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      icon: 0,
      size: 1,
      active: 2,
      tooltip: 3,
      nopadding: 4
    }, add_css4);
  }
};
var IconButton_default = IconButton;

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian = __toModule(require("obsidian"));
function useIcon(node, name) {
  (0, import_obsidian.setIcon)(node, name);
  return {
    update(name2) {
      (0, import_obsidian.setIcon)(node, name2);
    }
  };
}

// node_modules/obsidian-svelte/Popover/MenuItem.svelte
function create_if_block_1(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({ props: { checked: ctx[0] } });
  switch_1.$on("check", ctx[6]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0];
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "menu-item-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, div, ctx[2]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 4)
        useIcon_action.update.call(null, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment7(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let t22;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0] !== void 0 && create_if_block_1(ctx);
  let if_block1 = ctx[2] && create_if_block2(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      t22 = text(ctx[1]);
      attr(div0, "class", "menu-item-title");
      attr(div1, "class", "menu-item");
      toggle_class(div1, "selected", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, t22);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[7]),
          listen(div1, "mouseleave", ctx[8]),
          listen(div1, "click", ctx[4]),
          listen(div1, "keypress", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0] !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 2)
        set_data(t22, ctx2[1]);
      if (!current || dirty & 8) {
        toggle_class(div1, "selected", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let selected = false;
  let { icon = "" } = $$props;
  let { checked = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const check_handler = ({ detail: enabled }) => $$invalidate(0, checked = enabled);
  const mouseenter_handler = () => $$invalidate(3, selected = true);
  const mouseleave_handler = () => $$invalidate(3, selected = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
  };
  return [
    checked,
    label,
    icon,
    selected,
    click_handler,
    keypress_handler,
    check_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var MenuItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { label: 1, icon: 2, checked: 0 });
  }
};
var MenuItem_default = MenuItem;

// node_modules/obsidian-svelte/Popover/Suggestion.svelte
function create_default_slot3(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "suggestion");
      set_style(div, "max-height", "300px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: ctx[3],
      className: "suggestion-container",
      onClose: ctx[2],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 8)
        popover_changes.placement = ctx2[3];
      if (dirty & 4)
        popover_changes.onClose = ctx2[2];
      if (dirty & 32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Suggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Suggestion_default = Suggestion;

// node_modules/obsidian-svelte/Popover/SuggestionItem.svelte
function create_fragment9(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t22;
  let t3;
  let div3;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      t22 = text(ctx[2]);
      t3 = space();
      div3 = element("div");
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-note");
      attr(div2, "class", "suggestion-content");
      attr(div3, "class", "suggestion-aux");
      attr(div4, "class", "suggestion-item mod-complex");
      toggle_class(div4, "is-selected", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t22);
      append(div4, t3);
      append(div4, div3);
      ctx[5](div4);
      if (!mounted) {
        dispose = [
          listen(div4, "mouseenter", ctx[6]),
          listen(div4, "mouseleave", ctx[7]),
          listen(div4, "mousedown", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4)
        set_data(t22, ctx2[2]);
      if (dirty & 1) {
        toggle_class(div4, "is-selected", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { description = "" } = $$props;
  let { selected = false } = $$props;
  const dispatch = createEventDispatcher();
  let ref;
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const mouseenter_handler = () => {
    $$invalidate(0, selected = true);
  };
  const mouseleave_handler = () => $$invalidate(0, selected = false);
  const mousedown_handler = () => dispatch("click");
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("select", selected);
    }
    if ($$self.$$.dirty & 9) {
      $: {
        if (selected && ref) {
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }
    }
  };
  return [
    selected,
    label,
    description,
    ref,
    dispatch,
    div4_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousedown_handler
  ];
}
var SuggestionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { label: 1, description: 2, selected: 0 });
  }
};
var SuggestionItem_default = SuggestionItem;

// node_modules/obsidian-svelte/Input/Input.svelte
function add_css5(target) {
  append_styles(target, "svelte-su9mt0", ".embed.svelte-su9mt0{all:unset;box-sizing:border-box;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal)}.embed.svelte-su9mt0:focus{box-shadow:none}.noPadding.svelte-su9mt0{padding:0}.error.svelte-su9mt0{border-color:var(--background-modifier-error)}.error.svelte-su9mt0:hover{border-color:var(--background-modifier-error-hover)}.error.svelte-su9mt0:focus{box-shadow:0 0 0 2px var(--background-modifier-error);border-color:var(--background-modifier-error)}small.svelte-su9mt0{margin-top:var(--size-4-1);font-size:var(--font-ui-smaller);color:var(--text-muted);display:block}.errorText.svelte-su9mt0{color:var(--text-error)}");
}
function create_if_block3(ctx) {
  let small;
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(ctx[9]);
      attr(small, "class", "svelte-su9mt0");
      toggle_class(small, "errorText", ctx[6]);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 512)
        set_data(t3, ctx2[9]);
      if (dirty & 64) {
        toggle_class(small, "errorText", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment10(ctx) {
  let div;
  let input;
  let input_style_value;
  let t3;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = !!ctx[9] && create_if_block3(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t3 = space();
      if (if_block)
        if_block.c();
      input.value = ctx[2];
      attr(input, "type", ctx[1]);
      attr(input, "placeholder", ctx[4]);
      input.readOnly = ctx[3];
      attr(input, "style", input_style_value = `width: ${ctx[5]}`);
      attr(input, "class", "svelte-su9mt0");
      toggle_class(input, "error", ctx[6]);
      toggle_class(input, "embed", ctx[7]);
      toggle_class(input, "noPadding", ctx[8]);
      attr(div, "style", div_style_value = `width: ${ctx[5]}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[16](input);
      append(div, t3);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[11]),
          listen(input, "focus", ctx[12]),
          listen(input, "blur", ctx[13]),
          listen(input, "keydown", ctx[14]),
          listen(input, "keyup", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        input.value = ctx2[2];
      }
      if (dirty & 2) {
        attr(input, "type", ctx2[1]);
      }
      if (dirty & 16) {
        attr(input, "placeholder", ctx2[4]);
      }
      if (dirty & 8) {
        input.readOnly = ctx2[3];
      }
      if (dirty & 32 && input_style_value !== (input_style_value = `width: ${ctx2[5]}`)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & 64) {
        toggle_class(input, "error", ctx2[6]);
      }
      if (dirty & 128) {
        toggle_class(input, "embed", ctx2[7]);
      }
      if (dirty & 256) {
        toggle_class(input, "noPadding", ctx2[8]);
      }
      if (!!ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5]}`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    if (autoFocus && ref) {
      ref.focus();
    }
  });
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(10, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        dispatch("input", value);
    }
  };
  return [
    ref,
    type,
    value,
    readonly,
    placeholder,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    autoFocus,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    input_binding
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      type: 1,
      value: 2,
      ref: 0,
      readonly: 3,
      placeholder: 4,
      autoFocus: 10,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    }, add_css5);
  }
};
var Input_default = Input;

// node_modules/obsidian-svelte/Input/TextInput.svelte
function create_fragment11(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "text",
    readonly: ctx[2],
    noPadding: ctx[9],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[8],
    error: ctx[6],
    helperText: ctx[7]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  input.$on("keyup", ctx[16]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 512)
        input_changes.noPadding = ctx2[9];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 256)
        input_changes.embed = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 128)
        input_changes.helperText = ctx2[7];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { helperText = "" } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.value);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("helperText" in $$props2)
      $$invalidate(7, helperText = $$props2.helperText);
    if ("embed" in $$props2)
      $$invalidate(8, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(9, noPadding = $$props2.noPadding);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    helperText,
    embed,
    noPadding,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      value: 0,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      helperText: 7,
      embed: 8,
      noPadding: 9,
      ref: 1
    });
  }
};
var TextInput_default = TextInput;

// node_modules/obsidian-svelte/Input/NumberInput.svelte
function create_fragment12(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "number",
    readonly: ctx[2],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[7],
    noPadding: ctx[8],
    error: ctx[6],
    helperText: ctx[9]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 128)
        input_changes.embed = ctx2[7];
      if (dirty & 256)
        input_changes.noPadding = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 512)
        input_changes.helperText = ctx2[9];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler
  ];
}
var NumberInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      value: 0,
      ref: 1,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    });
  }
};
var NumberInput_default = NumberInput;

// node_modules/obsidian-svelte/Autocomplete/Autocomplete.svelte
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2].label;
  child_ctx[24] = list[i2].description;
  child_ctx[26] = i2;
  return child_ctx;
}
function create_if_block4(ctx) {
  let suggestionitem;
  let current;
  suggestionitem = new SuggestionItem_default({
    props: { label: "", description: "No options" }
  });
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_each_block(ctx) {
  let suggestionitem;
  let current;
  function click_handler() {
    return ctx[20](ctx[26]);
  }
  function select_handler(...args) {
    return ctx[21](ctx[26], ...args);
  }
  suggestionitem = new SuggestionItem_default({
    props: {
      label: ctx[23],
      description: ctx[24],
      selected: ctx[8] === ctx[26]
    }
  });
  suggestionitem.$on("click", click_handler);
  suggestionitem.$on("select", select_handler);
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const suggestionitem_changes = {};
      if (dirty & 1024)
        suggestionitem_changes.label = ctx[23];
      if (dirty & 1024)
        suggestionitem_changes.description = ctx[24];
      if (dirty & 256)
        suggestionitem_changes.selected = ctx[8] === ctx[26];
      suggestionitem.$set(suggestionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let t3;
  let each_1_anchor;
  let current;
  let if_block = !ctx[10].length && create_if_block4(ctx);
  let each_value = ctx[10];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[10].length) {
        if (if_block) {
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 3329) {
        each_value = ctx2[10];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment13(ctx) {
  let textinput;
  let updating_value;
  let updating_ref;
  let t3;
  let suggestion;
  let current;
  function textinput_value_binding(value) {
    ctx[14](value);
  }
  function textinput_ref_binding(value) {
    ctx[15](value);
  }
  let textinput_props = {
    readonly: ctx[2],
    width: ctx[4],
    placeholder: ctx[3],
    autoFocus: ctx[6],
    embed: ctx[5]
  };
  if (ctx[0] !== void 0) {
    textinput_props.value = ctx[0];
  }
  if (ctx[9] !== void 0) {
    textinput_props.ref = ctx[9];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  binding_callbacks.push(() => bind(textinput, "ref", textinput_ref_binding));
  textinput.$on("focus", ctx[16]);
  textinput.$on("blur", ctx[17]);
  textinput.$on("input", ctx[18]);
  textinput.$on("keydown", ctx[19]);
  suggestion = new Suggestion_default({
    props: {
      anchorEl: ctx[9],
      open: ctx[1],
      onClose: ctx[22],
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
      t3 = space();
      create_component(suggestion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t3, anchor);
      mount_component(suggestion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & 4)
        textinput_changes.readonly = ctx2[2];
      if (dirty & 16)
        textinput_changes.width = ctx2[4];
      if (dirty & 8)
        textinput_changes.placeholder = ctx2[3];
      if (dirty & 64)
        textinput_changes.autoFocus = ctx2[6];
      if (dirty & 32)
        textinput_changes.embed = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textinput_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_ref && dirty & 512) {
        updating_ref = true;
        textinput_changes.ref = ctx2[9];
        add_flush_callback(() => updating_ref = false);
      }
      textinput.$set(textinput_changes);
      const suggestion_changes = {};
      if (dirty & 512)
        suggestion_changes.anchorEl = ctx2[9];
      if (dirty & 2)
        suggestion_changes.open = ctx2[1];
      if (dirty & 2)
        suggestion_changes.onClose = ctx2[22];
      if (dirty & 134219009) {
        suggestion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suggestion.$set(suggestion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(suggestion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(suggestion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t3);
      destroy_component(suggestion, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let filteredOptions;
  let { value } = $$props;
  let { options } = $$props;
  let { maxItems = 50 } = $$props;
  let { open = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { embed = false } = $$props;
  let { autoFocus = false } = $$props;
  let selected = -1;
  let inputRef;
  const dispatch = createEventDispatcher();
  let willClose = false;
  function textinput_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textinput_ref_binding(value2) {
    inputRef = value2;
    $$invalidate(9, inputRef);
  }
  const focus_handler = () => $$invalidate(1, open = true);
  const blur_handler = (event) => {
    $$invalidate(1, open = false);
    dispatch("change", value);
    dispatch("blur", event);
  };
  const input_handler = () => $$invalidate(1, open = true);
  const keydown_handler = (event) => {
    var _a, _b;
    if (open) {
      switch (event.key) {
        case "ArrowUp":
          const prev = selected - 1;
          $$invalidate(8, selected = prev < 0 ? filteredOptions.length - 1 : prev);
          event.stopPropagation();
          break;
        case "ArrowDown":
          const next = selected + 1;
          $$invalidate(8, selected = next > filteredOptions.length - 1 ? 0 : next);
          event.stopPropagation();
          break;
        case "Enter":
          $$invalidate(0, value = (_b = (_a = filteredOptions[selected]) == null ? void 0 : _a.label) != null ? _b : value);
          $$invalidate(7, willClose = true);
          break;
      }
    }
  };
  const click_handler = (i2) => {
    var _a, _b;
    $$invalidate(0, value = (_b = (_a = filteredOptions[i2]) == null ? void 0 : _a.label) != null ? _b : value);
    dispatch("change", value);
  };
  const select_handler = (i2, { detail }) => {
    if (detail) {
      $$invalidate(8, selected = i2);
    }
  };
  const func7 = () => $$invalidate(1, open = false);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("options" in $$props2)
      $$invalidate(12, options = $$props2.options);
    if ("maxItems" in $$props2)
      $$invalidate(13, maxItems = $$props2.maxItems);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("embed" in $$props2)
      $$invalidate(5, embed = $$props2.embed);
    if ("autoFocus" in $$props2)
      $$invalidate(6, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12289) {
      $:
        $$invalidate(10, filteredOptions = options.filter((option) => !value || option.label.toLocaleLowerCase().contains(value.toLocaleLowerCase())).slice(0, Math.min(maxItems, options.length)));
    }
    if ($$self.$$.dirty & 128) {
      $:
        if (willClose) {
          $$invalidate(1, open = false);
          $$invalidate(7, willClose = false);
        }
    }
  };
  return [
    value,
    open,
    readonly,
    placeholder,
    width,
    embed,
    autoFocus,
    willClose,
    selected,
    inputRef,
    filteredOptions,
    dispatch,
    options,
    maxItems,
    textinput_value_binding,
    textinput_ref_binding,
    focus_handler,
    blur_handler,
    input_handler,
    keydown_handler,
    click_handler,
    select_handler,
    func7
  ];
}
var Autocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      value: 0,
      options: 12,
      maxItems: 13,
      open: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      embed: 5,
      autoFocus: 6
    });
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/obsidian-svelte/Autocomplete/FileAutocomplete.svelte
function create_fragment14(ctx) {
  let autocomplete;
  let updating_value;
  let updating_options;
  let current;
  function autocomplete_value_binding(value) {
    ctx[10](value);
  }
  function autocomplete_options_binding(value) {
    ctx[11](value);
  }
  let autocomplete_props = {
    readonly: ctx[2],
    placeholder: ctx[3],
    width: ctx[4],
    embed: ctx[1],
    autoFocus: ctx[5]
  };
  if (ctx[0] !== void 0) {
    autocomplete_props.value = ctx[0];
  }
  if (ctx[6] !== void 0) {
    autocomplete_props.options = ctx[6];
  }
  autocomplete = new Autocomplete_default({ props: autocomplete_props });
  binding_callbacks.push(() => bind(autocomplete, "value", autocomplete_value_binding));
  binding_callbacks.push(() => bind(autocomplete, "options", autocomplete_options_binding));
  autocomplete.$on("change", ctx[12]);
  autocomplete.$on("blur", ctx[13]);
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const autocomplete_changes = {};
      if (dirty & 4)
        autocomplete_changes.readonly = ctx2[2];
      if (dirty & 8)
        autocomplete_changes.placeholder = ctx2[3];
      if (dirty & 16)
        autocomplete_changes.width = ctx2[4];
      if (dirty & 2)
        autocomplete_changes.embed = ctx2[1];
      if (dirty & 32)
        autocomplete_changes.autoFocus = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        autocomplete_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_options && dirty & 64) {
        updating_options = true;
        autocomplete_changes.options = ctx2[6];
        add_flush_callback(() => updating_options = false);
      }
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let options;
  let { value } = $$props;
  let { files } = $$props;
  let { getLabel = (file) => file.name } = $$props;
  let { getDescription = () => "" } = $$props;
  let { embed = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { autoFocus = false } = $$props;
  function autocomplete_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function autocomplete_options_binding(value2) {
    options = value2;
    $$invalidate(6, options), $$invalidate(7, files), $$invalidate(8, getLabel), $$invalidate(9, getDescription);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("files" in $$props2)
      $$invalidate(7, files = $$props2.files);
    if ("getLabel" in $$props2)
      $$invalidate(8, getLabel = $$props2.getLabel);
    if ("getDescription" in $$props2)
      $$invalidate(9, getDescription = $$props2.getDescription);
    if ("embed" in $$props2)
      $$invalidate(1, embed = $$props2.embed);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("autoFocus" in $$props2)
      $$invalidate(5, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 896) {
      $:
        $$invalidate(6, options = files.map((file) => ({
          label: getLabel(file),
          description: getDescription(file)
        })));
    }
  };
  return [
    value,
    embed,
    readonly,
    placeholder,
    width,
    autoFocus,
    options,
    files,
    getLabel,
    getDescription,
    autocomplete_value_binding,
    autocomplete_options_binding,
    change_handler,
    blur_handler
  ];
}
var FileAutocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      value: 0,
      files: 7,
      getLabel: 8,
      getDescription: 9,
      embed: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      autoFocus: 5
    });
  }
};
var FileAutocomplete_default = FileAutocomplete;

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css6(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment15(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "aria-label", ctx[2]);
      button.disabled = ctx[1];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(button, "mod-cta", ctx[0] === "primary");
      toggle_class(button, "mod-warning", ctx[0] === "destructive");
      toggle_class(button, "mod-plain", ctx[0] === "plain");
      toggle_class(button, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        attr(button, "aria-label", ctx2[2]);
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-cta", ctx2[0] === "primary");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-warning", ctx2[0] === "destructive");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-plain", ctx2[0] === "plain");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "disabled", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(2, tooltip = $$props2.tooltip);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, disabled, tooltip, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { variant: 0, disabled: 1, tooltip: 2 }, add_css6);
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/Callout/Callout.svelte
function create_fragment16(ctx) {
  let div4;
  let div2;
  let div0;
  let useIcon_action;
  let t0;
  let div1;
  let t1;
  let t22;
  let div3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(ctx[0]);
      t22 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "callout-icon");
      attr(div1, "class", "callout-title-inner");
      attr(div2, "class", "callout-title");
      attr(div3, "class", "callout-content");
      attr(div4, "data-callout-metadata", "");
      attr(div4, "data-callout-fold", "");
      attr(div4, "data-callout", ctx[2]);
      attr(div4, "class", "callout");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
      append(div4, t22);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, div0, ctx[1]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 2)
        useIcon_action.update.call(null, ctx2[1]);
      if (!current || dirty & 1)
        set_data(t1, ctx2[0]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        attr(div4, "data-callout", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { icon } = $$props;
  let { variant } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [title, icon, variant, $$scope, slots];
}
var Callout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { title: 0, icon: 1, variant: 2 });
  }
};
var Callout_default = Callout;

// node_modules/obsidian-svelte/Card/Card.svelte
function add_css7(target) {
  append_styles(target, "svelte-166bpw4", "div.svelte-166bpw4{margin-bottom:var(--size-4-2)}");
}
function create_fragment17(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "card svelte-166bpw4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {}, add_css7);
  }
};
var Card_default = Card;

// node_modules/obsidian-svelte/Checkbox/Checkbox.svelte
function create_fragment18(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      input.checked = ctx[0];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "dblclick", stop_propagation(ctx[2])),
          listen(input, "click", stop_propagation(ctx[3])),
          listen(input, "change", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, checked = event.currentTarget.checked);
    }
  }
  function dblclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
  };
  return [checked, handleChange, dblclick_handler, click_handler];
}
var Checkbox = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { checked: 0 });
  }
};
var Checkbox_default = Checkbox;

// node_modules/obsidian-svelte/ColorInput/ColorInput.svelte
function create_fragment19(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "color");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[3]),
          listen(input, "input", ctx[1]),
          listen(input, "change", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_input_value(input, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { value } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, input_handler, change_handler, input_input_handler];
}
var ColorInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { value: 0 });
  }
};
var ColorInput_default = ColorInput;

// node_modules/obsidian-svelte/DateInput/DateInput.svelte
function add_css8(target) {
  append_styles(target, "svelte-2qn54x", "input.svelte-2qn54x{border-radius:9999px;border:0;background-color:var(--background-modifier-hover);font-family:var(--font-default);padding:0.1em 0.6em}.embed.svelte-2qn54x{margin:0 8px}");
}
function create_fragment20(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "date");
      attr(input, "class", "svelte-2qn54x");
      toggle_class(input, "embed", ctx[0]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[4](input);
      if (!mounted) {
        dispose = listen(input, "change", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(input, "embed", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { embed = false } = $$props;
  let ref;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      if (event.currentTarget.valueAsDate) {
        dispatch("change", event.currentTarget.valueAsDate);
      }
    }
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref), $$invalidate(3, value);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("embed" in $$props2)
      $$invalidate(0, embed = $$props2.embed);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      $: {
        if (ref && value) {
          $$invalidate(1, ref.valueAsDate = new Date(value.getFullYear(), value.getMonth(), value.getDate(), 12), ref);
        }
      }
    }
  };
  return [embed, ref, handleChange, value, input_binding];
}
var DateInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, { value: 3, embed: 0 }, add_css8);
  }
};
var DateInput_default = DateInput;

// node_modules/obsidian-svelte/Link/InternalLink.svelte
function add_css9(target) {
  append_styles(target, "svelte-u3bamg", ".is-unresolved.svelte-u3bamg{opacity:0.5}");
}
function create_fragment21(ctx) {
  let a2;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      attr(a2, "href", ctx[0]);
      attr(a2, "data-href", ctx[0]);
      attr(a2, "class", a_class_value = "" + (null_to_empty(`internal-link`) + " svelte-u3bamg"));
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noopener");
      toggle_class(a2, "is-unresolved", !ctx[2]);
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a2, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(a2, "href", ctx2[0]);
      }
      if (!current || dirty & 1) {
        attr(a2, "data-href", ctx2[0]);
      }
      if (!current || dirty & 4) {
        toggle_class(a2, "is-unresolved", !ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { linkText } = $$props;
  let { sourcePath } = $$props;
  let { resolved } = $$props;
  const dispatch = createEventDispatcher();
  const click_handler = (event) => {
    event.stopPropagation();
    dispatch("open", {
      linkText,
      sourcePath,
      newLeaf: event.ctrlKey || event.metaKey
    });
  };
  $$self.$$set = ($$props2) => {
    if ("linkText" in $$props2)
      $$invalidate(0, linkText = $$props2.linkText);
    if ("sourcePath" in $$props2)
      $$invalidate(1, sourcePath = $$props2.sourcePath);
    if ("resolved" in $$props2)
      $$invalidate(2, resolved = $$props2.resolved);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [linkText, sourcePath, resolved, dispatch, $$scope, slots, click_handler];
}
var InternalLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, { linkText: 0, sourcePath: 1, resolved: 2 }, add_css9);
  }
};
var InternalLink_default = InternalLink;

// node_modules/obsidian-svelte/Link/Link.svelte
function create_fragment22(ctx) {
  let a2;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [
    { href: ctx[0] },
    { rel: "noopener" },
    { target: "_blank" },
    ctx[1]
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign(a_data, a_levels[i2]);
  }
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a2, a_data);
      toggle_class(a2, "external-link", externalPattern.test(ctx[0]));
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      set_attributes(a2, a_data = get_spread_update(a_levels, [
        (!current || dirty & 1) && { href: ctx2[0] },
        { rel: "noopener" },
        { target: "_blank" },
        ctx2[1]
      ]));
      toggle_class(a2, "external-link", externalPattern.test(ctx2[0]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
var externalPattern = /^[a-zA-Z]+\:\/\//;
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href } = $$props;
  const aria = {
    "aria-label": href,
    "aria-label-position": "top"
  };
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2)
      $$invalidate(0, href = $$props2.href);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [href, aria, $$scope, slots];
}
var Link = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, { href: 0 });
  }
};
var Link_default = Link;

// node_modules/obsidian-svelte/Loading/Loading.svelte
function create_fragment23(ctx) {
  let div9;
  return {
    c() {
      div9 = element("div");
      div9.innerHTML = `<div class="sk-cube sk-cube1"></div> 
	<div class="sk-cube sk-cube2"></div> 
	<div class="sk-cube sk-cube3"></div> 
	<div class="sk-cube sk-cube4"></div> 
	<div class="sk-cube sk-cube5"></div> 
	<div class="sk-cube sk-cube6"></div> 
	<div class="sk-cube sk-cube7"></div> 
	<div class="sk-cube sk-cube8"></div> 
	<div class="sk-cube sk-cube9"></div>`;
      attr(div9, "class", "loader-cube");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div9);
    }
  };
}
var Loading = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment23, safe_not_equal, {});
  }
};
var Loading_default = Loading;

// node_modules/obsidian-svelte/Modal/ModalButtonGroup.svelte
function create_fragment24(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-button-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalButtonGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment24, safe_not_equal, {});
  }
};
var ModalButtonGroup_default = ModalButtonGroup;

// node_modules/obsidian-svelte/Modal/ModalContent.svelte
function create_fragment25(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment25, safe_not_equal, {});
  }
};
var ModalContent_default = ModalContent;

// node_modules/obsidian-svelte/Modal/ModalLayout.svelte
function create_fragment26(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
var ModalLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment26, safe_not_equal, { title: 0 });
  }
};
var ModalLayout_default = ModalLayout;

// node_modules/obsidian-svelte/Select/SelectItem.svelte
function create_fragment27(ctx) {
  let option;
  let t_value = (ctx[0] || ctx[1]) + "";
  let t3;
  return {
    c() {
      option = element("option");
      t3 = text(t_value);
      option.__value = ctx[1];
      option.value = option.__value;
      option.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[0] || ctx2[1]) + ""))
        set_data(t3, t_value);
      if (dirty & 2) {
        option.__value = ctx2[1];
        option.value = option.__value;
      }
      if (dirty & 4) {
        option.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [text2, value, disabled];
}
var SelectItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment27, safe_not_equal, { text: 0, value: 1, disabled: 2 });
  }
};
var SelectItem_default = SelectItem;

// node_modules/obsidian-svelte/Select/Select.svelte
function get_each_context2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[2],
      value: "",
      disabled: true
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: { text: ctx[2], value: "" }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[6].label,
      value: ctx[6].value
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 1)
        selectitem_changes.text = ctx2[6].label;
      if (dirty & 1)
        selectitem_changes.value = ctx2[6].value;
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_fragment28(ctx) {
  let select;
  let if_block0_anchor;
  let if_block1_anchor;
  let select_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[0].length && ctx[2] && create_if_block_12(ctx);
  let if_block1 = ctx[3] && create_if_block5(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      select = element("select");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      select.disabled = select_disabled_value = !ctx[0].length && !!ctx[2];
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block0)
        if_block0.m(select, null);
      append(select, if_block0_anchor);
      if (if_block1)
        if_block1.m(select, null);
      append(select, if_block1_anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[1]);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0].length && ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(select, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(select, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(select, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 5 && select_disabled_value !== (select_disabled_value = !ctx2[0].length && !!ctx2[2])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & 2) {
        select_option(select, ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { value } = $$props;
  let { placeholder = "" } = $$props;
  let { allowEmpty = false } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLSelectElement) {
      dispatch("change", event.currentTarget.value);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("allowEmpty" in $$props2)
      $$invalidate(3, allowEmpty = $$props2.allowEmpty);
  };
  return [options, value, placeholder, allowEmpty, handleChange];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment28, safe_not_equal, {
      options: 0,
      value: 1,
      placeholder: 2,
      allowEmpty: 3
    });
  }
};
var Select_default = Select;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css10(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment29(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = ((_a = ctx[0]) != null ? _a : "") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = ctx[1]) != null ? _b : "") + "";
  let t22;
  let t3;
  let div3;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t22 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(div3, "vertical-control", ctx[2]);
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(div4, "vertical", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t22);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t22, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        toggle_class(div3, "vertical-control", ctx2[2]);
      }
      if (!current || dirty & 4) {
        toggle_class(div4, "vertical", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, description, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment29, safe_not_equal, { name: 0, description: 1, vertical: 2 }, add_css10);
  }
};
var SettingItem_default = SettingItem;

// node_modules/obsidian-svelte/Slider/Slider.svelte
function create_fragment30(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "range");
      attr(input, "class", "slider");
      attr(input, "min", ctx[1]);
      attr(input, "max", ctx[2]);
      attr(input, "step", ctx[3]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[6]),
          listen(input, "input", ctx[6]),
          listen(input, "change", ctx[4]),
          listen(input, "input", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(input, "min", ctx2[1]);
      }
      if (dirty & 4) {
        attr(input, "max", ctx2[2]);
      }
      if (dirty & 8) {
        attr(input, "step", ctx2[3]);
      }
      if (dirty & 1) {
        set_input_value(input, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { min: min2 } = $$props;
  let { max: max2 } = $$props;
  let { step } = $$props;
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(1, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(2, max2 = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(3, step = $$props2.step);
  };
  return [
    value,
    min2,
    max2,
    step,
    change_handler,
    input_handler,
    input_change_input_handler
  ];
}
var Slider = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment30, safe_not_equal, { value: 0, min: 1, max: 2, step: 3 });
  }
};
var Slider_default = Slider;

// node_modules/obsidian-svelte/Tag/Tag.svelte
function add_css11(target) {
  append_styles(target, "svelte-ehq9e", "div.svelte-ehq9e{background-color:var(--tag-background);border:var(--tag-border-width) solid var(--tag-border-color);border-radius:var(--tag-radius);color:var(--tag-color);font-size:var(--tag-size);text-decoration:var(--tag-decoration);padding:var(--tag-padding-y) var(--tag-padding-x);line-height:1;display:inline-flex;align-items:center;gap:var(--size-4-1)}");
}
function create_fragment31(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-ehq9e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Tag = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment31, safe_not_equal, {}, add_css11);
  }
};
var Tag_default = Tag;

// node_modules/obsidian-svelte/TextArea/TextArea.svelte
function add_css12(target) {
  append_styles(target, "svelte-1yhxf9x", "textarea.svelte-1yhxf9x{font-family:var(--font-monospace-default)}");
}
function create_fragment32(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "rows", ctx[1]);
      attr(textarea, "style", textarea_style_value = `width: ${ctx[2]}`);
      attr(textarea, "class", "svelte-1yhxf9x");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(textarea, "rows", ctx2[1]);
      }
      if (dirty & 4 && textarea_style_value !== (textarea_style_value = `width: ${ctx2[2]}`)) {
        attr(textarea, "style", textarea_style_value);
      }
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { rows } = $$props;
  let { width = "auto" } = $$props;
  const dispatch = createEventDispatcher();
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("rows" in $$props2)
      $$invalidate(1, rows = $$props2.rows);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [value, rows, width, textarea_input_handler];
}
var TextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment32, safe_not_equal, { value: 0, rows: 1, width: 2 }, add_css12);
  }
};
var TextArea_default = TextArea;

// node_modules/obsidian-svelte/Typography/Typography.svelte
function add_css13(target) {
  append_styles(target, "svelte-1wyn8wx", ".nomargin.svelte-1wyn8wx{margin:0}");
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let svelte_element_levels = [{ class: "svelte-1wyn8wx" }];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = element(ctx[2][ctx[0]]);
      if (default_slot)
        default_slot.c();
      set_attributes(svelte_element, svelte_element_data);
      toggle_class(svelte_element, "nomargin", ctx[1]);
      toggle_class(svelte_element, "setting-item-name", ctx[0] === "label");
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{ class: "svelte-1wyn8wx" }]));
      toggle_class(svelte_element, "nomargin", ctx2[1]);
      toggle_class(svelte_element, "setting-item-name", ctx2[0] === "label");
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment33(ctx) {
  let previous_tag = ctx[2][ctx[0]];
  let svelte_element_anchor;
  let current;
  let svelte_element = ctx[2][ctx[0]] && create_dynamic_element(ctx);
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[2][ctx2[0]]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, ctx2[2][ctx2[0]])) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[2][ctx2[0]];
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o(local) {
      transition_out(svelte_element);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant } = $$props;
  let { nomargin = false } = $$props;
  const elements = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    body: "p",
    label: "p"
  };
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("nomargin" in $$props2)
      $$invalidate(1, nomargin = $$props2.nomargin);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, nomargin, elements, $$scope, slots];
}
var Typography = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment33, safe_not_equal, { variant: 0, nomargin: 1 }, add_css13);
  }
};
var Typography_default = Typography;

// node_modules/obsidian-svelte/useClickOutside.js
function useClickOutside2(element2, callbackFunction) {
  function onClick(event) {
    if (!element2.contains(event.target)) {
      callbackFunction();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(newCallbackFunction) {
      callbackFunction = newCallbackFunction;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// node_modules/immer/dist/immer.esm.mjs
function n(n2) {
  for (var r2 = arguments.length, t3 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++)
    t3[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? typeof i2 == "function" ? i2.apply(null, t3) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t3.length ? " " + t3.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || typeof n3 != "object")
      return false;
    var r2 = Object.getPrototypeOf(n3);
    if (r2 === null)
      return true;
    var t3 = Object.hasOwnProperty.call(r2, "constructor") && r2.constructor;
    return t3 === Object || typeof t3 == "function" && Function.toString.call(t3) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function i(n2, r2, t3) {
  t3 === void 0 && (t3 = false), o(n2) === 0 ? (t3 ? Object.keys : nn)(n2).forEach(function(e) {
    t3 && typeof e == "symbol" || r2(e, n2[e], n2);
  }) : n2.forEach(function(t4, e) {
    return r2(e, t4, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return o(n2) === 2 ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return o(n2) === 2 ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t3) {
  var e = o(n2);
  e === 2 ? n2.set(r2, t3) : e === 3 ? (n2.delete(r2), n2.add(t3)) : n2[r2] = t3;
}
function c(n2, r2) {
  return n2 === r2 ? n2 !== 0 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t3 = nn(r2), e = 0; e < t3.length; e++) {
    var i2 = t3[e], o2 = r2[i2];
    o2.writable === false && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return e === void 0 && (e = false), y(n2) || r(n2) || !t(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return n2 == null || typeof n2 != "object" || Object.isFrozen(n2);
}
function b(r2) {
  var t3 = tn[r2];
  return t3 || n(18, r2), t3;
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  r2.i === 0 || r2.i === 1 ? r2.j() : r2.O = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = r2 !== void 0 && r2 !== i2;
  return e.h.g || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (O(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), O(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t3) {
  if (y(r2))
    return r2;
  var e = r2[Q];
  if (!e)
    return i(r2, function(i2, o3) {
      return A(n2, e, r2, i2, o3, t3);
    }, true), r2;
  if (e.A !== n2)
    return r2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = e.i === 4 || e.i === 5 ? e.o = l(e.k) : e.o;
    i(e.i === 3 ? new Set(o2) : o2, function(r3, i2) {
      return A(n2, e, o2, r3, i2, t3);
    }), x(n2, o2, false), t3 && n2.u && b("Patches").R(e, t3, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2) {
  if (c2 === o2 && n(5), r(c2)) {
    var v2 = M(e, c2, s2 && i2 && i2.i !== 3 && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !r(v2))
      return;
    e.m = false;
  }
  if (t(c2) && !y(c2)) {
    if (!e.h.F && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t3) {
  t3 === void 0 && (t3 = false), n2.h.F && n2.m && d(r2, t3);
}
function z(n2, r2) {
  var t3 = n2[Q];
  return (t3 ? p(t3) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t3 = Object.getPrototypeOf(n2); t3; ) {
      var e = Object.getOwnPropertyDescriptor(t3, r2);
      if (e)
        return e;
      t3 = Object.getPrototypeOf(t3);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, r2, t3) {
  var e = s(r2) ? b("MapSet").N(r2, t3) : v(r2) ? b("MapSet").T(r2, t3) : n2.g ? function(n3, r3) {
    var t4 = Array.isArray(n3), e2 = { i: t4 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, D: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t4 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  }(r2, t3) : b("ES5").J(r2, t3);
  return (t3 ? t3.A : _()).p.push(e), e;
}
function D(e) {
  return r(e) || n(22, e), function n2(r2) {
    if (!t(r2))
      return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = F(r2, c2), u2.I = false;
    } else
      e2 = F(r2, c2);
    return i(e2, function(r3, t3) {
      u2 && a(u2.t, r3) === t3 || f(e2, r3, n2(t3));
    }), c2 === 3 ? new Set(e2) : e2;
  }(e);
}
function F(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
var X = typeof Map != "undefined";
var q = typeof Set != "undefined";
var B = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined";
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var V = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t3) {
    r2[t3] = Object.getOwnPropertyDescriptor(n2, t3);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, r2))
    return function(n3, r3, t3) {
      var e2, i3 = I(r3, t3);
      return i3 ? "value" in i3 ? i3.value : (e2 = i3.get) === null || e2 === void 0 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t3) {
  var e = I(p(n2), r2);
  if (e == null ? void 0 : e.set)
    return e.set.call(n2.k, t3), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = i2 == null ? void 0 : i2[Q];
    if (o2 && o2.t === t3)
      return n2.o[r2] = t3, n2.D[r2] = false, true;
    if (c(t3, i2) && (t3 !== void 0 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t3 && typeof t3 != "number" && (t3 !== void 0 || r2 in n2.o) || (n2.o[r2] = t3, n2.D[r2] = true, true);
}, deleteProperty: function(n2, r2) {
  return z(n2.t, r2) !== void 0 || r2 in n2.t ? (n2.D[r2] = false, E(n2), k(n2)) : delete n2.D[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t3 = p(n2), e = Reflect.getOwnPropertyDescriptor(t3, r2);
  return e ? { writable: true, configurable: n2.i !== 1 || r2 !== "length", enumerable: e.enumerable, value: t3[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t3) {
  return isNaN(parseInt(t3)) && n(13), on.set.call(this, r2, t3, void 0);
}, on.set = function(r2, t3, e) {
  return t3 !== "length" && isNaN(parseInt(t3)) && n(14), en.set.call(this, r2[0], t3, e, r2[0]);
};
var un = function() {
  function e(r2) {
    var e2 = this;
    this.g = B, this.F = true, this.produce = function(r3, i3, o2) {
      if (typeof r3 == "function" && typeof i3 != "function") {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          n2 === void 0 && (n2 = u2);
          for (var t3 = arguments.length, e3 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t4;
            return (t4 = i3).call.apply(t4, [r4, n3].concat(e3));
          });
        };
      }
      var f2;
      if (typeof i3 != "function" && n(6), o2 !== void 0 && typeof o2 != "function" && n(7), t(r3)) {
        var c2 = w(e2), s2 = R(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return typeof Promise != "undefined" && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || typeof r3 != "object") {
        if ((f2 = i3(r3)) === void 0 && (f2 = r3), f2 === H && (f2 = void 0), e2.F && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if (typeof n2 == "function")
        return function(r4) {
          for (var t4 = arguments.length, i4 = Array(t4 > 1 ? t4 - 1 : 0), o3 = 1; o3 < t4; o3++)
            i4[o3 - 1] = arguments[o3];
          return e2.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t3, i3, o2 = e2.produce(n2, r3, function(n3, r4) {
        t3 = n3, i3 = r4;
      });
      return typeof Promise != "undefined" && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t3, i3];
      }) : [o2, t3, i3];
    }, typeof (r2 == null ? void 0 : r2.useProxies) == "boolean" && this.setUseProxies(r2.useProxies), typeof (r2 == null ? void 0 : r2.autoFreeze) == "boolean" && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = D(e2));
    var i3 = w(this), o2 = R(this, e2, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(r2, t3) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t3), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.g = r2;
  }, i2.applyPatches = function(n2, t3) {
    var e2;
    for (e2 = t3.length - 1; e2 >= 0; e2--) {
      var i3 = t3[e2];
      if (i3.path.length === 0 && i3.op === "replace") {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t3 = t3.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t3) : this.produce(n2, function(n3) {
      return o2(n3, t3);
    });
  }, e;
}();
var an = new un();
var fn2 = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn2;

// src/lib/stores/settings.ts
function createSettings() {
  const { set, update: update2, subscribe: subscribe2 } = writable({
    version: 1,
    projects: []
  });
  return {
    set,
    subscribe: subscribe2,
    saveLayout(projectId, viewId) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.lastProjectId = projectId, draft.lastViewId = viewId;
          return draft;
        });
      });
    },
    addProject(project) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.projects.push(project);
          return draft;
        });
      });
    },
    updateProject(project) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.map((w2) => w2.id === project.id ? project : w2);
          return draft;
        });
      });
    },
    deleteProject(projectId) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.filter((w2) => w2.id !== projectId);
          return draft;
        });
      });
    },
    addView(projectId, view2) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((ws) => ws.id === projectId);
          if (idx >= 0) {
            const ws = draft.projects[idx];
            if (ws) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
                views: [...ws.views, view2]
              }));
            }
          }
          return draft;
        });
      });
    },
    renameView(projectId, viewId, name) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((p2) => p2.id === projectId);
          if (idx >= 0) {
            const p2 = draft.projects[idx];
            if (p2) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, p2), {
                views: p2.views.map((view2) => view2.id === viewId ? __spreadProps(__spreadValues({}, view2), { name }) : view2)
              }));
            }
          }
          return draft;
        });
      });
    },
    deleteView(projectId, viewId) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((ws) => ws.id === projectId);
          if (idx >= 0) {
            const ws = draft.projects[idx];
            if (ws) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
                views: ws.views.filter((view2) => view2.id !== viewId)
              }));
            }
          }
          return draft;
        });
      });
    },
    updateViewConfig(projectId, viewId, config) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.map((project) => {
          if (project.id === projectId) {
            return __spreadProps(__spreadValues({}, project), {
              views: project.views.map((view2) => {
                if (view2.id === viewId) {
                  return __spreadProps(__spreadValues({}, view2), {
                    config
                  });
                }
                return view2;
              })
            });
          }
          return project;
        });
        return draft;
      }));
    }
  };
}
var settings = createSettings();
function migrateAny(settings2) {
  if (!settings2) {
    return { version: 1, projects: [] };
  }
  if ("version" in settings2) {
    return Object.assign({}, DEFAULT_SETTINGS, settings2);
  }
  return migrate(settings2);
}
function migrate(v0) {
  return {
    version: 1,
    lastProjectId: v0.lastWorkspaceId,
    lastViewId: v0.lastViewId,
    projects: v0.workspaces
  };
}

// src/lib/stores/obsidian.ts
var app = writable();
var view = writable();
var plugin = writable();

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance90, Constructor) {
  if (!(instance90 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toArray.js
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

// node_modules/i18next/dist/esm/i18next.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init3(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t3) {
  a2.forEach(function(m) {
    if (s2[m])
      t3[m] = s2[m];
  });
}
function getLastOfPath(object, path3, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path3 !== "string" ? [].concat(path3) : path3.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path3, newValue) {
  var _getLastOfPath = getLastOfPath(object, path3, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path3, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path3, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat)
    obj[k2].push(newValue);
}
function getPath(object, path3) {
  var _getLastOfPath3 = getLastOfPath(object, path3), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path3) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path3])
    return obj[path3];
  var paths = path3.split(keySeparator);
  var current = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current)
      return void 0;
    if (typeof current[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i2]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i2, i2 + j2).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i2 + j2) {
        j2++;
        p2 = paths.slice(i2, i2 + j2).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path3.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i2]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path3 = [lng, ns];
      if (key && typeof key !== "string")
        path3 = path3.concat(key);
      if (key && typeof key === "string")
        path3 = path3.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path3 = lng.split(".");
      }
      var result = getPath(this.data, path3);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path3 = [lng, ns];
      if (key)
        path3 = path3.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path3 = lng.split(".");
        value = ns;
        ns = path3[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path3, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path3 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path3 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path3[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path3) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path3, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage2(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists2(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;
      if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey)
                copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && options[option] !== void 0) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _2(n2) {
    return Number(n2 > 1);
  },
  2: function _3(n2) {
    return Number(n2 != 1);
  },
  3: function _4(n2) {
    return 0;
  },
  4: function _5(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _6(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _9(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _10(n2) {
    return Number(n2 >= 2);
  },
  10: function _11(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _12(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _13(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _14(n2) {
    return Number(n2 !== 0);
  },
  14: function _15(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _17(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _18(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _19(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _21(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _22(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _23(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path3 = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path3, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path3;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread$3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r2 = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: function number(val, lng, options2) {
        return new Intl.NumberFormat(lng, options2).format(val);
      },
      currency: function currency(val, lng, options2) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options2), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options2) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options2)).format(val);
      },
      relativetime: function relativetime(val, lng, options2) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options2)).format(val, options2.range || "day");
      },
      list: function list(val, lng, options2) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options2)).format(val);
      }
    };
    this.init(options);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init3(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng, options) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = {};
            var loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loaded2[l2][ns2] === void 0)
                  loaded2[l2][ns2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop2() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init3() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop2;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t3) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t3);
          callback(err, t3);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources2(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append2 = function append3(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        } else {
          append2(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources2(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop2;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use2(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage2(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT2(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t3() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists2() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace2(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone.logger = clone.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone[m] = _this8[m];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance33 = I18n.createInstance();
instance33.createInstance = I18n.createInstance;
var createInstance = instance33.createInstance;
var init2 = instance33.init;
var loadResources = instance33.loadResources;
var reloadResources = instance33.reloadResources;
var use = instance33.use;
var changeLanguage = instance33.changeLanguage;
var getFixedT = instance33.getFixedT;
var t2 = instance33.t;
var exists = instance33.exists;
var setDefaultNamespace = instance33.setDefaultNamespace;
var hasLoadedNamespace = instance33.hasLoadedNamespace;
var loadNamespaces = instance33.loadNamespaces;
var loadLanguages = instance33.loadLanguages;
var i18next_default = instance33;

// src/lib/stores/i18n.ts
var import_svelte_i18next = __toModule(require_svelte_i18next());
i18next_default.init({
  lng: "en",
  resources: {
    en: {
      translation: {
        "data-types": {
          string: "Text",
          number: "Number",
          boolean: "True or false",
          date: "Date",
          link: "Link",
          list: "List",
          unknown: "Unknown data type"
        },
        commands: {
          "show-projects": {
            name: "Show projects"
          },
          "create-project": {
            name: "Create new project"
          },
          "create-note": {
            name: "Create new note"
          }
        },
        menus: {
          project: {
            create: {
              title: "Create project in folder"
            }
          }
        },
        modals: {
          project: {
            create: {
              "short-title": "New project",
              untitled: "Untitled project",
              title: "Create new project",
              cta: "Create project",
              "existing-name-error": "A project with that name already exists.",
              "empty-name-error": "Project name can't be empty."
            },
            edit: {
              "short-title": "Edit project",
              title: "Edit project",
              cta: "Save"
            },
            delete: {
              "short-title": "Delete project",
              title: "Delete project",
              message: "Are you sure you want to delete the project?",
              cta: "Delete"
            },
            name: {
              name: "Name",
              description: ""
            },
            path: {
              name: "Path",
              description: "Path to the folder you want to manage. Leave empty to use root folder."
            },
            dataview: {
              name: "Use Dataview",
              description: "Use Dataview to query read-only data instead of using paths.",
              error: {
                title: "Dataview is disabled",
                message: "Enable the Dataview plugin to continue using this project."
              }
            },
            query: {
              name: "Query",
              description: "Only supports TABLE queries."
            },
            recursive: {
              name: "Include subfolders",
              description: "Manage notes inside subfolders within the project path."
            },
            templates: {
              name: "Templates",
              description: "Templates to choose from when you create new notes."
            },
            defaultName: {
              name: "Default name",
              description: "Default name for new notes. Supports {{date}} and {{time}} template variables.",
              invalid: "Contains illegal characters."
            }
          },
          view: {
            create: {
              "short-title": "New view",
              title: "Add new view",
              optional: "Optional",
              type: {
                name: "Type",
                description: ""
              },
              name: {
                name: "Name",
                description: ""
              },
              cta: "Add view",
              "existing-name-error": "A view with that name already exists."
            },
            delete: {
              "short-title": "Delete view",
              title: "Delete view",
              message: "Are you sure you want to delete the view?",
              cta: "Delete"
            }
          },
          note: {
            create: {
              "short-title": "New note",
              title: "Create new note",
              name: {
                name: "Name",
                description: ""
              },
              templatePath: {
                name: "Template",
                description: "",
                none: "None"
              },
              project: {
                name: "Project",
                description: ""
              },
              "name-taken-error": "A note with that name already exists.",
              "empty-name-error": "Name can't be empty.",
              create: "Create note",
              readonly: {
                title: "Read-only project",
                message: "{{project}} is a read-only project. Select another project to create a note."
              },
              untitled: "Untitled note"
            },
            edit: {
              "short-title": "Edit note",
              title: "Edit note",
              save: "Save",
              "no-editable-fields": {
                title: "No editable fields",
                message: "This note has no editable fields."
              }
            }
          },
          input: {
            cancel: "Cancel"
          },
          confirm: {
            delete: "Delete",
            cancel: "Cancel"
          }
        },
        views: {
          developer: {
            name: "Developer"
          },
          table: {
            name: "Table",
            "hide-fields": "Hide fields",
            "rename-field": "Rename field",
            rename: "Rename"
          },
          board: {
            name: "Board",
            "no-status": "No status",
            fields: {
              status: "Status",
              priority: "Priority",
              none: "None"
            },
            unprioritized: "Unprioritized",
            note: {
              add: "Add note"
            }
          },
          calendar: {
            name: "Calendar",
            "new-note": "New note",
            fields: {
              date: "Date",
              check: "Check",
              none: "None"
            },
            today: "Today",
            weekday: "{{value, datetime}}",
            date: "{{value, datetime}}",
            interval: "{{from, datetime}} \u2013 {{to, datetime}}",
            intervals: {
              month_one: "Month",
              month_other: "Months",
              monthWithCount_one: "{{count}} month",
              monthWithCount_other: "{{count}} months",
              week_one: "Week",
              week_other: "Weeks",
              weekWithCount_one: "{{count}} week",
              weekWithCount_other: "{{count}} weeks",
              day_one: "Day",
              day_other: "Days",
              dayWithCount_one: "{{count}} day",
              dayWithCount_other: "{{count}} days"
            }
          }
        },
        components: {
          "data-grid": {
            column: {
              rename: "Rename field",
              delete: "Delete field",
              hide: "Hide field"
            },
            row: {
              add: "Add note",
              edit: "Edit note",
              delete: "Delete note"
            },
            cell: {
              clear: "Clear value"
            },
            sort: {
              asc: "Sort A \u2192 Z",
              desc: "Sort Z \u2192 A"
            }
          }
        },
        toolbar: {
          new: "New",
          view: {
            add: "Add view"
          },
          projects: {
            none: "No projects"
          }
        },
        errors: {
          missingDataview: {
            title: "Dataview is disabled",
            message: "Enable the Dataview plugin to continue using this project."
          }
        }
      }
    }
  },
  interpolation: {
    escapeValue: false
  }
});
var i18n = (0, import_svelte_i18next.createI18nStore)(i18next_default);

// src/lib/api.ts
var import_dayjs = __toModule(require_dayjs_min());
var import_moment = __toModule(require_moment());
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// src/lib/templates/index.ts
function interpolateTemplate(template, data) {
  return template.replace(/\{\{\s*(.*?)\s*\}\}/g, (_24, name) => {
    const [func7, arg] = name.split(/:(.*)/s);
    const f2 = data[func7];
    return f2 ? f2(arg) : "";
  });
}

// src/lib/data.ts
var DataFieldType;
(function(DataFieldType2) {
  DataFieldType2["String"] = "string";
  DataFieldType2["Number"] = "number";
  DataFieldType2["Boolean"] = "boolean";
  DataFieldType2["Date"] = "date";
  DataFieldType2["Link"] = "link";
  DataFieldType2["List"] = "list";
  DataFieldType2["Unknown"] = "unknown";
})(DataFieldType || (DataFieldType = {}));
var DataSource = class {
  constructor(project) {
    this.project = project;
  }
  readonly() {
    return false;
  }
};
function isBoolean(value) {
  return typeof value === "boolean";
}
function isString(value) {
  return typeof value === "string";
}
function isLink(value) {
  if (value && typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return false;
}
function isNumber(value) {
  return typeof value === "number";
}
function isDate(value) {
  return value instanceof Date;
}
function isOptionalBoolean(value) {
  return typeof value === "boolean" || value === void 0;
}
function isOptionalString(value) {
  return typeof value === "string" || value === void 0;
}
function isOptionalLink(value) {
  if (typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return value === void 0;
}
function isOptionalList(value) {
  return Array.isArray(value) || value === void 0;
}
function isOptionalNumber(value) {
  return typeof value === "number" || value === void 0;
}
function isOptionalDate(value) {
  return value instanceof Date || value === void 0;
}
function isRawLink(value) {
  if (value && Array.isArray(value)) {
    if (value.length === 1) {
      const nextValue = value[0];
      if (nextValue && Array.isArray(nextValue)) {
        return nextValue.length === 1;
      }
    }
  }
  return false;
}

// src/lib/helpers.ts
var import_obsidian2 = __toModule(require("obsidian"));
function notEmpty(value) {
  return value !== null && value !== void 0;
}
function uniquify(name, exists2) {
  if (!exists2(name)) {
    return name;
  }
  let num = 1;
  while (exists2(name + " " + num)) {
    num++;
  }
  return name + " " + num;
}
function nextUniqueFileName(path3, name) {
  return uniquify(name, (name2) => {
    return get_store_value(app).vault.getAbstractFileByPath((0, import_obsidian2.normalizePath)(path3 + "/" + name2 + ".md")) instanceof import_obsidian2.TFile;
  });
}
function nextUniqueProjectName(projects, name) {
  return uniquify(name, (candidate) => {
    return !!projects.find((project) => project.name === candidate);
  });
}
function nextUniqueViewName(views, name) {
  return uniquify(name, (candidate) => {
    return !!views.find((view2) => view2.name === candidate);
  });
}

// src/lib/api.ts
var DataApi = class {
  constructor(app2) {
    this.app = app2;
  }
  updateRecord(fields, record) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(record.id);
      if (file instanceof import_obsidian4.TFile) {
        this.updateFile(file, (data) => doUpdateRecord(data, fields, record));
      }
    });
  }
  renameField(files, from, to) {
    return __async(this, null, function* () {
      for (let file of files) {
        this.updateFile(file, (data) => doRenameField(data, from, to));
      }
    });
  }
  deleteField(files, name) {
    return __async(this, null, function* () {
      for (let file of files) {
        this.updateFile(file, (data) => doDeleteField(data, name));
      }
    });
  }
  createNote(record, templatePath) {
    return __async(this, null, function* () {
      let content = "";
      if (templatePath) {
        const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
        if (templateFile instanceof import_obsidian4.TFile) {
          content = yield this.app.vault.read(templateFile);
          content = interpolateTemplate(content, {
            title: () => {
              var _a;
              return (_a = record.values["name"]) != null ? _a : "";
            },
            date: (format2) => (0, import_moment.default)().format(format2 || "YYYY-MM-DD"),
            time: (format2) => (0, import_moment.default)().format(format2 || "HH:mm")
          });
        }
      }
      const file = yield this.app.vault.create(record.id, content);
      this.updateFile(file, (data) => doUpdateRecord(data, [], record));
      return file;
    });
  }
  updateFile(file, cb) {
    return __async(this, null, function* () {
      const data = yield this.app.vault.read(file);
      yield this.app.vault.modify(file, cb(data));
    });
  }
  deleteRecord(path3) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(path3);
      if (file) {
        this.app.vault.trash(file, true);
      }
    });
  }
};
function doUpdateRecord(data, fields, record) {
  const frontmatter = decodeFrontMatter(data);
  const updated = Object.fromEntries(Object.entries(__spreadValues(__spreadValues({}, frontmatter), record.values)).map((entry) => isDate(entry[1]) ? immer_esm_default(entry, (draft) => {
    draft[1] = (0, import_dayjs.default)(entry[1]).format("YYYY-MM-DD");
  }) : entry).map((entry) => isLink(entry[1]) ? immer_esm_default(entry, (draft) => {
    draft[1] = `[[${draft[1].linkText}]]`;
  }) : entry).filter((entry) => !fields.find((field) => field.name === entry[0] && field.derived)).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  const encoded = encodeFrontMatter(data, updated);
  return encoded.replace(/\"\[\[(.*)\]\]\"/, (_24, p1) => {
    return `[[${p1}]]`;
  });
}
function doDeleteField(data, field) {
  const frontmatter = decodeFrontMatter(data);
  frontmatter[field] = null;
  const updated = Object.fromEntries(Object.entries(frontmatter).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  return encodeFrontMatter(data, updated);
}
function doRenameField(data, from, to) {
  const frontmatter = decodeFrontMatter(data);
  frontmatter[to] = frontmatter[from];
  frontmatter[from] = null;
  const updated = Object.fromEntries(Object.entries(frontmatter).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  return encodeFrontMatter(data, updated);
}
function decodeFrontMatter(data) {
  const delim = "---";
  var startPosition = data.indexOf(delim) + delim.length;
  const isStart = data.slice(0, startPosition).trim() === delim;
  var endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const hasFrontMatter = isStart && endPosition > startPosition;
  const _a = hasFrontMatter ? (0, import_obsidian4.parseYaml)(data.slice(startPosition, endPosition)) : {}, { position } = _a, cache = __objRest(_a, ["position"]);
  return cache;
}
function encodeFrontMatter(data, frontmatter) {
  const delim = "---";
  var startPosition = data.indexOf(delim) + delim.length;
  const isStart = data.slice(0, startPosition).trim() === delim;
  var endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const hasFrontMatter = isStart && endPosition > startPosition;
  if (Object.entries(frontmatter).length) {
    const res = hasFrontMatter ? data.slice(0, startPosition + 1) + (0, import_obsidian4.stringifyYaml)(frontmatter) + data.slice(endPosition) : delim + "\n" + (0, import_obsidian4.stringifyYaml)(frontmatter) + delim + "\n\n" + data;
    return res;
  }
  return hasFrontMatter ? data.slice(0, startPosition - delim.length) + data.slice(endPosition + delim.length + 1) : data;
}
function createProject() {
  return {
    id: v4_default(),
    name: nextUniqueProjectName(get_store_value(settings).projects, get_store_value(i18n).t("modals.project.create.untitled")),
    path: "",
    recursive: false,
    defaultName: "",
    templates: [],
    views: [
      {
        id: v4_default(),
        name: get_store_value(i18n).t("views.table.name"),
        type: "table",
        config: {}
      }
    ]
  };
}
function createDataRecord(name, project, values) {
  return {
    id: (0, import_obsidian4.normalizePath)(project.path + "/" + name + ".md"),
    values: values != null ? values : {}
  };
}

// src/lib/stores/api.ts
var api = derived(app, ($app) => new DataApi($app));

// src/lib/stores/dataframe.ts
var dataSource = writable();
var dataFrame = createDataFrame();
function createDataFrame() {
  const { update: update2, set, subscribe: subscribe2 } = writable({
    fields: [],
    records: []
  });
  return {
    set,
    subscribe: subscribe2,
    addRecord(record) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.records.push(record);
          return draft;
        });
      });
    },
    updateRecord(record) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.records = draft.records.map((r2) => {
            if (r2.id === record.id) {
              return record;
            }
            return r2;
          });
          return draft;
        });
      });
    },
    deleteRecord(id) {
      update2((state) => {
        const res = immer_esm_default(state, (draft) => {
          draft.records = draft.records.filter((record) => record.id !== id);
          return draft;
        });
        return res;
      });
    },
    renameField(from, to) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.fields = draft.fields.map((field) => field.name === from ? __spreadProps(__spreadValues({}, field), {
            name: to
          }) : field);
          return draft;
        });
      });
    },
    deleteField(fieldName) {
      update2((state) => {
        return immer_esm_default(state, (draft) => {
          draft.fields = draft.fields.filter((field) => field.name !== fieldName);
          return draft;
        });
      });
    },
    merge(frame) {
      update2((existing) => {
        const frame2 = immer_esm_default(existing, (draft) => {
          const recordSet = Object.fromEntries(existing.records.map((record) => [record.id, record]));
          frame.records.forEach((record) => {
            recordSet[record.id] = record;
          });
          draft.records = Object.values(recordSet);
          frame.fields.forEach((newField) => {
            const existingField = existing.fields.find((f2) => f2.name === newField.name);
            if (existingField) {
              if (existingField.type !== newField.type) {
                const existingFieldIndex = existing.fields.findIndex((field) => field.name === newField.name);
                draft.fields[existingFieldIndex] = __spreadProps(__spreadValues({}, newField), {
                  type: DataFieldType.String
                });
              }
            } else {
              draft.fields.push(newField);
            }
          });
          return draft;
        });
        return frame2;
      });
    }
  };
}

// src/app/Toolbar.svelte
var import_obsidian19 = __toModule(require("obsidian"));

// src/modals/create-project-modal.ts
var import_obsidian12 = __toModule(require("obsidian"));

// src/modals/components/CreateProject.svelte
var import_moment2 = __toModule(require_moment());

// src/lib/stores/capabilities.ts
var import_obsidian_dataview = __toModule(require_lib());
var capabilities = derived(app, ($app) => {
  return {
    dataview: (0, import_obsidian_dataview.isPluginEnabled)($app)
  };
});

// src/lib/obsidian.ts
var import_obsidian7 = __toModule(require("obsidian"));
var import_os = __toModule(require("os"));
function isTFile(value) {
  return value instanceof import_obsidian7.TFile;
}
function filesFromRecords(app2, records) {
  return records.map((record) => record.id).map((path3) => {
    return app2.vault.getAbstractFileByPath(path3);
  }).filter(isTFile);
}
function getFilesInFolder(folder) {
  const result = [];
  import_obsidian7.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian7.TFile) {
      result.push(file);
    }
  });
  return result;
}
function getNotesInFolder(folder) {
  return getFilesInFolder(folder).filter((file) => file.extension === "md");
}
function getFoldersInFolder(folder) {
  const result = [];
  import_obsidian7.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian7.TFolder) {
      result.push(file);
    }
  });
  return result;
}
function isValidPath(path3) {
  const illegalCharacters = {
    darwin: /[\\\/\|\#\^\[\]]/,
    win32: /[\\\/\|\:\<\>\*\"\?]/
  };
  const expr = illegalCharacters[import_os.default.platform()];
  if (!expr) {
    return true;
  }
  return !expr.test(path3);
}

// src/components/FileListInput/FileListInput.svelte
function add_css14(target) {
  append_styles(target, "svelte-123vkct", "div.svelte-123vkct{display:flex;align-items:center;justify-content:space-between;gap:4px;padding-bottom:4px;width:100%}div.svelte-123vkct:first-child{flex:1}");
}
function get_each_context3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let fileautocomplete;
  let t3;
  let iconbutton;
  let current;
  function change_handler(...args) {
    return ctx[3](ctx[8], ...args);
  }
  fileautocomplete = new FileAutocomplete_default({
    props: {
      value: ctx[6],
      files: getFilesInFolder(ctx[2].vault.getRoot()),
      getLabel: func,
      width: "100%"
    }
  });
  fileautocomplete.$on("change", change_handler);
  function click_handler() {
    return ctx[4](ctx[8]);
  }
  iconbutton = new IconButton_default({ props: { icon: "x" } });
  iconbutton.$on("click", click_handler);
  return {
    c() {
      div = element("div");
      create_component(fileautocomplete.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "class", "svelte-123vkct");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(fileautocomplete, div, null);
      append(div, t3);
      mount_component(iconbutton, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fileautocomplete_changes = {};
      if (dirty & 1)
        fileautocomplete_changes.value = ctx[6];
      if (dirty & 4)
        fileautocomplete_changes.files = getFilesInFolder(ctx[2].vault.getRoot());
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(fileautocomplete);
      destroy_component(iconbutton);
    }
  };
}
function create_default_slot5(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Add template");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment34(ctx) {
  let t3;
  let button;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[5]);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty & 512) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button, detaching);
    }
  };
}
var func = (file) => file.path;
function instance34($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(2, $app = $$value));
  let { paths } = $$props;
  let { onPathsChange } = $$props;
  const change_handler = (i2, { detail: value }) => {
    onPathsChange(immer_esm_default(paths, (draft) => {
      draft[i2] = value;
      return draft;
    }));
  };
  const click_handler = (i2) => {
    onPathsChange(paths.filter((_24, j2) => j2 !== i2));
  };
  const click_handler_1 = () => {
    onPathsChange([...paths, ""]);
  };
  $$self.$$set = ($$props2) => {
    if ("paths" in $$props2)
      $$invalidate(0, paths = $$props2.paths);
    if ("onPathsChange" in $$props2)
      $$invalidate(1, onPathsChange = $$props2.onPathsChange);
  };
  return [paths, onPathsChange, $app, change_handler, click_handler, click_handler_1];
}
var FileListInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, { paths: 0, onPathsChange: 1 }, add_css14);
  }
};
var FileListInput_default = FileListInput;

// src/modals/components/CreateProject.svelte
function add_css15(target) {
  append_styles(target, "svelte-jbo0mz", "small.svelte-jbo0mz{font-size:var(--font-ui-smaller);color:var(--text-accent);font-weight:var(--font-semibold)}.error.svelte-jbo0mz{color:var(--text-error)}");
}
function create_default_slot_11(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[0].name,
      autoFocus: true,
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[12]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0].name;
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.dataview.name"),
      description: (_a = ctx[6].t("modals.project.dataview.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 64)
        settingitem_changes.name = ctx2[6].t("modals.project.dataview.name");
      if (dirty & 64)
        settingitem_changes.description = (_a2 = ctx2[6].t("modals.project.dataview.description")) != null ? _a2 : "";
      if (dirty & 8388609) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: { checked: !!ctx[0].dataview }
  });
  switch_1.$on("check", ctx[13]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = !!ctx2[0].dataview;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[6].t("modals.project.dataview.error.title"),
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 64)
        callout_changes.title = ctx2[6].t("modals.project.dataview.error.title");
      if (dirty & 8388672) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let t_value = ctx[6].t("modals.project.dataview.error.message") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.project.dataview.error.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block(ctx) {
  var _a, _b;
  let settingitem0;
  let t3;
  let settingitem1;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.path.name"),
      description: (_a = ctx[6].t("modals.project.path.description")) != null ? _a : "",
      vertical: true,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.recursive.name"),
      description: (_b = ctx[6].t("modals.project.recursive.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.project.path.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.project.path.description")) != null ? _a2 : "";
      if (dirty & 8388865) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.project.recursive.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.project.recursive.description")) != null ? _b2 : "";
      if (dirty & 8388609) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.query.name"),
      description: (_a = ctx[6].t("modals.project.query.description")) != null ? _a : "",
      vertical: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 64)
        settingitem_changes.name = ctx2[6].t("modals.project.query.name");
      if (dirty & 64)
        settingitem_changes.description = (_a2 = ctx2[6].t("modals.project.query.description")) != null ? _a2 : "";
      if (dirty & 8388609) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getFoldersInFolder(ctx[8].vault.getRoot()),
      value: ctx[0].path,
      getLabel: func2,
      width: "100%"
    }
  });
  fileautocomplete.$on("change", ctx[15]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 256)
        fileautocomplete_changes.files = getFoldersInFolder(ctx2[8].vault.getRoot());
      if (dirty & 1)
        fileautocomplete_changes.value = ctx2[0].path;
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: { checked: ctx[0].recursive }
  });
  switch_1.$on("check", ctx[16]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0].recursive;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  var _a;
  let textarea;
  let current;
  textarea = new TextArea_default({
    props: {
      value: (_a = ctx[0].query) != null ? _a : "",
      rows: 6,
      width: "100%"
    }
  });
  textarea.$on("input", ctx[14]);
  return {
    c() {
      create_component(textarea.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textarea_changes = {};
      if (dirty & 1)
        textarea_changes.value = (_a2 = ctx2[0].query) != null ? _a2 : "";
      textarea.$set(textarea_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textarea, detaching);
    }
  };
}
function create_if_block6(ctx) {
  let small;
  let t_value = ctx[6].t("modals.project.defaultName.invalid") + "";
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(t_value);
      attr(small, "class", "error svelte-jbo0mz");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.project.defaultName.invalid") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_default_slot_5(ctx) {
  var _a;
  let textinput;
  let t0;
  let small;
  let t1;
  let t22;
  let show_if = !isValidPath(ctx[5]);
  let if_block_anchor;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (_a = ctx[0].defaultName) != null ? _a : "",
      width: "100%"
    }
  });
  textinput.$on("input", ctx[17]);
  let if_block = show_if && create_if_block6(ctx);
  return {
    c() {
      create_component(textinput.$$.fragment);
      t0 = space();
      small = element("small");
      t1 = text(ctx[5]);
      t22 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(small, "class", "svelte-jbo0mz");
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, small, anchor);
      append(small, t1);
      insert(target, t22, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = (_a2 = ctx2[0].defaultName) != null ? _a2 : "";
      textinput.$set(textinput_changes);
      if (!current || dirty & 32)
        set_data(t1, ctx2[5]);
      if (dirty & 32)
        show_if = !isValidPath(ctx2[5]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(small);
      if (detaching)
        detach(t22);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_4(ctx) {
  var _a;
  let filelistinput;
  let current;
  filelistinput = new FileListInput_default({
    props: {
      paths: (_a = ctx[0].templates) != null ? _a : [],
      onPathsChange: ctx[18]
    }
  });
  return {
    c() {
      create_component(filelistinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filelistinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const filelistinput_changes = {};
      if (dirty & 1)
        filelistinput_changes.paths = (_a2 = ctx2[0].templates) != null ? _a2 : [];
      if (dirty & 1)
        filelistinput_changes.onPathsChange = ctx2[18];
      filelistinput.$set(filelistinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filelistinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filelistinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filelistinput, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let t1;
  let t22;
  let current_block_type_index;
  let if_block2;
  let t3;
  let settingitem1;
  let t4;
  let settingitem2;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.name.name"),
      description: (_a = ctx[6].t("modals.project.name.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (ctx[0].dataview || ctx[7].dataview) && create_if_block_3(ctx);
  let if_block1 = ctx[0].dataview && !ctx[7].dataview && create_if_block_2(ctx);
  const if_block_creators = [create_if_block_13, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].dataview)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.defaultName.name"),
      description: (_b = ctx[6].t("modals.project.defaultName.description")) != null ? _b : "",
      vertical: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.templates.name"),
      description: (_c = ctx[6].t("modals.project.templates.description")) != null ? _c : "",
      vertical: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t22 = space();
      if_block2.c();
      t3 = space();
      create_component(settingitem1.$$.fragment);
      t4 = space();
      create_component(settingitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t22, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.project.name.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.project.name.description")) != null ? _a2 : "";
      if (dirty & 8388625) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      if (ctx2[0].dataview || ctx2[7].dataview) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 129) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].dataview && !ctx2[7].dataview) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 129) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t22.parentNode, t22);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(t3.parentNode, t3);
      }
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.project.defaultName.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.project.defaultName.description")) != null ? _b2 : "";
      if (dirty & 8388705) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 64)
        settingitem2_changes.name = ctx2[6].t("modals.project.templates.name");
      if (dirty & 64)
        settingitem2_changes.description = (_c2 = ctx2[6].t("modals.project.templates.description")) != null ? _c2 : "";
      if (dirty & 8388609) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t22);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t4);
      destroy_component(settingitem2, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!ctx[4],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[19]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 16)
        button_changes.disabled = !!ctx2[4];
      if (dirty & 8388612) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot6(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 8389105) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 8388637) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment35(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[1],
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 2)
        modallayout_changes.title = ctx2[1];
      if (dirty & 8389117) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func2 = (file) => file.path;
function instance35($$self, $$props, $$invalidate) {
  let projects;
  let defaultName;
  let name;
  let nameError;
  let $i18n;
  let $settings;
  let $capabilities;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(11, $settings = $$value));
  component_subscribe($$self, capabilities, ($$value) => $$invalidate(7, $capabilities = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  var _a;
  let { title } = $$props;
  let { cta } = $$props;
  let { onSave } = $$props;
  let { project } = $$props;
  let originalName = project.name;
  function validateName(name2) {
    if (name2 === originalName) {
      return "";
    }
    if (name2 === "") {
      return $i18n.t("modals.project.create.empty-name-error");
    }
    if (projects.find((project2) => project2.name === name2)) {
      return $i18n.t("modals.project.create.existing-name-error");
    }
    return "";
  }
  const input_handler = ({ detail: name2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { name: name2 }));
  const check_handler = ({ detail: dataview }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { dataview }));
  const input_handler_1 = ({ detail: query }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { query }));
  const change_handler = ({ detail: path3 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { path: path3 }));
  const check_handler_1 = ({ detail: recursive }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { recursive }));
  const input_handler_2 = ({ detail: defaultName2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { defaultName: defaultName2 }));
  const func_14 = (templates) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { templates }));
  const click_handler = () => {
    var _a2, _b;
    onSave(__spreadProps(__spreadValues({}, project), {
      templates: (_b = (_a2 = project.templates) == null ? void 0 : _a2.filter(notEmpty)) != null ? _b : []
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSave" in $$props2)
      $$invalidate(3, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $:
        projects = $settings.projects;
    }
    if ($$self.$$.dirty & 513) {
      $:
        $$invalidate(5, defaultName = interpolateTemplate($$invalidate(9, _a = project.defaultName) !== null && _a !== void 0 ? _a : "", {
          date: (format2) => (0, import_moment2.default)().format(format2 || "YYYY-MM-DD"),
          time: (format2) => (0, import_moment2.default)().format(format2 || "HH:mm")
        }));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(10, { name } = project, name);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    title,
    cta,
    onSave,
    nameError,
    defaultName,
    $i18n,
    $capabilities,
    $app,
    _a,
    name,
    $settings,
    input_handler,
    check_handler,
    input_handler_1,
    change_handler,
    check_handler_1,
    input_handler_2,
    func_14,
    click_handler
  ];
}
var CreateProject = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, { title: 1, cta: 2, onSave: 3, project: 0 }, add_css15);
  }
};
var CreateProject_default = CreateProject;

// src/modals/create-project-modal.ts
var CreateProjectModal = class extends import_obsidian12.Modal {
  constructor(app2, title, cta, onSave, defaults) {
    super(app2);
    this.title = title;
    this.cta = cta;
    this.onSave = onSave;
    this.defaults = defaults;
  }
  onOpen() {
    this.component = new CreateProject_default({
      target: this.contentEl,
      props: {
        title: this.title,
        cta: this.cta,
        project: this.defaults,
        onSave: (project) => {
          this.onSave(project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/add-view-modal.ts
var import_obsidian13 = __toModule(require("obsidian"));

// src/lib/stores/custom-views.ts
var customViews = writable({});
var customViewsV2 = writable({});

// src/builder.ts
var Builder = class {
  constructor() {
  }
  setTitle(title) {
    this.title = title;
    return this;
  }
  setIcon(icon) {
    this.icon = icon;
    return this;
  }
  setNoPadding() {
    this.noPadding = true;
    return this;
  }
  setOnOpen(cb) {
    this.onOpen = cb;
    return this;
  }
};

// src/modals/components/AddView.svelte
function create_default_slot_62(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[3],
      options: ctx[8]
    }
  });
  select.$on("change", ctx[9]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = ctx2[3];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_52(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[2],
      placeholder: (_a = ctx[6].t("modals.view.create.optional")) != null ? _a : "",
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[10]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & 4)
        textinput_changes.value = ctx2[2];
      if (dirty & 64)
        textinput_changes.placeholder = (_a2 = ctx2[6].t("modals.view.create.optional")) != null ? _a2 : "";
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_42(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[0].id,
      options: ctx[7].projects.map(func3)
    }
  });
  select.$on("change", ctx[11]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = ctx2[0].id;
      if (dirty & 128)
        select_changes.options = ctx2[7].projects.map(func3);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let settingitem2;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.view.create.type.name"),
      description: (_a = ctx[6].t("modals.view.create.type.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.view.create.name.name"),
      description: (_b = ctx[6].t("modals.view.create.name.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.note.create.project.name"),
      description: (_c = ctx[6].t("modals.note.create.project.description")) != null ? _c : "",
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      create_component(settingitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.view.create.type.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.view.create.type.description")) != null ? _a2 : "";
      if (dirty & 524296) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.view.create.name.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.view.create.name.description")) != null ? _b2 : "";
      if (dirty & 524372) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 64)
        settingitem2_changes.name = ctx2[6].t("modals.note.create.project.name");
      if (dirty & 64)
        settingitem2_changes.description = (_c2 = ctx2[6].t("modals.note.create.project.description")) != null ? _c2 : "";
      if (dirty & 524417) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem2, detaching);
    }
  };
}
function create_default_slot_22(ctx) {
  let t_value = ctx[6].t("modals.view.create.cta") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.view.create.cta") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_12(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[12]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 524352) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot7(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 524509) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 524399) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment36(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[6].t("modals.view.create.title"),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 64)
        modallayout_changes.title = ctx2[6].t("modals.view.create.title");
      if (dirty & 524543) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func3 = (project) => ({ label: project.name, value: project.id });
function instance36($$self, $$props, $$invalidate) {
  let selectedOption;
  let nameError;
  let $i18n;
  let $customViewsV2;
  let $customViews;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, customViewsV2, ($$value) => $$invalidate(13, $customViewsV2 = $$value));
  component_subscribe($$self, customViews, ($$value) => $$invalidate(14, $customViews = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(7, $settings = $$value));
  let { onSave } = $$props;
  let { project } = $$props;
  let name = "";
  let type = "table";
  let v1 = Object.entries($customViews).map(([id, builder]) => {
    var _a;
    const view2 = new Builder();
    builder(view2);
    return {
      label: (_a = view2.title) !== null && _a !== void 0 ? _a : id,
      value: id
    };
  });
  let v2 = Object.entries($customViewsV2).map(([id, builder]) => {
    const view2 = builder();
    return { label: view2.getDisplayName(), value: id };
  });
  let selectableCustomViews = [...v1, ...v2];
  const options = [
    {
      label: $i18n.t("views.table.name"),
      value: "table"
    },
    {
      label: $i18n.t("views.board.name"),
      value: "board"
    },
    {
      label: $i18n.t("views.calendar.name"),
      value: "calendar"
    },
    ...selectableCustomViews
  ];
  function validateName(name2) {
    if (project.views.find((view2) => view2.name === name2)) {
      return $i18n.t("modals.view.create.existing-name-error");
    }
    return "";
  }
  const change_handler = ({ detail: value }) => {
    $$invalidate(3, type = value);
  };
  const input_handler = ({ detail: value }) => $$invalidate(2, name = value);
  const change_handler_1 = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(0, project = res);
    }
  };
  const click_handler = () => {
    var _a;
    onSave(project.id, {
      id: v4_default(),
      name: name || nextUniqueViewName(project.views, (_a = selectedOption == null ? void 0 : selectedOption.label) != null ? _a : type),
      type,
      config: {}
    });
  };
  $$self.$$set = ($$props2) => {
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(5, selectedOption = options.find((option) => option.value === type));
    }
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    onSave,
    name,
    type,
    nameError,
    selectedOption,
    $i18n,
    $settings,
    options,
    change_handler,
    input_handler,
    change_handler_1,
    click_handler
  ];
}
var AddView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, { onSave: 1, project: 0 });
  }
};
var AddView_default = AddView;

// src/modals/add-view-modal.ts
var AddViewModal = class extends import_obsidian13.Modal {
  constructor(app2, project, onSave) {
    super(app2);
    this.project = project;
    this.onSave = onSave;
  }
  onOpen() {
    this.component = new AddView_default({
      target: this.contentEl,
      props: {
        project: this.project,
        onSave: (projectId, view2) => {
          this.onSave(projectId, view2);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/confirm-dialog.ts
var import_obsidian14 = __toModule(require("obsidian"));

// src/modals/components/ConfirmDialog.svelte
function create_default_slot_53(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t3, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_43(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 258) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_default_slot_33(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_23(ctx) {
  let t_value = ctx[5].t("modals.confirm.cancel") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].t("modals.confirm.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_13(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: ctx[2] === ctx[5].t("modals.confirm.delete") ? "destructive" : "primary",
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[6]);
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[7]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 36)
        button0_changes.variant = ctx2[2] === ctx2[5].t("modals.confirm.delete") ? "destructive" : "primary";
      if (dirty & 260) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 288) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot8(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 258) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 316) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment37(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[0],
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 1)
        modallayout_changes.title = ctx2[0];
      if (dirty & 318) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  let { title } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onConfirm } = $$props;
  let { onCancel } = $$props;
  const click_handler = () => {
    onConfirm();
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onConfirm" in $$props2)
      $$invalidate(3, onConfirm = $$props2.onConfirm);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    title,
    message,
    cta,
    onConfirm,
    onCancel,
    $i18n,
    click_handler,
    click_handler_1
  ];
}
var ConfirmDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      title: 0,
      message: 1,
      cta: 2,
      onConfirm: 3,
      onCancel: 4
    });
  }
};
var ConfirmDialog_default = ConfirmDialog;

// src/modals/confirm-dialog.ts
var ConfirmDialogModal = class extends import_obsidian14.Modal {
  constructor(app2, title, message, cta, onConfirm) {
    super(app2);
    this.title = title;
    this.message = message;
    this.cta = cta;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    this.component = new ConfirmDialog_default({
      target: this.contentEl,
      props: {
        title: this.title,
        message: this.message,
        cta: this.cta,
        onConfirm: () => {
          this.onConfirm();
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/create-note-modal.ts
var import_moment3 = __toModule(require_moment());
var import_obsidian18 = __toModule(require("obsidian"));

// src/modals/components/CreateNote.svelte
var import_obsidian15 = __toModule(require("obsidian"));
function create_default_slot_72(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[0],
      autoFocus: true,
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[7]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0];
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_63(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[1].id,
      options: ctx[6].projects.map(func4)
    }
  });
  select.$on("change", ctx[8]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 2)
        select_changes.value = ctx2[1].id;
      if (dirty & 64)
        select_changes.options = ctx2[6].projects.map(func4);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.templatePath.name"),
      description: (_a = ctx[5].t("modals.note.create.templatePath.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 32)
        settingitem_changes.name = ctx2[5].t("modals.note.create.templatePath.name");
      if (dirty & 32)
        settingitem_changes.description = (_a2 = ctx2[5].t("modals.note.create.templatePath.description")) != null ? _a2 : "";
      if (dirty & 8234) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_54(ctx) {
  var _a;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[3],
      options: ctx[1].templates.map(func_1),
      placeholder: (_a = ctx[5].t("modals.note.create.templatePath.none")) != null ? _a : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[9]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = ctx2[3];
      if (dirty & 2)
        select_changes.options = ctx2[1].templates.map(func_1);
      if (dirty & 32)
        select_changes.placeholder = (_a2 = ctx2[5].t("modals.note.create.templatePath.none")) != null ? _a2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block7(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[5].t("modals.note.create.readonly.title"),
      icon: "alert-triangle",
      variant: "danger",
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 32)
        callout_changes.title = ctx2[5].t("modals.note.create.readonly.title");
      if (dirty & 8226) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_44(ctx) {
  let t_value = ctx[5].t("modals.note.create.readonly.message", { project: ctx[1].name }) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 34 && t_value !== (t_value = ctx2[5].t("modals.note.create.readonly.message", { project: ctx2[1].name }) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_34(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let t22;
  let if_block1_anchor;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.name.name"),
      description: (_a = ctx[5].t("modals.note.create.name.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.project.name"),
      description: (_b = ctx[5].t("modals.note.create.project.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_63] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ((_c = ctx[1].templates) == null ? void 0 : _c.length) && create_if_block_14(ctx);
  let if_block1 = ctx[1].dataview && create_if_block7(ctx);
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t22 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t22, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 32)
        settingitem0_changes.name = ctx2[5].t("modals.note.create.name.name");
      if (dirty & 32)
        settingitem0_changes.description = (_a2 = ctx2[5].t("modals.note.create.name.description")) != null ? _a2 : "";
      if (dirty & 8209) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 32)
        settingitem1_changes.name = ctx2[5].t("modals.note.create.project.name");
      if (dirty & 32)
        settingitem1_changes.description = (_b2 = ctx2[5].t("modals.note.create.project.description")) != null ? _b2 : "";
      if (dirty & 8258) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if ((_c2 = ctx2[1].templates) == null ? void 0 : _c2.length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t22.parentNode, t22);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1].dataview) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t22);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_default_slot_24(ctx) {
  let t_value = ctx[5].t("modals.note.create.create") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].t("modals.note.create.create") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_14(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!ctx[4] || !!ctx[1].dataview,
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[10]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 18)
        button_changes.disabled = !!ctx2[4] || !!ctx2[1].dataview;
      if (dirty & 8224) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot9(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 8315) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 8255) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment38(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[5].t("modals.note.create.title"),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 32)
        modallayout_changes.title = ctx2[5].t("modals.note.create.title");
      if (dirty & 8319) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func4 = (project) => ({ label: project.name, value: project.id });
var func_1 = (path3) => ({ label: path3, value: path3 });
function instance38($$self, $$props, $$invalidate) {
  let nameError;
  let $i18n;
  let $app;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(11, $app = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(6, $settings = $$value));
  let { name } = $$props;
  let { project } = $$props;
  let { onSave } = $$props;
  let templatePath = "";
  function validateName(name2) {
    if (name2 === "") {
      return $i18n.t("modals.note.create.empty-name-error");
    }
    const existingFile = $app.vault.getAbstractFileByPath((0, import_obsidian15.normalizePath)(project.path + "/" + name2 + ".md"));
    if (existingFile instanceof import_obsidian15.TFile) {
      return $i18n.t("modals.note.create.name-taken-error");
    }
    if (!isValidPath(name2)) {
      return $i18n.t("modals.project.defaultName.invalid");
    }
    return "";
  }
  const input_handler = ({ detail: value }) => $$invalidate(0, name = value);
  const change_handler = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(1, project = res);
    }
  };
  const change_handler_1 = ({ detail: value }) => $$invalidate(3, templatePath = value);
  const click_handler = () => {
    onSave(name, templatePath, project);
  };
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("onSave" in $$props2)
      $$invalidate(2, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    name,
    project,
    onSave,
    templatePath,
    nameError,
    $i18n,
    $settings,
    input_handler,
    change_handler,
    change_handler_1,
    click_handler
  ];
}
var CreateNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, { name: 0, project: 1, onSave: 2 });
  }
};
var CreateNote_default = CreateNote;

// src/modals/create-note-modal.ts
var CreateNoteModal = class extends import_obsidian18.Modal {
  constructor(app2, project, onSave) {
    super(app2);
    this.onSave = onSave;
    this.project = project;
  }
  onOpen() {
    var _a;
    this.component = new CreateNote_default({
      target: this.contentEl,
      props: {
        name: this.project.defaultName ? interpolateTemplate((_a = this.project.defaultName) != null ? _a : "", {
          date: (format2) => (0, import_moment3.default)().format(format2 || "YYYY-MM-DD"),
          time: (format2) => (0, import_moment3.default)().format(format2 || "HH:mm")
        }) : nextUniqueFileName(this.project.path, get_store_value(i18n).t("modals.note.create.untitled")),
        project: this.project,
        onSave: (name, templatePath, project) => {
          this.onSave(name, templatePath, project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/app/ViewItemList.svelte
function add_css16(target) {
  append_styles(target, "svelte-1x3xokk", "div.svelte-1x3xokk{display:flex;justify-content:center;gap:var(--size-4-1);min-width:min-content}section.svelte-1x3xokk{flex:1;overflow-x:auto}section.svelte-1x3xokk::-webkit-scrollbar{display:none}");
}
function create_fragment39(ctx) {
  let section;
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      section = element("section");
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1x3xokk");
      attr(section, "class", "svelte-1x3xokk");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ViewItemList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, {}, add_css16);
  }
};
var ViewItemList_default = ViewItemList;

// src/app/ViewItem.svelte
function add_css17(target) {
  append_styles(target, "svelte-eliwod", "div.svelte-eliwod{display:inline-flex;align-items:center;gap:4px;height:1.8rem;padding:0 8px;min-width:min-content;font-size:var(--font-ui-small);border-radius:var(--radius-s);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;border:1px solid transparent}div.svelte-eliwod:hover{background-color:var(--background-modifier-hover)}.active.svelte-eliwod{background-color:var(--background-modifier-hover)}.error.svelte-eliwod{border:1px solid var(--background-modifier-error)}");
}
function create_if_block_22(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({ props: { name: ctx[2] } });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & 4)
        icon_1_changes.name = ctx2[2];
      icon_1.$set(icon_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function create_else_block2(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_if_block_15(ctx) {
  let textinput;
  let updating_ref;
  let updating_value;
  let current;
  function textinput_ref_binding(value) {
    ctx[12](value);
  }
  function textinput_value_binding(value) {
    ctx[13](value);
  }
  let textinput_props = {
    noPadding: true,
    embed: true,
    width: ctx[0].length + "ch"
  };
  if (ctx[4] !== void 0) {
    textinput_props.ref = ctx[4];
  }
  if (ctx[0] !== void 0) {
    textinput_props.value = ctx[0];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "ref", textinput_ref_binding));
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  textinput.$on("keydown", ctx[14]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.width = ctx2[0].length + "ch";
      if (!updating_ref && dirty & 16) {
        updating_ref = true;
        textinput_changes.ref = ctx2[4];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textinput_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block8(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      size: "sm",
      nopadding: true
    }
  });
  iconbutton.$on("click", ctx[15]);
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_fragment40(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_22(ctx);
  const if_block_creators = [create_if_block_15, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = ctx[6] && ctx[1] && create_if_block8(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "svelte-eliwod");
      toggle_class(div, "active", ctx[1]);
      toggle_class(div, "error", ctx[7]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", ctx[16]),
          listen(div, "mouseleave", ctx[17]),
          listen(div, "focus", ctx[18]),
          listen(div, "blur", ctx[19]),
          listen(div, "dblclick", ctx[20]),
          listen(div, "click", ctx[11]),
          action_destroyer(useClickOutside_action = useClickOutside2.call(null, div, ctx[21]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (ctx2[6] && ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 66) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block8(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 8)
        useClickOutside_action.update.call(null, ctx2[21]);
      if (!current || dirty & 2) {
        toggle_class(div, "active", ctx2[1]);
      }
      if (!current || dirty & 128) {
        toggle_class(div, "error", ctx2[7]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let error2;
  let { label } = $$props;
  let { active = false } = $$props;
  let { icon = "" } = $$props;
  let { onValidate } = $$props;
  let fallback = label;
  function rollback() {
    $$invalidate(0, label = fallback);
  }
  let hovering = false;
  let editing = false;
  let inputRef;
  const dispatch = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textinput_ref_binding(value) {
    inputRef = value;
    $$invalidate(4, inputRef);
  }
  function textinput_value_binding(value) {
    label = value;
    $$invalidate(0, label);
  }
  const keydown_handler = (event) => {
    if (event.key === "Enter") {
      $$invalidate(3, editing = false);
      if (!error2) {
        $$invalidate(5, fallback = label);
        dispatch("rename", label);
      } else {
        rollback();
      }
    }
  };
  const click_handler_1 = () => dispatch("delete");
  const mouseenter_handler = () => $$invalidate(6, hovering = true);
  const mouseleave_handler = () => $$invalidate(6, hovering = false);
  const focus_handler = () => $$invalidate(6, hovering = true);
  const blur_handler = () => {
    $$invalidate(6, hovering = false);
    $$invalidate(3, editing = false);
    rollback();
  };
  const dblclick_handler = () => $$invalidate(3, editing = true);
  const useClickOutside_function = () => {
    $$invalidate(3, editing = false);
    rollback();
  };
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("onValidate" in $$props2)
      $$invalidate(10, onValidate = $$props2.onValidate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 24) {
      $:
        if (inputRef && editing) {
          inputRef.focus();
          inputRef.select();
        }
    }
    if ($$self.$$.dirty & 1025) {
      $:
        $$invalidate(7, error2 = !onValidate(label));
    }
  };
  return [
    label,
    active,
    icon,
    editing,
    inputRef,
    fallback,
    hovering,
    error2,
    rollback,
    dispatch,
    onValidate,
    click_handler,
    textinput_ref_binding,
    textinput_value_binding,
    keydown_handler,
    click_handler_1,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler,
    dblclick_handler,
    useClickOutside_function
  ];
}
var ViewItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      label: 0,
      active: 1,
      icon: 2,
      onValidate: 10
    }, add_css17);
  }
};
var ViewItem_default = ViewItem;

// src/app/Toolbar.svelte
function add_css18(target) {
  append_styles(target, "svelte-11yom9n", "div.svelte-11yom9n{background-color:var(--tab-background-active);display:flex;align-items:center;padding:var(--size-4-2);gap:8px;border-bottom:1px solid var(--background-modifier-border);justify-content:space-between}span.svelte-11yom9n{display:flex;align-items:center;gap:4px}");
}
function get_each_context4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_if_block_16(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: { icon: "more-vertical", size: "sm" }
  });
  iconbutton.$on("click", ctx[13]);
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_if_block9(ctx) {
  let viewitemlist;
  let current;
  viewitemlist = new ViewItemList_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewitemlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewitemlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewitemlist_changes = {};
      if (dirty & 16777722) {
        viewitemlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewitemlist.$set(viewitemlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitemlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitemlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewitemlist, detaching);
    }
  };
}
function create_each_block4(ctx) {
  let viewitem;
  let current;
  function func_14(...args) {
    return ctx[14](ctx[21], ...args);
  }
  function click_handler_1() {
    return ctx[15](ctx[21]);
  }
  function rename_handler(...args) {
    return ctx[16](ctx[21], ...args);
  }
  function delete_handler() {
    return ctx[17](ctx[21]);
  }
  viewitem = new ViewItem_default({
    props: {
      active: ctx[3] === ctx[21].id,
      label: ctx[21].name,
      icon: ctx[10](ctx[21].type),
      onValidate: func_14
    }
  });
  viewitem.$on("click", click_handler_1);
  viewitem.$on("rename", rename_handler);
  viewitem.$on("delete", delete_handler);
  return {
    c() {
      create_component(viewitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const viewitem_changes = {};
      if (dirty & 72)
        viewitem_changes.active = ctx[3] === ctx[21].id;
      if (dirty & 64)
        viewitem_changes.label = ctx[21].name;
      if (dirty & 64)
        viewitem_changes.icon = ctx[10](ctx[21].type);
      if (dirty & 96)
        viewitem_changes.onValidate = func_14;
      viewitem.$set(viewitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewitem, detaching);
    }
  };
}
function create_key_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1530) {
        each_value = ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_15(ctx) {
  let previous_key = ctx[6];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_default_slot10(ctx) {
  let t_value = ctx[7].t("toolbar.new") + "";
  let t3;
  let icon;
  let current;
  icon = new Icon_default({
    props: { accent: true, name: "chevron-down" }
  });
  return {
    c() {
      t3 = text(t_value);
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 128) && t_value !== (t_value = ctx2[7].t("toolbar.new") + ""))
        set_data(t3, t_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t3);
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment41(ctx) {
  var _a, _b;
  let div;
  let span;
  let select;
  let t0;
  let t1;
  let t22;
  let button;
  let current;
  select = new Select_default({
    props: {
      value: (_a = ctx[1]) != null ? _a : "",
      options: ctx[0].map(func5),
      placeholder: (_b = ctx[7].t("toolbar.projects.none")) != null ? _b : ""
    }
  });
  select.$on("change", ctx[12]);
  let if_block0 = ctx[0].length && create_if_block_16(ctx);
  let if_block1 = ctx[5] && create_if_block9(ctx);
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[18]);
  return {
    c() {
      div = element("div");
      span = element("span");
      create_component(select.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t22 = space();
      create_component(button.$$.fragment);
      attr(span, "class", "svelte-11yom9n");
      attr(div, "class", "svelte-11yom9n");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      mount_component(select, span, null);
      append(span, t0);
      if (if_block0)
        if_block0.m(span, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t22);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      const select_changes = {};
      if (dirty & 2)
        select_changes.value = (_a2 = ctx2[1]) != null ? _a2 : "";
      if (dirty & 1)
        select_changes.options = ctx2[0].map(func5);
      if (dirty & 128)
        select_changes.placeholder = (_b2 = ctx2[7].t("toolbar.projects.none")) != null ? _b2 : "";
      select.$set(select_changes);
      if (ctx2[0].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_16(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t22);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const button_changes = {};
      if (dirty & 16777344) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(button);
    }
  };
}
var func5 = (project) => ({ label: project.name, value: project.id });
function instance41($$self, $$props, $$invalidate) {
  let projectDefinition;
  let views;
  let $customViews;
  let $customViewsV2;
  let $i18n;
  let $app;
  let $api;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(19, $customViews = $$value));
  component_subscribe($$self, customViewsV2, ($$value) => $$invalidate(20, $customViewsV2 = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(7, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  component_subscribe($$self, api, ($$value) => $$invalidate(9, $api = $$value));
  var _a;
  let { projects } = $$props;
  let { project } = $$props;
  let { onProjectChange } = $$props;
  let { view: view2 } = $$props;
  let { onViewChange } = $$props;
  function iconFromViewType(type) {
    var _a2;
    switch (type) {
      case "table":
        return "table";
      case "board":
        return "columns";
      case "calendar":
        return "calendar";
      case "developer":
        return "wrench";
      default:
        const createView = $customViewsV2[type];
        if (createView) {
          const view3 = createView();
          return view3.getIcon();
        }
        const builder = $customViews[type];
        if (builder) {
          const view3 = new Builder();
          builder(view3);
          return (_a2 = view3.icon) !== null && _a2 !== void 0 ? _a2 : "";
        }
        return "";
    }
  }
  const change_handler = ({ detail: value }) => onProjectChange(value);
  const click_handler = (event) => {
    const menu = new import_obsidian19.Menu();
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.edit.short-title")).setIcon("edit").onClick(() => {
        if (projectDefinition) {
          new CreateProjectModal($app, $i18n.t("modals.project.edit.title"), $i18n.t("modals.project.edit.cta"), settings.updateProject, projectDefinition).open();
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.delete.short-title")).setIcon("trash").onClick(() => {
        new ConfirmDialogModal($app, $i18n.t("modals.project.delete.title"), $i18n.t("modals.project.delete.message"), $i18n.t("modals.project.delete.cta"), () => {
          if (project) {
            settings.deleteProject(project);
          }
        }).open();
      });
    });
    menu.showAtMouseEvent(event);
  };
  const func_14 = (v2, name) => {
    if (name === v2.name) {
      return true;
    }
    return name !== "" && !(projectDefinition == null ? void 0 : projectDefinition.views.find((view3) => view3.name === name));
  };
  const click_handler_1 = (v2) => onViewChange(v2.id);
  const rename_handler = (v2, { detail: name }) => {
    if (project) {
      settings.renameView(project, v2.id, name);
    }
  };
  const delete_handler = (v2) => {
    new ConfirmDialogModal($app, $i18n.t("modals.view.delete.title"), $i18n.t("modals.view.delete.message"), $i18n.t("modals.view.delete.cta"), () => {
      if (project) {
        settings.deleteView(project, v2.id);
      }
    }).open();
  };
  const click_handler_2 = (event) => {
    const menu = new import_obsidian19.Menu();
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.create.short-title")).setIcon("folder").onClick(() => {
        new CreateProjectModal($app, $i18n.t("modals.project.create.title"), $i18n.t("modals.project.create.cta"), settings.addProject, createProject()).open();
      });
    });
    if (projectDefinition) {
      menu.addItem((item) => {
        item.setTitle($i18n.t("modals.view.create.short-title")).setIcon("table").onClick(() => {
          if (projectDefinition) {
            new AddViewModal($app, projectDefinition, (projectId, view3) => {
              settings.addView(projectId, view3);
            }).open();
          }
        });
      });
      menu.addItem((item) => {
        item.setTitle($i18n.t("modals.note.create.short-title")).setIcon("file").onClick(() => {
          if (projectDefinition) {
            new CreateNoteModal($app, projectDefinition, (name, templatePath, project2) => {
              $api.createNote(createDataRecord(name, project2), templatePath);
            }).open();
          }
        });
      });
    }
    menu.showAtMouseEvent(event);
  };
  $$self.$$set = ($$props2) => {
    if ("projects" in $$props2)
      $$invalidate(0, projects = $$props2.projects);
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("onProjectChange" in $$props2)
      $$invalidate(2, onProjectChange = $$props2.onProjectChange);
    if ("view" in $$props2)
      $$invalidate(3, view2 = $$props2.view);
    if ("onViewChange" in $$props2)
      $$invalidate(4, onViewChange = $$props2.onViewChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        $$invalidate(5, projectDefinition = projects.find((w2) => w2.id === project));
    }
    if ($$self.$$.dirty & 2080) {
      $:
        $$invalidate(6, views = $$invalidate(11, _a = projectDefinition === null || projectDefinition === void 0 ? void 0 : projectDefinition.views) !== null && _a !== void 0 ? _a : []);
    }
  };
  return [
    projects,
    project,
    onProjectChange,
    view2,
    onViewChange,
    projectDefinition,
    views,
    $i18n,
    $app,
    $api,
    iconFromViewType,
    _a,
    change_handler,
    click_handler,
    func_14,
    click_handler_1,
    rename_handler,
    delete_handler,
    click_handler_2
  ];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      projects: 0,
      project: 1,
      onProjectChange: 2,
      view: 3,
      onViewChange: 4
    }, add_css18);
  }
};
var Toolbar_default = Toolbar;

// src/lib/datasources/dataview/dataview.ts
var import_obsidian_dataview2 = __toModule(require_lib());

// src/lib/datasources/dataview/dataview-helpers.ts
var import_dayjs2 = __toModule(require_dayjs_min());
var import_obsidian21 = __toModule(require("obsidian"));
function standardizeValues(app2, values) {
  const res = {};
  Object.keys(values).forEach((field) => {
    var _a, _b;
    const value = values[field];
    if (!value) {
      return;
    }
    if (typeof value === "object") {
      if ("path" in value && "display" in value) {
        const file = app2.vault.getAbstractFileByPath(value.path);
        if (file instanceof import_obsidian21.TFile) {
          const linkText = app2.metadataCache.fileToLinktext(file, "", true);
          res[field] = {
            displayName: (_a = value.display) != null ? _a : linkText,
            fullPath: value.path,
            linkText,
            sourcePath: ""
          };
        } else {
          res[field] = {
            displayName: (_b = value.display) != null ? _b : value.path,
            fullPath: value.path,
            linkText: value.path,
            sourcePath: ""
          };
        }
      }
      if ("ts" in value) {
        res[field] = (0, import_dayjs2.default)(value.ts).format("YYYY-MM-DD");
      }
    } else {
      res[field] = value;
    }
  });
  return res;
}

// src/lib/datasources/helpers.ts
var import_dayjs3 = __toModule(require_dayjs_min());
function parseRecords(records, fields) {
  for (let field of fields) {
    for (let record of records) {
      const value = record.values[field.name];
      switch (field.type) {
        case DataFieldType.Date:
          if (typeof value === "string") {
            record.values[field.name] = (0, import_dayjs3.default)(value).toDate();
          }
          break;
        case DataFieldType.List:
          if (typeof value === "string") {
            record.values[field.name] = [value];
          }
          break;
        case DataFieldType.Number:
          if (typeof value === "string") {
            record.values[field.name] = parseFloat(value);
          }
          break;
        case DataFieldType.Boolean:
          if (typeof value === "string") {
            record.values[field.name] = stringToBoolean(value);
          }
          break;
        case DataFieldType.String:
          if (typeof value !== "object") {
            record.values[field.name] = value == null ? void 0 : value.toLocaleString();
          }
          break;
      }
    }
  }
  return records;
}
function detectFields(records) {
  const valuesByField = {};
  records.forEach((record) => {
    Object.entries(record.values).forEach(([field, value]) => {
      var _a;
      valuesByField[field] = [...(_a = valuesByField[field]) != null ? _a : [], value];
    });
  });
  return Object.entries(valuesByField).map(([field, values]) => {
    return {
      name: field,
      type: typeFromValues(values),
      identifier: false,
      derived: false
    };
  });
}
function typeFromValues(values) {
  const types = values.map((value) => detectCellType(value));
  const result = {};
  for (let type of types) {
    if (!result[type]) {
      result[type] = 0;
    }
    result[type]++;
  }
  const detectedTypes = Object.keys(result).filter((type) => type !== DataFieldType.Unknown);
  if (detectedTypes.length === 1) {
    return detectedTypes[0];
  } else if (detectedTypes.length > 1) {
    return DataFieldType.String;
  } else {
    return DataFieldType.Unknown;
  }
}
function detectCellType(value) {
  if (typeof value === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
      return DataFieldType.Date;
    }
    return DataFieldType.String;
  } else if (typeof value === "number") {
    return DataFieldType.Number;
  } else if (typeof value === "boolean") {
    return DataFieldType.Boolean;
  }
  if (isLink2(value)) {
    return DataFieldType.Link;
  } else if (Array.isArray(value)) {
    return DataFieldType.List;
  }
  return DataFieldType.Unknown;
}
function isLink2(value) {
  if (value && typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return false;
}
function stringToBoolean(stringValue) {
  var _a;
  switch ((_a = stringValue == null ? void 0 : stringValue.toLowerCase()) == null ? void 0 : _a.trim()) {
    case "true":
    case "yes":
    case "1":
      return true;
    case "false":
    case "no":
    case "0":
    case null:
    case void 0:
      return false;
    default:
      return !!stringValue;
  }
}

// src/lib/datasources/dataview/dataview.ts
var UnsupportedCapability = class extends Error {
  constructor(message) {
    super(message);
    this.name = get_store_value(i18n).t("errors.missingDataview.title");
  }
};
var DataviewDataSource = class extends DataSource {
  constructor(app2, project) {
    super(project);
    this.app = app2;
  }
  queryOne() {
    return __async(this, null, function* () {
      return this.queryAll();
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      var _a;
      const api2 = this.getDataviewAPI();
      const result = yield api2 == null ? void 0 : api2.query((_a = this.project.query) != null ? _a : "", void 0, {
        forceId: true
      });
      if (!(result == null ? void 0 : result.successful) || result.value.type !== "table") {
        throw new Error("dataview query failed");
      }
      const rows = parseTableResult(result.value);
      const standardizedRecords = this.standardizeRecords(rows);
      const fields = detectSchema(standardizedRecords);
      const records = parseRecords(standardizedRecords, fields);
      return { fields, records };
    });
  }
  includes(_24) {
    return true;
  }
  readonly() {
    return true;
  }
  getDataviewAPI() {
    if ((0, import_obsidian_dataview2.isPluginEnabled)(this.app)) {
      return (0, import_obsidian_dataview2.getAPI)(this.app);
    } else {
      throw new UnsupportedCapability(get_store_value(i18n).t("errors.missingDataview.message"));
    }
  }
  standardizeRecords(rows) {
    const records = [];
    rows.forEach((row) => {
      const values = standardizeValues(this.app, row);
      const id = values["File"];
      if (id && isLink2(id) && id.fullPath) {
        records.push({ id: id.fullPath, values });
      }
    });
    return records;
  }
};
function parseTableResult(value) {
  const headers = value.headers;
  const rows = [];
  value.values.forEach((row) => {
    const values = {};
    headers.forEach((header, index) => {
      const value2 = row[index];
      values[header] = value2;
    });
    rows.push(values);
  });
  return rows;
}
function detectSchema(records) {
  return detectFields(records).map((field) => __spreadProps(__spreadValues({}, field), { derived: true })).map((field) => field.name === "File" ? __spreadProps(__spreadValues({}, field), { identifier: true }) : field);
}

// src/lib/datasources/frontmatter/frontmatter-helpers.ts
function standardizeRecord(id, values) {
  const res = {};
  Object.keys(values).forEach((field) => {
    const value = values[field];
    if (isRawLink(value)) {
      res[field] = parseRawLink(value, "");
    } else {
      res[field] = value;
    }
  });
  return {
    id,
    values: res
  };
}
function parseRawLink(rawLink, sourcePath) {
  var _a;
  if (rawLink[0]) {
    const text2 = rawLink[0][0];
    if (text2) {
      const split = text2.split("|");
      const linkText = (_a = split[0]) != null ? _a : "";
      const link = {
        linkText,
        sourcePath
      };
      if (split[1]) {
        link.displayName = split[1];
      }
      return link;
    }
  }
  return void 0;
}

// src/lib/datasources/frontmatter/frontmatter.ts
var FrontMatterDataSource = class extends DataSource {
  constructor(app2, project) {
    super(project);
    this.app = app2;
  }
  queryOne(file, fields) {
    return __async(this, null, function* () {
      return this.queryFiles([file], fields);
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      const files = this.app.vault.getMarkdownFiles().filter((file) => this.includes(file.path));
      return this.queryFiles(files);
    });
  }
  queryFiles(files, predefinedFields) {
    return __async(this, null, function* () {
      const standardizedRecords = standardizeRecords(files, this.app.metadataCache);
      let fields = detectSchema2(standardizedRecords);
      for (let predefinedField of predefinedFields != null ? predefinedFields : []) {
        const currentFieldIdx = fields.findIndex((field) => field.name === predefinedField.name);
        if (currentFieldIdx >= 0) {
          if (fields[currentFieldIdx]) {
            fields[currentFieldIdx].type = predefinedField.type;
          }
        }
      }
      const records = parseRecords(standardizedRecords, fields);
      return { fields, records };
    });
  }
  includes(path3) {
    const trimmedPath = this.project.path.startsWith("/") ? this.project.path.slice(1) : this.project.path;
    if (!path3.startsWith(trimmedPath)) {
      return false;
    }
    if (!this.project.recursive) {
      const pathElements = path3.split("/").slice(0, -1);
      const projectPathElements = trimmedPath.split("/").filter((el) => el);
      return pathElements.join("/") === projectPathElements.join("/");
    }
    return true;
  }
};
function standardizeRecords(files, metadataCache) {
  var _a;
  const records = [];
  for (let file of files) {
    const cache = metadataCache.getFileCache(file);
    if (cache) {
      const _b = (_a = cache.frontmatter) != null ? _a : {}, { position } = _b, values = __objRest(_b, ["position"]);
      const filteredValues = Object.fromEntries(Object.entries(values).filter(([_24, value]) => notEmpty(value)));
      filteredValues["path"] = file.path;
      filteredValues["name"] = file.basename;
      records.push(standardizeRecord(file.path, filteredValues));
    }
  }
  return records;
}
function detectSchema2(records) {
  return detectFields(records).map((field) => field.name === "name" || field.name === "path" ? __spreadProps(__spreadValues({}, field), { derived: true }) : field).map((field) => field.name === "path" ? __spreadProps(__spreadValues({}, field), { identifier: true }) : field);
}

// src/views/Board/BoardColumn.svelte
var import_path = __toModule(require("path"));

// src/views/Board/Card.svelte
function add_css19(target) {
  append_styles(target, "svelte-1lmhy7z", "div.svelte-1lmhy7z{background-color:var(--background-primary);border-radius:var(--radius-s);border:1px solid var(--background-modifier-border);padding:var(--size-4-2)}div.svelte-1lmhy7z:hover{border:1px solid var(--background-modifier-border-hover)}");
}
function create_fragment42(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1lmhy7z");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots, click_handler];
}
var Card2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, {}, add_css19);
  }
};
var Card_default2 = Card2;

// src/views/Board/CardList.svelte
function add_css20(target) {
  append_styles(target, "svelte-1l2cceo", "div.svelte-1l2cceo{display:flex;flex-direction:column;gap:var(--size-4-2)}");
}
function create_fragment43(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1l2cceo");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CardList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, {}, add_css20);
  }
};
var CardList_default = CardList;

// src/views/Board/BoardColumn.svelte
function add_css21(target) {
  append_styles(target, "svelte-4s9cev", ".column.svelte-4s9cev{min-width:350px;border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);background-color:var(--background-secondary);display:flex;flex-direction:column}.column-section.svelte-4s9cev{padding:var(--size-4-2);display:flex;flex-direction:column}.unprio.svelte-4s9cev{border-top:1px solid var(--background-modifier-border)}p.svelte-4s9cev{font-weight:500;margin:0;margin-bottom:4px;color:var(--text-faint);font-size:var(--font-smaller)}");
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function get_each_context5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function create_default_slot_102(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block3(ctx) {
  let div;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_73] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(cardlist.$$.fragment);
      attr(div, "class", "column-section svelte-4s9cev");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardlist_changes = {};
      if (dirty & 134218002) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_if_block_17(ctx) {
  let t3;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[7].length && create_if_block_32(ctx);
  let if_block1 = ctx[6].length && create_if_block_23(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_23(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_default_slot_92(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_82(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler_2(...args) {
    return ctx[15](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_92] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler_2);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 2)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217730) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_2(ctx) {
  let card;
  let current;
  function click_handler_2() {
    return ctx[16](ctx[20]);
  }
  card = new Card_default2({
    props: {
      $$slots: { default: [create_default_slot_82] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler_2);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218002) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_73(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1298) {
        each_value_2 = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(cardlist.$$.fragment);
      attr(div, "class", "column-section svelte-4s9cev");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardlist_changes = {};
      if (dirty & 134218128) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_default_slot_64(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_55(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler(...args) {
    return ctx[11](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_64] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 128)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217856) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_1(ctx) {
  let card;
  let current;
  function click_handler() {
    return ctx[12](ctx[20]);
  }
  card = new Card_default2({
    props: {
      $$slots: { default: [create_default_slot_55] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218128) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_45(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[7];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1424) {
        each_value_1 = ctx2[7];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_23(ctx) {
  let div;
  let p2;
  let t0_value = ctx[9].t("views.board.unprioritized") + "";
  let t0;
  let t1;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      create_component(cardlist.$$.fragment);
      attr(p2, "class", "svelte-4s9cev");
      attr(div, "class", "column-section unprio svelte-4s9cev");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(p2, t0);
      append(div, t1);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 512) && t0_value !== (t0_value = ctx2[9].t("views.board.unprioritized") + ""))
        set_data(t0, t0_value);
      const cardlist_changes = {};
      if (dirty & 134218064) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_default_slot_35(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_25(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler_1(...args) {
    return ctx[13](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler_1);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 64)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217792) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block5(ctx) {
  let card;
  let current;
  function click_handler_1() {
    return ctx[14](ctx[20]);
  }
  card = new Card_default2({
    props: {
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler_1);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218064) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_16(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block5(get_each_context5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1360) {
        each_value = ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block10(ctx) {
  let div;
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[17]);
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "column-section svelte-4s9cev");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 134218240) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button);
    }
  };
}
function create_default_slot11(ctx) {
  let t_value = ctx[9].t("views.board.note.add") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[9].t("views.board.note.add") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment44(ctx) {
  let div1;
  let div0;
  let typography;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot_102] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_17, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !ctx[3] && create_if_block10(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(typography.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "column-section svelte-4s9cev");
      attr(div1, "class", "column svelte-4s9cev");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(typography, div0, null);
      append(div1, t0);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & 134217729) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div1, t1);
      }
      if (!ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block10(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(typography);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let prioritized;
  let unprioritized;
  let $app;
  let $i18n;
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  let { name } = $$props;
  let { records } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordAdd } = $$props;
  function getPrioritizedRecords(records2) {
    return records2.filter((record) => {
      return groupByPriority && isNumber(record.values[groupByPriority]);
    });
  }
  function getUnprioritizedRecords(records2) {
    return records2.filter((record) => {
      return groupByPriority && !isNumber(record.values[groupByPriority]);
    });
  }
  function getDisplayName(record) {
    const basename = import_path.default.basename(record.id);
    return basename.slice(0, basename.lastIndexOf("."));
  }
  const open_handler = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler = (record) => onRecordClick(record);
  const open_handler_1 = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler_1 = (record) => onRecordClick(record);
  const open_handler_2 = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler_2 = (record) => onRecordClick(record);
  const click_handler_3 = () => {
    onRecordAdd();
  };
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("records" in $$props2)
      $$invalidate(1, records = $$props2.records);
    if ("groupByPriority" in $$props2)
      $$invalidate(2, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("onRecordClick" in $$props2)
      $$invalidate(4, onRecordClick = $$props2.onRecordClick);
    if ("onRecordAdd" in $$props2)
      $$invalidate(5, onRecordAdd = $$props2.onRecordAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(7, prioritized = getPrioritizedRecords(records));
    }
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(6, unprioritized = getUnprioritizedRecords(records));
    }
  };
  return [
    name,
    records,
    groupByPriority,
    readonly,
    onRecordClick,
    onRecordAdd,
    unprioritized,
    prioritized,
    $app,
    $i18n,
    getDisplayName,
    open_handler,
    click_handler,
    open_handler_1,
    click_handler_1,
    open_handler_2,
    click_handler_2,
    click_handler_3
  ];
}
var BoardColumn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, {
      name: 0,
      records: 1,
      groupByPriority: 2,
      readonly: 3,
      onRecordClick: 4,
      onRecordAdd: 5
    }, add_css21);
  }
};
var BoardColumn_default = BoardColumn;

// src/views/Board/Board.svelte
function add_css22(target) {
  append_styles(target, "svelte-khd6k2", "div.svelte-khd6k2{display:flex;align-items:flex-start;gap:8px;padding:8px}");
}
function get_each_context6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block6(key_1, ctx) {
  let first;
  let boardcolumn;
  let current;
  function func7() {
    return ctx[5](ctx[6]);
  }
  boardcolumn = new BoardColumn_default({
    props: {
      readonly: ctx[2],
      name: ctx[6].name,
      records: ctx[6].records,
      groupByPriority: ctx[1],
      onRecordClick: ctx[3],
      onRecordAdd: func7
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(boardcolumn.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(boardcolumn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const boardcolumn_changes = {};
      if (dirty & 4)
        boardcolumn_changes.readonly = ctx[2];
      if (dirty & 1)
        boardcolumn_changes.name = ctx[6].name;
      if (dirty & 1)
        boardcolumn_changes.records = ctx[6].records;
      if (dirty & 2)
        boardcolumn_changes.groupByPriority = ctx[1];
      if (dirty & 8)
        boardcolumn_changes.onRecordClick = ctx[3];
      if (dirty & 17)
        boardcolumn_changes.onRecordAdd = func7;
      boardcolumn.$set(boardcolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(boardcolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(boardcolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(boardcolumn, detaching);
    }
  };
}
function create_fragment45(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[6].name;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block6(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "svelte-khd6k2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 31) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block6, null, get_each_context6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordAdd } = $$props;
  const func7 = (column) => onRecordAdd(column.name);
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("groupByPriority" in $$props2)
      $$invalidate(1, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("onRecordClick" in $$props2)
      $$invalidate(3, onRecordClick = $$props2.onRecordClick);
    if ("onRecordAdd" in $$props2)
      $$invalidate(4, onRecordAdd = $$props2.onRecordAdd);
  };
  return [columns, groupByPriority, readonly, onRecordClick, onRecordAdd, func7];
}
var Board = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      columns: 0,
      groupByPriority: 1,
      readonly: 2,
      onRecordClick: 3,
      onRecordAdd: 4
    }, add_css22);
  }
};
var Board_default = Board;

// src/views/helpers.ts
function fieldToSelectableValue(field) {
  return {
    label: field.name,
    value: field.name
  };
}

// src/modals/edit-note-modal.ts
var import_obsidian25 = __toModule(require("obsidian"));

// src/modals/input-dialog.ts
var import_obsidian23 = __toModule(require("obsidian"));

// src/modals/components/InputDialog.svelte
function add_css23(target) {
  append_styles(target, "svelte-unwbto", "input.svelte-unwbto{width:100%}");
}
function create_default_slot_46(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "svelte-unwbto");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[7](input);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[8]),
          listen(input, "focus", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_36(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_26(ctx) {
  let t_value = ctx[6].t("modals.input.cancel") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.input.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_17(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_36] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[10]);
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[11]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 4100) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4160) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot12(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_46] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 4129) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 4189) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment46(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[1],
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 2)
        modallayout_changes.title = ctx2[1];
      if (dirty & 4221) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  let { value } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let ref;
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const focus_handler = () => ref.select();
  const click_handler = () => {
    onSubmit(value);
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSubmit" in $$props2)
      $$invalidate(3, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    value,
    message,
    cta,
    onSubmit,
    onCancel,
    ref,
    $i18n,
    input_binding,
    input_input_handler,
    focus_handler,
    click_handler,
    click_handler_1
  ];
}
var InputDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      value: 0,
      message: 1,
      cta: 2,
      onSubmit: 3,
      onCancel: 4
    }, add_css23);
  }
};
var InputDialog_default = InputDialog;

// src/modals/input-dialog.ts
var InputDialogModal = class extends import_obsidian23.Modal {
  constructor(app2, message, cta, onSubmit, value) {
    super(app2);
    this.message = message;
    this.cta = cta;
    this.onSubmit = onSubmit;
    this.value = value;
  }
  onOpen() {
    var _a;
    this.component = new InputDialog_default({
      target: this.contentEl,
      props: {
        message: this.message,
        cta: this.cta,
        value: (_a = this.value) != null ? _a : "",
        onSubmit: (value) => {
          this.onSubmit(value);
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/components/TagList/TagList.svelte
function add_css24(target) {
  append_styles(target, "svelte-u0ab2z", "div.svelte-u0ab2z{display:flex;align-items:center;gap:4px;overflow:hidden;padding:4px}.edit.svelte-u0ab2z{flex-wrap:wrap}");
}
function get_each_context_12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function get_each_context7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block4(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_12(get_each_context_12(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value_1 = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_12(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block11(ctx) {
  let t3;
  let iconbutton;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block7(get_each_context7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  iconbutton = new IconButton_default({ props: { icon: "plus", nopadding: true } });
  iconbutton.$on("click", ctx[5]);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_18(ctx) {
  let t_value = ctx[6] + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[6] + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_12(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & 2049) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_default_slot13(ctx) {
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let iconbutton;
  let current;
  function click_handler() {
    return ctx[4](ctx[8]);
  }
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      size: "xs",
      nopadding: true
    }
  });
  iconbutton.$on("click", click_handler);
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[6] + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block7(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & 2053) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block11, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "svelte-u0ab2z");
      toggle_class(div, "edit", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 2) {
        toggle_class(div, "edit", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(3, $app = $$value));
  let { values } = $$props;
  let { edit } = $$props;
  let { onChange = () => {
  } } = $$props;
  const click_handler = (i2) => {
    onChange(values.filter((_24, j2) => i2 !== j2));
  };
  const click_handler_1 = () => {
    new InputDialogModal($app, "Add list item", "Add", (value) => {
      onChange([...values, value]);
    }).open();
  };
  $$self.$$set = ($$props2) => {
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
  };
  return [values, edit, onChange, $app, click_handler, click_handler_1];
}
var TagList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, { values: 0, edit: 1, onChange: 2 }, add_css24);
  }
};
var TagList_default = TagList;

// src/components/FieldControl/FieldControl.svelte
function create_if_block_5(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: isLink(ctx[1]) ? ctx[1].linkText : ""
    }
  });
  textinput.$on("input", ctx[8]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 2)
        textinput_changes.value = isLink(ctx2[1]) ? ctx2[1].linkText : "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      edit: true,
      values: (_a = ctx[1]) != null ? _a : [],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 2)
        taglist_changes.values = (_a2 = ctx2[1]) != null ? _a2 : [];
      if (dirty & 4)
        taglist_changes.onChange = ctx2[2];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_if_block_33(ctx) {
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: isDate(ctx[1]) ? ctx[1] : null
    }
  });
  dateinput.$on("change", ctx[7]);
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dateinput_changes = {};
      if (dirty & 2)
        dateinput_changes.value = isDate(ctx2[1]) ? ctx2[1] : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_if_block_24(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      value: isNumber(ctx[1]) ? ctx[1] : null
    }
  });
  numberinput.$on("input", ctx[6]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & 2)
        numberinput_changes.value = isNumber(ctx2[1]) ? ctx2[1] : null;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_18(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: isString(ctx[1]) ? ctx[1] : "",
      readonly: ctx[3]
    }
  });
  textinput.$on("input", ctx[5]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 2)
        textinput_changes.value = isString(ctx2[1]) ? ctx2[1] : "";
      if (dirty & 8)
        textinput_changes.readonly = ctx2[3];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block12(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: isBoolean(ctx[1]) ? ctx[1] : false
    }
  });
  switch_1.$on("check", ctx[4]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 2)
        switch_1_changes.checked = isBoolean(ctx2[1]) ? ctx2[1] : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment48(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block12,
    create_if_block_18,
    create_if_block_24,
    create_if_block_33,
    create_if_block_4,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 3)
      show_if = null;
    if (ctx2[0] === DataFieldType.Boolean)
      return 0;
    if (ctx2[0] === DataFieldType.String)
      return 1;
    if (ctx2[0] === DataFieldType.Number)
      return 2;
    if (ctx2[0] === DataFieldType.Date)
      return 3;
    if (show_if == null)
      show_if = !!(ctx2[0] === DataFieldType.List && isOptionalList(ctx2[1]));
    if (show_if)
      return 4;
    if (ctx2[0] === DataFieldType.Link)
      return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { onChange } = $$props;
  let { readonly = false } = $$props;
  const check_handler = ({ detail }) => onChange(detail);
  const input_handler = ({ detail: value2 }) => onChange(value2);
  const input_handler_1 = ({ detail: value2 }) => onChange(value2 !== null ? value2 : void 0);
  const change_handler = ({ detail: value2 }) => onChange(value2);
  const input_handler_2 = ({ detail: val }) => {
    if (isLink(value)) {
      onChange(__spreadProps(__spreadValues({}, value), { linkText: val }));
    }
  };
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
  };
  return [
    type,
    value,
    onChange,
    readonly,
    check_handler,
    input_handler,
    input_handler_1,
    change_handler,
    input_handler_2
  ];
}
var FieldControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      type: 0,
      value: 1,
      onChange: 2,
      readonly: 3
    });
  }
};
var FieldControl_default = FieldControl;

// src/modals/components/EditNote.svelte
function get_each_context8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_if_block13(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[3].t("modals.note.edit.no-editable-fields.title"),
      icon: "info",
      variant: "info",
      $$slots: { default: [create_default_slot_56] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 8)
        callout_changes.title = ctx2[3].t("modals.note.edit.no-editable-fields.title");
      if (dirty & 1032) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_56(ctx) {
  let t_value = ctx[3].t("modals.note.edit.no-editable-fields.message") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("modals.note.edit.no-editable-fields.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_47(ctx) {
  let fieldcontrol;
  let t3;
  let current;
  function func7(...args) {
    return ctx[5](ctx[7], ...args);
  }
  fieldcontrol = new FieldControl_default({
    props: {
      value: ctx[0].values[ctx[7].name],
      onChange: func7,
      type: ctx[7].type
    }
  });
  return {
    c() {
      create_component(fieldcontrol.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(fieldcontrol, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fieldcontrol_changes = {};
      if (dirty & 5)
        fieldcontrol_changes.value = ctx[0].values[ctx[7].name];
      if (dirty & 5)
        fieldcontrol_changes.onChange = func7;
      if (dirty & 4)
        fieldcontrol_changes.type = ctx[7].type;
      fieldcontrol.$set(fieldcontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldcontrol, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block8(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[7].name,
      $$slots: { default: [create_default_slot_47] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 4)
        settingitem_changes.name = ctx2[7].name;
      if (dirty & 1029) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_37(ctx) {
  let t3;
  let each_1_anchor;
  let current;
  let if_block = !ctx[2].length && create_if_block13(ctx);
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block8(get_each_context8(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[2].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 5) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_27(ctx) {
  let t_value = ctx[3].t("modals.note.edit.save") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("modals.note.edit.save") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_19(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[6]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 1032) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot14(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_37] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 1037) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 1035) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment49(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[3].t("modals.note.edit.title"),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 8)
        modallayout_changes.title = ctx2[3].t("modals.note.edit.title");
      if (dirty & 1039) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let editableFields;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { fields } = $$props;
  let { record } = $$props;
  let { onSave } = $$props;
  const func7 = (field, value) => {
    $$invalidate(0, record = immer_esm_default(record, (draft) => {
      draft.values[field.name] = value;
    }));
  };
  const click_handler = () => {
    onSave(record);
  };
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(4, fields = $$props2.fields);
    if ("record" in $$props2)
      $$invalidate(0, record = $$props2.record);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, editableFields = fields.filter((field) => !field.derived));
    }
  };
  return [record, onSave, editableFields, $i18n, fields, func7, click_handler];
}
var EditNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, { fields: 4, record: 0, onSave: 1 });
  }
};
var EditNote_default = EditNote;

// src/modals/edit-note-modal.ts
var EditNoteModal = class extends import_obsidian25.Modal {
  constructor(app2, fields, onSave, defaults) {
    super(app2);
    this.defaults = defaults;
    this.fields = fields;
    this.onSave = onSave;
  }
  onOpen() {
    this.component = new EditNote_default({
      target: this.contentEl,
      props: {
        record: this.defaults,
        fields: this.fields,
        onSave: (record) => {
          this.onSave(record);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/Board/board.ts
function unique(records, fieldName) {
  const keys = records.map((record) => record.values[fieldName]).map((value) => value && isString(value) ? value : null).filter(notEmpty);
  const set = new Set(keys);
  return [...set];
}
function groupRecordsByField(records, fieldName) {
  var _a;
  const noStatus = get_store_value(i18n).t("views.board.no-status");
  if (!fieldName) {
    return { [noStatus]: records };
  }
  const keys = unique(records, fieldName);
  const res = {
    [noStatus]: []
  };
  for (let key of keys) {
    res[key] = [];
  }
  records.forEach((record, id) => {
    var _a2, _b;
    const value = record.values[fieldName];
    if (value && isString(value)) {
      (_a2 = res[value]) == null ? void 0 : _a2.push(record);
    } else {
      (_b = res[noStatus]) == null ? void 0 : _b.push(record);
    }
  });
  if (!((_a = res[noStatus]) == null ? void 0 : _a.length)) {
    delete res[noStatus];
  }
  return res;
}

// src/components/HorizontalGroup/HorizontalGroup.svelte
function add_css25(target) {
  append_styles(target, "svelte-1xeg6vs", "div.svelte-1xeg6vs{display:flex;gap:8px}.padding.svelte-1xeg6vs{padding:8px}.fullWidth.svelte-1xeg6vs{width:100%;justify-content:space-between}");
}
function create_fragment50(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "style", div_style_value = `align-items: ${ctx[1]}`);
      attr(div, "class", "svelte-1xeg6vs");
      toggle_class(div, "padding", ctx[2]);
      toggle_class(div, "fullWidth", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 2 && div_style_value !== (div_style_value = `align-items: ${ctx2[1]}`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 4) {
        toggle_class(div, "padding", ctx2[2]);
      }
      if (!current || dirty & 1) {
        toggle_class(div, "fullWidth", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { fullWidth = false } = $$props;
  let { alignItems = "center" } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fullWidth" in $$props2)
      $$invalidate(0, fullWidth = $$props2.fullWidth);
    if ("alignItems" in $$props2)
      $$invalidate(1, alignItems = $$props2.alignItems);
    if ("padding" in $$props2)
      $$invalidate(2, padding = $$props2.padding);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [fullWidth, alignItems, padding, $$scope, slots];
}
var HorizontalGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, { fullWidth: 0, alignItems: 1, padding: 2 }, add_css25);
  }
};
var HorizontalGroup_default = HorizontalGroup;

// src/components/Field/Field.svelte
function add_css26(target) {
  append_styles(target, "svelte-10n0s0w", "div.svelte-10n0s0w{display:flex;align-items:center;justify-content:flex-end;gap:var(--spacing-md)}");
}
function create_default_slot15(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment51(ctx) {
  let div;
  let typography;
  let t3;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      create_component(typography.$$.fragment);
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-10n0s0w");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography, div, null);
      append(div, t3);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & 5) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, slots, $$scope];
}
var Field = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, { name: 0 }, add_css26);
  }
};
var Field_default = Field;

// src/components/ToolBar/ToolBar.svelte
function add_css27(target) {
  append_styles(target, "svelte-lcf3nr", "div.svelte-lcf3nr{display:flex;align-items:center;padding:var(--spacing-md);background-color:var(--background-secondary);border-bottom:1px solid var(--background-modifier-border);justify-content:space-between}");
}
function create_fragment52(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-lcf3nr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ToolBar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, {}, add_css27);
  }
};
var ToolBar_default = ToolBar;

// src/views/Board/BoardView.svelte
function add_css28(target) {
  append_styles(target, "svelte-5tbm7y", "div.svelte-5tbm7y{background-color:var(--background-primary);overflow:auto}");
}
function create_default_slot_38(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[3]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[8].map(fieldToSelectableValue),
      placeholder: (_c = ctx[9].t("views.board.fields.none")) != null ? _c : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[17]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & 256)
        select_changes.options = ctx2[8].map(fieldToSelectableValue);
      if (dirty & 512)
        select_changes.placeholder = (_c2 = ctx2[9].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_28(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[6]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[7].map(fieldToSelectableValue),
      placeholder: (_c = ctx[9].t("views.board.fields.none")) != null ? _c : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[18]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & 64)
        select_changes.value = (_b2 = (_a2 = ctx2[6]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & 128)
        select_changes.options = ctx2[7].map(fieldToSelectableValue);
      if (dirty & 512)
        select_changes.placeholder = (_c2 = ctx2[9].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_110(ctx) {
  let field0;
  let t3;
  let field1;
  let current;
  field0 = new Field_default({
    props: {
      name: ctx[9].t("views.board.fields.status"),
      $$slots: { default: [create_default_slot_38] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: ctx[9].t("views.board.fields.priority"),
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t3 = space();
      create_component(field1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t3, anchor);
      mount_component(field1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 512)
        field0_changes.name = ctx2[9].t("views.board.fields.status");
      if (dirty & 4195086) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 512)
        field1_changes.name = ctx2[9].t("views.board.fields.priority");
      if (dirty & 4195014) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field1, detaching);
    }
  };
}
function create_default_slot16(ctx) {
  let p2;
  let t3;
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & 4195278) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_fragment53(ctx) {
  var _a;
  let toolbar;
  let t3;
  let div;
  let board;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot16] },
      $$scope: { ctx }
    }
  });
  board = new Board_default({
    props: {
      readonly: ctx[0],
      columns: ctx[5].sort(ctx[19]).map(ctx[20]),
      groupByPriority: (_a = ctx[6]) == null ? void 0 : _a.name,
      onRecordClick: ctx[10],
      onRecordAdd: ctx[11]
    }
  });
  return {
    c() {
      create_component(toolbar.$$.fragment);
      t3 = space();
      div = element("div");
      create_component(board.$$.fragment);
      attr(div, "class", "svelte-5tbm7y");
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      mount_component(board, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      const toolbar_changes = {};
      if (dirty & 4195278) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const board_changes = {};
      if (dirty & 1)
        board_changes.readonly = ctx2[0];
      if (dirty & 560)
        board_changes.columns = ctx2[5].sort(ctx2[19]).map(ctx2[20]);
      if (dirty & 64)
        board_changes.groupByPriority = (_a2 = ctx2[6]) == null ? void 0 : _a2.name;
      board.$set(board_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(board.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(board.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_component(board);
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let textFields;
  let groupByField;
  let numberFields;
  let priorityField;
  let groupedRecords;
  let columns;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(21, $app = $$value));
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function handleRecordClick(record) {
    new EditNoteModal($app, fields, (record2) => api2.updateRecord(record2, fields), record).open();
  }
  function handleRecordAdd(column) {
    new CreateNoteModal($app, project, (name, templatePath) => {
      if (groupByField) {
        api2.addRecord(createDataRecord(name, project, groupByField ? {
          [groupByField.name]: column !== $i18n.t("views.board.no-status") ? column : void 0
        } : {}), templatePath);
      }
    }).open();
  }
  const change_handler = ({ detail: value }) => onConfigChange(__spreadProps(__spreadValues({}, config), { groupByField: value }));
  const change_handler_1 = ({ detail: value }) => {
    onConfigChange(__spreadProps(__spreadValues({}, config), { priorityField: value }));
  };
  const func7 = (a2, b2) => {
    if (a2 === $i18n.t("views.board.no-status"))
      return -1;
    if (b2 === $i18n.t("views.board.no-status"))
      return 1;
    if (a2 === $i18n.t("views.board.no-status") && a2 === b2)
      return 0;
    return a2.localeCompare(b2);
  };
  const func_14 = (column) => {
    var _a;
    return {
      id: column,
      name: column,
      records: (_a = groupedRecords[column]) != null ? _a : []
    };
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(12, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(13, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(0, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(14, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(2, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(15, { fields, records } = frame, fields, ($$invalidate(16, records), $$invalidate(13, frame)));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(8, textFields = fields.filter((field) => field.type === DataFieldType.String));
    }
    if ($$self.$$.dirty & 32770) {
      $:
        $$invalidate(3, groupByField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.groupByField) === field.name));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(7, numberFields = fields.filter((field) => field.type === DataFieldType.Number));
    }
    if ($$self.$$.dirty & 32770) {
      $:
        $$invalidate(6, priorityField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.priorityField) === field.name));
    }
    if ($$self.$$.dirty & 65544) {
      $:
        $$invalidate(4, groupedRecords = groupRecordsByField(records, groupByField === null || groupByField === void 0 ? void 0 : groupByField.name));
    }
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(5, columns = Object.entries(groupedRecords).map((entry) => entry[0]));
    }
  };
  return [
    readonly,
    config,
    onConfigChange,
    groupByField,
    groupedRecords,
    columns,
    priorityField,
    numberFields,
    textFields,
    $i18n,
    handleRecordClick,
    handleRecordAdd,
    project,
    frame,
    api2,
    fields,
    records,
    change_handler,
    change_handler_1,
    func7,
    func_14
  ];
}
var BoardView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      project: 12,
      frame: 13,
      readonly: 0,
      api: 14,
      config: 1,
      onConfigChange: 2
    }, add_css28);
  }
};
var BoardView_default = BoardView;

// src/views/Calendar/CalendarView.svelte
var import_dayjs6 = __toModule(require_dayjs_min());

// src/views/Calendar/components/Table/Table.svelte
function add_css29(target) {
  append_styles(target, "svelte-1o9zltv", "table.svelte-1o9zltv{border-collapse:collapse;border-spacing:0;table-layout:fixed;overflow:auto}.grow.svelte-1o9zltv{height:100%}");
}
function create_fragment54(ctx) {
  let table;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      table = element("table");
      if (default_slot)
        default_slot.c();
      attr(table, "class", "svelte-1o9zltv");
      toggle_class(table, "grow", ctx[0]);
    },
    m(target, anchor) {
      insert(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        toggle_class(table, "grow", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { grow = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("grow" in $$props2)
      $$invalidate(0, grow = $$props2.grow);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [grow, $$scope, slots];
}
var Table = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment54, safe_not_equal, { grow: 0 }, add_css29);
  }
};
var Table_default = Table;

// src/views/Calendar/components/Table/TableBody.svelte
function create_fragment55(ctx) {
  let tbody;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tbody);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableBody = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, {});
  }
};
var TableBody_default = TableBody;

// src/views/Calendar/components/Table/TableCell.svelte
function add_css30(target) {
  append_styles(target, "svelte-wqxtg1", "td.svelte-wqxtg1{vertical-align:top;box-sizing:border-box;padding:0;border:1px solid var(--background-modifier-border);height:calc(100% / 5)}td.svelte-wqxtg1:first-of-type{border-left:1px solid var(--background-modifier-border)}td.svelte-wqxtg1:last-of-type{border-right:1px solid var(--background-modifier-border)}");
}
function create_fragment56(ctx) {
  let td;
  let td_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      attr(td, "colspan", ctx[0]);
      attr(td, "style", td_style_value = `width: ${ctx[1]}`);
      attr(td, "class", "svelte-wqxtg1");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(td, "dblclick", ctx[4]),
          listen(td, "mousedown", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(td, "colspan", ctx2[0]);
      }
      if (!current || dirty & 2 && td_style_value !== (td_style_value = `width: ${ctx2[1]}`)) {
        attr(td, "style", td_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { colspan = null } = $$props;
  let { width } = $$props;
  function dblclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("colspan" in $$props2)
      $$invalidate(0, colspan = $$props2.colspan);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [colspan, width, $$scope, slots, dblclick_handler, mousedown_handler];
}
var TableCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment56, safe_not_equal, { colspan: 0, width: 1 }, add_css30);
  }
};
var TableCell_default = TableCell;

// src/views/Calendar/components/Table/TableColumnHeaderCell.svelte
function add_css31(target) {
  append_styles(target, "svelte-1eo1o1v", "div.svelte-1eo1o1v{display:flex;align-items:center;width:100%;justify-content:space-between;gap:1rem}th.svelte-1eo1o1v{background:var(--background-secondary);border:1px solid var(--background-modifier-border);border-top:0;border-left:0;text-align:center;font-weight:500;min-width:100px;vertical-align:top;position:sticky !important;top:0;padding:0.3em}th.svelte-1eo1o1v:first-child{min-width:5ch}.nopadding.svelte-1eo1o1v{padding:0}");
}
function create_fragment57(ctx) {
  let th;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      th = element("th");
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1eo1o1v");
      attr(th, "scope", "col");
      attr(th, "class", "svelte-1eo1o1v");
      toggle_class(th, "nopadding", ctx[0]);
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(th, "mousedown", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        toggle_class(th, "nopadding", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(th);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nopadding = false } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("nopadding" in $$props2)
      $$invalidate(0, nopadding = $$props2.nopadding);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [nopadding, $$scope, slots, mousedown_handler];
}
var TableColumnHeaderCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment57, safe_not_equal, { nopadding: 0 }, add_css31);
  }
};
var TableColumnHeaderCell_default = TableColumnHeaderCell;

// src/views/Calendar/components/Table/TableHead.svelte
function create_fragment58(ctx) {
  let thead;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(thead);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableHead = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
  }
};
var TableHead_default = TableHead;

// src/views/Calendar/components/Table/TableRow.svelte
function create_fragment59(ctx) {
  let tr;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
  }
};
var TableRow_default = TableRow;

// src/views/Calendar/CalendarDate.svelte
var import_dayjs4 = __toModule(require_dayjs_min());
function add_css32(target) {
  append_styles(target, "svelte-1xloh8w", "span.svelte-1xloh8w{padding:0.2em 0.4em;border-radius:4px}.today.svelte-1xloh8w{background:var(--interactive-accent);display:inline-block;color:var(--text-on-accent)}");
}
function create_fragment60(ctx) {
  let span;
  let t_value = ctx[0].date() + "";
  let t3;
  return {
    c() {
      span = element("span");
      t3 = text(t_value);
      attr(span, "class", "svelte-1xloh8w");
      toggle_class(span, "today", ctx[1]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].date() + ""))
        set_data(t3, t_value);
      if (dirty & 2) {
        toggle_class(span, "today", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance60($$self, $$props, $$invalidate) {
  let today;
  let { date } = $$props;
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(1, today = date.startOf("day").isSame((0, import_dayjs4.default)().startOf("day")));
    }
  };
  return [date, today];
}
var CalendarDate = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance60, create_fragment60, safe_not_equal, { date: 0 }, add_css32);
  }
};
var CalendarDate_default = CalendarDate;

// src/views/Calendar/CalendarEntry.svelte
function add_css33(target) {
  append_styles(target, "svelte-1t0v41n", "div.svelte-1t0v41n{border-radius:4px;border:1px solid var(--background-modifier-border);background-color:var(--background-secondary);padding:0.2em 0.4em;font-size:var(--font-ui-small);width:100%;display:grid;grid-template-columns:auto 1fr}div.svelte-1t0v41n:hover{border:1px solid var(--background-modifier-border-hover)}span.svelte-1t0v41n{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}");
}
function create_if_block_19(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox_default({ props: { checked: false } });
  checkbox.$on("check", ctx[7]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_if_block14(ctx) {
  let checkbox;
  let updating_checked;
  let current;
  function checkbox_checked_binding(value) {
    ctx[5](value);
  }
  let checkbox_props = {};
  if (ctx[0] !== void 0) {
    checkbox_props.checked = ctx[0];
  }
  checkbox = new Checkbox_default({ props: checkbox_props });
  binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
  checkbox.$on("check", ctx[6]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (!updating_checked && dirty & 1) {
        updating_checked = true;
        checkbox_changes.checked = ctx2[0];
        add_flush_callback(() => updating_checked = false);
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_fragment61(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t3;
  let span;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block14, create_if_block_19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] !== void 0 && ctx2[0] !== null)
      return 0;
    if (ctx2[0] === null && ctx2[1])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "class", "svelte-1t0v41n");
      attr(div, "class", "svelte-1t0v41n");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t3);
      append(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[4]),
          listen(div, "mouseenter", ctx[8]),
          listen(div, "mouseleave", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, t3);
        } else {
          if_block = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance61($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { checked = void 0 } = $$props;
  let hover = false;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function checkbox_checked_binding(value) {
    checked = value;
    $$invalidate(0, checked);
  }
  function check_handler(event) {
    bubble.call(this, $$self, event);
  }
  function check_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  const mouseenter_handler = () => $$invalidate(1, hover = true);
  const mouseleave_handler = () => $$invalidate(1, hover = false);
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [
    checked,
    hover,
    $$scope,
    slots,
    click_handler,
    checkbox_checked_binding,
    check_handler,
    check_handler_1,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CalendarEntry = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance61, create_fragment61, safe_not_equal, { checked: 0 }, add_css33);
  }
};
var CalendarEntry_default = CalendarEntry;

// src/views/Calendar/CalendarDay.svelte
var import_path2 = __toModule(require("path"));
var import_obsidian28 = __toModule(require("obsidian"));
function add_css34(target) {
  append_styles(target, "svelte-qx13xl", "div.svelte-qx13xl{padding:4px;height:100%;display:flex;flex-direction:column;gap:4px;align-items:start;overflow:scroll}.weekend.svelte-qx13xl{background-color:var(--background-secondary)}");
}
function get_each_context9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_if_block15(ctx) {
  let calendarentry;
  let current;
  function check_handler(...args) {
    return ctx[10](ctx[14], ...args);
  }
  function click_handler() {
    return ctx[11](ctx[14]);
  }
  calendarentry = new CalendarEntry_default({
    props: {
      checked: ctx[2] !== void 0 ? asOptionalBoolean(ctx[14][1].values[ctx[2]]) : void 0,
      $$slots: { default: [create_default_slot_111] },
      $$scope: { ctx }
    }
  });
  calendarentry.$on("check", check_handler);
  calendarentry.$on("click", click_handler);
  return {
    c() {
      create_component(calendarentry.$$.fragment);
    },
    m(target, anchor) {
      mount_component(calendarentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const calendarentry_changes = {};
      if (dirty & 6)
        calendarentry_changes.checked = ctx[2] !== void 0 ? asOptionalBoolean(ctx[14][1].values[ctx[2]]) : void 0;
      if (dirty & 131210) {
        calendarentry_changes.$$scope = { dirty, ctx };
      }
      calendarentry.$set(calendarentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(calendarentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendarentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(calendarentry, detaching);
    }
  };
}
function create_default_slot_29(ctx) {
  let t_value = ctx[8](ctx[14][1]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[8](ctx2[14][1]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_111(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler(...args) {
    return ctx[9](ctx[14], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[14][1].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 2)
        internallink_changes.linkText = ctx[14][1].id;
      if (dirty & 131074) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block9(ctx) {
  let show_if = ctx[8](ctx[14][1]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block15(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = ctx2[8](ctx2[14][1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot17(ctx) {
  let div;
  let calendardate;
  let t3;
  let current;
  calendardate = new CalendarDate_default({ props: { date: ctx[0] } });
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block9(get_each_context9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      create_component(calendardate.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "svelte-qx13xl");
      toggle_class(div, "weekend", ctx[0].day() === 0 || ctx[0].day() === 6);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(calendardate, div, null);
      append(div, t3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const calendardate_changes = {};
      if (dirty & 1)
        calendardate_changes.date = ctx2[0];
      calendardate.$set(calendardate_changes);
      if (dirty & 430) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 1) {
        toggle_class(div, "weekend", ctx2[0].day() === 0 || ctx2[0].day() === 6);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(calendardate.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(calendardate.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(calendardate);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment62(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      width: "calc(100% / 7)",
      $$slots: { default: [create_default_slot17] },
      $$scope: { ctx }
    }
  });
  tablecell.$on("dblclick", ctx[12]);
  tablecell.$on("mousedown", ctx[13]);
  return {
    c() {
      create_component(tablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tablecell_changes = {};
      if (dirty & 131247) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
}
function asOptionalBoolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return null;
}
function instance62($$self, $$props, $$invalidate) {
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  let { date } = $$props;
  let { records } = $$props;
  let { checkField } = $$props;
  let { onEntryClick } = $$props;
  let { onEntryAdd } = $$props;
  let { onRecordUpdate } = $$props;
  function getDisplayName(record) {
    const basename = import_path2.default.basename(record.id);
    return basename.slice(0, basename.lastIndexOf("."));
  }
  const open_handler = (recordPair, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onEntryClick(recordPair[0]);
    }
  };
  const check_handler = (recordPair, { detail: checked }) => {
    if (checkField) {
      onRecordUpdate(__spreadProps(__spreadValues({}, recordPair[1]), {
        values: __spreadProps(__spreadValues({}, recordPair[1].values), {
          [checkField]: checked
        })
      }));
    }
  };
  const click_handler = (recordPair) => {
    onEntryClick(recordPair[0]);
  };
  const dblclick_handler = () => onEntryAdd();
  const mousedown_handler = (event) => {
    if (event.button === 2) {
      const menu = new import_obsidian28.Menu();
      menu.addItem((item) => {
        item.setTitle($i18n.t("views.calendar.new-note")).setIcon("file").onClick(onEntryAdd);
      });
      menu.showAtMouseEvent(event);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("records" in $$props2)
      $$invalidate(1, records = $$props2.records);
    if ("checkField" in $$props2)
      $$invalidate(2, checkField = $$props2.checkField);
    if ("onEntryClick" in $$props2)
      $$invalidate(3, onEntryClick = $$props2.onEntryClick);
    if ("onEntryAdd" in $$props2)
      $$invalidate(4, onEntryAdd = $$props2.onEntryAdd);
    if ("onRecordUpdate" in $$props2)
      $$invalidate(5, onRecordUpdate = $$props2.onRecordUpdate);
  };
  return [
    date,
    records,
    checkField,
    onEntryClick,
    onEntryAdd,
    onRecordUpdate,
    $i18n,
    $app,
    getDisplayName,
    open_handler,
    check_handler,
    click_handler,
    dblclick_handler,
    mousedown_handler
  ];
}
var CalendarDay = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      date: 0,
      records: 1,
      checkField: 2,
      onEntryClick: 3,
      onEntryAdd: 4,
      onRecordUpdate: 5
    }, add_css34);
  }
};
var CalendarDay_default = CalendarDay;

// src/views/Calendar/Navigation.svelte
function add_css35(target) {
  append_styles(target, "svelte-4mop69", "div.svelte-4mop69{display:flex;gap:4px;align-items:center}");
}
function create_default_slot18(ctx) {
  let t_value = ctx[3].t("views.calendar.today") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("views.calendar.today") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment63(ctx) {
  let div;
  let iconbutton0;
  let t0;
  let button;
  let t1;
  let iconbutton1;
  let current;
  iconbutton0 = new IconButton_default({ props: { icon: "chevron-left" } });
  iconbutton0.$on("click", function() {
    if (is_function(ctx[1]))
      ctx[1].apply(this, arguments);
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot18] },
      $$scope: { ctx }
    }
  });
  button.$on("click", function() {
    if (is_function(ctx[2]))
      ctx[2].apply(this, arguments);
  });
  iconbutton1 = new IconButton_default({ props: { icon: "chevron-right" } });
  iconbutton1.$on("click", function() {
    if (is_function(ctx[0]))
      ctx[0].apply(this, arguments);
  });
  return {
    c() {
      div = element("div");
      create_component(iconbutton0.$$.fragment);
      t0 = space();
      create_component(button.$$.fragment);
      t1 = space();
      create_component(iconbutton1.$$.fragment);
      attr(div, "class", "svelte-4mop69");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(iconbutton0, div, null);
      append(div, t0);
      mount_component(button, div, null);
      append(div, t1);
      mount_component(iconbutton1, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 24) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton0.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      transition_in(iconbutton1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton0.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      transition_out(iconbutton1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(iconbutton0);
      destroy_component(button);
      destroy_component(iconbutton1);
    }
  };
}
function instance63($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { onNext } = $$props;
  let { onPrevious } = $$props;
  let { onToday } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onNext" in $$props2)
      $$invalidate(0, onNext = $$props2.onNext);
    if ("onPrevious" in $$props2)
      $$invalidate(1, onPrevious = $$props2.onPrevious);
    if ("onToday" in $$props2)
      $$invalidate(2, onToday = $$props2.onToday);
  };
  return [onNext, onPrevious, onToday, $i18n];
}
var Navigation = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance63, create_fragment63, safe_not_equal, { onNext: 0, onPrevious: 1, onToday: 2 }, add_css35);
  }
};
var Navigation_default = Navigation;

// src/views/Calendar/calendar.ts
var import_dayjs5 = __toModule(require_dayjs_min());
function isCalendarInterval(value) {
  switch (value) {
    case "month":
    case "2weeks":
    case "week":
    case "3days":
    case "day":
      return true;
    default:
      return false;
  }
}
function addInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.add(1, "month");
    case "2weeks":
      return date.add(2, "week");
    case "week":
      return date.add(1, "week");
    case "3days":
      return date.add(1, "day");
    case "day":
      return date.add(1, "day");
  }
}
function subtractInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.subtract(1, "month");
    case "2weeks":
      return date.subtract(2, "week");
    case "week":
      return date.subtract(1, "week");
    case "3days":
      return date.subtract(1, "day");
    case "day":
      return date.subtract(1, "day");
  }
}
function groupRecordsByField2(records, field) {
  const res = {};
  records.forEach((record, i2) => {
    var _a;
    const dateValue = record.values[field];
    const start2 = dateValue ? isDate(dateValue) ? (0, import_dayjs5.default)(dateValue) : null : null;
    if (start2) {
      const dateStr = start2.format("YYYY-MM-DD");
      if (!(dateStr in res)) {
        res[dateStr] = [];
      }
      (_a = res[dateStr]) == null ? void 0 : _a.push([i2, record]);
    }
  });
  return res;
}
function computeDateInterval(anchor, interval) {
  switch (interval) {
    case "month":
      return [
        anchor.startOf("month").startOf("isoWeek"),
        anchor.endOf("month").endOf("isoWeek")
      ];
    case "2weeks":
      return [
        anchor.startOf("isoWeek"),
        anchor.add(1, "week").endOf("isoWeek")
      ];
    case "week":
      return [anchor.startOf("isoWeek"), anchor.endOf("isoWeek")];
    case "3days":
      return [anchor, anchor.add(2, "days")];
    case "day":
      return [anchor, anchor];
  }
}
function generateTitle(dateInterval) {
  if (dateInterval[0].startOf("day").isSame(dateInterval[1].startOf("day"))) {
    return get_store_value(i18n).t("views.calendar.date", {
      value: dateInterval[0],
      formatParams: {
        value: { year: "numeric", month: "long", day: "numeric" }
      }
    });
  }
  return get_store_value(i18n).t("views.calendar.interval", {
    from: dateInterval[0],
    to: dateInterval[1],
    formatParams: {
      from: { month: "short", day: "numeric" },
      to: { month: "short", day: "numeric" }
    }
  });
}
function generateDates(dateInterval) {
  const dates = [];
  const numDays = dateInterval[1].diff(dateInterval[0], "days");
  for (let i2 = 0; i2 <= numDays; i2++) {
    dates.push(dateInterval[0].add(i2, "day"));
  }
  return dates;
}
function chunkDates(dates, chunks) {
  const chunkedDates = [];
  let rest = dates;
  while (rest.length) {
    const chunked = take(rest, chunks);
    chunkedDates.push(chunked);
    rest = rest.slice(chunked.length);
  }
  return chunkedDates;
}
function take(arr, num) {
  const buffer = [];
  for (let i2 = 0; i2 < num && i2 < arr.length; i2++) {
    const el = arr[i2];
    if (el) {
      buffer.push(el);
    }
  }
  return buffer;
}

// src/views/Calendar/CalendarView.svelte
function add_css36(target) {
  append_styles(target, "svelte-lvsxvy", "div.svelte-lvsxvy{display:flex;flex-direction:column;height:100%}div.svelte-lvsxvy:last-child{flex:2}");
}
function get_each_context10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i2];
  return child_ctx;
}
function get_each_context_13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i2];
  return child_ctx;
}
function get_each_context_22(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i2];
  return child_ctx;
}
function create_default_slot_103(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[13]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8192)
        set_data(t3, ctx2[13]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_93(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[5]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[9].map(fieldToSelectableValue),
      placeholder: (_c = ctx[10].t("views.calendar.fields.none")) != null ? _c : ""
    }
  });
  select.$on("change", ctx[31]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & 32)
        select_changes.value = (_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & 512)
        select_changes.options = ctx2[9].map(fieldToSelectableValue);
      if (dirty[0] & 1024)
        select_changes.placeholder = (_c2 = ctx2[10].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_83(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      allowEmpty: true,
      value: (_b = (_a = ctx[15]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[16].map(fieldToSelectableValue),
      placeholder: (_c = ctx[10].t("views.calendar.fields.none")) != null ? _c : ""
    }
  });
  select.$on("change", ctx[32]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & 32768)
        select_changes.value = (_b2 = (_a2 = ctx2[15]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & 65536)
        select_changes.options = ctx2[16].map(fieldToSelectableValue);
      if (dirty[0] & 1024)
        select_changes.placeholder = (_c2 = ctx2[10].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_74(ctx) {
  var _a, _b;
  let field0;
  let t0;
  let field1;
  let t1;
  let select;
  let current;
  field0 = new Field_default({
    props: {
      name: ctx[10].t("views.calendar.fields.date"),
      $$slots: { default: [create_default_slot_93] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: ctx[10].t("views.calendar.fields.check"),
      $$slots: { default: [create_default_slot_83] },
      $$scope: { ctx }
    }
  });
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[3]) == null ? void 0 : _a.interval) != null ? _b : "week",
      options: [
        {
          label: ctx[10].t("views.calendar.intervals.month", { count: 1 }),
          value: "month"
        },
        {
          label: ctx[10].t("views.calendar.intervals.weekWithCount", { count: 2 }),
          value: "2weeks"
        },
        {
          label: ctx[10].t("views.calendar.intervals.week", { count: 1 }),
          value: "week"
        },
        {
          label: ctx[10].t("views.calendar.intervals.dayWithCount", { count: 3 }),
          value: "3days"
        },
        {
          label: ctx[10].t("views.calendar.intervals.day", { count: 1 }),
          value: "day"
        }
      ]
    }
  });
  select.$on("change", ctx[33]);
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const field0_changes = {};
      if (dirty[0] & 1024)
        field0_changes.name = ctx2[10].t("views.calendar.fields.date");
      if (dirty[0] & 1568 | dirty[1] & 32768) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 1024)
        field1_changes.name = ctx2[10].t("views.calendar.fields.check");
      if (dirty[0] & 99328 | dirty[1] & 32768) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const select_changes = {};
      if (dirty[0] & 8)
        select_changes.value = (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.interval) != null ? _b2 : "week";
      if (dirty[0] & 1024)
        select_changes.options = [
          {
            label: ctx2[10].t("views.calendar.intervals.month", { count: 1 }),
            value: "month"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.weekWithCount", { count: 2 }),
            value: "2weeks"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.week", { count: 1 }),
            value: "week"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.dayWithCount", { count: 3 }),
            value: "3days"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.day", { count: 1 }),
            value: "day"
          }
        ];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_65(ctx) {
  let navigation;
  let t0;
  let typography;
  let t1;
  let horizontalgroup;
  let current;
  navigation = new Navigation_default({
    props: {
      onNext: ctx[28],
      onPrevious: ctx[29],
      onToday: ctx[30]
    }
  });
  typography = new Typography_default({
    props: {
      variant: "h2",
      nomargin: true,
      $$slots: { default: [create_default_slot_103] },
      $$scope: { ctx }
    }
  });
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_74] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navigation.$$.fragment);
      t0 = space();
      create_component(typography.$$.fragment);
      t1 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navigation, target, anchor);
      insert(target, t0, anchor);
      mount_component(typography, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navigation_changes = {};
      if (dirty[0] & 144)
        navigation_changes.onNext = ctx2[28];
      if (dirty[0] & 144)
        navigation_changes.onPrevious = ctx2[29];
      if (dirty[0] & 16)
        navigation_changes.onToday = ctx2[30];
      navigation.$set(navigation_changes);
      const typography_changes = {};
      if (dirty[0] & 8192 | dirty[1] & 32768) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const horizontalgroup_changes = {};
      if (dirty[0] & 99880 | dirty[1] & 32768) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigation.$$.fragment, local);
      transition_in(typography.$$.fragment, local);
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigation.$$.fragment, local);
      transition_out(typography.$$.fragment, local);
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navigation, detaching);
      if (detaching)
        detach(t0);
      destroy_component(typography, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_default_slot_57(ctx) {
  let t_value = ctx[43] + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048 && t_value !== (t_value = ctx2[43] + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_22(ctx) {
  let tablecolumnheadercell;
  let current;
  tablecolumnheadercell = new TableColumnHeaderCell_default({
    props: {
      $$slots: { default: [create_default_slot_57] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablecolumnheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablecolumnheadercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablecolumnheadercell_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablecolumnheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecolumnheadercell.$set(tablecolumnheadercell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablecolumnheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablecolumnheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablecolumnheadercell, detaching);
    }
  };
}
function create_default_slot_48(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[11];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_22(get_each_context_22(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048) {
        each_value_2 = ctx2[11];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_22(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_39(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_48] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
}
function create_each_block_13(ctx) {
  var _a;
  let calendarday;
  let current;
  function func_5() {
    return ctx[36](ctx[40]);
  }
  calendarday = new CalendarDay_default({
    props: {
      date: ctx[40],
      checkField: (_a = ctx[15]) == null ? void 0 : _a.name,
      onRecordUpdate: ctx[34],
      records: ctx[14][ctx[40].format("YYYY-MM-DD")] || [],
      onEntryClick: ctx[35],
      onEntryAdd: func_5
    }
  });
  return {
    c() {
      create_component(calendarday.$$.fragment);
    },
    m(target, anchor) {
      mount_component(calendarday, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const calendarday_changes = {};
      if (dirty[0] & 4096)
        calendarday_changes.date = ctx[40];
      if (dirty[0] & 32768)
        calendarday_changes.checkField = (_a2 = ctx[15]) == null ? void 0 : _a2.name;
      if (dirty[0] & 260)
        calendarday_changes.onRecordUpdate = ctx[34];
      if (dirty[0] & 20480)
        calendarday_changes.records = ctx[14][ctx[40].format("YYYY-MM-DD")] || [];
      if (dirty[0] & 324)
        calendarday_changes.onEntryClick = ctx[35];
      if (dirty[0] & 135207)
        calendarday_changes.onEntryAdd = func_5;
      calendarday.$set(calendarday_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(calendarday.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendarday.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(calendarday, detaching);
    }
  };
}
function create_default_slot_210(ctx) {
  let t3;
  let current;
  let each_value_1 = ctx[37];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_13(get_each_context_13(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 184679) {
        each_value_1 = ctx2[37];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_13(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block10(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_210] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & 184679 | dirty[1] & 32768) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
}
function create_default_slot_112(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block10(get_each_context10(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 184679) {
        each_value = ctx2[12];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block10(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot19(ctx) {
  let tablehead;
  let t3;
  let tablebody;
  let current;
  tablehead = new TableHead_default({
    props: {
      $$slots: { default: [create_default_slot_39] },
      $$scope: { ctx }
    }
  });
  tablebody = new TableBody_default({
    props: {
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablehead.$$.fragment);
      t3 = space();
      create_component(tablebody.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablehead, target, anchor);
      insert(target, t3, anchor);
      mount_component(tablebody, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablehead_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablehead_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablehead.$set(tablehead_changes);
      const tablebody_changes = {};
      if (dirty[0] & 184679 | dirty[1] & 32768) {
        tablebody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablebody.$set(tablebody_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablehead.$$.fragment, local);
      transition_in(tablebody.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablehead.$$.fragment, local);
      transition_out(tablebody.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablehead, detaching);
      if (detaching)
        detach(t3);
      destroy_component(tablebody, detaching);
    }
  };
}
function create_fragment64(ctx) {
  let div;
  let toolbar;
  let t3;
  let table;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot_65] },
      $$scope: { ctx }
    }
  });
  table = new Table_default({
    props: {
      grow: true,
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t3 = space();
      create_component(table.$$.fragment);
      attr(div, "class", "svelte-lvsxvy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(toolbar, div, null);
      append(div, t3);
      mount_component(table, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const toolbar_changes = {};
      if (dirty[0] & 108216 | dirty[1] & 32768) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const table_changes = {};
      if (dirty[0] & 186727 | dirty[1] & 32768) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(toolbar);
      destroy_component(table);
    }
  };
}
function instance64($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let dateFields;
  let dateField;
  let booleanFields;
  let booleanField;
  let interval;
  let dateInterval;
  let groupedRecords;
  let title;
  let dates;
  let numColumns;
  let weeks;
  let weekDays;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(10, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(17, $app = $$value));
  var _a, _b;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  let anchorDate = (0, import_dayjs6.default)();
  function handleIntervalChange(interval2) {
    if (isCalendarInterval(interval2)) {
      onConfigChange(Object.assign(Object.assign({}, config), { interval: interval2 }));
    }
  }
  function handleDateFieldChange(dateField2) {
    onConfigChange(Object.assign(Object.assign({}, config), { dateField: dateField2 }));
  }
  function handleCheckFieldChange(checkField) {
    onConfigChange(Object.assign(Object.assign({}, config), { checkField }));
  }
  const func7 = () => $$invalidate(4, anchorDate = addInterval(anchorDate, interval));
  const func_14 = () => $$invalidate(4, anchorDate = subtractInterval(anchorDate, interval));
  const func_2 = () => $$invalidate(4, anchorDate = (0, import_dayjs6.default)());
  const change_handler = ({ detail }) => handleDateFieldChange(detail);
  const change_handler_1 = ({ detail }) => handleCheckFieldChange(detail);
  const change_handler_2 = ({ detail }) => handleIntervalChange(detail);
  const func_3 = (record) => {
    api2.updateRecord(record, fields);
  };
  const func_4 = (id) => {
    new EditNoteModal(get_store_value(app), fields, (record) => {
      api2.updateRecord(record, fields);
    }, records[id]).open();
  };
  const func_5 = (date) => {
    if (dateField && !readonly) {
      new CreateNoteModal($app, project, (name, templatePath) => {
        if (dateField) {
          api2.addRecord(createDataRecord(name, project, { [dateField.name]: date.toDate() }), templatePath);
        }
      }).open();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(21, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(2, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(22, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2097152) {
      $:
        $$invalidate(8, { fields, records } = frame, fields, ($$invalidate(6, records), $$invalidate(21, frame)));
    }
    if ($$self.$$.dirty[0] & 256) {
      $:
        $$invalidate(9, dateFields = fields.filter((field) => field.type === DataFieldType.Date));
    }
    if ($$self.$$.dirty[0] & 8389128) {
      $:
        $$invalidate(5, dateField = $$invalidate(23, _a = dateFields.find((field) => (config === null || config === void 0 ? void 0 : config.dateField) === field.name)) !== null && _a !== void 0 ? _a : dateFields[0]);
    }
    if ($$self.$$.dirty[0] & 256) {
      $:
        $$invalidate(16, booleanFields = fields.filter((field) => field.type === DataFieldType.Boolean));
    }
    if ($$self.$$.dirty[0] & 264) {
      $:
        $$invalidate(15, booleanField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.checkField) === field.name));
    }
    if ($$self.$$.dirty[0] & 16777224) {
      $:
        $$invalidate(7, interval = $$invalidate(24, _b = config === null || config === void 0 ? void 0 : config.interval) !== null && _b !== void 0 ? _b : "week");
    }
    if ($$self.$$.dirty[0] & 144) {
      $:
        $$invalidate(27, dateInterval = computeDateInterval(anchorDate, interval));
    }
    if ($$self.$$.dirty[0] & 96) {
      $:
        $$invalidate(14, groupedRecords = dateField ? groupRecordsByField2(records, dateField.name) : {});
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(13, title = dateInterval ? generateTitle(dateInterval) : "");
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(26, dates = dateInterval ? generateDates(dateInterval) : []);
    }
    if ($$self.$$.dirty[0] & 67108864) {
      $:
        $$invalidate(25, numColumns = Math.min(dates.length, 7));
    }
    if ($$self.$$.dirty[0] & 100663296) {
      $:
        $$invalidate(12, weeks = chunkDates(dates, numColumns));
    }
    if ($$self.$$.dirty[0] & 100664320) {
      $:
        $$invalidate(11, weekDays = dates.slice(0, numColumns).map((date) => $i18n.t("views.calendar.weekday", {
          value: date.toDate(),
          formatParams: { value: { weekday: "short" } }
        })));
    }
  };
  return [
    project,
    readonly,
    api2,
    config,
    anchorDate,
    dateField,
    records,
    interval,
    fields,
    dateFields,
    $i18n,
    weekDays,
    weeks,
    title,
    groupedRecords,
    booleanField,
    booleanFields,
    $app,
    handleIntervalChange,
    handleDateFieldChange,
    handleCheckFieldChange,
    frame,
    onConfigChange,
    _a,
    _b,
    numColumns,
    dates,
    dateInterval,
    func7,
    func_14,
    func_2,
    change_handler,
    change_handler_1,
    change_handler_2,
    func_3,
    func_4,
    func_5
  ];
}
var CalendarView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      project: 0,
      frame: 21,
      readonly: 1,
      api: 2,
      config: 3,
      onConfigChange: 22
    }, add_css36, [-1, -1]);
  }
};
var CalendarView_default = CalendarView;

// src/views/Table/components/DataGrid/DataGrid.svelte
var import_obsidian36 = __toModule(require("obsidian"));

// src/views/Table/components/DataGrid/GridCell/Resizer.svelte
function add_css37(target) {
  append_styles(target, "svelte-1desyj5", ".handle.svelte-1desyj5{position:relative;left:7.5px;width:6px;min-width:6px;height:100%;border-radius:1px}.handle.svelte-1desyj5:hover{background-color:var(--interactive-accent);cursor:ew-resize}.visible.svelte-1desyj5{background-color:var(--interactive-accent);cursor:ew-resize}");
}
function create_else_block5(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "handle svelte-1desyj5");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "mousedown", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block16(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "handle visible svelte-1desyj5");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "mousedown", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment65(ctx) {
  let if_block_anchor;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block16;
    return create_else_block5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(window, "mouseup", ctx[2]),
          listen(window, "mousemove", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance65($$self, $$props, $$invalidate) {
  let { width } = $$props;
  let { onChange } = $$props;
  let { onFinalize } = $$props;
  let { min: min2 } = $$props;
  let start2;
  let initial;
  function startResize(event) {
    $$invalidate(0, start2 = event.pageX);
    initial = width;
  }
  function stopResize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min2) {
        onFinalize(width);
      }
    }
    $$invalidate(0, start2 = null);
    initial = null;
  }
  function resize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min2) {
        onChange(newWidth);
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("onChange" in $$props2)
      $$invalidate(5, onChange = $$props2.onChange);
    if ("onFinalize" in $$props2)
      $$invalidate(6, onFinalize = $$props2.onFinalize);
    if ("min" in $$props2)
      $$invalidate(7, min2 = $$props2.min);
  };
  return [start2, startResize, stopResize, resize, width, onChange, onFinalize, min2];
}
var Resizer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance65, create_fragment65, safe_not_equal, {
      width: 4,
      onChange: 5,
      onFinalize: 6,
      min: 7
    }, add_css37);
  }
};
var Resizer_default = Resizer;

// src/views/Table/components/DataGrid/GridCell/GridCell.svelte
function add_css38(target) {
  append_styles(target, "svelte-1sroa00", "div.svelte-1sroa00{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:var(--background-primary);border-right:1px solid var(--background-modifier-border);border-left-color:var(--background-modifier-border);border-bottom:1px solid var(--background-modifier-border);box-sizing:border-box;vertical-align:middle;width:100%;min-height:30px}.selected.svelte-1sroa00{box-shadow:0 0 0 3px var(--interactive-accent);z-index:4;padding:0}.columnHeader.svelte-1sroa00{background-color:var(--background-secondary);font-weight:500;text-align:center;justify-content:space-between;padding:0 4px}.header.svelte-1sroa00{background-color:var(--background-secondary);position:sticky;left:60px}.rowHeader.svelte-1sroa00{left:0px;justify-content:center;z-index:5;background-color:var(--background-secondary);font-weight:500;text-align:center;padding:0 4px}");
}
var get_read_slot_changes_1 = (dirty) => ({});
var get_read_slot_context_1 = (ctx) => ({});
var get_hover_slot_changes = (dirty) => ({});
var get_hover_slot_context = (ctx) => ({});
var get_selected_slot_changes = (dirty) => ({});
var get_selected_slot_context = (ctx) => ({});
var get_read_slot_changes = (dirty) => ({});
var get_read_slot_context = (ctx) => ({});
var get_edit_slot_changes = (dirty) => ({});
var get_edit_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let current;
  const read_slot_template = ctx[23].read;
  const read_slot = create_slot(read_slot_template, ctx, ctx[22], get_read_slot_context_1);
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(read_slot, read_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(read_slot_template, ctx2[22], dirty, get_read_slot_changes_1), get_read_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let current;
  const hover_slot_template = ctx[23].hover;
  const hover_slot = create_slot(hover_slot_template, ctx, ctx[22], get_hover_slot_context);
  return {
    c() {
      if (hover_slot)
        hover_slot.c();
    },
    m(target, anchor) {
      if (hover_slot) {
        hover_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (hover_slot) {
        if (hover_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(hover_slot, hover_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(hover_slot_template, ctx2[22], dirty, get_hover_slot_changes), get_hover_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hover_slot, local);
      current = true;
    },
    o(local) {
      transition_out(hover_slot, local);
      current = false;
    },
    d(detaching) {
      if (hover_slot)
        hover_slot.d(detaching);
    }
  };
}
function create_if_block_34(ctx) {
  let current;
  const selected_slot_template = ctx[23].selected;
  const selected_slot = create_slot(selected_slot_template, ctx, ctx[22], get_selected_slot_context);
  return {
    c() {
      if (selected_slot)
        selected_slot.c();
    },
    m(target, anchor) {
      if (selected_slot) {
        selected_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (selected_slot) {
        if (selected_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(selected_slot, selected_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(selected_slot_template, ctx2[22], dirty, get_selected_slot_changes), get_selected_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selected_slot, local);
      current = true;
    },
    o(local) {
      transition_out(selected_slot, local);
      current = false;
    },
    d(detaching) {
      if (selected_slot)
        selected_slot.d(detaching);
    }
  };
}
function create_if_block_110(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_25, create_else_block6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[5].editable)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block6(ctx) {
  let current;
  const read_slot_template = ctx[23].read;
  const read_slot = create_slot(read_slot_template, ctx, ctx[22], get_read_slot_context);
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(read_slot, read_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(read_slot_template, ctx2[22], dirty, get_read_slot_changes), get_read_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_25(ctx) {
  let current;
  const edit_slot_template = ctx[23].edit;
  const edit_slot = create_slot(edit_slot_template, ctx, ctx[22], get_edit_slot_context);
  return {
    c() {
      if (edit_slot)
        edit_slot.c();
    },
    m(target, anchor) {
      if (edit_slot) {
        edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (edit_slot) {
        if (edit_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(edit_slot, edit_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(edit_slot_template, ctx2[22], dirty, get_edit_slot_changes), get_edit_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (edit_slot)
        edit_slot.d(detaching);
    }
  };
}
function create_if_block17(ctx) {
  var _a;
  let resizer;
  let current;
  resizer = new Resizer_default({
    props: {
      width: (_a = ctx[5].width) != null ? _a : 180,
      min: 100,
      onChange: ctx[3],
      onFinalize: ctx[4]
    }
  });
  return {
    c() {
      create_component(resizer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(resizer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const resizer_changes = {};
      if (dirty & 32)
        resizer_changes.width = (_a2 = ctx2[5].width) != null ? _a2 : 180;
      if (dirty & 8)
        resizer_changes.onChange = ctx2[3];
      if (dirty & 16)
        resizer_changes.onFinalize = ctx2[4];
      resizer.$set(resizer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(resizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(resizer, detaching);
    }
  };
}
function create_fragment66(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t3;
  let div_role_value;
  let div_aria_selected_value;
  let div_style_value;
  let div_tabindex_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_110, create_if_block_34, create_if_block_42, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[17].edit && ctx2[1])
      return 0;
    if (ctx2[17].selected && ctx2[0])
      return 1;
    if (ctx2[17].hover && ctx2[11])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block17(ctx);
  return {
    c() {
      div = element("div");
      if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "role", div_role_value = ctx[16]());
      attr(div, "aria-selected", div_aria_selected_value = ctx[8] || ctx[7] ? void 0 : ctx[0]);
      attr(div, "aria-colindex", ctx[6]);
      attr(div, "style", div_style_value = `width: ${ctx[5].width}px`);
      attr(div, "tabindex", div_tabindex_value = !ctx[7] && !ctx[8] ? 1 : void 0);
      attr(div, "class", "svelte-1sroa00");
      toggle_class(div, "columnHeader", ctx[7]);
      toggle_class(div, "header", ctx[5].header);
      toggle_class(div, "selected", ctx[0]);
      toggle_class(div, "rowHeader", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      ctx[25](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[12]),
          listen(div, "dblclick", ctx[13]),
          listen(div, "mousedown", ctx[24]),
          listen(div, "mouseenter", ctx[26]),
          listen(div, "mouseleave", ctx[27]),
          listen(div, "focus", ctx[28]),
          listen(div, "blur", ctx[15]),
          listen(div, "keydown", ctx[14]),
          action_destroyer(useClickOutside_action = useClickOutside2.call(null, div, ctx[29]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t3);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 385 && div_aria_selected_value !== (div_aria_selected_value = ctx2[8] || ctx2[7] ? void 0 : ctx2[0])) {
        attr(div, "aria-selected", div_aria_selected_value);
      }
      if (!current || dirty & 64) {
        attr(div, "aria-colindex", ctx2[6]);
      }
      if (!current || dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5].width}px`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 384 && div_tabindex_value !== (div_tabindex_value = !ctx2[7] && !ctx2[8] ? 1 : void 0)) {
        attr(div, "tabindex", div_tabindex_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 513)
        useClickOutside_action.update.call(null, ctx2[29]);
      if (!current || dirty & 128) {
        toggle_class(div, "columnHeader", ctx2[7]);
      }
      if (!current || dirty & 32) {
        toggle_class(div, "header", ctx2[5].header);
      }
      if (!current || dirty & 1) {
        toggle_class(div, "selected", ctx2[0]);
      }
      if (!current || dirty & 256) {
        toggle_class(div, "rowHeader", ctx2[8]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance66($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { edit = false } = $$props;
  let { resizable = false } = $$props;
  let { onResize = () => {
  } } = $$props;
  let { onFinalizeResize = () => {
  } } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { columnHeader = false } = $$props;
  let { rowHeader = false } = $$props;
  let { onEditChange = (value) => {
    $$invalidate(1, edit = value);
  } } = $$props;
  let { onCopy = () => {
  } } = $$props;
  let { onCut = () => {
  } } = $$props;
  let { onPaste = () => {
  } } = $$props;
  const dispatch = createEventDispatcher();
  let hover = false;
  let ref;
  function handleClick() {
    if (!column.header && !columnHeader && !rowHeader) {
      $$invalidate(0, selected = true);
    }
  }
  function handleDoubleClick() {
    if (!column.header && !columnHeader && !rowHeader) {
      onEditChange(true);
    }
  }
  function handleKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      switch (event.key) {
        case "c":
          onCopy();
          break;
        case "x":
          onCut();
          break;
        case "v":
          onPaste();
          break;
      }
    }
    switch (event.key) {
      case "Enter":
        if (edit) {
          onEditChange(false);
          ref.focus();
        } else {
          onEditChange(true);
        }
        break;
      case "Escape":
        onEditChange(false);
        ref.focus();
        break;
      case "ArrowLeft":
        dispatch("navigate", [colindex - 1, rowindex]);
        event.preventDefault();
        break;
      case "ArrowRight":
        dispatch("navigate", [colindex + 1, rowindex]);
        event.preventDefault();
        break;
      case "ArrowUp":
        dispatch("navigate", [colindex, rowindex - 1]);
        event.preventDefault();
        break;
      case "ArrowDown":
        dispatch("navigate", [colindex, rowindex + 1]);
        event.preventDefault();
        break;
      case "Tab":
        if (event.shiftKey) {
          dispatch("navigate", [colindex - 1, rowindex]);
        } else {
          dispatch("navigate", [colindex + 1, rowindex]);
        }
        event.preventDefault();
        break;
    }
  }
  function handleBlur(event) {
    $$invalidate(11, hover = false);
    if (event.currentTarget instanceof HTMLDivElement && event.relatedTarget instanceof HTMLElement && !event.currentTarget.contains(event.relatedTarget)) {
      $$invalidate(0, selected = false);
      onEditChange(false);
    }
  }
  function role() {
    if (columnHeader) {
      return "columnheader";
    } else if (rowHeader) {
      return "rowheader";
    } else {
      return "gridcell";
    }
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(10, ref);
    });
  }
  const mouseenter_handler = () => $$invalidate(11, hover = true);
  const mouseleave_handler = () => $$invalidate(11, hover = false);
  const focus_handler = () => {
    $$invalidate(11, hover = true);
    $$invalidate(0, selected = true);
  };
  const useClickOutside_function = () => {
    onEditChange(false);
    $$invalidate(0, selected = false);
  };
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("resizable" in $$props2)
      $$invalidate(2, resizable = $$props2.resizable);
    if ("onResize" in $$props2)
      $$invalidate(3, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(4, onFinalizeResize = $$props2.onFinalizeResize);
    if ("column" in $$props2)
      $$invalidate(5, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(18, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(6, colindex = $$props2.colindex);
    if ("columnHeader" in $$props2)
      $$invalidate(7, columnHeader = $$props2.columnHeader);
    if ("rowHeader" in $$props2)
      $$invalidate(8, rowHeader = $$props2.rowHeader);
    if ("onEditChange" in $$props2)
      $$invalidate(9, onEditChange = $$props2.onEditChange);
    if ("onCopy" in $$props2)
      $$invalidate(19, onCopy = $$props2.onCopy);
    if ("onCut" in $$props2)
      $$invalidate(20, onCut = $$props2.onCut);
    if ("onPaste" in $$props2)
      $$invalidate(21, onPaste = $$props2.onPaste);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1025) {
      $:
        if (selected && ref) {
          ref.focus();
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
    }
  };
  return [
    selected,
    edit,
    resizable,
    onResize,
    onFinalizeResize,
    column,
    colindex,
    columnHeader,
    rowHeader,
    onEditChange,
    ref,
    hover,
    handleClick,
    handleDoubleClick,
    handleKeyDown,
    handleBlur,
    role,
    $$slots,
    rowindex,
    onCopy,
    onCut,
    onPaste,
    $$scope,
    slots,
    mousedown_handler,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    useClickOutside_function
  ];
}
var GridCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance66, create_fragment66, safe_not_equal, {
      selected: 0,
      edit: 1,
      resizable: 2,
      onResize: 3,
      onFinalizeResize: 4,
      column: 5,
      rowindex: 18,
      colindex: 6,
      columnHeader: 7,
      rowHeader: 8,
      onEditChange: 9,
      onCopy: 19,
      onCut: 20,
      onPaste: 21
    }, add_css38);
  }
};
var GridCell_default = GridCell;

// src/views/Table/components/DataGrid/GridCell/GridBooleanCell/GridBooleanCell.svelte
function create_if_block18(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: ctx[0],
      disabled: !ctx[2].editable
    }
  });
  switch_1.$on("check", ctx[7]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0];
      if (dirty & 4)
        switch_1_changes.disabled = !ctx2[2].editable;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_read_slot(ctx) {
  let show_if = isBoolean(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block18(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isBoolean(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot(ctx) {
  var _a;
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      slot: "edit",
      checked: (_a = ctx[0]) != null ? _a : false
    }
  });
  switch_1.$on("check", ctx[6]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = (_a2 = ctx2[0]) != null ? _a2 : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment67(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot],
        read: [create_read_slot]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[8]);
  gridcell.$on("navigate", ctx[9]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 1031) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance67($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  const check_handler = ({ detail: checked }) => onChange(checked);
  const check_handler_1 = ({ detail: checked }) => onChange(checked);
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    check_handler,
    check_handler_1,
    mousedown_handler,
    navigate_handler
  ];
}
var GridBooleanCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance67, create_fragment67, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridBooleanCell_default = GridBooleanCell;

// src/views/Table/components/DataGrid/GridCell/GridDateCell/GridDateCell.svelte
function create_if_block19(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      value: ctx[0].toLocaleDateString()
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx2[0].toLocaleDateString();
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_read_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block19(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot2(ctx) {
  var _a;
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: (_a = ctx[0]) != null ? _a : null,
      embed: true
    }
  });
  dateinput.$on("change", ctx[7]);
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const dateinput_changes = {};
      if (dirty & 1)
        dateinput_changes.value = (_a2 = ctx2[0]) != null ? _a2 : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_fragment68(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      edit: ctx[6],
      onEditChange: ctx[8],
      column: ctx[2],
      onCopy: ctx[9],
      $$slots: {
        edit: [create_edit_slot2],
        read: [create_read_slot2]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[10]);
  gridcell.$on("navigate", ctx[11]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 64)
        gridcell_changes.edit = ctx2[6];
      if (dirty & 64)
        gridcell_changes.onEditChange = ctx2[8];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 1)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 4163) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance68($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const change_handler = ({ detail: value2 }) => {
    $$invalidate(6, edit = false);
    onChange(value2);
  };
  const func7 = (mode) => {
    $$invalidate(6, edit = mode);
  };
  const func_14 = () => {
    if (value) {
      navigator.clipboard.writeText(value.toLocaleDateString());
    }
  };
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    edit,
    change_handler,
    func7,
    func_14,
    mousedown_handler,
    navigate_handler
  ];
}
var GridDateCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance68, create_fragment68, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridDateCell_default = GridDateCell;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberLabel.svelte
function add_css39(target) {
  append_styles(target, "svelte-1xccag5", "div.svelte-1xccag5{width:100%;padding:6px;text-align:right}");
}
function create_fragment69(ctx) {
  let div;
  let t_value = new Intl.NumberFormat().format(ctx[0]) + "";
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(t_value);
      attr(div, "class", "svelte-1xccag5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t_value !== (t_value = new Intl.NumberFormat().format(ctx2[0]) + ""))
        set_data(t3, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance69($$self, $$props, $$invalidate) {
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value];
}
var NumberLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance69, create_fragment69, safe_not_equal, { value: 0 }, add_css39);
  }
};
var NumberLabel_default = NumberLabel;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberInput.svelte
function add_css40(target) {
  append_styles(target, "svelte-1ncoulf", "input.svelte-1ncoulf{all:unset;background-color:var(--background-primary);box-sizing:border-box;width:100%;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal);text-align:right}input.svelte-1ncoulf:focus{box-shadow:none !important}input.svelte-1ncoulf:hover{background-color:transparent}");
}
function create_fragment70(ctx) {
  let input;
  let input_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "tabindex", input_tabindex_value = -1);
      attr(input, "type", "number");
      input.value = ctx[0];
      attr(input, "class", "svelte-1ncoulf");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[6](input);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[2]),
          listen(input, "keypress", ctx[3]),
          listen(input, "blur", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance70($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let ref;
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
      onChange(value);
    }
  }
  function handleKeyup(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  onMount(() => {
    ref.focus();
  });
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(4, onChange = $$props2.onChange);
  };
  return [value, ref, handleInput, handleKeyup, onChange, blur_handler, input_binding];
}
var NumberInput2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance70, create_fragment70, safe_not_equal, { value: 0, onChange: 4 }, add_css40);
  }
};
var NumberInput_default2 = NumberInput2;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/GridNumberCell.svelte
function create_if_block20(ctx) {
  let numberlabel;
  let current;
  numberlabel = new NumberLabel_default({ props: { value: ctx[1] } });
  return {
    c() {
      create_component(numberlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberlabel_changes = {};
      if (dirty & 2)
        numberlabel_changes.value = ctx2[1];
      numberlabel.$set(numberlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberlabel, detaching);
    }
  };
}
function create_read_slot3(ctx) {
  let show_if = isNumber(ctx[1]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block20(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = isNumber(ctx2[1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot3(ctx) {
  var _a;
  let numberinput;
  let current;
  numberinput = new NumberInput_default2({
    props: {
      slot: "edit",
      value: (_a = ctx[1]) != null ? _a : 0,
      onChange: ctx[7]
    }
  });
  numberinput.$on("blur", ctx[8]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const numberinput_changes = {};
      if (dirty & 2)
        numberinput_changes.value = (_a2 = ctx2[1]) != null ? _a2 : 0;
      if (dirty & 4)
        numberinput_changes.onChange = ctx2[7];
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_fragment71(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[12](value);
  }
  function gridcell_selected_binding(value) {
    ctx[13](value);
  }
  let gridcell_props = {
    column: ctx[3],
    rowindex: ctx[4],
    colindex: ctx[5],
    onCopy: ctx[9],
    onCut: ctx[10],
    onPaste: ctx[11],
    $$slots: {
      edit: [create_edit_slot3],
      read: [create_read_slot3]
    },
    $$scope: { ctx }
  };
  if (ctx[6] !== void 0) {
    gridcell_props.edit = ctx[6];
  }
  if (ctx[0] !== void 0) {
    gridcell_props.selected = ctx[0];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on("mousedown", ctx[14]);
  gridcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.column = ctx2[3];
      if (dirty & 16)
        gridcell_changes.rowindex = ctx2[4];
      if (dirty & 32)
        gridcell_changes.colindex = ctx2[5];
      if (dirty & 2)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 6)
        gridcell_changes.onCut = ctx2[10];
      if (dirty & 4)
        gridcell_changes.onPaste = ctx2[11];
      if (dirty & 65607) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & 64) {
        updating_edit = true;
        gridcell_changes.edit = ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        gridcell_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance71($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const func7 = (value2) => {
    onChange(value2);
  };
  const blur_handler = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(0, selected = false);
      $$invalidate(6, edit = false);
    }
  };
  const func_14 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
  };
  const func_2 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
    onChange(void 0);
  };
  const func_3 = () => __async(this, null, function* () {
    onChange(parseFloat(yield navigator.clipboard.readText()));
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(0, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  return [
    selected,
    value,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    func7,
    blur_handler,
    func_14,
    func_2,
    func_3,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridNumberCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      value: 1,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 0
    });
  }
};
var GridNumberCell_default = GridNumberCell;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/TextLabel.svelte
function add_css41(target) {
  append_styles(target, "svelte-mdpwqc", "div.svelte-mdpwqc{padding:6px;width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}");
}
function create_fragment72(ctx) {
  let div;
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(ctx[0]);
      attr(div, "class", "svelte-mdpwqc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance72($$self, $$props, $$invalidate) {
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value];
}
var TextLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance72, create_fragment72, safe_not_equal, { value: 0 }, add_css41);
  }
};
var TextLabel_default = TextLabel;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/GridTextCell.svelte
function create_read_slot4(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      slot: "read",
      value: ctx[0] || ""
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx2[0] || "";
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_edit_slot4(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      autoFocus: true,
      slot: "edit",
      value: ctx[0] || "",
      embed: true,
      width: "100%"
    }
  });
  textinput.$on("input", ctx[7]);
  textinput.$on("blur", ctx[8]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0] || "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment73(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[12](value);
  }
  function gridcell_selected_binding(value) {
    ctx[13](value);
  }
  let gridcell_props = {
    column: ctx[3],
    rowindex: ctx[4],
    colindex: ctx[5],
    onCopy: ctx[9],
    onCut: ctx[10],
    onPaste: ctx[11],
    $$slots: {
      edit: [create_edit_slot4],
      read: [create_read_slot4]
    },
    $$scope: { ctx }
  };
  if (ctx[6] !== void 0) {
    gridcell_props.edit = ctx[6];
  }
  if (ctx[1] !== void 0) {
    gridcell_props.selected = ctx[1];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on("mousedown", ctx[14]);
  gridcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.column = ctx2[3];
      if (dirty & 16)
        gridcell_changes.rowindex = ctx2[4];
      if (dirty & 32)
        gridcell_changes.colindex = ctx2[5];
      if (dirty & 1)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 5)
        gridcell_changes.onCut = ctx2[10];
      if (dirty & 4)
        gridcell_changes.onPaste = ctx2[11];
      if (dirty & 65607) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & 64) {
        updating_edit = true;
        gridcell_changes.edit = ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & 2) {
        updating_selected = true;
        gridcell_changes.selected = ctx2[1];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance73($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const input_handler = ({ detail }) => $$invalidate(0, value = detail);
  const blur_handler = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(1, selected = false);
      $$invalidate(6, edit = false);
    }
    onChange(value);
  };
  const func7 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
  };
  const func_14 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
    onChange(void 0);
  };
  const func_2 = () => __async(this, null, function* () {
    onChange(yield navigator.clipboard.readText());
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(1, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
  };
  return [
    value,
    selected,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    input_handler,
    blur_handler,
    func7,
    func_14,
    func_2,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridTextCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      value: 0,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 1
    });
  }
};
var GridTextCell_default = GridTextCell;

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/GridLinkCell.svelte
var import_obsidian31 = __toModule(require("obsidian"));

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/LinkLabel.svelte
function add_css42(target) {
  append_styles(target, "svelte-1r2cjw9", "div.svelte-1r2cjw9{padding:6px;width:100%}");
}
function create_if_block21(ctx) {
  let internallink;
  let current;
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[0].linkText,
      sourcePath: ctx[0].sourcePath,
      resolved: !!ctx[1].metadataCache.getFirstLinkpathDest(ctx[0].linkText, ctx[0].sourcePath),
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", ctx[2]);
  return {
    c() {
      create_component(internallink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const internallink_changes = {};
      if (dirty & 1)
        internallink_changes.linkText = ctx2[0].linkText;
      if (dirty & 1)
        internallink_changes.sourcePath = ctx2[0].sourcePath;
      if (dirty & 3)
        internallink_changes.resolved = !!ctx2[1].metadataCache.getFirstLinkpathDest(ctx2[0].linkText, ctx2[0].sourcePath);
      if (dirty & 9) {
        internallink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
    }
  };
}
function create_default_slot20(ctx) {
  var _a;
  let t_value = ((_a = ctx[0].displayName) != null ? _a : ctx[0].linkText) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 1 && t_value !== (t_value = ((_a2 = ctx2[0].displayName) != null ? _a2 : ctx2[0].linkText) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment74(ctx) {
  let div;
  let current;
  let if_block = ctx[0] && create_if_block21(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "svelte-1r2cjw9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance74($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { value } = $$props;
  const open_handler = ({ detail: { linkText, sourcePath, newLeaf } }) => {
    $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, $app, open_handler];
}
var LinkLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance74, create_fragment74, safe_not_equal, { value: 0 }, add_css42);
  }
};
var LinkLabel_default = LinkLabel;

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/GridLinkCell.svelte
function create_if_block_111(ctx) {
  let linklabel;
  let current;
  linklabel = new LinkLabel_default({ props: { value: ctx[0] } });
  return {
    c() {
      create_component(linklabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(linklabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const linklabel_changes = {};
      if (dirty & 1)
        linklabel_changes.value = ctx2[0];
      linklabel.$set(linklabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(linklabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(linklabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(linklabel, detaching);
    }
  };
}
function create_read_slot5(ctx) {
  let show_if = isOptionalLink(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_111(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isOptionalLink(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_111(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block22(ctx) {
  var _a, _b;
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getNotesInFolder(ctx[7].vault.getRoot()),
      value: (_b = (_a = ctx[0]) == null ? void 0 : _a.linkText) != null ? _b : "",
      embed: true,
      autoFocus: true,
      width: "100%",
      getLabel: ctx[9],
      getDescription: func_12
    }
  });
  fileautocomplete.$on("blur", ctx[10]);
  fileautocomplete.$on("change", ctx[11]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const fileautocomplete_changes = {};
      if (dirty & 128)
        fileautocomplete_changes.files = getNotesInFolder(ctx2[7].vault.getRoot());
      if (dirty & 1)
        fileautocomplete_changes.value = (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.linkText) != null ? _b2 : "";
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_edit_slot5(ctx) {
  let show_if = isOptionalLink(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block22(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isOptionalLink(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment75(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      edit: ctx[6],
      onEditChange: ctx[12],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot5],
        read: [create_read_slot5]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[13]);
  gridcell.$on("navigate", ctx[14]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 64)
        gridcell_changes.edit = ctx2[6];
      if (dirty & 64)
        gridcell_changes.onEditChange = ctx2[12];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 32963) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
var func_12 = (file) => file.path.split("/").slice(0, -1).join("/");
function instance75($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  const sourcePath = getContext("sourcePath");
  let edit = false;
  const func7 = (file) => file instanceof import_obsidian31.TFile ? file.basename : "";
  const blur_handler = () => {
    $$invalidate(6, edit = false);
  };
  const change_handler = ({ detail: linkText }) => {
    onChange(linkText ? { linkText, sourcePath } : void 0);
  };
  const func_2 = (value2) => $$invalidate(6, edit = value2);
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    edit,
    $app,
    sourcePath,
    func7,
    blur_handler,
    change_handler,
    func_2,
    mousedown_handler,
    navigate_handler
  ];
}
var GridLinkCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridLinkCell_default = GridLinkCell;

// src/views/Table/components/DataGrid/GridCell/GridListCell/GridListCell.svelte
function create_read_slot6(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "read",
      edit: false,
      values: (_a = ctx[0]) != null ? _a : []
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 1)
        taglist_changes.values = (_a2 = ctx2[0]) != null ? _a2 : [];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_edit_slot6(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "edit",
      edit: true,
      values: (_a = ctx[0]) != null ? _a : [],
      onChange: ctx[1]
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 1)
        taglist_changes.values = (_a2 = ctx2[0]) != null ? _a2 : [];
      if (dirty & 2)
        taglist_changes.onChange = ctx2[1];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_fragment76(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot6],
        read: [create_read_slot6]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[6]);
  gridcell.$on("navigate", ctx[7]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 259) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance76($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler
  ];
}
var GridListCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance76, create_fragment76, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridListCell_default = GridListCell;

// src/views/Table/components/DataGrid/GridCell/GridTypedCell.svelte
function create_else_block7(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: ctx[3],
      selected: ctx[5],
      colindex: ctx[4],
      column: ctx[2]
    }
  });
  gridcell.$on("mousedown", ctx[18]);
  gridcell.$on("navigate", ctx[19]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let gridlistcell;
  let current;
  gridlistcell = new GridListCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridlistcell.$on("mousedown", ctx[16]);
  gridlistcell.$on("navigate", ctx[17]);
  return {
    c() {
      create_component(gridlistcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridlistcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridlistcell_changes = {};
      if (dirty & 32)
        gridlistcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridlistcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridlistcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridlistcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridlistcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridlistcell_changes.column = ctx2[2];
      gridlistcell.$set(gridlistcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridlistcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridlistcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridlistcell, detaching);
    }
  };
}
function create_if_block_43(ctx) {
  let gridlinkcell;
  let current;
  gridlinkcell = new GridLinkCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridlinkcell.$on("mousedown", ctx[14]);
  gridlinkcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridlinkcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridlinkcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridlinkcell_changes = {};
      if (dirty & 32)
        gridlinkcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridlinkcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridlinkcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridlinkcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridlinkcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridlinkcell_changes.column = ctx2[2];
      gridlinkcell.$set(gridlinkcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridlinkcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridlinkcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridlinkcell, detaching);
    }
  };
}
function create_if_block_35(ctx) {
  let griddatecell;
  let current;
  griddatecell = new GridDateCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  griddatecell.$on("mousedown", ctx[12]);
  griddatecell.$on("navigate", ctx[13]);
  return {
    c() {
      create_component(griddatecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(griddatecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const griddatecell_changes = {};
      if (dirty & 32)
        griddatecell_changes.selected = ctx2[5];
      if (dirty & 8)
        griddatecell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        griddatecell_changes.colindex = ctx2[4];
      if (dirty & 1)
        griddatecell_changes.value = ctx2[0];
      if (dirty & 2)
        griddatecell_changes.onChange = ctx2[1];
      if (dirty & 4)
        griddatecell_changes.column = ctx2[2];
      griddatecell.$set(griddatecell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(griddatecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(griddatecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(griddatecell, detaching);
    }
  };
}
function create_if_block_26(ctx) {
  let gridnumbercell;
  let current;
  gridnumbercell = new GridNumberCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridnumbercell.$on("mousedown", ctx[10]);
  gridnumbercell.$on("navigate", ctx[11]);
  return {
    c() {
      create_component(gridnumbercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridnumbercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridnumbercell_changes = {};
      if (dirty & 32)
        gridnumbercell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridnumbercell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridnumbercell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridnumbercell_changes.value = ctx2[0];
      if (dirty & 2)
        gridnumbercell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridnumbercell_changes.column = ctx2[2];
      gridnumbercell.$set(gridnumbercell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridnumbercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridnumbercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridnumbercell, detaching);
    }
  };
}
function create_if_block_112(ctx) {
  let gridbooleancell;
  let current;
  gridbooleancell = new GridBooleanCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridbooleancell.$on("mousedown", ctx[8]);
  gridbooleancell.$on("navigate", ctx[9]);
  return {
    c() {
      create_component(gridbooleancell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridbooleancell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridbooleancell_changes = {};
      if (dirty & 32)
        gridbooleancell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridbooleancell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridbooleancell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridbooleancell_changes.value = ctx2[0];
      if (dirty & 2)
        gridbooleancell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridbooleancell_changes.column = ctx2[2];
      gridbooleancell.$set(gridbooleancell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridbooleancell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridbooleancell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridbooleancell, detaching);
    }
  };
}
function create_if_block23(ctx) {
  let gridtextcell;
  let current;
  gridtextcell = new GridTextCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridtextcell.$on("mousedown", ctx[6]);
  gridtextcell.$on("navigate", ctx[7]);
  return {
    c() {
      create_component(gridtextcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridtextcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridtextcell_changes = {};
      if (dirty & 32)
        gridtextcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridtextcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridtextcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridtextcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridtextcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridtextcell_changes.column = ctx2[2];
      gridtextcell.$set(gridtextcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtextcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtextcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridtextcell, detaching);
    }
  };
}
function create_fragment77(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let show_if_5;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block23,
    create_if_block_112,
    create_if_block_26,
    create_if_block_35,
    create_if_block_43,
    create_if_block_52,
    create_else_block7
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 5)
      show_if = null;
    if (dirty & 5)
      show_if_1 = null;
    if (dirty & 5)
      show_if_2 = null;
    if (dirty & 5)
      show_if_3 = null;
    if (dirty & 5)
      show_if_4 = null;
    if (dirty & 5)
      show_if_5 = null;
    if (show_if == null)
      show_if = !!(ctx2[2].type === "string" && isOptionalString(ctx2[0]));
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!(ctx2[2].type === "boolean" && isOptionalBoolean(ctx2[0]));
    if (show_if_1)
      return 1;
    if (show_if_2 == null)
      show_if_2 = !!(ctx2[2].type === "number" && isOptionalNumber(ctx2[0]));
    if (show_if_2)
      return 2;
    if (show_if_3 == null)
      show_if_3 = !!(ctx2[2].type === "date" && isOptionalDate(ctx2[0]));
    if (show_if_3)
      return 3;
    if (show_if_4 == null)
      show_if_4 = !!(ctx2[2].type === "link" && isOptionalLink(ctx2[0]));
    if (show_if_4)
      return 4;
    if (show_if_5 == null)
      show_if_5 = !!(ctx2[2].type === "list" && isOptionalList(ctx2[0]));
    if (show_if_5)
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance77($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler,
    mousedown_handler_1,
    navigate_handler_1,
    mousedown_handler_2,
    navigate_handler_2,
    mousedown_handler_3,
    navigate_handler_3,
    mousedown_handler_4,
    navigate_handler_4,
    mousedown_handler_5,
    navigate_handler_5,
    mousedown_handler_6,
    navigate_handler_6
  ];
}
var GridTypedCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance77, create_fragment77, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridTypedCell_default = GridTypedCell;

// src/views/Table/components/DataGrid/data-grid.ts
function fieldIcon(field) {
  switch (field) {
    case DataFieldType.String:
      return "text";
    case DataFieldType.Number:
      return "hash";
    case DataFieldType.Boolean:
      return "check";
    case DataFieldType.Date:
      return "calendar-days";
    case DataFieldType.Link:
      return "link";
    case DataFieldType.List:
      return "list";
  }
  return "alert-triangle";
}
function sortRows(rows, sortModel) {
  return rows.sort((a2, b2) => {
    let aval = a2.row[sortModel.field];
    let bval = b2.row[sortModel.field];
    const isAsc = sortModel.sort === "asc";
    if (!aval && bval)
      return isAsc ? 1 : -1;
    if (aval && !bval)
      return isAsc ? -1 : 1;
    if (!aval && !bval)
      return 0;
    if (isNumber(aval) && isNumber(bval)) {
      if (aval < bval) {
        return isAsc ? -1 : 1;
      } else if (aval > bval) {
        return isAsc ? 1 : -1;
      } else {
        return 0;
      }
    }
    aval = aval.toString().toLocaleLowerCase();
    bval = bval.toString().toLocaleLowerCase();
    if (aval < bval) {
      return isAsc ? -1 : 1;
    } else if (aval > bval) {
      return isAsc ? 1 : -1;
    } else {
      return 0;
    }
  });
}
function sortColumns(columns) {
  return columns.sort((a2, b2) => {
    var _a, _b;
    let left2 = (_a = a2.weight) != null ? _a : 9999;
    let right2 = (_b = b2.weight) != null ? _b : 9999;
    if (left2 < right2) {
      return -1;
    } else if (left2 > right2) {
      return 1;
    } else {
      return 0;
    }
  });
}
function menuOnContextMenu(event, menu) {
  const contextMenuFunc = (event2) => {
    window.removeEventListener("contextmenu", contextMenuFunc);
    event2.preventDefault();
    event2.stopPropagation();
    menu.showAtMouseEvent(event2);
  };
  window.addEventListener("contextmenu", contextMenuFunc, false);
}

// src/views/Table/components/DataGrid/GridCellGroup.svelte
function add_css43(target) {
  append_styles(target, "svelte-11yy4d1", "div.svelte-11yy4d1{display:flex}.header.svelte-11yy4d1{position:sticky;top:0;z-index:10}");
}
function create_fragment78(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "role", "row");
      attr(div, "aria-rowindex", ctx[0]);
      attr(div, "class", "svelte-11yy4d1");
      toggle_class(div, "header", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseover", ctx[4]),
          listen(div, "focus", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(div, "aria-rowindex", ctx2[0]);
      }
      if (!current || dirty & 2) {
        toggle_class(div, "header", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { index } = $$props;
  let { header = false } = $$props;
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(0, index = $$props2.index);
    if ("header" in $$props2)
      $$invalidate(1, header = $$props2.header);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [index, header, $$scope, slots, mouseover_handler, focus_handler];
}
var GridCellGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance78, create_fragment78, safe_not_equal, { index: 0, header: 1 }, add_css43);
  }
};
var GridCellGroup_default = GridCellGroup;

// src/views/Table/components/DataGrid/GridHeader.svelte
function get_each_context11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  child_ctx[10] = i2;
  return child_ctx;
}
function create_read_slot7(ctx) {
  var _a, _b;
  let icon;
  let t0;
  let textlabel;
  let t1;
  let iconbutton;
  let t22;
  let current;
  icon = new Icon_default({
    props: {
      name: fieldIcon((_a = ctx[8].type) != null ? _a : DataFieldType.Unknown),
      tooltip: (_b = get_store_value(i18n).t(`data-types.${ctx[8].type}`)) != null ? _b : ""
    }
  });
  textlabel = new TextLabel_default({
    props: { value: ctx[8].field }
  });
  iconbutton = new IconButton_default({
    props: { size: "sm", icon: "vertical-three-dots" }
  });
  iconbutton.$on("click", function() {
    if (is_function(ctx[4](ctx[8])))
      ctx[4](ctx[8]).apply(this, arguments);
  });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      create_component(textlabel.$$.fragment);
      t1 = space();
      create_component(iconbutton.$$.fragment);
      t22 = space();
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      mount_component(textlabel, target, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      insert(target, t22, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2, _b2;
      ctx = new_ctx;
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.name = fieldIcon((_a2 = ctx[8].type) != null ? _a2 : DataFieldType.Unknown);
      if (dirty & 1)
        icon_changes.tooltip = (_b2 = get_store_value(i18n).t(`data-types.${ctx[8].type}`)) != null ? _b2 : "";
      icon.$set(icon_changes);
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx[8].field;
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(textlabel.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(textlabel.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      destroy_component(textlabel, detaching);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
      if (detaching)
        detach(t22);
    }
  };
}
function create_each_block11(ctx) {
  let gridcell;
  let current;
  function func7(...args) {
    return ctx[6](ctx[8], ...args);
  }
  function func_14(...args) {
    return ctx[7](ctx[8], ...args);
  }
  gridcell = new GridCell_default({
    props: {
      colindex: ctx[10] + 2,
      rowindex: 1,
      column: ctx[8],
      resizable: true,
      onResize: func7,
      onFinalizeResize: func_14,
      columnHeader: true,
      $$slots: { read: [create_read_slot7] },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", function() {
    if (is_function(ctx[3](ctx[8])))
      ctx[3](ctx[8]).apply(this, arguments);
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridcell_changes = {};
      if (dirty & 1)
        gridcell_changes.column = ctx[8];
      if (dirty & 3)
        gridcell_changes.onResize = func7;
      if (dirty & 5)
        gridcell_changes.onFinalizeResize = func_14;
      if (dirty & 2049) {
        gridcell_changes.$$scope = { dirty, ctx };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function create_default_slot21(ctx) {
  let gridcell;
  let t3;
  let each_1_anchor;
  let current;
  gridcell = new GridCell_default({
    props: {
      colindex: 1,
      rowindex: 1,
      column: {
        field: "",
        width: 60,
        header: true,
        editable: false
      },
      columnHeader: true,
      rowHeader: true
    }
  });
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block11(get_each_context11(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 31) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block11(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment79(ctx) {
  let gridcellgroup;
  let current;
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: 1,
      header: true,
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(gridcellgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcellgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcellgroup_changes = {};
      if (dirty & 2055) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcellgroup, detaching);
    }
  };
}
function instance79($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { onResize } = $$props;
  let { onFinalizeResize } = $$props;
  let { onColumnMenu } = $$props;
  function handleColumnHeaderClick(column) {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onColumnMenu(column));
      }
    };
  }
  function handleFieldClick(column) {
    return (event) => {
      onColumnMenu(column).showAtMouseEvent(event);
    };
  }
  const func7 = (column, width) => {
    onResize(column.field, width);
  };
  const func_14 = (column, width) => {
    onFinalizeResize(column.field, width);
  };
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("onResize" in $$props2)
      $$invalidate(1, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(2, onFinalizeResize = $$props2.onFinalizeResize);
    if ("onColumnMenu" in $$props2)
      $$invalidate(5, onColumnMenu = $$props2.onColumnMenu);
  };
  return [
    columns,
    onResize,
    onFinalizeResize,
    handleColumnHeaderClick,
    handleFieldClick,
    onColumnMenu,
    func7,
    func_14
  ];
}
var GridHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance79, create_fragment79, safe_not_equal, {
      columns: 0,
      onResize: 1,
      onFinalizeResize: 2,
      onColumnMenu: 5
    });
  }
};
var GridHeader_default = GridHeader;

// src/views/Table/components/DataGrid/GridRow.svelte
var import_obsidian34 = __toModule(require("obsidian"));
function get_each_context12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[17] = i2;
  return child_ctx;
}
function create_read_slot8(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      slot: "read",
      value: (ctx[1] - 1).toString()
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 2)
        textlabel_changes.value = (ctx2[1] - 1).toString();
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_hover_slot(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: { slot: "hover", icon: "link", size: "sm" }
  });
  iconbutton.$on("click", function() {
    if (is_function(ctx[6]))
      ctx[6].apply(this, arguments);
  });
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block12(ctx) {
  let gridtypedcell;
  let current;
  function func7(...args) {
    return ctx[12](ctx[15], ...args);
  }
  gridtypedcell = new GridTypedCell_default({
    props: {
      selected: ctx[4][0] === ctx[17] + 2 && ctx[4][1] === ctx[1] + 2,
      rowindex: ctx[1] + 2,
      colindex: ctx[17] + 2,
      value: ctx[2][ctx[15].field],
      column: ctx[15],
      onChange: func7
    }
  });
  gridtypedcell.$on("mousedown", function() {
    if (is_function(ctx[8](ctx[15], ctx[2][ctx[15].field])))
      ctx[8](ctx[15], ctx[2][ctx[15].field]).apply(this, arguments);
  });
  gridtypedcell.$on("navigate", ctx[13]);
  return {
    c() {
      create_component(gridtypedcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridtypedcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridtypedcell_changes = {};
      if (dirty & 18)
        gridtypedcell_changes.selected = ctx[4][0] === ctx[17] + 2 && ctx[4][1] === ctx[1] + 2;
      if (dirty & 2)
        gridtypedcell_changes.rowindex = ctx[1] + 2;
      if (dirty & 12)
        gridtypedcell_changes.value = ctx[2][ctx[15].field];
      if (dirty & 8)
        gridtypedcell_changes.column = ctx[15];
      if (dirty & 45)
        gridtypedcell_changes.onChange = func7;
      gridtypedcell.$set(gridtypedcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtypedcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtypedcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridtypedcell, detaching);
    }
  };
}
function create_default_slot22(ctx) {
  let gridcell;
  let t3;
  let each_1_anchor;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: 1,
      colindex: 1,
      column: {
        field: "",
        header: true,
        width: 60,
        editable: false
      },
      rowHeader: true,
      $$slots: {
        hover: [create_hover_slot],
        read: [create_read_slot8]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[7]());
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block12(get_each_context12(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & 262210) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
      if (dirty & 319) {
        each_value = ctx2[3];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block12(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment80(ctx) {
  let gridcellgroup;
  let current;
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: ctx[1],
      $$slots: { default: [create_default_slot22] },
      $$scope: { ctx }
    }
  });
  gridcellgroup.$on("mouseover", ctx[9]);
  return {
    c() {
      create_component(gridcellgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcellgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcellgroup_changes = {};
      if (dirty & 2)
        gridcellgroup_changes.index = ctx2[1];
      if (dirty & 262271) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcellgroup, detaching);
    }
  };
}
function instance80($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(14, $app = $$value));
  let { rowId } = $$props;
  let { index } = $$props;
  let { row } = $$props;
  let { columns } = $$props;
  let { activeCell } = $$props;
  setContext("sourcePath", row["path"]);
  let { onRowChange } = $$props;
  let { onRowMenu } = $$props;
  let { onCellMenu } = $$props;
  let { onNavigate } = $$props;
  function handleHeaderClick() {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onRowMenu(rowId, row));
      }
    };
  }
  function handleCellClick(column, value) {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onCellMenu(rowId, column, value));
      }
      if (event.target instanceof HTMLTableCellElement) {
        if (event.target.firstChild instanceof HTMLInputElement) {
          event.target.firstChild.focus();
          event.preventDefault();
        }
      }
    };
  }
  function handleHoverLink(event) {
    if (!event.ctrlKey && !event.metaKey) {
      return;
    }
    const targetEl = event.target;
    if (targetEl instanceof HTMLDivElement) {
      const file = $app.vault.getAbstractFileByPath(rowId);
      if (file instanceof import_obsidian34.TFile) {
        $app.workspace.trigger("hover-link", {
          event,
          source: "obsidian-projects-table-view",
          hoverParent: targetEl.parentElement,
          targetEl,
          linktext: file.name,
          sourcePath: file.path
        });
      }
    }
  }
  const func7 = (column, value) => {
    onRowChange(rowId, immer_esm_default(row, (draft) => {
      draft[column.field] = value;
      return draft;
    }));
  };
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rowId" in $$props2)
      $$invalidate(0, rowId = $$props2.rowId);
    if ("index" in $$props2)
      $$invalidate(1, index = $$props2.index);
    if ("row" in $$props2)
      $$invalidate(2, row = $$props2.row);
    if ("columns" in $$props2)
      $$invalidate(3, columns = $$props2.columns);
    if ("activeCell" in $$props2)
      $$invalidate(4, activeCell = $$props2.activeCell);
    if ("onRowChange" in $$props2)
      $$invalidate(5, onRowChange = $$props2.onRowChange);
    if ("onRowMenu" in $$props2)
      $$invalidate(10, onRowMenu = $$props2.onRowMenu);
    if ("onCellMenu" in $$props2)
      $$invalidate(11, onCellMenu = $$props2.onCellMenu);
    if ("onNavigate" in $$props2)
      $$invalidate(6, onNavigate = $$props2.onNavigate);
  };
  return [
    rowId,
    index,
    row,
    columns,
    activeCell,
    onRowChange,
    onNavigate,
    handleHeaderClick,
    handleCellClick,
    handleHoverLink,
    onRowMenu,
    onCellMenu,
    func7,
    navigate_handler
  ];
}
var GridRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance80, create_fragment80, safe_not_equal, {
      rowId: 0,
      index: 1,
      row: 2,
      columns: 3,
      activeCell: 4,
      onRowChange: 5,
      onRowMenu: 10,
      onCellMenu: 11,
      onNavigate: 6
    });
  }
};
var GridRow_default = GridRow;

// src/views/Table/components/DataGrid/DataGrid.svelte
function add_css44(target) {
  append_styles(target, "svelte-w5i4x9", "div.svelte-w5i4x9{display:inline-block}span.svelte-w5i4x9{padding:4px;position:sticky;left:0}");
}
function get_each_context13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i2].rowId;
  child_ctx[33] = list[i2].row;
  child_ctx[35] = i2;
  return child_ctx;
}
function create_each_block13(ctx) {
  let gridrow;
  let current;
  function func_4(...args) {
    return ctx[28](ctx[33], ...args);
  }
  function func_5(...args) {
    return ctx[29](ctx[32], ...args);
  }
  gridrow = new GridRow_default({
    props: {
      columns: ctx[9],
      index: ctx[35] + 2,
      rowId: ctx[32],
      row: ctx[33],
      activeCell: ctx[6],
      onRowChange: ctx[4],
      onRowMenu: ctx[27],
      onCellMenu: func_4,
      onNavigate: func_5
    }
  });
  gridrow.$on("navigate", ctx[30]);
  return {
    c() {
      create_component(gridrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridrow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridrow_changes = {};
      if (dirty[0] & 512)
        gridrow_changes.columns = ctx[9];
      if (dirty[0] & 256)
        gridrow_changes.rowId = ctx[32];
      if (dirty[0] & 256)
        gridrow_changes.row = ctx[33];
      if (dirty[0] & 64)
        gridrow_changes.activeCell = ctx[6];
      if (dirty[0] & 16)
        gridrow_changes.onRowChange = ctx[4];
      if (dirty[0] & 256)
        gridrow_changes.onCellMenu = func_4;
      if (dirty[0] & 288)
        gridrow_changes.onNavigate = func_5;
      gridrow.$set(gridrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridrow, detaching);
    }
  };
}
function create_if_block24(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_113] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[31]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & 128 | dirty[1] & 32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_113(ctx) {
  let icon;
  let t0;
  let t1_value = ctx[7]("components.data-grid.row.add") + "";
  let t1;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 128) && t1_value !== (t1_value = ctx2[7]("components.data-grid.row.add") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot23(ctx) {
  let span;
  let span_style_value;
  let current;
  let if_block = !ctx[1] && create_if_block24(ctx);
  return {
    c() {
      var _a, _b;
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "style", span_style_value = `width: ${60 + ((_b = (_a = ctx[9][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`);
      attr(span, "class", "svelte-w5i4x9");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a, _b;
      if (!ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 512 && span_style_value !== (span_style_value = `width: ${60 + ((_b = (_a = ctx2[9][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`)) {
        attr(span, "style", span_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment81(ctx) {
  let div;
  let gridheader;
  let t0;
  let t1;
  let gridcellgroup;
  let div_aria_colcount_value;
  let div_aria_rowcount_value;
  let current;
  gridheader = new GridHeader_default({
    props: {
      columns: ctx[9],
      onResize: ctx[24],
      onFinalizeResize: ctx[25],
      onColumnMenu: ctx[26]
    }
  });
  let each_value = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block13(get_each_context13(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: ctx[8].length + 2,
      $$slots: { default: [create_default_slot23] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(gridheader.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(gridcellgroup.$$.fragment);
      attr(div, "role", "grid");
      attr(div, "aria-colcount", div_aria_colcount_value = ctx[9].length + 1);
      attr(div, "aria-rowcount", div_aria_rowcount_value = ctx[8].length + 2);
      attr(div, "class", "svelte-w5i4x9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(gridheader, div, null);
      append(div, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      append(div, t1);
      mount_component(gridcellgroup, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const gridheader_changes = {};
      if (dirty[0] & 512)
        gridheader_changes.columns = ctx2[9];
      if (dirty[0] & 1)
        gridheader_changes.onResize = ctx2[24];
      if (dirty[0] & 4)
        gridheader_changes.onFinalizeResize = ctx2[25];
      gridheader.$set(gridheader_changes);
      if (dirty[0] & 15216) {
        each_value = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context13(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block13(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const gridcellgroup_changes = {};
      if (dirty[0] & 256)
        gridcellgroup_changes.index = ctx2[8].length + 2;
      if (dirty[0] & 650 | dirty[1] & 32) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
      if (!current || dirty[0] & 512 && div_aria_colcount_value !== (div_aria_colcount_value = ctx2[9].length + 1)) {
        attr(div, "aria-colcount", div_aria_colcount_value);
      }
      if (!current || dirty[0] & 256 && div_aria_rowcount_value !== (div_aria_rowcount_value = ctx2[8].length + 2)) {
        attr(div, "aria-rowcount", div_aria_rowcount_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(gridheader);
      destroy_each(each_blocks, detaching);
      destroy_component(gridcellgroup);
    }
  };
}
function instance81($$self, $$props, $$invalidate) {
  let t3;
  let visibleColumns;
  let sortedColumns;
  let sortedRows;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(23, $i18n = $$value));
  let { columns } = $$props;
  let { rows } = $$props;
  let { sortModel } = $$props;
  let { readonly } = $$props;
  let { onSortModelChange } = $$props;
  let { onColumnResize } = $$props;
  let { onRowAdd } = $$props;
  let { onRowChange } = $$props;
  let { onRowNavigate } = $$props;
  let { onColumnRename } = $$props;
  let { onColumnDelete } = $$props;
  let { onColumnHide } = $$props;
  let { onRowDelete } = $$props;
  let { onRowEdit } = $$props;
  let activeCell = [3, 3];
  function createColumnMenu(column) {
    const menu = new import_obsidian36.Menu();
    if (column.editable && !readonly) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.column.rename")).setIcon("edit").onClick(() => onColumnRename(column.field));
      });
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.column.delete")).setIcon("trash").onClick(() => onColumnDelete(column.field));
      });
      menu.addSeparator();
    }
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.sort.asc")).setIcon("sort-asc").onClick(() => onSortModelChange(column.field, "asc"));
    });
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.sort.desc")).setIcon("sort-desc").onClick(() => onSortModelChange(column.field, "desc"));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.column.hide")).setIcon("eye-off").onClick(() => {
        onColumnHide(column);
      });
    });
    return menu;
  }
  function createRowMenu(rowId, row) {
    const menu = new import_obsidian36.Menu();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.row.edit")).setIcon("edit").onClick(() => onRowEdit(rowId, row));
    });
    if (!readonly) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.row.delete")).setIcon("trash").onClick(() => onRowDelete(rowId));
      });
    }
    return menu;
  }
  function createCellMenu(rowId, row, column) {
    const menu = new import_obsidian36.Menu();
    if (column.editable) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.cell.clear")).setIcon("x").onClick(() => {
          onRowChange(rowId, immer_esm_default(row, (draft) => {
            draft[column.field] = null;
            return draft;
          }));
        });
      });
    }
    return menu;
  }
  const clamp = (num, min2, max2) => Math.min(Math.max(num, min2), max2);
  const func7 = (name, width) => {
    $$invalidate(0, columns = columns.map((column) => column.field === name ? __spreadProps(__spreadValues({}, column), { width }) : column));
  };
  const func_14 = (name, width) => {
    onColumnResize(name, width);
  };
  const func_2 = (field) => createColumnMenu(field);
  const func_3 = (rowId, row) => createRowMenu(rowId, row);
  const func_4 = (row, rowId, column) => createCellMenu(rowId, row, column);
  const func_5 = (rowId, event) => onRowNavigate(rowId, event.ctrlKey || event.metaKey);
  const navigate_handler = ({ detail: cell }) => {
    $$invalidate(6, activeCell = [
      clamp(cell[0], 2, sortedColumns.length + 1),
      clamp(cell[1], 4, sortedRows.length + 3)
    ]);
  };
  const click_handler = () => onRowAdd();
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("rows" in $$props2)
      $$invalidate(14, rows = $$props2.rows);
    if ("sortModel" in $$props2)
      $$invalidate(15, sortModel = $$props2.sortModel);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("onSortModelChange" in $$props2)
      $$invalidate(16, onSortModelChange = $$props2.onSortModelChange);
    if ("onColumnResize" in $$props2)
      $$invalidate(2, onColumnResize = $$props2.onColumnResize);
    if ("onRowAdd" in $$props2)
      $$invalidate(3, onRowAdd = $$props2.onRowAdd);
    if ("onRowChange" in $$props2)
      $$invalidate(4, onRowChange = $$props2.onRowChange);
    if ("onRowNavigate" in $$props2)
      $$invalidate(5, onRowNavigate = $$props2.onRowNavigate);
    if ("onColumnRename" in $$props2)
      $$invalidate(17, onColumnRename = $$props2.onColumnRename);
    if ("onColumnDelete" in $$props2)
      $$invalidate(18, onColumnDelete = $$props2.onColumnDelete);
    if ("onColumnHide" in $$props2)
      $$invalidate(19, onColumnHide = $$props2.onColumnHide);
    if ("onRowDelete" in $$props2)
      $$invalidate(20, onRowDelete = $$props2.onRowDelete);
    if ("onRowEdit" in $$props2)
      $$invalidate(21, onRowEdit = $$props2.onRowEdit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388608) {
      $:
        $$invalidate(7, t3 = $i18n.t);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(22, visibleColumns = columns.filter((column) => !column.hide));
    }
    if ($$self.$$.dirty[0] & 4194304) {
      $:
        $$invalidate(9, sortedColumns = sortColumns(visibleColumns));
    }
    if ($$self.$$.dirty[0] & 49152) {
      $:
        $$invalidate(8, sortedRows = sortRows(rows, sortModel));
    }
  };
  return [
    columns,
    readonly,
    onColumnResize,
    onRowAdd,
    onRowChange,
    onRowNavigate,
    activeCell,
    t3,
    sortedRows,
    sortedColumns,
    createColumnMenu,
    createRowMenu,
    createCellMenu,
    clamp,
    rows,
    sortModel,
    onSortModelChange,
    onColumnRename,
    onColumnDelete,
    onColumnHide,
    onRowDelete,
    onRowEdit,
    visibleColumns,
    $i18n,
    func7,
    func_14,
    func_2,
    func_3,
    func_4,
    func_5,
    navigate_handler,
    click_handler
  ];
}
var DataGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance81, create_fragment81, safe_not_equal, {
      columns: 0,
      rows: 14,
      sortModel: 15,
      readonly: 1,
      onSortModelChange: 16,
      onColumnResize: 2,
      onRowAdd: 3,
      onRowChange: 4,
      onRowNavigate: 5,
      onColumnRename: 17,
      onColumnDelete: 18,
      onColumnHide: 19,
      onRowDelete: 20,
      onRowEdit: 21
    }, add_css44, [-1, -1]);
  }
};
var DataGrid_default = DataGrid;

// src/views/Table/components/SwitchSelect/SwitchSelect.svelte
function add_css45(target) {
  append_styles(target, "svelte-mhc3z6", "div.svelte-mhc3z6{align-items:center;display:inline-flex;text-align:start}");
}
function get_each_context14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2].label;
  child_ctx[9] = list[i2].value;
  child_ctx[10] = list[i2].enabled;
  return child_ctx;
}
function create_each_block14(ctx) {
  let menuitem;
  let current;
  function check_handler(...args) {
    return ctx[7](ctx[9], ...args);
  }
  menuitem = new MenuItem_default({
    props: {
      label: ctx[2],
      checked: ctx[10]
    }
  });
  menuitem.$on("check", check_handler);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1)
        menuitem_changes.label = ctx[2];
      if (dirty & 1)
        menuitem_changes.checked = ctx[10];
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot24(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block14(get_each_context14(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block14(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment82(ctx) {
  let div;
  let t0;
  let t1;
  let menu;
  let current;
  let mounted;
  let dispose;
  menu = new Menu_default({
    props: {
      anchorEl: ctx[3],
      open: ctx[4],
      onClose: ctx[8],
      $$slots: { default: [create_default_slot24] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      t0 = text(ctx[2]);
      t1 = space();
      create_component(menu.$$.fragment);
      attr(div, "class", "dropdown svelte-mhc3z6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      ctx[5](div);
      insert(target, t1, anchor);
      mount_component(menu, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t0, ctx2[2]);
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.anchorEl = ctx2[3];
      if (dirty & 16)
        menu_changes.open = ctx2[4];
      if (dirty & 16)
        menu_changes.onClose = ctx2[8];
      if (dirty & 8195) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[5](null);
      if (detaching)
        detach(t1);
      destroy_component(menu, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance82($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { label } = $$props;
  let { onChange } = $$props;
  let ref;
  let isOpen = false;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler = () => $$invalidate(4, isOpen = true);
  const check_handler = (value, { detail: checked }) => onChange(value, checked);
  const func7 = () => $$invalidate(4, isOpen = false);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
  };
  return [
    items,
    onChange,
    label,
    ref,
    isOpen,
    div_binding,
    click_handler,
    check_handler,
    func7
  ];
}
var SwitchSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance82, create_fragment82, safe_not_equal, { items: 0, label: 2, onChange: 1 }, add_css45);
  }
};
var SwitchSelect_default = SwitchSelect;

// src/views/Table/TableView.svelte
function add_css46(target) {
  append_styles(target, "svelte-16qlac6", "div.svelte-16qlac6{overflow:auto}");
}
function create_default_slot_114(ctx) {
  let switchselect;
  let current;
  switchselect = new SwitchSelect_default({
    props: {
      label: ctx[8].t("views.table.hide-fields"),
      items: ctx[7].map(func6),
      onChange: ctx[10]
    }
  });
  return {
    c() {
      create_component(switchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switchselect_changes = {};
      if (dirty & 256)
        switchselect_changes.label = ctx2[8].t("views.table.hide-fields");
      if (dirty & 128)
        switchselect_changes.items = ctx2[7].map(func6);
      switchselect.$set(switchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switchselect, detaching);
    }
  };
}
function create_default_slot25(ctx) {
  let p2;
  let t3;
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_114] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & 33554816) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_fragment83(ctx) {
  var _a, _b, _c;
  let toolbar;
  let t3;
  let div;
  let datagrid;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot25] },
      $$scope: { ctx }
    }
  });
  datagrid = new DataGrid_default({
    props: {
      columns: ctx[7],
      rows: ctx[6],
      readonly: ctx[1],
      onRowAdd: ctx[16],
      onRowEdit: ctx[17],
      onRowDelete: ctx[18],
      onColumnHide: ctx[19],
      onColumnRename: ctx[20],
      onColumnDelete: ctx[21],
      onRowChange: ctx[22],
      onColumnResize: ctx[11],
      onRowNavigate: ctx[23],
      sortModel: {
        field: (_b = (_a = ctx[3]) == null ? void 0 : _a.sortField) != null ? _b : "name",
        sort: ((_c = ctx[3]) == null ? void 0 : _c.sortAsc) ? "asc" : "desc"
      },
      onSortModelChange: ctx[24]
    }
  });
  return {
    c() {
      create_component(toolbar.$$.fragment);
      t3 = space();
      div = element("div");
      create_component(datagrid.$$.fragment);
      attr(div, "class", "svelte-16qlac6");
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      mount_component(datagrid, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2;
      const toolbar_changes = {};
      if (dirty & 33554816) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const datagrid_changes = {};
      if (dirty & 128)
        datagrid_changes.columns = ctx2[7];
      if (dirty & 64)
        datagrid_changes.rows = ctx2[6];
      if (dirty & 2)
        datagrid_changes.readonly = ctx2[1];
      if (dirty & 517)
        datagrid_changes.onRowAdd = ctx2[16];
      if (dirty & 548)
        datagrid_changes.onRowEdit = ctx2[17];
      if (dirty & 4)
        datagrid_changes.onRowDelete = ctx2[18];
      if (dirty & 772)
        datagrid_changes.onColumnRename = ctx2[20];
      if (dirty & 4)
        datagrid_changes.onColumnDelete = ctx2[21];
      if (dirty & 36)
        datagrid_changes.onRowChange = ctx2[22];
      if (dirty & 512)
        datagrid_changes.onRowNavigate = ctx2[23];
      if (dirty & 8)
        datagrid_changes.sortModel = {
          field: (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.sortField) != null ? _b2 : "name",
          sort: ((_c2 = ctx2[3]) == null ? void 0 : _c2.sortAsc) ? "asc" : "desc"
        };
      if (dirty & 24)
        datagrid_changes.onSortModelChange = ctx2[24];
      datagrid.$set(datagrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(datagrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(datagrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_component(datagrid);
    }
  };
}
function defaultWeight(field) {
  switch (field) {
    case "name":
      return 1;
    case "path":
      return 2;
    case "Field":
      return 1;
    default:
      return void 0;
  }
}
var func6 = (column) => ({
  label: column.field,
  value: column.field,
  enabled: !column.hide
});
function instance83($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let fieldConfig;
  let columns;
  let rows;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(8, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(9, $app = $$value));
  var _a;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function handleVisibilityChange(field, enabled) {
    onConfigChange(Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { hide: !enabled })
      })
    }));
  }
  function handleWidthChange(field, width) {
    onConfigChange(Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { width })
      })
    }));
  }
  const func_14 = () => {
    new CreateNoteModal($app, project, (name, templatePath, project2) => {
      api2.addRecord(createDataRecord(name, project2), templatePath);
    }).open();
  };
  const func_2 = (id, values) => {
    new EditNoteModal($app, fields, (record) => {
      api2.updateRecord(record, fields);
    }, { id, values }).open();
  };
  const func_3 = (id) => api2.deleteRecord(id);
  const func_4 = (column) => handleVisibilityChange(column.field, false);
  const func_5 = (field) => {
    new InputDialogModal($app, $i18n.t("views.table.rename-field"), $i18n.t("views.table.rename"), (value) => {
      api2.renameField(field, value);
    }, field).open();
  };
  const func_6 = (field) => api2.deleteField(field);
  const func_7 = (rowId, row) => {
    api2.updateRecord({ id: rowId, values: row }, fields);
  };
  const func_8 = (rowId, openNew) => $app.workspace.openLinkText(rowId, "", openNew);
  const func_9 = (field, sort) => {
    onConfigChange(__spreadProps(__spreadValues({}, config), {
      sortField: field,
      sortAsc: sort === "asc"
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(12, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(2, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(4, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(5, { fields, records } = frame, fields, ($$invalidate(15, records), $$invalidate(12, frame)));
    }
    if ($$self.$$.dirty & 8200) {
      $:
        $$invalidate(14, fieldConfig = $$invalidate(13, _a = config === null || config === void 0 ? void 0 : config.fieldConfig) !== null && _a !== void 0 ? _a : {});
    }
    if ($$self.$$.dirty & 16416) {
      $:
        $$invalidate(7, columns = fields.map((field) => {
          var _a2, _b, _c, _d;
          const colDef = {
            field: field.name,
            type: field.type,
            width: (_b = (_a2 = fieldConfig[field.name]) === null || _a2 === void 0 ? void 0 : _a2.width) !== null && _b !== void 0 ? _b : 180,
            hide: (_d = (_c = fieldConfig[field.name]) === null || _c === void 0 ? void 0 : _c.hide) !== null && _d !== void 0 ? _d : false,
            editable: !field.derived
          };
          const weight = defaultWeight(field.name);
          if (weight) {
            colDef.weight = weight;
          }
          return colDef;
        }));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(6, rows = records.map(({ id, values }) => ({ rowId: id, row: values })));
    }
  };
  return [
    project,
    readonly,
    api2,
    config,
    onConfigChange,
    fields,
    rows,
    columns,
    $i18n,
    $app,
    handleVisibilityChange,
    handleWidthChange,
    frame,
    _a,
    fieldConfig,
    records,
    func_14,
    func_2,
    func_3,
    func_4,
    func_5,
    func_6,
    func_7,
    func_8,
    func_9
  ];
}
var TableView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      project: 0,
      frame: 12,
      readonly: 1,
      api: 2,
      config: 3,
      onConfigChange: 4
    }, add_css46);
  }
};
var TableView_default = TableView;

// src/views/Custom/CustomView.svelte
function add_css47(target) {
  append_styles(target, "svelte-18l8rqt", "div.svelte-18l8rqt{width:100%;height:100%;padding:var(--size-4-3)}.noPadding.svelte-18l8rqt{padding:0}");
}
function create_fragment84(ctx) {
  let div;
  let useCustomView_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "svelte-18l8rqt");
      toggle_class(div, "noPadding", ctx[0].noPadding);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useCustomView_action = ctx[3].call(null, div, {
          fields: ctx[2],
          records: ctx[1]
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useCustomView_action && is_function(useCustomView_action.update) && dirty & 6)
        useCustomView_action.update.call(null, {
          fields: ctx2[2],
          records: ctx2[1]
        });
      if (dirty & 1) {
        toggle_class(div, "noPadding", ctx2[0].noPadding);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance84($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let createView;
  let viewV2;
  let viewBuilder;
  let $customViews;
  let $customViewsV2;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(9, $customViews = $$value));
  component_subscribe($$self, customViewsV2, ($$value) => $$invalidate(10, $customViewsV2 = $$value));
  var _a;
  let { type } = $$props;
  let { frame } = $$props;
  let builder = new Builder();
  function useCustomView(node, frame2) {
    var _a2, _b, _c;
    if (viewV2) {
      viewV2.containerEl = node;
      (_a2 = viewV2.onOpen) === null || _a2 === void 0 ? void 0 : _a2.call(viewV2);
      (_b = viewV2.onData) === null || _b === void 0 ? void 0 : _b.call(viewV2, frame2);
    } else {
      (_c = builder.onOpen) === null || _c === void 0 ? void 0 : _c.call(builder, frame2, node);
    }
    return {
      update(frame3) {
        var _a3, _b2;
        if (viewV2) {
          (_a3 = viewV2.onData) === null || _a3 === void 0 ? void 0 : _a3.call(viewV2, frame3);
        } else {
          node.empty();
          (_b2 = builder.onOpen) === null || _b2 === void 0 ? void 0 : _b2.call(builder, frame3, node);
        }
      },
      destroy() {
        viewV2 === null || viewV2 === void 0 ? void 0 : viewV2.onClose();
      }
    };
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
    if ("frame" in $$props2)
      $$invalidate(5, frame = $$props2.frame);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(2, { fields, records } = frame, fields, ($$invalidate(1, records), $$invalidate(5, frame)));
    }
    if ($$self.$$.dirty & 1040) {
      $:
        $$invalidate(8, createView = $customViewsV2[type]);
    }
    if ($$self.$$.dirty & 256) {
      $:
        viewV2 = createView === null || createView === void 0 ? void 0 : createView();
    }
    if ($$self.$$.dirty & 592) {
      $:
        $$invalidate(7, viewBuilder = $$invalidate(6, _a = $customViews[type]) !== null && _a !== void 0 ? _a : () => {
        });
    }
    if ($$self.$$.dirty & 129) {
      $: {
        $$invalidate(0, builder = new Builder());
        viewBuilder(builder);
      }
    }
  };
  return [
    builder,
    records,
    fields,
    useCustomView,
    type,
    frame,
    _a,
    viewBuilder,
    createView,
    $customViews,
    $customViewsV2
  ];
}
var CustomView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance84, create_fragment84, safe_not_equal, { type: 4, frame: 5 }, add_css47);
  }
};
var CustomView_default = CustomView;

// src/views/Developer/DeveloperView.svelte
var import_obsidian38 = __toModule(require("obsidian"));
function add_css48(target) {
  append_styles(target, "svelte-qi93d1", "button.svelte-qi93d1{display:inline;width:auto}.container.svelte-qi93d1{padding:0 20%;overflow:auto}");
}
function create_default_slot_51(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Inputs");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_50(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Buttons");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_49(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Default");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_482(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Primary");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_472(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Destructive");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_462(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Plain");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_452(ctx) {
  let typography;
  let t0;
  let div;
  let button0;
  let t1;
  let button1;
  let t22;
  let button2;
  let t3;
  let button3;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_50] },
      $$scope: { ctx }
    }
  });
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_49] },
      $$scope: { ctx }
    }
  });
  button1 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_482] },
      $$scope: { ctx }
    }
  });
  button2 = new Button_default({
    props: {
      variant: "destructive",
      $$slots: { default: [create_default_slot_472] },
      $$scope: { ctx }
    }
  });
  button3 = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_462] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(button0.$$.fragment);
      t1 = space();
      create_component(button1.$$.fragment);
      t22 = space();
      create_component(button2.$$.fragment);
      t3 = space();
      create_component(button3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t1);
      mount_component(button1, div, null);
      append(div, t22);
      mount_component(button2, div, null);
      append(div, t3);
      mount_component(button3, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const button0_changes = {};
      if (dirty & 4194304) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4194304) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & 4194304) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & 4194304) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
    }
  };
}
function create_default_slot_442(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Toggles");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_432(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({ props: { checked: false } });
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_default_slot_422(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox_default({ props: { checked: false } });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot_41(ctx) {
  let typography;
  let t0;
  let settingitem0;
  let t1;
  let settingitem1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_442] },
      $$scope: { ctx }
    }
  });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Switch",
      $$slots: { default: [create_default_slot_432] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Checkbox",
      $$slots: { default: [create_default_slot_422] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      create_component(settingitem0.$$.fragment);
      t1 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const settingitem0_changes = {};
      if (dirty & 4194304) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 4194304) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_default_slot_40(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Input");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_392(ctx) {
  let textinput;
  let updating_value;
  let current;
  function textinput_value_binding(value) {
    ctx[9](value);
  }
  let textinput_props = { helperText: ctx[6] };
  if (ctx[6] !== void 0) {
    textinput_props.value = ctx[6];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 64)
        textinput_changes.helperText = ctx2[6];
      if (!updating_value && dirty & 64) {
        updating_value = true;
        textinput_changes.value = ctx2[6];
        add_flush_callback(() => updating_value = false);
      }
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_382(ctx) {
  let numberinput;
  let updating_value;
  let current;
  function numberinput_value_binding(value) {
    ctx[10](value);
  }
  let numberinput_props = {
    helperText: ctx[6],
    error: true
  };
  if (ctx[7] !== void 0) {
    numberinput_props.value = ctx[7];
  }
  numberinput = new NumberInput_default({ props: numberinput_props });
  binding_callbacks.push(() => bind(numberinput, "value", numberinput_value_binding));
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & 64)
        numberinput_changes.helperText = ctx2[6];
      if (!updating_value && dirty & 128) {
        updating_value = true;
        numberinput_changes.value = ctx2[7];
        add_flush_callback(() => updating_value = false);
      }
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_default_slot_372(ctx) {
  let dateinput;
  let current;
  dateinput = new DateInput_default({ props: { value: new Date() } });
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_default_slot_362(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: "bar",
      options: [
        { label: "Foo", value: "foo" },
        { label: "Bar", value: "bar" },
        { label: "Baz", value: "baz" }
      ]
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_352(ctx) {
  let typography;
  let t0;
  let settingitem0;
  let t1;
  let settingitem1;
  let t22;
  let settingitem2;
  let t3;
  let settingitem3;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_40] },
      $$scope: { ctx }
    }
  });
  settingitem0 = new SettingItem_default({
    props: {
      name: "TextInput",
      $$slots: { default: [create_default_slot_392] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "NumberInput",
      $$slots: { default: [create_default_slot_382] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: "DateInput",
      $$slots: { default: [create_default_slot_372] },
      $$scope: { ctx }
    }
  });
  settingitem3 = new SettingItem_default({
    props: {
      name: "Select",
      $$slots: { default: [create_default_slot_362] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      create_component(settingitem0.$$.fragment);
      t1 = space();
      create_component(settingitem1.$$.fragment);
      t22 = space();
      create_component(settingitem2.$$.fragment);
      t3 = space();
      create_component(settingitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t22, anchor);
      mount_component(settingitem2, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const settingitem0_changes = {};
      if (dirty & 4194368) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 4194496) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 4194304) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      const settingitem3_changes = {};
      if (dirty & 4194304) {
        settingitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem3.$set(settingitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(settingitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(settingitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t22);
      destroy_component(settingitem2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem3, detaching);
    }
  };
}
function create_default_slot_342(ctx) {
  let colorinput;
  let current;
  colorinput = new ColorInput_default({ props: { value: "#ff0000" } });
  return {
    c() {
      create_component(colorinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(colorinput, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(colorinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(colorinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(colorinput, detaching);
    }
  };
}
function create_default_slot_332(ctx) {
  let slider;
  let current;
  slider = new Slider_default({
    props: { value: 3, min: 1, max: 30, step: 1 }
  });
  return {
    c() {
      create_component(slider.$$.fragment);
    },
    m(target, anchor) {
      mount_component(slider, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slider, detaching);
    }
  };
}
function create_default_slot_322(ctx) {
  let settingitem0;
  let t3;
  let settingitem1;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Color",
      $$slots: { default: [create_default_slot_342] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Slider",
      $$slots: { default: [create_default_slot_332] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem0_changes = {};
      if (dirty & 4194304) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 4194304) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_default_slot_31(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Autocomplete");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_30(ctx) {
  let autocomplete;
  let current;
  autocomplete = new Autocomplete_default({
    props: {
      value: "",
      options: [{ label: "Foo", description: "Description" }]
    }
  });
  autocomplete.$on("change", ctx[11]);
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function create_default_slot_292(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      value: "",
      files: getNotesInFolder(ctx[8].vault.getRoot()),
      getLabel: ctx[12],
      getDescription: func_13
    }
  });
  fileautocomplete.$on("change", ctx[13]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 256)
        fileautocomplete_changes.files = getNotesInFolder(ctx2[8].vault.getRoot());
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_default_slot_282(ctx) {
  let typography;
  let t0;
  let settingitem0;
  let t1;
  let settingitem1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_31] },
      $$scope: { ctx }
    }
  });
  settingitem0 = new SettingItem_default({
    props: {
      name: "Autocomplete",
      $$slots: { default: [create_default_slot_30] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "FileAutocomplete",
      $$slots: { default: [create_default_slot_292] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      create_component(settingitem0.$$.fragment);
      t1 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const settingitem0_changes = {};
      if (dirty & 4194304) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 4194560) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_default_slot_272(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Data display");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_262(ctx) {
  let t3;
  return {
    c() {
      t3 = text("#tag");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_252(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot_262] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & 4194304) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_default_slot_242(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Tag",
      $$slots: { default: [create_default_slot_252] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 4194304) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_232(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Popover");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_222(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Click me");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_21(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_222] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4194304) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_20(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem_default({ props: { label: "Item 1", icon: "eye" } });
  menuitem1 = new MenuItem_default({
    props: {
      label: "Item 2",
      icon: "eye",
      checked: true
    }
  });
  menuitem2 = new MenuItem_default({
    props: { label: "Item 3", checked: false }
  });
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
    }
  };
}
function create_default_slot_192(ctx) {
  let suggestionitem0;
  let t0;
  let suggestionitem1;
  let t1;
  let suggestionitem2;
  let current;
  suggestionitem0 = new SuggestionItem_default({
    props: {
      label: "Item 1",
      description: "A pretty long description",
      selected: true
    }
  });
  suggestionitem1 = new SuggestionItem_default({
    props: { label: "Item 2", description: "Short" }
  });
  suggestionitem2 = new SuggestionItem_default({ props: { label: "Item 3" } });
  return {
    c() {
      create_component(suggestionitem0.$$.fragment);
      t0 = space();
      create_component(suggestionitem1.$$.fragment);
      t1 = space();
      create_component(suggestionitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(suggestionitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(suggestionitem2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem0.$$.fragment, local);
      transition_in(suggestionitem1.$$.fragment, local);
      transition_in(suggestionitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem0.$$.fragment, local);
      transition_out(suggestionitem1.$$.fragment, local);
      transition_out(suggestionitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(suggestionitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(suggestionitem2, detaching);
    }
  };
}
function create_default_slot_182(ctx) {
  let button0;
  let t1;
  let popover;
  let t22;
  let button1;
  let t4;
  let menu;
  let t5;
  let button2;
  let t7;
  let suggestion;
  let current;
  let mounted;
  let dispose;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: "auto",
      $$slots: { default: [create_default_slot_21] },
      $$scope: { ctx }
    }
  });
  menu = new Menu_default({
    props: {
      anchorEl: ctx[2],
      open: ctx[3],
      placement: "auto",
      $$slots: { default: [create_default_slot_20] },
      $$scope: { ctx }
    }
  });
  suggestion = new Suggestion_default({
    props: {
      anchorEl: ctx[4],
      open: ctx[5],
      placement: "auto",
      $$slots: { default: [create_default_slot_192] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      button0 = element("button");
      button0.textContent = "Popover";
      t1 = space();
      create_component(popover.$$.fragment);
      t22 = space();
      button1 = element("button");
      button1.textContent = "Menu";
      t4 = space();
      create_component(menu.$$.fragment);
      t5 = space();
      button2 = element("button");
      button2.textContent = "Suggestions";
      t7 = space();
      create_component(suggestion.$$.fragment);
      attr(button0, "class", "svelte-qi93d1");
      attr(button1, "class", "svelte-qi93d1");
      attr(button2, "class", "svelte-qi93d1");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      ctx[14](button0);
      insert(target, t1, anchor);
      mount_component(popover, target, anchor);
      insert(target, t22, anchor);
      insert(target, button1, anchor);
      ctx[16](button1);
      insert(target, t4, anchor);
      mount_component(menu, target, anchor);
      insert(target, t5, anchor);
      insert(target, button2, anchor);
      ctx[18](button2);
      insert(target, t7, anchor);
      mount_component(suggestion, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[15]),
          listen(button1, "click", ctx[17]),
          listen(button2, "click", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 4194304) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
      const menu_changes = {};
      if (dirty & 4)
        menu_changes.anchorEl = ctx2[2];
      if (dirty & 8)
        menu_changes.open = ctx2[3];
      if (dirty & 4194304) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      const suggestion_changes = {};
      if (dirty & 16)
        suggestion_changes.anchorEl = ctx2[4];
      if (dirty & 32)
        suggestion_changes.open = ctx2[5];
      if (dirty & 4194304) {
        suggestion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suggestion.$set(suggestion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      transition_in(menu.$$.fragment, local);
      transition_in(suggestion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      transition_out(menu.$$.fragment, local);
      transition_out(suggestion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      ctx[14](null);
      if (detaching)
        detach(t1);
      destroy_component(popover, detaching);
      if (detaching)
        detach(t22);
      if (detaching)
        detach(button1);
      ctx[16](null);
      if (detaching)
        detach(t4);
      destroy_component(menu, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(button2);
      ctx[18](null);
      if (detaching)
        detach(t7);
      destroy_component(suggestion, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_172(ctx) {
  let typography;
  let t3;
  let horizontalgroup;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_232] },
      $$scope: { ctx }
    }
  });
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_182] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const horizontalgroup_changes = {};
      if (dirty & 4194367) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_default_slot_162(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Icons");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_152(ctx) {
  let icon0;
  let t0;
  let icon1;
  let t1;
  let icon2;
  let t22;
  let icon3;
  let current;
  icon0 = new Icon_default({ props: { name: "heart", size: "xs" } });
  icon1 = new Icon_default({ props: { name: "heart", size: "sm" } });
  icon2 = new Icon_default({ props: { name: "heart", size: "md" } });
  icon3 = new Icon_default({ props: { name: "heart", size: "lg" } });
  return {
    c() {
      create_component(icon0.$$.fragment);
      t0 = space();
      create_component(icon1.$$.fragment);
      t1 = space();
      create_component(icon2.$$.fragment);
      t22 = space();
      create_component(icon3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon0, target, anchor);
      insert(target, t0, anchor);
      mount_component(icon1, target, anchor);
      insert(target, t1, anchor);
      mount_component(icon2, target, anchor);
      insert(target, t22, anchor);
      mount_component(icon3, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      transition_in(icon3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      transition_out(icon3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(icon1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(icon2, detaching);
      if (detaching)
        detach(t22);
      destroy_component(icon3, detaching);
    }
  };
}
function create_default_slot_142(ctx) {
  let iconbutton0;
  let t0;
  let iconbutton1;
  let t1;
  let iconbutton2;
  let t22;
  let iconbutton3;
  let current;
  iconbutton0 = new IconButton_default({ props: { icon: "heart", size: "xs" } });
  iconbutton1 = new IconButton_default({ props: { icon: "heart", size: "sm" } });
  iconbutton2 = new IconButton_default({
    props: { icon: "heart", size: "md", active: true }
  });
  iconbutton3 = new IconButton_default({ props: { icon: "heart", size: "lg" } });
  return {
    c() {
      create_component(iconbutton0.$$.fragment);
      t0 = space();
      create_component(iconbutton1.$$.fragment);
      t1 = space();
      create_component(iconbutton2.$$.fragment);
      t22 = space();
      create_component(iconbutton3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton0, target, anchor);
      insert(target, t0, anchor);
      mount_component(iconbutton1, target, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton2, target, anchor);
      insert(target, t22, anchor);
      mount_component(iconbutton3, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton0.$$.fragment, local);
      transition_in(iconbutton1.$$.fragment, local);
      transition_in(iconbutton2.$$.fragment, local);
      transition_in(iconbutton3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton0.$$.fragment, local);
      transition_out(iconbutton1.$$.fragment, local);
      transition_out(iconbutton2.$$.fragment, local);
      transition_out(iconbutton3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(iconbutton1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton2, detaching);
      if (detaching)
        detach(t22);
      destroy_component(iconbutton3, detaching);
    }
  };
}
function create_default_slot_132(ctx) {
  let typography;
  let t0;
  let horizontalgroup0;
  let t1;
  let horizontalgroup1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_162] },
      $$scope: { ctx }
    }
  });
  horizontalgroup0 = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_152] },
      $$scope: { ctx }
    }
  });
  horizontalgroup1 = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_142] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      create_component(horizontalgroup0.$$.fragment);
      t1 = space();
      create_component(horizontalgroup1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      mount_component(horizontalgroup0, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizontalgroup1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const horizontalgroup0_changes = {};
      if (dirty & 4194304) {
        horizontalgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup0.$set(horizontalgroup0_changes);
      const horizontalgroup1_changes = {};
      if (dirty & 4194304) {
        horizontalgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup1.$set(horizontalgroup1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(horizontalgroup0.$$.fragment, local);
      transition_in(horizontalgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(horizontalgroup0.$$.fragment, local);
      transition_out(horizontalgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      destroy_component(horizontalgroup0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizontalgroup1, detaching);
    }
  };
}
function create_default_slot_122(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Links");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_115(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Image");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_104(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Google");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_94(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Resolved internal link");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_84(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Unresolved internal link");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_75(ctx) {
  let typography;
  let t0;
  let ul;
  let li0;
  let link0;
  let t1;
  let li1;
  let link1;
  let t22;
  let li2;
  let internallink0;
  let t3;
  let li3;
  let internallink1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_122] },
      $$scope: { ctx }
    }
  });
  link0 = new Link_default({
    props: {
      href: "image.png",
      $$slots: { default: [create_default_slot_115] },
      $$scope: { ctx }
    }
  });
  link1 = new Link_default({
    props: {
      href: "https://google.com",
      $$slots: { default: [create_default_slot_104] },
      $$scope: { ctx }
    }
  });
  internallink0 = new InternalLink_default({
    props: {
      linkText: "Untitled 1",
      sourcePath: "Untitled.md",
      resolved: true,
      $$slots: { default: [create_default_slot_94] },
      $$scope: { ctx }
    }
  });
  internallink0.$on("open", ctx[20]);
  internallink1 = new InternalLink_default({
    props: {
      linkText: "Untitled 1",
      sourcePath: "Untitled.md",
      resolved: false,
      $$slots: { default: [create_default_slot_84] },
      $$scope: { ctx }
    }
  });
  internallink1.$on("open", ctx[21]);
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      ul = element("ul");
      li0 = element("li");
      create_component(link0.$$.fragment);
      t1 = space();
      li1 = element("li");
      create_component(link1.$$.fragment);
      t22 = space();
      li2 = element("li");
      create_component(internallink0.$$.fragment);
      t3 = space();
      li3 = element("li");
      create_component(internallink1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      insert(target, ul, anchor);
      append(ul, li0);
      mount_component(link0, li0, null);
      append(ul, t1);
      append(ul, li1);
      mount_component(link1, li1, null);
      append(ul, t22);
      append(ul, li2);
      mount_component(internallink0, li2, null);
      append(ul, t3);
      append(ul, li3);
      mount_component(internallink1, li3, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const link0_changes = {};
      if (dirty & 4194304) {
        link0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link0.$set(link0_changes);
      const link1_changes = {};
      if (dirty & 4194304) {
        link1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link1.$set(link1_changes);
      const internallink0_changes = {};
      if (dirty & 4194304) {
        internallink0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      internallink0.$set(internallink0_changes);
      const internallink1_changes = {};
      if (dirty & 4194304) {
        internallink1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      internallink1.$set(internallink1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(link0.$$.fragment, local);
      transition_in(link1.$$.fragment, local);
      transition_in(internallink0.$$.fragment, local);
      transition_in(internallink1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(link0.$$.fragment, local);
      transition_out(link1.$$.fragment, local);
      transition_out(internallink0.$$.fragment, local);
      transition_out(internallink1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(ul);
      destroy_component(link0);
      destroy_component(link1);
      destroy_component(internallink0);
      destroy_component(internallink1);
    }
  };
}
function create_default_slot_66(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Feedback");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_58(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Loading");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_410(ctx) {
  let typography;
  let t3;
  let loading;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_58] },
      $$scope: { ctx }
    }
  });
  loading = new Loading_default({});
  return {
    c() {
      create_component(typography.$$.fragment);
      t3 = space();
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t3, anchor);
      mount_component(loading, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t3);
      destroy_component(loading, detaching);
    }
  };
}
function create_default_slot_310(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Callout");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_211(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Lorem ipsum");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_116(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Lorem ipsum");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot26(ctx) {
  let typography;
  let t0;
  let callout0;
  let t1;
  let callout1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h3",
      $$slots: { default: [create_default_slot_310] },
      $$scope: { ctx }
    }
  });
  callout0 = new Callout_default({
    props: {
      title: "Info",
      icon: "star",
      variant: "info",
      $$slots: { default: [create_default_slot_211] },
      $$scope: { ctx }
    }
  });
  callout1 = new Callout_default({
    props: {
      title: "Danger",
      icon: "alert-circle",
      variant: "danger",
      $$slots: { default: [create_default_slot_116] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
      t0 = space();
      create_component(callout0.$$.fragment);
      t1 = space();
      create_component(callout1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      insert(target, t0, anchor);
      mount_component(callout0, target, anchor);
      insert(target, t1, anchor);
      mount_component(callout1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 4194304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const callout0_changes = {};
      if (dirty & 4194304) {
        callout0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout0.$set(callout0_changes);
      const callout1_changes = {};
      if (dirty & 4194304) {
        callout1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout1.$set(callout1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(callout0.$$.fragment, local);
      transition_in(callout1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(callout0.$$.fragment, local);
      transition_out(callout1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
      if (detaching)
        detach(t0);
      destroy_component(callout0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(callout1, detaching);
    }
  };
}
function create_fragment85(ctx) {
  let div;
  let typography0;
  let t0;
  let card0;
  let t1;
  let card1;
  let t22;
  let card2;
  let t3;
  let card3;
  let t4;
  let card4;
  let t5;
  let typography1;
  let t6;
  let card5;
  let t7;
  let card6;
  let t8;
  let card7;
  let t9;
  let card8;
  let t10;
  let typography2;
  let t11;
  let card9;
  let t12;
  let card10;
  let current;
  typography0 = new Typography_default({
    props: {
      variant: "h2",
      $$slots: { default: [create_default_slot_51] },
      $$scope: { ctx }
    }
  });
  card0 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_452] },
      $$scope: { ctx }
    }
  });
  card1 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_41] },
      $$scope: { ctx }
    }
  });
  card2 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_352] },
      $$scope: { ctx }
    }
  });
  card3 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_322] },
      $$scope: { ctx }
    }
  });
  card4 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_282] },
      $$scope: { ctx }
    }
  });
  typography1 = new Typography_default({
    props: {
      variant: "h2",
      $$slots: { default: [create_default_slot_272] },
      $$scope: { ctx }
    }
  });
  card5 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_242] },
      $$scope: { ctx }
    }
  });
  card6 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_172] },
      $$scope: { ctx }
    }
  });
  card7 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_132] },
      $$scope: { ctx }
    }
  });
  card8 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_75] },
      $$scope: { ctx }
    }
  });
  typography2 = new Typography_default({
    props: {
      variant: "h2",
      $$slots: { default: [create_default_slot_66] },
      $$scope: { ctx }
    }
  });
  card9 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot_410] },
      $$scope: { ctx }
    }
  });
  card10 = new Card_default({
    props: {
      $$slots: { default: [create_default_slot26] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(typography0.$$.fragment);
      t0 = space();
      create_component(card0.$$.fragment);
      t1 = space();
      create_component(card1.$$.fragment);
      t22 = space();
      create_component(card2.$$.fragment);
      t3 = space();
      create_component(card3.$$.fragment);
      t4 = space();
      create_component(card4.$$.fragment);
      t5 = space();
      create_component(typography1.$$.fragment);
      t6 = space();
      create_component(card5.$$.fragment);
      t7 = space();
      create_component(card6.$$.fragment);
      t8 = space();
      create_component(card7.$$.fragment);
      t9 = space();
      create_component(card8.$$.fragment);
      t10 = space();
      create_component(typography2.$$.fragment);
      t11 = space();
      create_component(card9.$$.fragment);
      t12 = space();
      create_component(card10.$$.fragment);
      attr(div, "class", "container svelte-qi93d1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography0, div, null);
      append(div, t0);
      mount_component(card0, div, null);
      append(div, t1);
      mount_component(card1, div, null);
      append(div, t22);
      mount_component(card2, div, null);
      append(div, t3);
      mount_component(card3, div, null);
      append(div, t4);
      mount_component(card4, div, null);
      append(div, t5);
      mount_component(typography1, div, null);
      append(div, t6);
      mount_component(card5, div, null);
      append(div, t7);
      mount_component(card6, div, null);
      append(div, t8);
      mount_component(card7, div, null);
      append(div, t9);
      mount_component(card8, div, null);
      append(div, t10);
      mount_component(typography2, div, null);
      append(div, t11);
      mount_component(card9, div, null);
      append(div, t12);
      mount_component(card10, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography0_changes = {};
      if (dirty & 4194304) {
        typography0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography0.$set(typography0_changes);
      const card0_changes = {};
      if (dirty & 4194304) {
        card0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card0.$set(card0_changes);
      const card1_changes = {};
      if (dirty & 4194304) {
        card1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card1.$set(card1_changes);
      const card2_changes = {};
      if (dirty & 4194496) {
        card2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card2.$set(card2_changes);
      const card3_changes = {};
      if (dirty & 4194304) {
        card3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card3.$set(card3_changes);
      const card4_changes = {};
      if (dirty & 4194560) {
        card4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card4.$set(card4_changes);
      const typography1_changes = {};
      if (dirty & 4194304) {
        typography1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography1.$set(typography1_changes);
      const card5_changes = {};
      if (dirty & 4194304) {
        card5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card5.$set(card5_changes);
      const card6_changes = {};
      if (dirty & 4194367) {
        card6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card6.$set(card6_changes);
      const card7_changes = {};
      if (dirty & 4194304) {
        card7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card7.$set(card7_changes);
      const card8_changes = {};
      if (dirty & 4194560) {
        card8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card8.$set(card8_changes);
      const typography2_changes = {};
      if (dirty & 4194304) {
        typography2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography2.$set(typography2_changes);
      const card9_changes = {};
      if (dirty & 4194304) {
        card9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card9.$set(card9_changes);
      const card10_changes = {};
      if (dirty & 4194304) {
        card10_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card10.$set(card10_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography0.$$.fragment, local);
      transition_in(card0.$$.fragment, local);
      transition_in(card1.$$.fragment, local);
      transition_in(card2.$$.fragment, local);
      transition_in(card3.$$.fragment, local);
      transition_in(card4.$$.fragment, local);
      transition_in(typography1.$$.fragment, local);
      transition_in(card5.$$.fragment, local);
      transition_in(card6.$$.fragment, local);
      transition_in(card7.$$.fragment, local);
      transition_in(card8.$$.fragment, local);
      transition_in(typography2.$$.fragment, local);
      transition_in(card9.$$.fragment, local);
      transition_in(card10.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography0.$$.fragment, local);
      transition_out(card0.$$.fragment, local);
      transition_out(card1.$$.fragment, local);
      transition_out(card2.$$.fragment, local);
      transition_out(card3.$$.fragment, local);
      transition_out(card4.$$.fragment, local);
      transition_out(typography1.$$.fragment, local);
      transition_out(card5.$$.fragment, local);
      transition_out(card6.$$.fragment, local);
      transition_out(card7.$$.fragment, local);
      transition_out(card8.$$.fragment, local);
      transition_out(typography2.$$.fragment, local);
      transition_out(card9.$$.fragment, local);
      transition_out(card10.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography0);
      destroy_component(card0);
      destroy_component(card1);
      destroy_component(card2);
      destroy_component(card3);
      destroy_component(card4);
      destroy_component(typography1);
      destroy_component(card5);
      destroy_component(card6);
      destroy_component(card7);
      destroy_component(card8);
      destroy_component(typography2);
      destroy_component(card9);
      destroy_component(card10);
    }
  };
}
var func_13 = (file) => file.path.split("/").slice(0, -1).join("/");
function instance85($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  let btn1;
  let btn1Open = false;
  let btn2;
  let btn2Open = false;
  let btn3;
  let btn3Open = false;
  let textValue = "Text";
  let numberValue = 10;
  function textinput_value_binding(value) {
    textValue = value;
    $$invalidate(6, textValue);
  }
  function numberinput_value_binding(value) {
    numberValue = value;
    $$invalidate(7, numberValue);
  }
  const change_handler = ({ detail }) => new import_obsidian38.Notice(`Autocomplete changed: ${detail}`);
  const func7 = (file) => file instanceof import_obsidian38.TFile ? file.basename : file.name;
  const change_handler_1 = ({ detail }) => new import_obsidian38.Notice(`FileAutocomplete changed: ${detail}`);
  function button0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btn1 = $$value;
      $$invalidate(0, btn1);
    });
  }
  const click_handler = () => $$invalidate(1, btn1Open = !btn1Open);
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btn2 = $$value;
      $$invalidate(2, btn2);
    });
  }
  const click_handler_1 = () => $$invalidate(3, btn2Open = !btn2Open);
  function button2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      btn3 = $$value;
      $$invalidate(4, btn3);
    });
  }
  const click_handler_2 = () => $$invalidate(5, btn3Open = !btn3Open);
  const open_handler = ({ detail: { linkText, sourcePath, newLeaf } }) => {
    $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
  };
  const open_handler_1 = ({ detail: { linkText, sourcePath, newLeaf } }) => {
    $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
  };
  return [
    btn1,
    btn1Open,
    btn2,
    btn2Open,
    btn3,
    btn3Open,
    textValue,
    numberValue,
    $app,
    textinput_value_binding,
    numberinput_value_binding,
    change_handler,
    func7,
    change_handler_1,
    button0_binding,
    click_handler,
    button1_binding,
    click_handler_1,
    button2_binding,
    click_handler_2,
    open_handler,
    open_handler_1
  ];
}
var DeveloperView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance85, create_fragment85, safe_not_equal, {}, add_css48);
  }
};
var DeveloperView_default = DeveloperView;

// src/app/View.svelte
function create_fragment86(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[6];
  function switch_props(ctx2) {
    return {
      props: {
        frame: ctx2[2],
        project: ctx2[0],
        type: ctx2[1].type,
        config: ctx2[1].config,
        readonly: ctx2[3],
        api: ctx2[4],
        onConfigChange: ctx2[5]
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 4)
        switch_instance_changes.frame = ctx2[2];
      if (dirty & 1)
        switch_instance_changes.project = ctx2[0];
      if (dirty & 2)
        switch_instance_changes.type = ctx2[1].type;
      if (dirty & 2)
        switch_instance_changes.config = ctx2[1].config;
      if (dirty & 8)
        switch_instance_changes.readonly = ctx2[3];
      if (dirty & 16)
        switch_instance_changes.api = ctx2[4];
      if (dirty & 32)
        switch_instance_changes.onConfigChange = ctx2[5];
      if (switch_value !== (switch_value = ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance86($$self, $$props, $$invalidate) {
  let viewComponent;
  let $customViews;
  let $customViewsV2;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(7, $customViews = $$value));
  component_subscribe($$self, customViewsV2, ($$value) => $$invalidate(8, $customViewsV2 = $$value));
  let { project } = $$props;
  let { view: view2 } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { onConfigChange } = $$props;
  function getViewComponent(type) {
    const standardViewComponents = {
      table: TableView_default,
      board: BoardView_default,
      calendar: CalendarView_default,
      developer: DeveloperView_default
    };
    const standardComponent = standardViewComponents[type];
    if (standardComponent) {
      return standardComponent;
    }
    if ($customViewsV2[type] || $customViews[type]) {
      return CustomView_default;
    }
    return null;
  }
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("view" in $$props2)
      $$invalidate(1, view2 = $$props2.view);
    if ("frame" in $$props2)
      $$invalidate(2, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(4, api2 = $$props2.api);
    if ("onConfigChange" in $$props2)
      $$invalidate(5, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(6, viewComponent = view2 ? getViewComponent(view2.type) : null);
    }
  };
  return [project, view2, frame, readonly, api2, onConfigChange, viewComponent];
}
var View = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance86, create_fragment86, safe_not_equal, {
      project: 0,
      view: 1,
      frame: 2,
      readonly: 3,
      api: 4,
      onConfigChange: 5
    });
  }
};
var View_default = View;

// src/app/view-api.ts
var ViewApi = class {
  constructor(app2, dataSource2, dataApi) {
    this.app = app2;
    this.dataSource = dataSource2;
    this.dataApi = dataApi;
  }
  addRecord(record, templatePath) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.addRecord(record);
    }
    this.dataApi.createNote(record, templatePath);
  }
  updateRecord(record, fields) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.updateRecord(record);
    }
    this.dataApi.updateRecord(fields, record);
  }
  deleteRecord(recordId) {
    if (this.dataSource.includes(recordId)) {
      dataFrame.deleteRecord(recordId);
    }
    this.dataApi.deleteRecord(recordId);
  }
  renameField(from, to) {
    dataFrame.renameField(from, to);
    this.dataApi.renameField(filesFromRecords(this.app, get_store_value(dataFrame).records), from, to);
  }
  deleteField(field) {
    dataFrame.deleteField(field);
    this.dataApi.deleteField(filesFromRecords(this.app, get_store_value(dataFrame).records), field);
  }
};

// src/app/onboarding/onboarding-modal.ts
var import_obsidian42 = __toModule(require("obsidian"));

// src/app/onboarding/TabContainer.svelte
function add_css49(target) {
  append_styles(target, "svelte-1bexdx8", ".nomargin.svelte-1bexdx8{margin:0;padding:8px}.header.svelte-1bexdx8{display:flex;gap:4px;margin-bottom:4px}");
}
var get_default_slot_changes = (dirty) => ({ selected: dirty & 2 });
var get_default_slot_context = (ctx) => ({ selected: ctx[1] });
function get_each_context15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block15(ctx) {
  let div;
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[4](ctx[6]);
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "clickable-icon");
      toggle_class(div, "is-active", ctx[6] === ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[6] + ""))
        set_data(t0, t0_value);
      if (dirty & 3) {
        toggle_class(div, "is-active", ctx[6] === ctx[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment87(ctx) {
  let div2;
  let div0;
  let t3;
  let div1;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block15(get_each_context15(ctx, each_value, i2));
  }
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], get_default_slot_context);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "header svelte-1bexdx8");
      attr(div1, "class", "card nomargin svelte-1bexdx8");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div0, null);
      }
      append(div2, t3);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block15(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 6)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, get_default_slot_changes), get_default_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a;
  let { options } = $$props;
  let selected = (_a = options[0]) !== null && _a !== void 0 ? _a : "";
  const click_handler = (option) => {
    $$invalidate(1, selected = option);
  };
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [options, selected, $$scope, slots, click_handler];
}
var TabContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance87, create_fragment87, safe_not_equal, { options: 0 }, add_css49);
  }
};
var TabContainer_default = TabContainer;

// src/app/onboarding/Onboarding.svelte
function add_css50(target) {
  append_styles(target, "svelte-10e8th2", "pre.svelte-10e8th2{background-color:var(--background-secondary);border-radius:var(--radius-s);padding:8px}ol.svelte-10e8th2{margin:0;padding:0 22px}");
}
function create_default_slot_67(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Get started with Projects");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_59(ctx) {
  let t0;
  let a2;
  let t22;
  return {
    c() {
      t0 = text("Projects lets you manage groups of related notes using\n		");
      a2 = element("a");
      a2.textContent = "front matter\n		";
      t22 = text(". For example, a folder with the blog posts you're working on.");
      attr(a2, "href", "https://help.obsidian.md/Advanced+topics/YAML+front+matter");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a2, anchor);
      insert(target, t22, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t22);
    }
  };
}
function create_default_slot_411(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Start from scratch, or explore a demo project \u{1F447}");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_311(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Create new project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_212(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Try a demo project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_117(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_311] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[2]);
  button1 = new Button_default({
    props: {
      variant: "default",
      tooltip: "Creates a new folder at the root of your vault with example notes.",
      $$slots: { default: [create_default_slot_212] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[3]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_else_block8(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>In the top-right corner of the <strong>Projects</strong>
					view, click
					<strong>New</strong>.</li> 
				<li>Click <strong>New project</strong>.</li>`;
      attr(ol, "class", "svelte-10e8th2");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_113(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Open the <strong>Command palette</strong>.</li> 
				<li>Search for <strong>Create new project</strong></li> 
				<li>Press <strong>Enter</strong>.</li>`;
      attr(ol, "class", "svelte-10e8th2");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block25(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Right-click a folder in <strong>File explorer</strong>.</li> 
				<li>Click <strong>Create project in folder</strong>.</li>`;
      attr(ol, "class", "svelte-10e8th2");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_default_slot27(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] === "File explorer")
      return create_if_block25;
    if (ctx2[4] === "Command palette")
      return create_if_block_113;
    return create_else_block8;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment88(ctx) {
  let div;
  let typography0;
  let t0;
  let typography1;
  let t1;
  let pre;
  let t3;
  let typography2;
  let t4;
  let modalbuttongroup;
  let t5;
  let p2;
  let p_style_value;
  let t8;
  let tabcontainer;
  let current;
  typography0 = new Typography_default({
    props: {
      variant: "h1",
      $$slots: { default: [create_default_slot_67] },
      $$scope: { ctx }
    }
  });
  typography1 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_59] },
      $$scope: { ctx }
    }
  });
  typography2 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_411] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_117] },
      $$scope: { ctx }
    }
  });
  tabcontainer = new TabContainer_default({
    props: {
      options: ["Projects view", "Command palette", "File explorer"],
      $$slots: {
        default: [
          create_default_slot27,
          ({ selected }) => ({ 4: selected }),
          ({ selected }) => selected ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(typography0.$$.fragment);
      t0 = space();
      create_component(typography1.$$.fragment);
      t1 = space();
      pre = element("pre");
      pre.innerHTML = `<code>---
status: Backlog
due: 2023-01-01
published: false
---

# My blog post</code>`;
      t3 = space();
      create_component(typography2.$$.fragment);
      t4 = space();
      create_component(modalbuttongroup.$$.fragment);
      t5 = space();
      p2 = element("p");
      p2.innerHTML = `<strong>Psst! \u{1F44B}</strong> Next time you can create your projects using any
		of the following ways:`;
      t8 = space();
      create_component(tabcontainer.$$.fragment);
      attr(pre, "class", "svelte-10e8th2");
      attr(p2, "style", p_style_value = "color: var(--text-muted); margin-top: 45px; font-size: var(--font-ui-smaller);");
      attr(div, "class", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography0, div, null);
      append(div, t0);
      mount_component(typography1, div, null);
      append(div, t1);
      append(div, pre);
      append(div, t3);
      mount_component(typography2, div, null);
      append(div, t4);
      mount_component(modalbuttongroup, div, null);
      append(div, t5);
      append(div, p2);
      append(div, t8);
      mount_component(tabcontainer, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography0_changes = {};
      if (dirty & 32) {
        typography0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography0.$set(typography0_changes);
      const typography1_changes = {};
      if (dirty & 32) {
        typography1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography1.$set(typography1_changes);
      const typography2_changes = {};
      if (dirty & 32) {
        typography2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography2.$set(typography2_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 35) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
      const tabcontainer_changes = {};
      if (dirty & 48) {
        tabcontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabcontainer.$set(tabcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography0.$$.fragment, local);
      transition_in(typography1.$$.fragment, local);
      transition_in(typography2.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      transition_in(tabcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography0.$$.fragment, local);
      transition_out(typography1.$$.fragment, local);
      transition_out(typography2.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      transition_out(tabcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography0);
      destroy_component(typography1);
      destroy_component(typography2);
      destroy_component(modalbuttongroup);
      destroy_component(tabcontainer);
    }
  };
}
function instance88($$self, $$props, $$invalidate) {
  let { onCreate } = $$props;
  let { onTry } = $$props;
  const click_handler = () => onCreate();
  const click_handler_1 = () => onTry();
  $$self.$$set = ($$props2) => {
    if ("onCreate" in $$props2)
      $$invalidate(0, onCreate = $$props2.onCreate);
    if ("onTry" in $$props2)
      $$invalidate(1, onTry = $$props2.onTry);
  };
  return [onCreate, onTry, click_handler, click_handler_1];
}
var Onboarding = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance88, create_fragment88, safe_not_equal, { onCreate: 0, onTry: 1 }, add_css50);
  }
};
var Onboarding_default = Onboarding;

// src/app/onboarding/onboarding-modal.ts
var OnboardingModal = class extends import_obsidian42.Modal {
  constructor(app2, onCreate, onTry) {
    super(app2);
    this.onCreate = onCreate;
    this.onTry = onTry;
  }
  onOpen() {
    this.component = new Onboarding_default({
      target: this.contentEl,
      props: {
        onCreate: () => {
          this.onCreate();
          this.close();
        },
        onTry: () => {
          this.onTry();
          this.close();
        }
      }
    });
  }
};

// src/app/onboarding/demo-project.ts
var import_dayjs7 = __toModule(require_dayjs_min());
var import_obsidian43 = __toModule(require("obsidian"));
function createDemoProject(vault) {
  return __async(this, null, function* () {
    const demoFolder = "Projects - Demo Project";
    yield vault.createFolder(demoFolder);
    const startDate = (0, import_dayjs7.default)();
    const files = {
      "The Best Notes You'll Ever Make": {
        status: "Done",
        due: startDate.subtract(2, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 1,
        tags: ["note-taking"]
      },
      "The Easiest Way to Start Taking Notes": {
        status: "Done",
        due: startDate.subtract(1, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 2,
        tags: ["note-taking", "obsidian"]
      },
      "Why You Should Be Taking More Notes": {
        status: "Doing",
        due: startDate.format("YYYY-MM-DD"),
        published: false,
        weight: 3,
        tags: ["note-taking", "pkm"]
      },
      "What I Learned From Taking 15,000 Notes": {
        status: "Backlog",
        due: startDate.add(1, "weeks").format("YYYY-MM-DD"),
        published: false,
        weight: 4,
        tags: ["pkm", "obsidian"]
      },
      "5 Mistake I Made When I Started Using Obsidian": {
        status: "Backlog",
        due: startDate.add(2, "weeks").format("YYYY-MM-DD"),
        published: false,
        tags: ["obsidian"]
      }
    };
    for (let [linkText, data] of Object.entries(files)) {
      const content = "---\n" + (0, import_obsidian43.stringifyYaml)(data) + "---\n\n# " + linkText;
      yield vault.create((0, import_obsidian43.normalizePath)(demoFolder + "/" + linkText + ".md"), content);
    }
    const tableConfig = {
      fieldConfig: {
        name: {
          width: 360
        },
        path: {
          hide: true
        }
      }
    };
    const boardConfig = {
      groupByField: "status",
      priorityField: "weight"
    };
    const calendarConfig = {
      interval: "month",
      dateField: "due",
      checkField: "published"
    };
    settings.addProject({
      name: "Demo project",
      id: v4_default(),
      path: demoFolder,
      recursive: false,
      views: [
        { name: "Table", id: v4_default(), type: "table", config: tableConfig },
        { name: "Board", id: v4_default(), type: "board", config: boardConfig },
        {
          name: "Calendar",
          id: v4_default(),
          type: "calendar",
          config: calendarConfig
        }
      ]
    });
  });
}

// src/app/App.svelte
function add_css51(target) {
  append_styles(target, "svelte-2ssdmk", "*{box-sizing:border-box}.projects-container.svelte-2ssdmk{display:flex;flex-direction:column;height:100%}.projects-main.svelte-2ssdmk{flex:1;display:flex;flex-direction:column;min-height:0}");
}
function create_catch_block(ctx) {
  let div;
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[18].name,
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(callout.$$.fragment);
      set_style(div, "padding", "var(--size-4-3)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(callout, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 16)
        callout_changes.title = ctx2[18].name;
      if (dirty & 524304) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(callout);
    }
  };
}
function create_default_slot_118(ctx) {
  let t_value = ctx[18].message + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[18].message + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot28(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_118] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 524304) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_then_block(ctx) {
  let div;
  let current;
  let if_block = ctx[1] && ctx[0] && ctx[5] && create_if_block26(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "projects-main svelte-2ssdmk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1] && ctx2[0] && ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 35) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block26(ctx) {
  var _a, _b;
  let view2;
  let current;
  view2 = new View_default({
    props: {
      project: ctx[1],
      view: ctx[0],
      readonly: (_b = (_a = ctx[3]) == null ? void 0 : _a.readonly()) != null ? _b : true,
      api: ctx[5],
      onConfigChange: ctx[9],
      frame: ctx[6]
    }
  });
  return {
    c() {
      create_component(view2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const view_changes = {};
      if (dirty & 2)
        view_changes.project = ctx2[1];
      if (dirty & 1)
        view_changes.view = ctx2[0];
      if (dirty & 8)
        view_changes.readonly = (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.readonly()) != null ? _b2 : true;
      if (dirty & 32)
        view_changes.api = ctx2[5];
      if (dirty & 64)
        view_changes.frame = ctx2[6];
      view2.$set(view_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(view2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view2, detaching);
    }
  };
}
function create_pending_block(ctx) {
  let loading;
  let current;
  loading = new Loading_default({});
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_fragment89(ctx) {
  var _a, _b;
  let div;
  let toolbar;
  let t3;
  let promise;
  let current;
  toolbar = new Toolbar_default({
    props: {
      projects: ctx[2],
      project: (_a = ctx[1]) == null ? void 0 : _a.id,
      onProjectChange: ctx[14],
      view: (_b = ctx[0]) == null ? void 0 : _b.id,
      onViewChange: ctx[15]
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    error: 18,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[4], info);
  return {
    c() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t3 = space();
      info.block.c();
      attr(div, "class", "projects-container svelte-2ssdmk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(toolbar, div, null);
      append(div, t3);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      var _a2, _b2;
      ctx = new_ctx;
      const toolbar_changes = {};
      if (dirty & 4)
        toolbar_changes.projects = ctx[2];
      if (dirty & 2)
        toolbar_changes.project = (_a2 = ctx[1]) == null ? void 0 : _a2.id;
      if (dirty & 1)
        toolbar_changes.view = (_b2 = ctx[0]) == null ? void 0 : _b2.id;
      toolbar.$set(toolbar_changes);
      info.ctx = ctx;
      if (dirty & 16 && promise !== (promise = ctx[4]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(toolbar);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance89($$self, $$props, $$invalidate) {
  let projects;
  let selectedProject;
  let views;
  let selectedView;
  let viewApi;
  let $dataSource;
  let $app;
  let $i18n;
  let $api;
  let $settings;
  let $dataFrame;
  component_subscribe($$self, dataSource, ($$value) => $$invalidate(3, $dataSource = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(11, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(16, $i18n = $$value));
  component_subscribe($$self, api, ($$value) => $$invalidate(12, $api = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(13, $settings = $$value));
  component_subscribe($$self, dataFrame, ($$value) => $$invalidate(6, $dataFrame = $$value));
  onMount(() => {
    if (!projects.length) {
      new OnboardingModal($app, () => {
        new CreateProjectModal($app, $i18n.t("modals.project.create.title"), $i18n.t("modals.project.create.cta"), settings.addProject, createProject()).open();
      }, () => {
        createDemoProject($app.vault);
      }).open();
    }
  });
  let querying;
  function handleProjectChange(projectId) {
    if (!projects.length) {
      $$invalidate(1, selectedProject = null);
      $$invalidate(0, selectedView = null);
      return;
    }
    $$invalidate(1, selectedProject = projects.find((project) => project.id === projectId) || projects[0]);
    if (selectedProject) {
      if (!selectedProject.views.length) {
        $$invalidate(0, selectedView = null);
        return;
      }
      $$invalidate(0, selectedView = selectedProject.views[0]);
    }
  }
  function handleViewChange(viewId) {
    var _a;
    if (!selectedProject || !selectedProject.views.length) {
      $$invalidate(0, selectedView = null);
      return;
    }
    $$invalidate(0, selectedView = (_a = selectedProject.views.find((v2) => v2.id === viewId)) !== null && _a !== void 0 ? _a : selectedProject.views[0]);
  }
  function handleViewConfigChange(config) {
    if ((selectedProject === null || selectedProject === void 0 ? void 0 : selectedProject.id) && (selectedView === null || selectedView === void 0 ? void 0 : selectedView.id)) {
      settings.updateViewConfig(selectedProject.id, selectedView.id, config);
    }
  }
  function resolveDataSource(project, app2) {
    if (project.dataview) {
      return new DataviewDataSource(app2, project);
    }
    return new FrontMatterDataSource(app2, project);
  }
  const func7 = (projectId) => handleProjectChange(projectId);
  const func_14 = (viewId) => handleViewChange(viewId);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(2, projects = $settings.projects);
    }
    if ($$self.$$.dirty & 8196) {
      $:
        $$invalidate(1, selectedProject = (projects === null || projects === void 0 ? void 0 : projects.length) ? projects.find((project) => project.id === $settings.lastProjectId) || projects[0] : null);
    }
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(10, views = selectedProject === null || selectedProject === void 0 ? void 0 : selectedProject.views);
    }
    if ($$self.$$.dirty & 9216) {
      $:
        $$invalidate(0, selectedView = (views === null || views === void 0 ? void 0 : views.length) ? views.find((view2) => view2.id === $settings.lastViewId) || views[0] : null);
    }
    if ($$self.$$.dirty & 2050) {
      $: {
        if (selectedProject) {
          dataSource.set(resolveDataSource(selectedProject, $app));
        }
      }
    }
    if ($$self.$$.dirty & 6152) {
      $:
        $$invalidate(5, viewApi = $dataSource ? new ViewApi($app, $dataSource, $api) : null);
    }
    if ($$self.$$.dirty & 8) {
      $: {
        $$invalidate(4, querying = (() => __awaiter(void 0, void 0, void 0, function* () {
          if ($dataSource) {
            dataFrame.set(yield $dataSource.queryAll());
          }
        }))());
      }
    }
    if ($$self.$$.dirty & 3) {
      $:
        settings.saveLayout(selectedProject === null || selectedProject === void 0 ? void 0 : selectedProject.id, selectedView === null || selectedView === void 0 ? void 0 : selectedView.id);
    }
  };
  return [
    selectedView,
    selectedProject,
    projects,
    $dataSource,
    querying,
    viewApi,
    $dataFrame,
    handleProjectChange,
    handleViewChange,
    handleViewConfigChange,
    views,
    $app,
    $api,
    $settings,
    func7,
    func_14
  ];
}
var App10 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance89, create_fragment89, safe_not_equal, {}, add_css51);
  }
};
var App_default = App10;

// src/view.ts
var VIEW_TYPE_PROJECTS = "obsidian-projects";
var ProjectsView = class extends import_obsidian45.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.navigation = true;
  }
  getViewType() {
    return VIEW_TYPE_PROJECTS;
  }
  getDisplayText() {
    return "Projects";
  }
  getIcon() {
    return "layout";
  }
  onload() {
    return __async(this, null, function* () {
      view.set(this);
    });
  }
  onunload() {
  }
  onOpen() {
    return __async(this, null, function* () {
      customViews.set(this.getViews());
      customViewsV2.set(this.getViewsV2());
      this.component = new App_default({
        target: this.contentEl
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      if (this.component) {
        this.component.$destroy();
      }
    });
  }
  getViewsV2() {
    const views = {};
    for (let pluginId in this.app.plugins.plugins) {
      if (this.app.plugins.enabledPlugins.has(pluginId)) {
        const plugin2 = this.app.plugins.plugins[pluginId];
        const registerView = plugin2 == null ? void 0 : plugin2.onRegisterProjectViewV2;
        if (registerView) {
          views[pluginId] = registerView.bind(plugin2);
        }
      }
    }
    return views;
  }
  getViews() {
    const views = {};
    for (let pluginId in this.app.plugins.plugins) {
      if (this.app.plugins.enabledPlugins.has(pluginId)) {
        const plugin2 = this.app.plugins.plugins[pluginId];
        const registerView = plugin2 == null ? void 0 : plugin2.onRegisterProjectView;
        if (registerView) {
          views[pluginId] = registerView.bind(plugin2);
        }
      }
    }
    return views;
  }
};

// src/events.ts
var import_obsidian47 = __toModule(require("obsidian"));
var import_obsidian_dataview3 = __toModule(require_lib());
function registerFileEvents(plugin2) {
  if (get_store_value(capabilities).dataview) {
    plugin2.registerEvent(plugin2.app.metadataCache.on("dataview:index-ready", () => {
    }));
    plugin2.registerEvent(plugin2.app.metadataCache.on("dataview:metadata-change", (type, file, oldPath) => __async(this, null, function* () {
      if (file instanceof import_obsidian47.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          switch (type) {
            case "update":
              dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
              break;
            case "delete":
              dataFrame.deleteRecord(file.path);
              break;
            case "rename":
              dataFrame.deleteRecord(oldPath);
              dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
              break;
          }
        }
      }
    })));
  } else {
    plugin2.registerEvent(plugin2.app.vault.on("create", (file) => __async(this, null, function* () {
      if (file instanceof import_obsidian47.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
    plugin2.registerEvent(plugin2.app.vault.on("rename", (file, oldPath) => __async(this, null, function* () {
      if (file instanceof import_obsidian47.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.deleteRecord(oldPath);
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
    plugin2.registerEvent(plugin2.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian47.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.deleteRecord(file.path);
        }
      }
    }));
    plugin2.registerEvent(plugin2.app.metadataCache.on("changed", (file) => __async(this, null, function* () {
      if (file instanceof import_obsidian47.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
  }
}

// src/main.ts
import_dayjs8.default.extend(import_isoWeek.default);
import_dayjs8.default.extend(import_localizedFormat.default);
var DEFAULT_SETTINGS = {
  projects: []
};
var ProjectsPlugin = class extends import_obsidian48.Plugin {
  onload() {
    return __async(this, null, function* () {
      const t3 = get_store_value(i18n).t;
      this.registerView(VIEW_TYPE_PROJECTS, (leaf) => new ProjectsView(leaf, this));
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian48.TFolder) {
          menu.addItem((item) => {
            item.setTitle(t3("menus.project.create.title")).setIcon("folder-plus").onClick(() => __async(this, null, function* () {
              const project = createProject();
              new CreateProjectModal(this.app, t3("modals.project.create.title"), t3("modals.project.create.cta"), settings.addProject, __spreadProps(__spreadValues({}, project), {
                name: file.name,
                path: file.path
              })).open();
            }));
          });
        }
      }));
      this.addCommand({
        id: "show-projects",
        name: t3("commands.show-projects.name"),
        callback: () => {
          this.activateView();
        }
      });
      this.addCommand({
        id: "create-project",
        name: t3("commands.create-project.name"),
        callback: () => {
          new CreateProjectModal(this.app, t3("modals.project.create.title"), t3("modals.project.create.cta"), settings.addProject, createProject()).open();
        }
      });
      this.addCommand({
        id: "create-note",
        name: t3("commands.create-note.name"),
        checkCallback: (checking) => {
          const projectDefinition = get_store_value(settings).projects[0];
          if (projectDefinition) {
            if (!checking) {
              new CreateNoteModal(this.app, projectDefinition, (name, templatePath, project) => __async(this, null, function* () {
                const file = yield get_store_value(api).createNote(createDataRecord(name, project), templatePath);
                this.app.workspace.getLeaf(true).openFile(file);
              })).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addRibbonIcon("layout", "Open projects", () => {
        this.activateView();
      });
      (0, import_obsidian48.addIcon)("text", `<g transform="matrix(1,0,0,1,2,2)"><path d="M20,32L28,32L28,24L41.008,24L30.72,72L20,72L20,80L52,80L52,72L42.992,72L53.28,24L68,24L68,32L76,32L76,16L20,16L20,32Z" /></g>`);
      app.set(this.app);
      plugin.set(this);
      settings.set(migrateAny(yield this.loadData()));
      registerFileEvents(this);
      this.unsubscribeSettings = settings.subscribe((value) => {
        this.saveData(value);
      });
    });
  }
  onunload() {
    return __async(this, null, function* () {
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_PROJECTS);
      this.unsubscribeSettings();
    });
  }
  activateView() {
    return __async(this, null, function* () {
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_PROJECTS);
      yield this.app.workspace.getLeaf(true).setViewState({
        type: VIEW_TYPE_PROJECTS,
        active: true
      });
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_PROJECTS);
      if (leaves[0]) {
        this.app.workspace.revealLeaf(leaves[0]);
      }
    });
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
