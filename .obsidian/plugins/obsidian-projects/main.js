/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve3, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve3(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t3, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t3 = "undefined" != typeof globalThis ? globalThis : t3 || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t3 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
        var e2 = ["th", "st", "nd", "rd"], n3 = t4 % 100;
        return "[" + t4 + (e2[(n3 - 20) % 10] || e2[n3] || e2[0]) + "]";
      } }, m = function(t4, e2, n3) {
        var r3 = String(t4);
        return !r3 || r3.length >= e2 ? t4 : "" + Array(e2 + 1 - r3.length).join(n3) + t4;
      }, v2 = { s: m, z: function(t4) {
        var e2 = -t4.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i3, 2, "0");
      }, m: function t4(e2, n3) {
        if (e2.date() < n3.date())
          return -t4(n3, e2);
        var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), f2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(t4) {
        return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return void 0 === t4;
      } }, g2 = "en", D2 = {};
      D2[g2] = M2;
      var p2 = function(t4) {
        return t4 instanceof _24;
      }, S2 = function t4(e2, n3, r3) {
        var i3;
        if (!e2)
          return g2;
        if ("string" == typeof e2) {
          var s3 = e2.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1)
            return t4(u3[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, w2 = function(t4, e2) {
        if (p2(t4))
          return t4.clone();
        var n3 = "object" == typeof e2 ? e2 : {};
        return n3.date = t4, n3.args = arguments, new _24(n3);
      }, O2 = v2;
      O2.l = S2, O2.i = p2, O2.w = function(t4, e2) {
        return w2(t4, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _24 = function() {
        function M3(t4) {
          this.$L = S2(t4.locale, null, true), this.parse(t4);
        }
        var m2 = M3.prototype;
        return m2.parse = function(t4) {
          this.$d = function(t5) {
            var e2 = t5.date, n3 = t5.utc;
            if (null === e2)
              return new Date(NaN);
            if (O2.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r3 = e2.match($2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t4), this.$x = t4.x || {}, this.init();
        }, m2.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, m2.$utils = function() {
          return O2;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m2.isSame = function(t4, e2) {
          var n3 = w2(t4);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m2.isAfter = function(t4, e2) {
          return w2(t4) < this.startOf(e2);
        }, m2.isBefore = function(t4, e2) {
          return this.endOf(e2) < w2(t4);
        }, m2.$g = function(t4, e2, n3) {
          return O2.u(t4) ? this[e2] : this.set(n3, t4);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t4, e2) {
          var n3 = this, r3 = !!O2.u(e2) || e2, h3 = O2.p(t4), l3 = function(t5, e3) {
            var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e3, t5) : new Date(n3.$y, e3, t5), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $3 = function(t5, e3) {
            return O2.w(n3.toDate()[t5].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m3 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (h3) {
            case c2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case f2:
              return r3 ? l3(1, M4) : l3(0, M4 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
              return l3(r3 ? m3 - D3 : m3 + (6 - D3), M4);
            case a2:
            case d2:
              return $3(v3 + "Hours", 0);
            case u2:
              return $3(v3 + "Minutes", 1);
            case s2:
              return $3(v3 + "Seconds", 2);
            case i2:
              return $3(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t4) {
          return this.startOf(t4, false);
        }, m2.$set = function(t4, e2) {
          var n3, o3 = O2.p(t4), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === f2 || o3 === c2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m2.set = function(t4, e2) {
          return this.clone().$set(t4, e2);
        }, m2.get = function(t4) {
          return this[O2.p(t4)]();
        }, m2.add = function(r3, h3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $3 = O2.p(h3), y3 = function(t4) {
            var e2 = w2(l3);
            return O2.w(e2.date(e2.date() + Math.round(t4 * r3)), l3);
          };
          if ($3 === f2)
            return this.set(f2, this.$M + r3);
          if ($3 === c2)
            return this.set(c2, this.$y + r3);
          if ($3 === a2)
            return y3(1);
          if ($3 === o2)
            return y3(7);
          var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t3, d3)[$3] || 1, m3 = this.$d.getTime() + r3 * M4;
          return O2.w(m3, this);
        }, m2.subtract = function(t4, e2) {
          return this.add(-1 * t4, e2);
        }, m2.format = function(t4) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t5, n4, i4, s4) {
            return t5 && (t5[n4] || t5(e2, r3)) || i4[n4].slice(0, s4);
          }, c3 = function(t5) {
            return O2.s(s3 % 12 || 12, t5, "0");
          }, d3 = n3.meridiem || function(t5, e3, n4) {
            var r4 = t5 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          }, $3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
          return r3.replace(y2, function(t5, e3) {
            return e3 || $3[t5] || i3.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d3, l3) {
          var $3, y3 = O2.p(d3), M4 = w2(r3), m3 = (M4.utcOffset() - this.utcOffset()) * e, v3 = this - M4, g3 = O2.m(this, M4);
          return g3 = ($3 = {}, $3[c2] = g3 / 12, $3[f2] = g3, $3[h2] = g3 / 3, $3[o2] = (v3 - m3) / 6048e5, $3[a2] = (v3 - m3) / 864e5, $3[u2] = v3 / n2, $3[s2] = v3 / e, $3[i2] = v3 / t3, $3)[y3] || v3, l3 ? g3 : O2.a(g3);
        }, m2.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m2.$locale = function() {
          return D2[this.$L];
        }, m2.locale = function(t4, e2) {
          if (!t4)
            return this.$L;
          var n3 = this.clone(), r3 = S2(t4, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return O2.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), T = _24.prototype;
      return w2.prototype = T, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t4) {
        T[t4[1]] = function(e2) {
          return this.$g(e2, t4[0], t4[1]);
        };
      }), w2.extend = function(t4, e2) {
        return t4.$i || (t4(e2, _24, w2), t4.$i = true), w2;
      }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t4) {
        return w2(1e3 * t4);
      }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
    });
  }
});

// node_modules/dayjs/plugin/isoWeek.js
var require_isoWeek = __commonJS({
  "node_modules/dayjs/plugin/isoWeek.js"(exports, module2) {
    !function(e, t3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t3() : "function" == typeof define && define.amd ? define(t3) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isoWeek = t3();
    }(exports, function() {
      "use strict";
      var e = "day";
      return function(t3, i2, s2) {
        var a2 = function(t4) {
          return t4.add(4 - t4.isoWeekday(), e);
        }, d2 = i2.prototype;
        d2.isoWeekYear = function() {
          return a2(this).year();
        }, d2.isoWeek = function(t4) {
          if (!this.$utils().u(t4))
            return this.add(7 * (t4 - this.isoWeek()), e);
          var i3, d3, n3, o2, r2 = a2(this), u2 = (i3 = this.isoWeekYear(), d3 = this.$u, n3 = (d3 ? s2.utc : s2)().year(i3).startOf("year"), o2 = 4 - n3.isoWeekday(), n3.isoWeekday() > 4 && (o2 += 7), n3.add(o2, e));
          return r2.diff(u2, "week") + 1;
        }, d2.isoWeekday = function(e2) {
          return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
        };
        var n2 = d2.startOf;
        d2.startOf = function(e2, t4) {
          var i3 = this.$utils(), s3 = !!i3.u(t4) || t4;
          return "isoweek" === i3.p(e2) ? s3 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n2.bind(this)(e2, t4);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = __commonJS({
  "node_modules/dayjs/plugin/localizedFormat.js"(exports, module2) {
    !function(e, t3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t3() : "function" == typeof define && define.amd ? define(t3) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_localizedFormat = t3();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t3, o2, n2) {
        var r2 = o2.prototype, i2 = r2.format;
        n2.en.formats = e, r2.format = function(t4) {
          void 0 === t4 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
          var o3 = this.$locale().formats, n3 = function(t5, o4) {
            return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n4, r3) {
              var i3 = r3 && r3.toUpperCase();
              return n4 || o4[r3] || e[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t7, o5) {
                return t7 || o5.slice(1);
              });
            });
          }(t4, void 0 === o3 ? {} : o3);
          return i2.call(this, n3);
        };
      };
    });
  }
});

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra2 = function(B2) {
      return function() {
        return {
          meet: function(x2, y2) {
            return function(a2) {
              return B2.meet(x2(a2), y2(a2));
            };
          },
          join: function(x2, y2) {
            return function(a2) {
              return B2.join(x2(a2), y2(a2));
            };
          },
          zero: function() {
            return B2.zero;
          },
          one: function() {
            return B2.one;
          },
          implies: function(x2, y2) {
            return function(a2) {
              return B2.implies(x2(a2), y2(a2));
            };
          },
          not: function(x2) {
            return function(a2) {
              return B2.not(x2(a2));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra2;
    var getSemigroup7 = function(S2) {
      return function() {
        return {
          concat: function(f2, g2) {
            return function(a2) {
              return S2.concat(f2(a2), g2(a2));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup7;
    var getMonoid5 = function(M2) {
      var getSemigroupM = (0, exports.getSemigroup)(M2);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M2.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid5;
    var getSemiring2 = function(S2) {
      return {
        add: function(f2, g2) {
          return function(x2) {
            return S2.add(f2(x2), g2(x2));
          };
        },
        zero: function() {
          return S2.zero;
        },
        mul: function(f2, g2) {
          return function(x2) {
            return S2.mul(f2(x2), g2(x2));
          };
        },
        one: function() {
          return S2.one;
        }
      };
    };
    exports.getSemiring = getSemiring2;
    var getRing2 = function(R2) {
      var S2 = (0, exports.getSemiring)(R2);
      return {
        add: S2.add,
        mul: S2.mul,
        one: S2.one,
        zero: S2.zero,
        sub: function(f2, g2) {
          return function(x2) {
            return R2.sub(f2(x2), g2(x2));
          };
        }
      };
    };
    exports.getRing = getRing2;
    var apply2 = function(a2) {
      return function(f2) {
        return f2(a2);
      };
    };
    exports.apply = apply2;
    function identity3(a2) {
      return a2;
    }
    exports.identity = identity3;
    exports.unsafeCoerce = identity3;
    function constant2(a2) {
      return function() {
        return a2;
      };
    }
    exports.constant = constant2;
    exports.constTrue = constant2(true);
    exports.constFalse = constant2(false);
    exports.constNull = constant2(null);
    exports.constUndefined = constant2(void 0);
    exports.constVoid = exports.constUndefined;
    function flip4(f2) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f2(args[1], args[0]);
        }
        return function(a2) {
          return f2(a2)(args[0]);
        };
      };
    }
    exports.flip = flip4;
    function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow2;
    function tuple2() {
      var t3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t3[_i] = arguments[_i];
      }
      return t3;
    }
    exports.tuple = tuple2;
    function increment2(n2) {
      return n2 + 1;
    }
    exports.increment = increment2;
    function decrement2(n2) {
      return n2 - 1;
    }
    exports.decrement = decrement2;
    function absurd2(_24) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd2;
    function tupled2(f2) {
      return function(a2) {
        return f2.apply(void 0, a2);
      };
    }
    exports.tupled = tupled2;
    function untupled2(f2) {
      return function() {
        var a2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a2[_i] = arguments[_i];
        }
        return f2(a2);
      };
    }
    exports.untupled = untupled2;
    function pipe3(a2, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a2;
        case 2:
          return ab(a2);
        case 3:
          return bc(ab(a2));
        case 4:
          return cd(bc(ab(a2)));
        case 5:
          return de(cd(bc(ab(a2))));
        case 6:
          return ef(de(cd(bc(ab(a2)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a2))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a2)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a2))))))));
        default: {
          var ret = arguments[0];
          for (var i2 = 1; i2 < arguments.length; i2++) {
            ret = arguments[i2](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe3;
    exports.hole = absurd2;
    var SK2 = function(_24, b2) {
      return b2;
    };
    exports.SK = SK2;
    function not3(predicate) {
      return function(a2) {
        return !predicate(a2);
      };
    }
    exports.not = not3;
    var getEndomorphismMonoid2 = function() {
      return {
        concat: function(first, second) {
          return flow2(first, second);
        },
        empty: identity3
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid2;
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s2 = "short";
    var l2 = "long";
    var DATE_SHORT = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED = {
      year: n2,
      month: s2,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2
    };
    var DATE_FULL = {
      year: n2,
      month: l2,
      day: n2
    };
    var DATE_HUGE = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2
    };
    var TIME_SIMPLE = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var TIME_24_SIMPLE = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s2
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l2
    };
    var DATETIME_SHORT = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s2
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var DATETIME_HUGE = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      timeZoneName: l2
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format2) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format: format2, locale }) {
        return parseZoneInfo(ts, format2, locale);
      }
      /** @override **/
      formatOffset(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i2 = 0; i2 < formatted.length; i2++) {
        const { type, value } = formatted[i2];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s3) {
        return this.isValidZone(s3);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format: format2, locale }) {
        return parseZoneInfo(ts, format2, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const _a = opts, { base } = _a, cacheKeyOpts = __objRest(_a, ["base"]);
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f2) {
      const ms = [];
      for (let i2 = 1; i2 <= 12; i2++) {
        const dt = DateTime.utc(2016, i2, 1);
        ms.push(f2(dt));
      }
      return ms;
    }
    function mapWeekdays(f2) {
      const ms = [];
      for (let i2 = 1; i2 <= 7; i2++) {
        const dt = DateTime.utc(2016, 11, 13 + i2);
        ms.push(f2(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      const mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const _a = opts, { padTo, floor } = _a, otherOpts = __objRest(_a, ["padTo", "floor"]);
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = __spreadValues({ useGrouping: false }, opts);
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i2) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i2) : i2;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i2) : roundTo(i2, 3);
          return padStart(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        let z2 = void 0;
        if (dt.zone.isUniversal) {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z2 = offsetZ;
            this.dt = dt;
          } else {
            z2 = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z2 = dt.zone.name;
        }
        const intlOpts = __spreadValues({}, this.opts);
        intlOpts.timeZone = intlOpts.timeZone || z2;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = __spreadValues({ style: "long" }, opts);
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: true }));
      }
      redefaultToSystem(alts = {}) {
        return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: false }));
      }
      months(length, format2 = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, months, () => {
          const intl = format2 ? { month: length, day: "numeric" } : { month: length }, formatStr = format2 ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format2 = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, weekdays, () => {
          const intl = format2 ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format2 ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems(defaultOK = true) {
        return listStuff(
          this,
          void 0,
          defaultOK,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length, defaultOK = true) {
        return listStuff(this, length, defaultOK, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton2 = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton2 === null) {
          singleton2 = new FixedOffsetZone(0);
        }
        return singleton2;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset3) {
        return offset3 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset3);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s3) {
        if (s3) {
          const r2 = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r2) {
            return new FixedOffsetZone(signedOffset(r2[1], r2[2]));
          }
        }
        return null;
      }
      constructor(offset3) {
        super();
        this.fixed = offset3;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format2) {
        return formatOffset(this.fixed, format2);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString2(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now2 = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now2;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now2 = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t3) {
        throwOnInvalid = t3;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o2) {
      return typeof o2 === "undefined";
    }
    function isNumber2(o2) {
      return typeof o2 === "number";
    }
    function isInteger(o2) {
      return typeof o2 === "number" && o2 % 1 === 0;
    }
    function isString2(o2) {
      return typeof o2 === "string";
    }
    function isDate2(o2) {
      return Object.prototype.toString.call(o2) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare2) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next2) => {
        const pair = [by(next2), next2];
        if (!best) {
          return pair;
        } else if (compare2(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a2, k2) => {
        a2[k2] = obj[k2];
        return a2;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom2, top2) {
      return isInteger(thing) && thing >= bottom2 && thing <= top2;
    }
    function floorMod(x2, n3) {
      return x2 - n3 * Math.floor(x2 / n3);
    }
    function padStart(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger(string2) {
      if (isUndefined(string2) || string2 === null || string2 === "") {
        return void 0;
      } else {
        return parseInt(string2, 10);
      }
    }
    function parseFloating(string2) {
      if (isUndefined(string2) || string2 === null || string2 === "") {
        return void 0;
      } else {
        return parseFloat(string2);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f2 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f2);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d2 = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d2 = new Date(d2);
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      return +d2;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last5 = weekYear - 1, p2 = (last5 + Math.floor(last5 / 4) - Math.floor(last5 / 100) + Math.floor(last5 / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = __spreadValues({ timeZoneName: offsetFormat }, intlOpts);
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u2 in obj) {
        if (hasOwnProperty(obj, u2)) {
          const v2 = obj[u2];
          if (v2 === void 0 || v2 === null)
            continue;
          normalized[normalizer(u2)] = asNumber(v2);
        }
      }
      return normalized;
    }
    function formatOffset(offset3, format2) {
      const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
      switch (format2) {
        case "short":
          return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format2} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s3 = "";
      for (const token of splits) {
        if (token.literal) {
          s3 += token.val;
        } else {
          s3 += tokenToString(token.val);
        }
      }
      return s3;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter2 = class {
      static create(locale, opts = {}) {
        return new Formatter2(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i2 = 0; i2 < fmt.length; i2++) {
          const c2 = fmt.charAt(i2);
          if (c2 === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed, val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c2;
          } else if (c2 === current) {
            currentFull += c2;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: false, val: currentFull });
            }
            currentFull = c2;
            current = c2;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
        return df.format();
      }
      formatDateTime(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
        return df.format();
      }
      formatDateTimeParts(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
        return df.formatToParts();
      }
      formatInterval(interval, opts = {}) {
        const df = this.loc.dtFormatter(interval.start, __spreadValues(__spreadValues({}, this.opts), opts));
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
        return df.resolvedOptions();
      }
      num(n3, p2 = 0) {
        if (this.opts.forceSimple) {
          return padStart(n3, p2);
        }
        const opts = __spreadValues({}, this.opts);
        if (p2 > 0) {
          opts.padTo = p2;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract2) => this.loc.extract(dt, opts, extract2), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t3) => t3));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f2, r2) => f2 + r2.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next2] = ex(m, cursor);
          return [__spreadValues(__spreadValues({}, mergedVals), val), zone || mergedZone, next2];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse2(s3, ...patterns) {
      if (s3 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s3);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match7, cursor) => {
        const ret = {};
        let i2;
        for (i2 = 0; i2 < keys.length; i2++) {
          ret[keys[i2]] = parseInteger(match7[cursor + i2]);
        }
        return [ret, null, cursor + i2];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int3(match7, pos, fallback) {
      const m = match7[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match7, cursor) {
      const item = {
        year: int3(match7, cursor),
        month: int3(match7, cursor + 1, 1),
        day: int3(match7, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match7, cursor) {
      const item = {
        hours: int3(match7, cursor, 0),
        minutes: int3(match7, cursor + 1, 0),
        seconds: int3(match7, cursor + 2, 0),
        milliseconds: parseMillis(match7[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match7, cursor) {
      const local = !match7[cursor] && !match7[cursor + 1], fullOffset = signedOffset(match7[cursor + 1], match7[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match7, cursor) {
      const zone = match7[cursor] ? IANAZone.create(match7[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match7) {
      const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match7;
      const hasNegativePrefix = s3[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match7) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match7, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset3;
      if (obsOffset) {
        offset3 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset3 = 0;
      } else {
        offset3 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset3)];
    }
    function preprocessRFC2822(s3) {
      return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match7) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match7, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match7) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match7, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s3) {
      return parse2(
        s3,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s3) {
      return parse2(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s3) {
      return parse2(
        s3,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s3) {
      return parse2(s3, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s3) {
      return parse2(s3, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s3) {
      return parse2(
        s3,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = __spreadValues({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = __spreadValues({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : __spreadValues(__spreadValues({}, dur.values), alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function antiTrunc(n3) {
      return n3 < 0 ? Math.floor(n3) : Math.ceil(n3);
    }
    function convert(matrix2, fromMap, fromUnit, toMap, toUnit) {
      const conv = matrix2[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix2, vals) {
      reverseUnits.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix2, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix2 = accurate ? accurateMatrix : casualMatrix;
        if (config.matrix) {
          matrix2 = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix2;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text2, opts) {
        const [parsed] = parseISODuration(text2);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text2, opts) {
        const [parsed] = parseISOTimeOnly(text2);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o2) {
        return o2 && o2.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = __spreadProps(__spreadValues({}, opts), {
          floor: opts.round !== false && opts.floor !== false
        });
        return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        const l3 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter(__spreadProps(__spreadValues({ style: "unit", unitDisplay: "long" }, opts), { unit: unit.slice(0, -1) })).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter(__spreadValues({ type: "conjunction", style: opts.listStyle || "narrow" }, opts)).format(l3);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return __spreadValues({}, this.values);
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s3 = "P";
        if (this.years !== 0)
          s3 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s3 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s3 += this.weeks + "W";
        if (this.days !== 0)
          s3 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s3 += "T";
        if (this.hours !== 0)
          s3 += this.hours + "H";
        if (this.minutes !== 0)
          s3 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s3 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s3 === "P")
          s3 += "T0S";
        return s3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = __spreadValues({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        let str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        return this.as("milliseconds");
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k2 of orderedUnits$1) {
          if (hasOwnProperty(dur.values, k2) || hasOwnProperty(this.values, k2)) {
            result[k2] = dur.get(k2) + this.get(k2);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn3) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k2 of Object.keys(this.values)) {
          result[k2] = asNumber(fn3(this.values[k2], k2));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = __spreadValues(__spreadValues({}, this.values), normalizeObject(values, Duration.normalizeUnit));
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix: matrix2 } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix: matrix2, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u2) => Duration.normalizeUnit(u2));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k2 of orderedUnits$1) {
          if (units.indexOf(k2) >= 0) {
            lastUnit = k2;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k2] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k2])) {
              own += vals[k2];
            }
            const i2 = Math.trunc(own);
            built[k2] = i2;
            accumulated[k2] = (own * 1e3 - i2 * 1e3) / 1e3;
            for (const down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k2)) {
                convert(this.matrix, vals, down, built, k2);
              }
            }
          } else if (isNumber2(vals[k2])) {
            accumulated[k2] = vals[k2];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$1(this, { values: built }, true).normalize();
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k2 of Object.keys(this.values)) {
          negated[k2] = this.values[k2] === 0 ? 0 : -this.values[k2];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u2 of orderedUnits$1) {
          if (!eq(this.values[u2], other.values[u2])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start2, end2) {
      if (!start2 || !start2.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end2 || !end2.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end2 < start2) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end2.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start2, end2) {
        const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end2);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start2, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end2, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end2);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text2, opts) {
        const [s3, e] = (text2 || "").split("/", 2);
        if (s3 && e) {
          let start2, startIsValid;
          try {
            start2 = DateTime.fromISO(s3, opts);
            startIsValid = start2.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end2, endIsValid;
          try {
            end2 = DateTime.fromISO(e, opts);
            endIsValid = end2.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start2, end2);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval.after(start2, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s3, opts);
            if (dur.isValid) {
              return Interval.before(end2, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o2) {
        return o2 && o2.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start2 = this.start.startOf(unit), end2 = this.end.startOf(unit);
        return Math.floor(end2.diff(start2, unit).get(unit)) + 1;
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start: start2, end: end2 } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start2 || this.s, end2 || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
        let { s: s3 } = this, i2 = 0;
        while (s3 < this.e) {
          const added = sorted[i2] || this.e, next2 = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s3, next2));
          s3 = next2;
          i2 += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s3 } = this, idx = 1, next2;
        const results = [];
        while (s3 < this.e) {
          const added = this.start.plus(dur.mapUnits((x2) => x2 * idx));
          next2 = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s3, next2));
          s3 = next2;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s3 >= e) {
          return null;
        } else {
          return Interval.fromDateTimes(s3, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s3, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a2, b2) => a2.s - b2.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start2 = null, currentCount = 0;
        const results = [], ends = intervals.map((i2) => [
          { time: i2.s, type: "s" },
          { time: i2.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b2) => a2.time - b2.time);
        for (const i2 of arr) {
          currentCount += i2.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start2 = i2.time;
          } else {
            if (start2 && +start2 !== +i2.time) {
              results.push(Interval.fromDateTimes(start2, i2.time));
            }
            start2 = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i2) => this.intersection(i2)).filter((i2) => i2 && !i2.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter2.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a2, b2) => b2.year - a2.year],
        ["quarters", (a2, b2) => b2.quarter - a2.quarter + (b2.year - a2.year) * 4],
        ["months", (a2, b2) => b2.month - a2.month + (b2.year - a2.year) * 12],
        [
          "weeks",
          (a2, b2) => {
            const days = dayDiff(a2, b2);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i2 = 0; i2 < str.length; i2++) {
          const code = str.charCodeAt(i2);
          if (str[i2].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i2]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min3, max3] = numberingSystemsUTF16[key];
              if (code >= min3 && code <= max3) {
                value += code - min3;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append5 = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append5}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i2) => i2) {
      return { regex, deser: ([s3]) => post(parseDigits(s3)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s3) {
      return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s3) {
      return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s3]) => strings.findIndex((i2) => stripInsensitivities(s3) === stripInsensitivities(i2)) + startIndex
        };
      }
    }
    function offset2(regex, groups) {
      return { regex, deser: ([, h2, m]) => signedOffset(h2, m), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s3]) => s3 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t3) => ({ regex: RegExp(escapeToken(t3.val)), deser: ([s3]) => s3, literal: true }), unitate = (t3) => {
        if (token.literal) {
          return literal(t3);
        }
        switch (t3.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t3);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts) {
      const { type, value } = part;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      const style = formatOpts[type];
      let val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u2) => u2.regex).reduce((f2, r2) => `${f2}(${r2.source})`, "");
      return [`^${re}$`, units];
    }
    function match6(input, regex, handlers) {
      const matches2 = input.match(regex);
      if (matches2) {
        const all = {};
        let matchIndex = 1;
        for (const i2 in handlers) {
          if (hasOwnProperty(handlers, i2)) {
            const h2 = handlers[i2], groups = h2.groups ? h2.groups + 1 : 1;
            if (!h2.literal && h2.token) {
              all[h2.token.val[0]] = h2.deser(matches2.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches2, all];
      } else {
        return [matches2, {}];
      }
    }
    function dateTimeFromMatches(matches2) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches2.z)) {
        zone = IANAZone.create(matches2.z);
      }
      if (!isUndefined(matches2.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches2.Z);
        }
        specificOffset = matches2.Z;
      }
      if (!isUndefined(matches2.q)) {
        matches2.M = (matches2.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches2.h)) {
        if (matches2.h < 12 && matches2.a === 1) {
          matches2.h += 12;
        } else if (matches2.h === 12 && matches2.a === 0) {
          matches2.h = 0;
        }
      }
      if (matches2.G === 0 && matches2.y) {
        matches2.y = -matches2.y;
      }
      if (!isUndefined(matches2.u)) {
        matches2.S = parseMillis(matches2.u);
      }
      const vals = Object.keys(matches2).reduce((r2, k2) => {
        const f2 = toField(k2);
        if (f2) {
          r2[f2] = matches2[k2];
        }
        return r2;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t3) => maybeExpandMacroToken(t3, locale)));
    }
    function explainFromTokens(locale, input, format2) {
      const tokens = expandMacroTokens(Formatter2.parseFormat(format2), locale), units = tokens.map((t3) => unitForToken(t3, locale)), disqualifyingUnit = units.find((t3) => t3.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches2] = match6(input, regex, handlers), [result, zone, specificOffset] = matches2 ? dateTimeFromMatches(matches2) : [null, null, void 0];
        if (hasOwnProperty(matches2, "a") && hasOwnProperty(matches2, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches: matches2, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format2) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format2);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter2.create(locale, formatOpts);
      const parts = formatter.formatDateTimeParts(getDummyDateTime());
      return parts.map((p2) => tokenForPart(p2, formatOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d2 = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      const js = d2.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i2) => i2 < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return __spreadValues({ weekYear, weekNumber, weekday }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return __spreadValues({ year, month, day }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return __spreadValues({ year, ordinal }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return __spreadValues({ year, month, day }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime(__spreadProps(__spreadValues(__spreadValues({}, current), alts), { old: current }));
    }
    function fixOffset(localTS, o2, tz) {
      let utcGuess = localTS - o2 * 60 * 1e3;
      const o22 = tz.offset(utcGuess);
      if (o2 === o22) {
        return [utcGuess, o2];
      }
      utcGuess -= (o22 - o2) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o22 === o3) {
        return [utcGuess, o22];
      }
      return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
    }
    function tsToObj(ts, offset3) {
      ts += offset3 * 60 * 1e3;
      const d2 = new Date(ts);
      return {
        year: d2.getUTCFullYear(),
        month: d2.getUTCMonth() + 1,
        day: d2.getUTCDate(),
        hour: d2.getUTCHours(),
        minute: d2.getUTCMinutes(),
        second: d2.getUTCSeconds(),
        millisecond: d2.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset3, zone) {
      return fixOffset(objToLocalTS(obj), offset3, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = __spreadProps(__spreadValues({}, inst.c), {
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }), millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c2);
      let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o2 = inst.zone.offset(ts);
      }
      return { ts, o: o2 };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format2, text2, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0) {
        const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, __spreadProps(__spreadValues({}, opts), {
          zone: interpretationZone,
          specificOffset
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(
          new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format2}`)
        );
      }
    }
    function toTechFormat(dt, format2, allowZ = true) {
      return dt.isValid ? Formatter2.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format2) : null;
    }
    function toISODate(o2, extended) {
      const longFormat = o2.c.year > 9999 || o2.c.year < 0;
      let c2 = "";
      if (longFormat && o2.c.year >= 0)
        c2 += "+";
      c2 += padStart(o2.c.year, longFormat ? 6 : 4);
      if (extended) {
        c2 += "-";
        c2 += padStart(o2.c.month);
        c2 += "-";
        c2 += padStart(o2.c.day);
      } else {
        c2 += padStart(o2.c.month);
        c2 += padStart(o2.c.day);
      }
      return c2;
    }
    function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c2 = padStart(o2.c.hour);
      if (extended) {
        c2 += ":";
        c2 += padStart(o2.c.minute);
        if (o2.c.second !== 0 || !suppressSeconds) {
          c2 += ":";
        }
      } else {
        c2 += padStart(o2.c.minute);
      }
      if (o2.c.second !== 0 || !suppressSeconds) {
        c2 += padStart(o2.c.second);
        if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
          c2 += ".";
          c2 += padStart(o2.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
          c2 += "Z";
        } else if (o2.o < 0) {
          c2 += "-";
          c2 += padStart(Math.trunc(-o2.o / 60));
          c2 += ":";
          c2 += padStart(Math.trunc(-o2.o % 60));
        } else {
          c2 += "+";
          c2 += padStart(Math.trunc(o2.o / 60));
          c2 += ":";
          c2 += padStart(Math.trunc(o2.o % 60));
        }
      }
      if (extendedZone) {
        c2 += "[" + o2.zone.ianaName + "]";
      }
      return c2;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o2;
      if (!isUndefined(obj.year)) {
        for (const u2 of orderedUnits) {
          if (isUndefined(obj[u2])) {
            obj[u2] = defaultUnitValues[u2];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o2] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime({ ts, zone, loc, o: o2 });
    }
    function diffRelative(start2, end2, opts) {
      const round2 = isUndefined(opts.round) ? true : opts.round, format2 = (c2, unit) => {
        c2 = roundTo(c2, round2 || opts.calendary ? 0 : 2, true);
        const formatter = end2.loc.clone(opts).relFormatter(opts);
        return formatter.format(c2, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end2.hasSame(start2, unit)) {
            return end2.startOf(unit).diff(start2.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end2.diff(start2, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format2(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format2(count, unit);
        }
      }
      return format2(start2 > end2 ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime = class {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        let c2 = null, o2 = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c2, o2] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c2 = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
            c2 = invalid ? null : c2;
            o2 = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c2;
        this.o = o2;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime.invalid("Timestamp out of range");
        } else {
          return new DateTime({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u2 of units) {
          const v2 = normalized[u2];
          if (!isUndefined(v2)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u2] = defaultValues[u2];
          } else {
            normalized[u2] = objNow[u2];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text2, opts = {}) {
        const [vals, parsedZone] = parseISODate(text2);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text2, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text2);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text2, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text2);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text2, fmt, opts = {}) {
        if (isUndefined(text2) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
        if (invalid) {
          return DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text2, fmt, opts = {}) {
        return DateTime.fromFormat(text2, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text2, opts = {}) {
        const [vals, parsedZone] = parseSQL(text2);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
      }
      /**
       * Create an invalid DateTime.
       * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o2) {
        return o2 && o2.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t3) => t3 ? t3.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter2.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t3) => t3.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter2.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset3 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset3), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian(__spreadValues(__spreadValues({}, gregorianToWeek(this.c)), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(__spreadValues(__spreadValues({}, gregorianToOrdinal(this.c)), normalized));
        } else {
          mixed = __spreadValues(__spreadValues({}, this.toObject()), normalized);
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o2] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o: o2 });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o2.month = 1;
          case "quarters":
          case "months":
            o2.day = 1;
          case "weeks":
          case "days":
            o2.hour = 0;
          case "hours":
            o2.minute = 0;
          case "minutes":
            o2.second = 0;
          case "seconds":
            o2.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o2.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q2 = Math.ceil(this.month / 3);
          o2.month = (q2 - 1) * 3 + 1;
        }
        return this.set(o2);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format: format2 = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format2 === "extended";
        let c2 = toISODate(this, ext);
        c2 += "T";
        c2 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c2;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format: format2 = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format2 === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format: format2 = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c2 = includePrefix ? "T" : "";
        return c2 + toISOTime(
          this,
          format2 === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = __spreadValues({}, this.c);
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = __spreadValues({ locale: this.locale, numberingSystem: this.numberingSystem }, opts);
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), __spreadProps(__spreadValues({}, options), {
          numeric: "always",
          units,
          unit
        }));
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, __spreadProps(__spreadValues({}, options), {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i2) => i2.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i2) => i2.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text2, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text2, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text2, fmt, options = {}) {
        return DateTime.fromFormatExplain(text2, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_QUERY_SETTINGS), DEFAULT_EXPORT_SETTINGS), {
      inlineQueryPrefix: "=",
      inlineJsQueryPrefix: "$=",
      inlineQueriesInCodeblocks: true,
      enableInlineDataview: true,
      enableDataviewJs: false,
      enableInlineDataviewJs: false,
      prettyRenderInlineFields: true,
      dataviewJsKeyword: "dataviewjs"
    });
    var Success = class {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f2) {
        return new Success(f2(this.value));
      }
      flatMap(f2) {
        return f2(this.value);
      }
      mapErr(f2) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error2) {
        this.error = error2;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f2) {
        return new Failure(f2(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error2) {
        return new Failure(error2);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f2) {
        if (first.successful) {
          if (second.successful)
            return f2(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map22(first, second, f2) {
        return flatMap2(first, second, (a2, b2) => success(f2(a2, b2)));
      }
      Result2.map2 = map22;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    (function(module3, exports2) {
      !function(n3, t3) {
        module3.exports = t3();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t3 = {};
          function r2(e) {
            if (t3[e])
              return t3[e].exports;
            var u2 = t3[e] = { i: e, l: false, exports: {} };
            return n3[e].call(u2.exports, u2, u2.exports, r2), u2.l = true, u2.exports;
          }
          return r2.m = n3, r2.c = t3, r2.d = function(n4, t4, e) {
            r2.o(n4, t4) || Object.defineProperty(n4, t4, { configurable: false, enumerable: true, get: e });
          }, r2.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r2.n = function(n4) {
            var t4 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r2.d(t4, "a", t4), t4;
          }, r2.o = function(n4, t4) {
            return Object.prototype.hasOwnProperty.call(n4, t4);
          }, r2.p = "", r2(r2.s = 0);
        }([function(n3, t3, r2) {
          function e(n4) {
            if (!(this instanceof e))
              return new e(n4);
            this._ = n4;
          }
          var u2 = e.prototype;
          function o2(n4, t4) {
            for (var r3 = 0; r3 < n4; r3++)
              t4(r3);
          }
          function i2(n4, t4, r3) {
            return function(n5, t5) {
              o2(t5.length, function(r4) {
                n5(t5[r4], r4, t5);
              });
            }(function(r4, e2, u3) {
              t4 = n4(t4, r4, e2, u3);
            }, r3), t4;
          }
          function a2(n4, t4) {
            return i2(function(t5, r3, e2, u3) {
              return t5.concat([n4(r3, e2, u3)]);
            }, [], t4);
          }
          function f2(n4, t4) {
            var r3 = { v: 0, buf: t4 };
            return o2(n4, function() {
              var n5;
              r3 = { v: r3.v << 1 | (n5 = r3.buf, n5[0] >> 7), buf: function(n6) {
                var t5 = i2(function(n7, t6, r4, e2) {
                  return n7.concat(r4 === e2.length - 1 ? Buffer.from([t6, 0]).readUInt16BE(0) : e2.readUInt16BE(r4));
                }, [], n6);
                return Buffer.from(a2(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t5));
              }(r3.buf) };
            }), r3;
          }
          function c2() {
            return "undefined" != typeof Buffer;
          }
          function s3() {
            if (!c2())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l3(n4) {
            s3();
            var t4 = i2(function(n5, t5) {
              return n5 + t5;
            }, 0, n4);
            if (t4 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t4 + " which is not an even number of bytes; the total should be divisible by 8");
            var r3, u3 = t4 / 8, o3 = (r3 = function(n5) {
              return n5 > 48;
            }, i2(function(n5, t5) {
              return n5 || (r3(t5) ? t5 : n5);
            }, null, n4));
            if (o3)
              throw new Error(o3 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t5, r4) {
              var e2 = u3 + r4;
              return e2 > t5.length ? x2(r4, u3.toString() + " bytes") : b2(e2, i2(function(n5, t6) {
                var r5 = f2(t6, n5.buf);
                return { coll: n5.coll.concat(r5.v), buf: r5.buf };
              }, { coll: [], buf: t5.slice(r4, e2) }, n4).coll);
            });
          }
          function h2(n4, t4) {
            return new e(function(r3, e2) {
              return s3(), e2 + t4 > r3.length ? x2(e2, t4 + " bytes for " + n4) : b2(e2 + t4, r3.slice(e2, e2 + t4));
            });
          }
          function p2(n4, t4) {
            if ("number" != typeof (r3 = t4) || Math.floor(r3) !== r3 || t4 < 0 || t4 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r3;
          }
          function d2(n4) {
            return p2("uintBE", n4), h2("uintBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntBE(0, n4);
            });
          }
          function v2(n4) {
            return p2("uintLE", n4), h2("uintLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntLE(0, n4);
            });
          }
          function g2(n4) {
            return p2("intBE", n4), h2("intBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntBE(0, n4);
            });
          }
          function m(n4) {
            return p2("intLE", n4), h2("intLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntLE(0, n4);
            });
          }
          function y2(n4) {
            return n4 instanceof e;
          }
          function E2(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w2(n4) {
            return c2() && Buffer.isBuffer(n4);
          }
          function b2(n4, t4) {
            return { status: true, index: n4, value: t4, furthest: -1, expected: [] };
          }
          function x2(n4, t4) {
            return E2(t4) || (t4 = [t4]), { status: false, index: -1, value: null, furthest: n4, expected: t4 };
          }
          function B2(n4, t4) {
            if (!t4)
              return n4;
            if (n4.furthest > t4.furthest)
              return n4;
            var r3 = n4.furthest === t4.furthest ? function(n5, t5) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r4 = new Set(n5), u3 = 0; u3 < t5.length; u3++)
                  r4.add(t5[u3]);
                var o3 = Array.from(r4);
                return o3.sort(), o3;
              }
              for (var i3 = {}, a3 = 0; a3 < n5.length; a3++)
                i3[n5[a3]] = true;
              for (var f3 = 0; f3 < t5.length; f3++)
                i3[t5[f3]] = true;
              var c3 = [];
              for (var s4 in i3)
                ({}).hasOwnProperty.call(i3, s4) && c3.push(s4);
              return c3.sort(), c3;
            }(n4.expected, t4.expected) : t4.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t4.furthest, expected: r3 };
          }
          var j2 = {};
          function S2(n4, t4) {
            if (w2(n4))
              return { offset: t4, line: -1, column: -1 };
            n4 in j2 || (j2[n4] = {});
            for (var r3 = j2[n4], e2 = 0, u3 = 0, o3 = 0, i3 = t4; i3 >= 0; ) {
              if (i3 in r3) {
                e2 = r3[i3].line, 0 === o3 && (o3 = r3[i3].lineStart);
                break;
              }
              ("\n" === n4.charAt(i3) || "\r" === n4.charAt(i3) && "\n" !== n4.charAt(i3 + 1)) && (u3++, 0 === o3 && (o3 = i3 + 1)), i3--;
            }
            var a3 = e2 + u3, f3 = t4 - o3;
            return r3[t4] = { line: a3, lineStart: o3 }, { offset: t4, line: a3 + 1, column: f3 + 1 };
          }
          function _24(n4) {
            if (!y2(n4))
              throw new Error("not a parser: " + n4);
          }
          function L2(n4, t4) {
            return "string" == typeof n4 ? n4.charAt(t4) : n4[t4];
          }
          function O2(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k2(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P2(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q2 = 2, A2 = 3, I2 = 8, F = 5 * I2, M2 = 4 * I2, z2 = "  ";
          function R2(n4, t4) {
            return new Array(t4 + 1).join(n4);
          }
          function U2(n4, t4, r3) {
            var e2 = t4 - n4.length;
            return e2 <= 0 ? n4 : R2(r3, e2) + n4;
          }
          function W2(n4, t4, r3, e2) {
            return { from: n4 - t4 > 0 ? n4 - t4 : 0, to: n4 + r3 > e2 ? e2 : n4 + r3 };
          }
          function D2(n4, t4) {
            var r3, e2, u3, o3, f3, c3 = t4.index, s4 = c3.offset, l4 = 1;
            if (s4 === n4.length)
              return "Got the end of the input";
            if (w2(n4)) {
              var h3 = s4 - s4 % I2, p3 = s4 - h3, d3 = W2(h3, F, M2 + I2, n4.length), v3 = a2(function(n5) {
                return a2(function(n6) {
                  return U2(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t5) {
                var r4 = n5.length, e3 = [], u4 = 0;
                if (r4 <= t5)
                  return [n5.slice()];
                for (var o4 = 0; o4 < r4; o4++)
                  e3[u4] || e3.push([]), e3[u4].push(n5[o4]), (o4 + 1) % t5 == 0 && u4++;
                return e3;
              }(n4.slice(d3.from, d3.to).toJSON().data, I2));
              o3 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I2, to: Math.floor(n5.to / I2) };
              }(d3), e2 = h3 / I2, r3 = 3 * p3, p3 >= 4 && (r3 += 1), l4 = 2, u3 = a2(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v3), (f3 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f3 = 2);
            } else {
              var g3 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r3 = c3.column - 1, e2 = c3.line - 1, o3 = W2(e2, q2, A2, g3.length), u3 = g3.slice(o3.from, o3.to), f3 = o3.to.toString().length;
            }
            var m2 = e2 - o3.from;
            return w2(n4) && (f3 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f3 = 2), i2(function(t5, e3, u4) {
              var i3, a3 = u4 === m2, c4 = a3 ? "> " : z2;
              return i3 = w2(n4) ? U2((8 * (o3.from + u4)).toString(16), f3, "0") : U2((o3.from + u4 + 1).toString(), f3, " "), [].concat(t5, [c4 + i3 + " | " + e3], a3 ? [z2 + R2(" ", f3) + " | " + U2("", r3, " ") + R2("^", l4)] : []);
            }, [], u3).join("\n");
          }
          function N2(n4, t4) {
            return ["\n", "-- PARSING FAILED " + R2("-", 50), "\n\n", D2(n4, t4), "\n\n", (r3 = t4.expected, 1 === r3.length ? "Expected:\n\n" + r3[0] : "Expected one of the following: \n\n" + r3.join(", ")), "\n"].join("");
            var r3;
          }
          function G2(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n4 = [].slice.call(arguments), t4 = n4.length, r3 = 0; r3 < t4; r3 += 1)
              _24(n4[r3]);
            return e(function(r4, e2) {
              for (var u3, o3 = new Array(t4), i3 = 0; i3 < t4; i3 += 1) {
                if (!(u3 = B2(n4[i3]._(r4, e2), u3)).status)
                  return u3;
                o3[i3] = u3.value, e2 = u3.index;
              }
              return B2(b2(e2, o3), u3);
            });
          }
          function J() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t4 = n4.pop();
            return k2(t4), C.apply(null, n4).map(function(n5) {
              return t4.apply(null, n5);
            });
          }
          function T() {
            var n4 = [].slice.call(arguments), t4 = n4.length;
            if (0 === t4)
              return Y2("zero alternates");
            for (var r3 = 0; r3 < t4; r3 += 1)
              _24(n4[r3]);
            return e(function(t5, r4) {
              for (var e2, u3 = 0; u3 < n4.length; u3 += 1)
                if ((e2 = B2(n4[u3]._(t5, r4), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n4, t4) {
            return H2(n4, t4).or(X2([]));
          }
          function H2(n4, t4) {
            return _24(n4), _24(t4), J(n4, t4.then(n4).many(), function(n5, t5) {
              return [n5].concat(t5);
            });
          }
          function K2(n4) {
            P2(n4);
            var t4 = "'" + n4 + "'";
            return e(function(r3, e2) {
              var u3 = e2 + n4.length, o3 = r3.slice(e2, u3);
              return o3 === n4 ? b2(u3, o3) : x2(e2, t4);
            });
          }
          function Q2(n4, t4) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t5 = G2(n5), r4 = 0; r4 < t5.length; r4++) {
                var e2 = t5.charAt(r4);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O2(t4) : t4 = 0;
            var r3 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G2(n5));
            }(n4), u3 = "" + n4;
            return e(function(n5, e2) {
              var o3 = r3.exec(n5.slice(e2));
              if (o3) {
                if (0 <= t4 && t4 <= o3.length) {
                  var i3 = o3[0], a3 = o3[t4];
                  return b2(e2 + i3.length, a3);
                }
                return x2(e2, "valid match group (0 to " + o3.length + ") in " + u3);
              }
              return x2(e2, u3);
            });
          }
          function X2(n4) {
            return e(function(t4, r3) {
              return b2(r3, n4);
            });
          }
          function Y2(n4) {
            return e(function(t4, r3) {
              return x2(r3, n4);
            });
          }
          function Z2(n4) {
            if (y2(n4))
              return e(function(t4, r3) {
                var e2 = n4._(t4, r3);
                return e2.index = r3, e2.value = "", e2;
              });
            if ("string" == typeof n4)
              return Z2(K2(n4));
            if (n4 instanceof RegExp)
              return Z2(Q2(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $2(n4) {
            return _24(n4), e(function(t4, r3) {
              var e2 = n4._(t4, r3), u3 = t4.slice(r3, e2.index);
              return e2.status ? x2(r3, 'not "' + u3 + '"') : b2(r3, null);
            });
          }
          function nn2(n4) {
            return k2(n4), e(function(t4, r3) {
              var e2 = L2(t4, r3);
              return r3 < t4.length && n4(e2) ? b2(r3 + 1, e2) : x2(r3, "a character/byte matching " + n4);
            });
          }
          function tn2(n4, t4) {
            arguments.length < 2 && (t4 = n4, n4 = void 0);
            var r3 = e(function(n5, e2) {
              return r3._ = t4()._, r3._(n5, e2);
            });
            return n4 ? r3.desc(n4) : r3;
          }
          function rn2() {
            return Y2("fantasy-land/empty");
          }
          u2.parse = function(n4) {
            if ("string" != typeof n4 && !w2(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t4, r3 = this.skip(an2)._(n4, 0);
            return t4 = r3.status ? { status: true, value: r3.value } : { status: false, index: S2(n4, r3.furthest), expected: r3.expected }, delete j2[n4], t4;
          }, u2.tryParse = function(n4) {
            var t4 = this.parse(n4);
            if (t4.status)
              return t4.value;
            var r3 = N2(n4, t4), e2 = new Error(r3);
            throw e2.type = "ParsimmonError", e2.result = t4, e2;
          }, u2.assert = function(n4, t4) {
            return this.chain(function(r3) {
              return n4(r3) ? X2(r3) : Y2(t4);
            });
          }, u2.or = function(n4) {
            return T(this, n4);
          }, u2.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u2.wrap = function(n4, t4) {
            return J(n4, this, t4, function(n5, t5) {
              return t5;
            });
          }, u2.thru = function(n4) {
            return n4(this);
          }, u2.then = function(n4) {
            return _24(n4), C(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u2.many = function() {
            var n4 = this;
            return e(function(t4, r3) {
              for (var e2 = [], u3 = void 0; ; ) {
                if (!(u3 = B2(n4._(t4, r3), u3)).status)
                  return B2(b2(r3, e2), u3);
                if (r3 === u3.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r3 = u3.index, e2.push(u3.value);
              }
            });
          }, u2.tieWith = function(n4) {
            return P2(n4), this.map(function(t4) {
              if (function(n5) {
                if (!E2(n5))
                  throw new Error("not an array: " + n5);
              }(t4), t4.length) {
                P2(t4[0]);
                for (var r3 = t4[0], e2 = 1; e2 < t4.length; e2++)
                  P2(t4[e2]), r3 += n4 + t4[e2];
                return r3;
              }
              return "";
            });
          }, u2.tie = function() {
            return this.tieWith("");
          }, u2.times = function(n4, t4) {
            var r3 = this;
            return arguments.length < 2 && (t4 = n4), O2(n4), O2(t4), e(function(e2, u3) {
              for (var o3 = [], i3 = void 0, a3 = void 0, f3 = 0; f3 < n4; f3 += 1) {
                if (a3 = B2(i3 = r3._(e2, u3), a3), !i3.status)
                  return a3;
                u3 = i3.index, o3.push(i3.value);
              }
              for (; f3 < t4 && (a3 = B2(i3 = r3._(e2, u3), a3), i3.status); f3 += 1)
                u3 = i3.index, o3.push(i3.value);
              return B2(b2(u3, o3), a3);
            });
          }, u2.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u2.atMost = function(n4) {
            return this.times(0, n4);
          }, u2.atLeast = function(n4) {
            return J(this.times(n4), this.many(), function(n5, t4) {
              return n5.concat(t4);
            });
          }, u2.map = function(n4) {
            k2(n4);
            var t4 = this;
            return e(function(r3, e2) {
              var u3 = t4._(r3, e2);
              return u3.status ? B2(b2(u3.index, n4(u3.value)), u3) : u3;
            });
          }, u2.contramap = function(n4) {
            k2(n4);
            var t4 = this;
            return e(function(r3, e2) {
              var u3 = t4.parse(n4(r3.slice(e2)));
              return u3.status ? b2(e2 + r3.length, u3.value) : u3;
            });
          }, u2.promap = function(n4, t4) {
            return k2(n4), k2(t4), this.contramap(n4).map(t4);
          }, u2.skip = function(n4) {
            return C(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u2.mark = function() {
            return J(en2, this, en2, function(n4, t4, r3) {
              return { start: n4, value: t4, end: r3 };
            });
          }, u2.node = function(n4) {
            return J(en2, this, en2, function(t4, r3, e2) {
              return { name: n4, value: r3, start: t4, end: e2 };
            });
          }, u2.sepBy = function(n4) {
            return V(this, n4);
          }, u2.sepBy1 = function(n4) {
            return H2(this, n4);
          }, u2.lookahead = function(n4) {
            return this.skip(Z2(n4));
          }, u2.notFollowedBy = function(n4) {
            return this.skip($2(n4));
          }, u2.desc = function(n4) {
            E2(n4) || (n4 = [n4]);
            var t4 = this;
            return e(function(r3, e2) {
              var u3 = t4._(r3, e2);
              return u3.status || (u3.expected = n4), u3;
            });
          }, u2.fallback = function(n4) {
            return this.or(X2(n4));
          }, u2.ap = function(n4) {
            return J(n4, this, function(n5, t4) {
              return n5(t4);
            });
          }, u2.chain = function(n4) {
            var t4 = this;
            return e(function(r3, e2) {
              var u3 = t4._(r3, e2);
              return u3.status ? B2(n4(u3.value)._(r3, u3.index), u3) : u3;
            });
          }, u2.concat = u2.or, u2.empty = rn2, u2.of = X2, u2["fantasy-land/ap"] = u2.ap, u2["fantasy-land/chain"] = u2.chain, u2["fantasy-land/concat"] = u2.concat, u2["fantasy-land/empty"] = u2.empty, u2["fantasy-land/of"] = u2.of, u2["fantasy-land/map"] = u2.map;
          var en2 = e(function(n4, t4) {
            return b2(t4, S2(n4, t4));
          }), un2 = e(function(n4, t4) {
            return t4 >= n4.length ? x2(t4, "any character/byte") : b2(t4 + 1, L2(n4, t4));
          }), on3 = e(function(n4, t4) {
            return b2(n4.length, n4.slice(t4));
          }), an2 = e(function(n4, t4) {
            return t4 < n4.length ? x2(t4, "EOF") : b2(t4, null);
          }), fn3 = Q2(/[0-9]/).desc("a digit"), cn2 = Q2(/[0-9]*/).desc("optional digits"), sn2 = Q2(/[a-z]/i).desc("a letter"), ln2 = Q2(/[a-z]*/i).desc("optional letters"), hn = Q2(/\s*/).desc("optional whitespace"), pn2 = Q2(/\s+/).desc("whitespace"), dn2 = K2("\r"), vn2 = K2("\n"), gn = K2("\r\n"), mn = T(gn, vn2, dn2).desc("newline"), yn = T(mn, an2);
          e.all = on3, e.alt = T, e.any = un2, e.cr = dn2, e.createLanguage = function(n4) {
            var t4 = {};
            for (var r3 in n4)
              ({}).hasOwnProperty.call(n4, r3) && function(r4) {
                t4[r4] = tn2(function() {
                  return n4[r4](t4);
                });
              }(r3);
            return t4;
          }, e.crlf = gn, e.custom = function(n4) {
            return e(n4(b2, x2));
          }, e.digit = fn3, e.digits = cn2, e.empty = rn2, e.end = yn, e.eof = an2, e.fail = Y2, e.formatError = N2, e.index = en2, e.isParser = y2, e.lazy = tn2, e.letter = sn2, e.letters = ln2, e.lf = vn2, e.lookahead = Z2, e.makeFailure = x2, e.makeSuccess = b2, e.newline = mn, e.noneOf = function(n4) {
            return nn2(function(t4) {
              return n4.indexOf(t4) < 0;
            }).desc("none of '" + n4 + "'");
          }, e.notFollowedBy = $2, e.of = X2, e.oneOf = function(n4) {
            for (var t4 = n4.split(""), r3 = 0; r3 < t4.length; r3++)
              t4[r3] = "'" + t4[r3] + "'";
            return nn2(function(t5) {
              return n4.indexOf(t5) >= 0;
            }).desc(t4);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n4, t4) {
            return nn2(function(r3) {
              return n4 <= r3 && r3 <= t4;
            }).desc(n4 + "-" + t4);
          }, e.regex = Q2, e.regexp = Q2, e.sepBy = V, e.sepBy1 = H2, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n4, t4 = {}, r3 = 0, u3 = (n4 = arguments, Array.prototype.slice.call(n4)), o3 = u3.length, i3 = 0; i3 < o3; i3 += 1) {
              var a3 = u3[i3];
              if (!y2(a3)) {
                if (E2(a3) && 2 === a3.length && "string" == typeof a3[0] && y2(a3[1])) {
                  var f3 = a3[0];
                  if (Object.prototype.hasOwnProperty.call(t4, f3))
                    throw new Error("seqObj: duplicate key " + f3);
                  t4[f3] = true, r3++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r3)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n5, t5) {
              for (var r4, e2 = {}, i4 = 0; i4 < o3; i4 += 1) {
                var a4, f4;
                if (E2(u3[i4]) ? (a4 = u3[i4][0], f4 = u3[i4][1]) : (a4 = null, f4 = u3[i4]), !(r4 = B2(f4._(n5, t5), r4)).status)
                  return r4;
                a4 && (e2[a4] = r4.value), t5 = r4.index;
              }
              return B2(b2(t5, e2), r4);
            });
          }, e.string = K2, e.succeed = X2, e.takeWhile = function(n4) {
            return k2(n4), e(function(t4, r3) {
              for (var e2 = r3; e2 < t4.length && n4(L2(t4, e2)); )
                e2++;
              return b2(e2, t4.slice(r3, e2));
            });
          }, e.test = nn2, e.whitespace = pn2, e["fantasy-land/empty"] = rn2, e["fantasy-land/of"] = X2, e.Binary = { bitSeq: l3, bitSeqObj: function(n4) {
            s3();
            var t4 = {}, r3 = 0, e2 = a2(function(n5) {
              if (E2(n5)) {
                var e3 = n5;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P2(e3[0]), O2(e3[1]), Object.prototype.hasOwnProperty.call(t4, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t4[e3[0]] = true, r3++, e3;
              }
              return O2(n5), [null, n5];
            }, n4);
            if (r3 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u3 = a2(function(n5) {
              return n5[0];
            }, e2);
            return l3(a2(function(n5) {
              return n5[1];
            }, e2)).map(function(n5) {
              return i2(function(n6, t5) {
                return null !== t5[0] && (n6[t5[0]] = t5[1]), n6;
              }, {}, a2(function(t5, r4) {
                return [t5, n5[r4]];
              }, u3));
            });
          }, byte: function(n4) {
            if (s3(), O2(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t4 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e(function(r3, e2) {
              var u3 = L2(r3, e2);
              return u3 === n4 ? b2(e2 + 1, u3) : x2(e2, t4);
            });
          }, buffer: function(n4) {
            return h2("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t4) {
            return h2("string", t4).map(function(t5) {
              return t5.toString(n4);
            });
          }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v2, uint8LE: v2(1), uint16LE: v2(2), uint32LE: v2(4), intBE: g2, int8BE: g2(1), int16BE: g2(2), int32BE: g2(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h2("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h2("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h2("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h2("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e;
        }]);
      });
    })(parsimmon_umd_min);
    var emojiRegex = () => {
      return /(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDD-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF6](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC2\uDED0-\uDED9\uDEE0-\uDEE7]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_min.exports.whitespace.map((_24) => "-"), parsimmon_umd_min.exports.any.map((_24) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_min.exports.whitespace.map((_24) => " "), parsimmon_umd_min.exports.any.map((_24) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity > 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString2(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f2) => toString2(f2, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString2(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString2;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString3(val))
          return { type: "string", value: val };
        else if (isBoolean2(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func8) {
        if (isObject(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func8);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func8));
          return result;
        } else {
          return func8(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x2) => x2;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) !== null && _a !== void 0 ? _a : "").localeCompare((_b = link2.subpath) !== null && _b !== void 0 ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index2 = 0; index2 < Math.min(f1.length, f2.length); index2++) {
              let comp = compareValue(f1[index2], f2[index2]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) === null || _a === void 0 ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v2) => deepCopy(v2)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString3(val) {
        return typeof val == "string";
      }
      Values2.isString = isString3;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean2(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean2;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element2 of entry)
          if (!isElementGroup(element2))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return Link.header(split[0], split[1], embed, display);
        } else
          return Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) === null || _a === void 0 ? void 0 : _a.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) === null || _b === void 0 ? void 0 : _b.replace("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) !== null && _a !== void 0 ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left6, op, right6) {
        return { type: "binaryop", left: left6, op, right: right6 };
      }
      Fields2.binaryOp = binaryOp;
      function index2(obj, index3) {
        return { type: "index", object: obj, index: index3 };
      }
      Fields2.index = index2;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index3 = 1; index3 < parts.length; index3++) {
          result = Fields2.index(result, Fields2.literal(parts[index3]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func8(func9, args) {
        return { type: "function", func: func9, arguments: args };
      }
      Fields2.func = func8;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left6, op, right6) {
        return { type: "binaryop", left: left6, op, right: right6 };
      }
      Sources2.binaryOp = binaryOp;
      function and(left6, right6) {
        return { type: "binaryop", left: left6, op: "&", right: right6 };
      }
      Sources2.and = and;
      function or(left6, right6) {
        return { type: "binaryop", left: left6, op: "|", right: right6 };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty4() {
        return { type: "empty" };
      }
      Sources2.empty = empty4;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime.local(),
      today: () => DateTime.local().startOf("day"),
      yesterday: () => DateTime.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime.local().startOf("week"),
      "start-of-week": () => DateTime.local().startOf("week"),
      eow: () => DateTime.local().endOf("week"),
      "end-of-week": () => DateTime.local().endOf("week"),
      soy: () => DateTime.local().startOf("year"),
      "start-of-year": () => DateTime.local().startOf("year"),
      eoy: () => DateTime.local().endOf("year"),
      "end-of-year": () => DateTime.local().endOf("year"),
      som: () => DateTime.local().startOf("month"),
      "start-of-month": () => DateTime.local().startOf("month"),
      eom: () => DateTime.local().endOf("month"),
      "end-of-month": () => DateTime.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe3 = -1;
      while ((pipe3 = link.indexOf("|", pipe3 + 1)) >= 0) {
        if (pipe3 > 0 && link[pipe3 - 1] == "\\")
          continue;
        return [link.substring(0, pipe3).replace(/\\\|/g, "|"), link.substring(pipe3 + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_min.exports.seqMap(child, parsimmon_umd_min.exports.seq(parsimmon_umd_min.exports.optWhitespace, sep, parsimmon_umd_min.exports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index2 = 1; index2 < rest.length; index2++) {
          node = combine(node, rest[index2][1], rest[index2][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i2) => {
          let result = base._(input, i2);
          if (!result.status)
            return result;
          for (let func8 of funcs) {
            let next2 = func8(result.value)._(input, result.index);
            if (!next2.status)
              return result;
            result = next2;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_min.exports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q2) => parsimmon_umd_min.exports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q2) => parsimmon_umd_min.exports.string('"').then(parsimmon_umd_min.exports.alt(q2.escapeCharacter, parsimmon_umd_min.exports.noneOf('"\\')).atLeast(0).map((chars2) => chars2.join(""))).skip(parsimmon_umd_min.exports.string('"')).desc("string"),
      escapeCharacter: (_24) => parsimmon_umd_min.exports.string("\\").then(parsimmon_umd_min.exports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_24) => parsimmon_umd_min.exports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_24) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("#"), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start2, rest) => start2 + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_24) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(new RegExp("\\p{Letter}", "u")), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_24) => parsimmon_umd_min.exports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!").atMost(1), q2.link, (p2, l3) => {
        if (p2.length > 0)
          l3.embed = true;
        return l3;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_24) => parsimmon_umd_min.exports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_24) => parsimmon_umd_min.exports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_24) => parsimmon_umd_min.exports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_24) => parsimmon_umd_min.exports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_24) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/\d{4}/), parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (year, _25, month) => {
        return DateTime.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_24) => parsimmon_umd_min.exports.alt(...Object.keys(DATE_SHORTHANDS).sort((a2, b2) => b2.length - a2.length).map(parsimmon_umd_min.exports.string)),
      date: (q2) => chainOpt(q2.rootDate, (ym) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_24, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("T"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_24, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_24, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_24, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), parsimmon_umd_min.exports.regexp(/\d{3}/), (_24, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_min.exports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("+").or(parsimmon_umd_min.exports.string("-")), parsimmon_umd_min.exports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_min.exports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q2) => parsimmon_umd_min.exports.alt(q2.dateShorthand.map((d2) => DATE_SHORTHANDS[d2]()), q2.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_24) => parsimmon_umd_min.exports.alt(...Object.keys(DURATION_TYPES).sort((a2, b2) => b2.length - a2.length).map(parsimmon_umd_min.exports.string)),
      duration: (q2) => parsimmon_umd_min.exports.seqMap(q2.number, parsimmon_umd_min.exports.optWhitespace, q2.durationType, (count, _24, t3) => DURATION_TYPES[t3].mapUnits((x2) => x2 * count)).sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).or(parsimmon_umd_min.exports.optWhitespace)).map((durations) => durations.reduce((p2, c2) => p2.plus(c2))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_24) => parsimmon_umd_min.exports.string("null"),
      // Source parsing.
      tagSource: (q2) => q2.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("csv(").skip(parsimmon_umd_min.exports.optWhitespace), q2.string, parsimmon_umd_min.exports.string(")"), (_1, path, _24) => Sources.csv(path)),
      linkIncomingSource: (q2) => q2.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("outgoing(").skip(parsimmon_umd_min.exports.optWhitespace), q2.link, parsimmon_umd_min.exports.string(")"), (_1, link, _24) => Sources.link(link.path, false)),
      folderSource: (q2) => q2.string.map((str) => Sources.folder(str)),
      parensSource: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q2.source, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _24, field, _32, _42) => field),
      negateSource: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.string("!")), q2.atomSource, (_24, source) => Sources.negate(source)),
      atomSource: (q2) => parsimmon_umd_min.exports.alt(q2.parensSource, q2.negateSource, q2.linkOutgoingSource, q2.linkIncomingSource, q2.folderSource, q2.tagSource, q2.csvSource),
      binaryOpSource: (q2) => createBinaryParser(q2.atomSource, q2.binaryBooleanOp.map((s3) => s3), Sources.binaryOp),
      source: (q2) => q2.binaryOpSource,
      // Field parsing.
      variableField: (q2) => q2.identifier.chain((r2) => {
        if (KEYWORDS.includes(r2.toUpperCase())) {
          return parsimmon_umd_min.exports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_min.exports.succeed(Fields.variable(r2));
        }
      }).desc("variable"),
      numberField: (q2) => q2.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q2) => q2.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q2) => q2.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("date("), parsimmon_umd_min.exports.optWhitespace, q2.datePlus, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, date, _24, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("dur("), parsimmon_umd_min.exports.optWhitespace, q2.duration, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, dur, _24, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q2) => q2.rawNull.map((_24) => Fields.NULL),
      linkField: (q2) => q2.link.map((f2) => Fields.literal(f2)),
      listField: (q2) => q2.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("[").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("]"))).map((l3) => Fields.list(l3)).desc("list ('[1, 2, 3]')"),
      objectField: (q2) => parsimmon_umd_min.exports.seqMap(q2.identifier.or(q2.string), parsimmon_umd_min.exports.string(":").trim(parsimmon_umd_min.exports.optWhitespace), q2.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("{").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q2) => parsimmon_umd_min.exports.alt(q2.date, q2.duration.map((d2) => normalizeDuration(d2)), q2.string, q2.tag, q2.embedLink, q2.bool, q2.number, q2.rawNull),
      inlineFieldList: (q2) => q2.atomInlineField.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).lookahead(q2.atomInlineField)),
      inlineField: (q2) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(q2.atomInlineField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace), q2.inlineFieldList, (f2, _s, l3) => [f2].concat(l3)), q2.atomInlineField),
      atomField: (q2) => parsimmon_umd_min.exports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q2.embedLink.map((l3) => Fields.literal(l3)),
        q2.negatedField,
        q2.linkField,
        q2.listField,
        q2.objectField,
        q2.lambdaField,
        q2.parensField,
        q2.boolField,
        q2.numberField,
        q2.stringField,
        q2.dateField,
        q2.durationField,
        q2.nullField,
        q2.variableField
      ),
      indexField: (q2) => parsimmon_umd_min.exports.seqMap(q2.atomField, parsimmon_umd_min.exports.alt(q2.dotPostfix, q2.indexPostfix, q2.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!"), q2.indexField, (_24, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q2.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _24, field, _32, _42) => field),
      lambdaField: (q2) => parsimmon_umd_min.exports.seqMap(q2.identifier.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("(").trim(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.string(")").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.string("=>").trim(parsimmon_umd_min.exports.optWhitespace), q2.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), q2.identifier, (_24, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.optWhitespace, q2.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string("]"), (_24, _25, field, _32, _42) => {
        return { type: "index", field };
      }),
      functionPostfix: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q2.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_24, _1, fields, _25, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q2) => createBinaryParser(q2.indexField, q2.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q2) => createBinaryParser(q2.binaryMulDivField, q2.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q2) => createBinaryParser(q2.binaryPlusMinusField, q2.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q2) => createBinaryParser(q2.binaryCompareField, q2.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q2) => q2.binaryBooleanField,
      field: (q2) => q2.binaryOpField
    });
    function parseField(text2) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text2));
      } catch (error2) {
        return Result.failure("" + error2);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy4(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy4;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i2) => {
          let result = base._(input, i2);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i2, result.index)] });
        };
      });
    }
    function stripNewlines(text2) {
      return text2.split(/[\r\n]+/).map((t3) => t3.trim()).join("");
    }
    var QUERY_LANGUAGE = parsimmon_umd_min.exports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q2) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q2) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.whitespace), parsimmon_umd_min.exports.regexp(/AS/i).skip(parsimmon_umd_min.exports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q2) => parsimmon_umd_min.exports.alt(q2.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text2]) => QueryFields.named(stripNewlines(text2), value))),
      sortField: (q2) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q2) => q2.queryType.skip(parsimmon_umd_min.exports.whitespace).chain((qtype) => {
        switch (qtype) {
          case "table":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), parsimmon_umd_min.exports.sepBy(q2.namedField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (withoutId, fields) => {
              return { type: "table", fields, showId: withoutId.length == 0 };
            });
          case "list":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format2) => {
              return {
                type: "list",
                format: format2.length == 1 ? format2[0] : void 0,
                showId: withoutId.length == 0
              };
            });
          case "task":
            return parsimmon_umd_min.exports.succeed({ type: "task" });
          case "calendar":
            return parsimmon_umd_min.exports.seqMap(q2.namedField, (field) => {
              return {
                type: "calendar",
                showId: true,
                field
              };
            });
          default:
            return parsimmon_umd_min.exports.fail(`Unrecognized query type '${qtype}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FROM/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.source, (_1, _24, source) => source),
      whereClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WHERE/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (where, _24, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/SORT/i), parsimmon_umd_min.exports.whitespace, q2.sortField.sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (sort4, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/LIMIT/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FLATTEN/i).skip(parsimmon_umd_min.exports.whitespace), q2.namedField, (_24, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q2) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/GROUP BY/i).skip(parsimmon_umd_min.exports.whitespace), q2.namedField, (_24, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q2) => parsimmon_umd_min.exports.alt(q2.fromClause, q2.whereClause, q2.sortByClause, q2.limitClause, q2.groupByClause, q2.flattenClause),
      query: (q2) => parsimmon_umd_min.exports.seqMap(q2.headerClause.trim(parsimmon_umd_min.exports.optWhitespace), q2.fromClause.trim(parsimmon_umd_min.exports.optWhitespace).atMost(1), q2.clause.trim(parsimmon_umd_min.exports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI2 = (app3) => {
      var _a;
      if (app3)
        return (_a = app3.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled3 = (app3) => app3.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled3;
    exports.parseField = parseField;
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a2, b2) {
        return Object.prototype.hasOwnProperty.call(a2, b2);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k2;
          for (k2 in obj) {
            if (hasOwnProp(obj, k2)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map8(arr, fn3) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn3(arr[i2], i2));
        }
        return res;
      }
      function extend4(a2, b2) {
        for (var i2 in b2) {
          if (hasOwnProp(b2, i2)) {
            a2[i2] = b2[i2];
          }
        }
        if (hasOwnProp(b2, "toString")) {
          a2.toString = b2.toString;
        }
        if (hasOwnProp(b2, "valueOf")) {
          a2.valueOf = b2.valueOf;
        }
        return a2;
      }
      function createUTC(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some4;
      if (Array.prototype.some) {
        some4 = Array.prototype.some;
      } else {
        some4 = function(fun) {
          var t3 = Object(this), len = t3.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t3 && fun.call(this, t3[i2], i2, t3)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some4.call(flags.parsedDateParts, function(i2) {
            return i2 != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend4(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn3(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn3) {
        var firstTime = true;
        return extend4(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args.push(arg);
            }
            warn3(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn3.apply(this, arguments);
        }, fn3);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn3(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend4({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend4(res[prop], parentConfig[prop]);
              extend4(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend4({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output2 = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output2) ? output2.call(mom, now3) : output2;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func8 = callback;
        if (typeof callback === "string") {
          func8 = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func8;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func8.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func8.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array2 = format3.match(formattingTokens), i2, length;
        for (i2 = 0, length = array2.length; i2 < length; i2++) {
          if (formatTokenFunctions[array2[i2]]) {
            array2[i2] = formatTokenFunctions[array2[i2]];
          } else {
            array2[i2] = removeFormattingTokens(array2[i2]);
          }
        }
        return function(mom) {
          var output2 = "", i3;
          for (i3 = 0; i3 < length; i3++) {
            output2 += isFunction(array2[i3]) ? array2[i3].call(mom, format3) : array2[i3];
          }
          return output2;
        };
      }
      function formatMoment(m, format3) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m);
      }
      function expandFormat(format3, locale2) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output2 = this._relativeTime[string2];
        return isFunction(output2) ? output2(number, withoutSuffix, string2, isFuture) : output2.replace(/%d/i, number);
      }
      function pastFuture(diff2, output2) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format3) ? format3(output2) : format3.replace(/%s/i, output2);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units.sort(function(a2, b2) {
          return a2.priority - b2.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match22 = /\d\d/, match32 = /\d{3}/, match42 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape2(
          s2.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape2(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i2, func8 = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func8 = function(input, array2) {
            array2[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func8;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array2, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n2, x2) {
        return (n2 % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o2) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o2) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match22);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array2) {
        array2[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array2, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array2[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format3) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format3) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i2] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i2 = 0; i2 < 12; i2++) {
          shortPieces[i2] = regexEscape2(shortPieces[i2]);
          longPieces[i2] = regexEscape2(longPieces[i2]);
        }
        for (i2 = 0; i2 < 24; i2++) {
          mixedPieces[i2] = regexEscape2(mixedPieces[i2]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y2 = this.year();
        return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match22);
      addRegexToken("YYYY", match1to4, match42);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array2) {
        array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array2) {
        array2[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array2) {
        array2[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y2, m, d2, h2, M2, s2, ms) {
        var date;
        if (y2 < 100 && y2 >= 0) {
          date = new Date(y2 + 400, m, d2, h2, M2, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y2);
          }
        } else {
          date = new Date(y2, m, d2, h2, M2, s2, ms);
        }
        return date;
      }
      function createUTCDate(y2) {
        var date, args;
        if (y2 < 100 && y2 >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y2 + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y2);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match22);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match22);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format3) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape2(this.weekdaysMin(mom, ""));
          shortp = regexEscape2(this.weekdaysShort(mom, ""));
          longp = regexEscape2(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match22);
      addRegexToken("hh", match1to2, match22);
      addRegexToken("kk", match1to2, match22);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array2, config) {
        var kInput = toInt(input);
        array2[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array2, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array2, config) {
        array2[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array2, config) {
        var pos = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos));
        array2[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array2, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos1));
        array2[MINUTE] = toInt(input.substr(pos1, 2));
        array2[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array2, config) {
        var pos = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos));
        array2[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array2, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos1));
        array2[MINUTE] = toInt(input.substr(pos1, 2));
        array2[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i2 = 0, j2, next2, locale2, split;
        while (i2 < names.length) {
          split = normalizeLocale(names[i2]).split("-");
          j2 = split.length;
          next2 = normalizeLocale(names[i2 + 1]);
          next2 = next2 ? next2.split("-") : null;
          while (j2 > 0) {
            locale2 = loadLocale(split.slice(0, j2).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next2 && next2.length >= j2 && commonPrefix(split, next2) >= j2 - 1) {
              break;
            }
            j2--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a2 = m._a;
        if (a2 && getParsingFlags(m).overflow === -2) {
          overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l2, string2 = config._i, match7 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match7) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
            if (isoDates[i2][1].exec(match7[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match7[3]) {
            for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
              if (isoTimes[i2][1].exec(match7[3])) {
                timeFormat = (match7[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match7[4]) {
            if (tzRegex.exec(match7[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
          return h2 * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match7 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match7) {
          parsedArray = extractFromRFC2822Strings(
            match7[4],
            match7[3],
            match7[2],
            match7[5],
            match7[6],
            match7[7]
          );
          if (!checkWeekday(match7[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match7[8], match7[9], match7[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults2(a2, b2, c2) {
        if (a2 != null) {
          return a2;
        }
        if (b2 != null) {
          return b2;
        }
        return c2;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w2 = config._w;
        if (w2.GG != null || w2.W != null || w2.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults2(
            w2.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults2(w2.W, 1);
          weekday = defaults2(w2.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults2(w2.gg, config._a[YEAR], curWeek.year);
          week = defaults2(w2.w, curWeek.week);
          if (w2.d != null) {
            weekday = w2.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w2.e != null) {
            weekday = w2.e + dow;
            if (w2.e < 0 || w2.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend4(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map8(
          [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map8(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
        var c2 = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c2._isAMomentObject = true;
        c2._useUTC = c2._isUTC = isUTC;
        c2._l = locale2;
        c2._i = input;
        c2._f = format3;
        c2._strict = strict;
        return createFromConfig(c2);
      }
      function createLocal(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn3, moments) {
        var res, i2;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn3](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min3() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max3() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset2(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset3 = this.utcOffset(), sign2 = "+";
          if (offset3 < 0) {
            offset3 = -offset3;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
        });
      }
      offset2("Z", ":");
      offset2("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array2, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches2 = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches2 === null) {
          return null;
        }
        chunk = matches2[matches2.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset3 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset3 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset3, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset3 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c2 = {}, other;
        copyConfig(c2, this);
        c2 = prepareConfig(c2);
        if (c2._a) {
          other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
          this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match7 = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match7 = aspNetRegex.exec(input)) {
          sign2 = match7[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match7[DATE]) * sign2,
            h: toInt(match7[HOUR]) * sign2,
            m: toInt(match7[MINUTE]) * sign2,
            s: toInt(match7[SECOND]) * sign2,
            ms: toInt(absRound(match7[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match7 = isoRegex.exec(input)) {
          sign2 = match7[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match7[2], sign2),
            M: parseIso(match7[3], sign2),
            w: parseIso(match7[4], sign2),
            d: parseIso(match7[5], sign2),
            h: parseIso(match7[6], sign2),
            m: parseIso(match7[7], sign2),
            s: parseIso(match7[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff2 = myMoment.diff(now3, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output2 = formats && (isFunction(formats[format3]) ? formats[format3].call(this, now3) : formats[format3]);
        return this.format(
          output2 || this.localeData().calendar(format3, this, createLocal(now3))
        );
      }
      function clone2() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output2;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output2 = monthDiff(this, that) / 12;
            break;
          case "month":
            output2 = monthDiff(this, that);
            break;
          case "quarter":
            output2 = monthDiff(this, that) / 3;
            break;
          case "second":
            output2 = (this - that) / 1e3;
            break;
          case "minute":
            output2 = (this - that) / 6e4;
            break;
          case "hour":
            output2 = (this - that) / 36e5;
            break;
          case "day":
            output2 = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output2 = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output2 = this - that;
        }
        return asFloat ? output2 : absFloor(output2);
      }
      function monthDiff(a2, b2) {
        if (a2.date() < b2.date()) {
          return -monthDiff(b2, a2);
        }
        var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b2 - anchor < 0) {
          anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b2 - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b2 - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString2() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func8 = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func8 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func8 + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output2 = formatMoment(this, inputString);
        return this.localeData().postformat(output2);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return new Date(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return new Date(y2, m, d2).valueOf();
        }
      }
      function utcStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return Date.UTC(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y2, m, d2);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend4({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array2, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array2, config, token2) {
        var match7;
        if (config._locale._eraYearOrdinalRegex) {
          match7 = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array2[YEAR] = config._locale.eraYearOrdinalParse(input, match7);
        } else {
          array2[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format3) {
        var i2, l2, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i2, l2, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l2, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          namePieces.push(regexEscape2(eras[i2].name));
          abbrPieces.push(regexEscape2(eras[i2].abbr));
          narrowPieces.push(regexEscape2(eras[i2].narrow));
          mixedPieces.push(regexEscape2(eras[i2].name));
          mixedPieces.push(regexEscape2(eras[i2].abbr));
          mixedPieces.push(regexEscape2(eras[i2].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match22);
      addRegexToken("gg", match1to2, match22);
      addRegexToken("GGGG", match1to4, match42);
      addRegexToken("gggg", match1to4, match42);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array2) {
        array2[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match22);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array2) {
        array2[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match32);
      addParseToken(["DDD", "DDDD"], function(input, array2, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match22);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match22);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match22);
      addRegexToken("SSS", match1to3, match32);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array2) {
        array2[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone2;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString2;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format3, index2, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index2);
        return locale2[field](utc, format3);
      }
      function listMonthsImpl(format3, index2, field) {
        if (isNumber2(format3)) {
          index2 = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index2 != null) {
          return get$1(format3, index2, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format3, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index2, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index2 = format3;
          localeSorted = false;
          if (isNumber2(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
        if (index2 != null) {
          return get$1(format3, (index2 + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format3, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index2) {
        return listMonthsImpl(format3, index2, "months");
      }
      function listMonthsShort(format3, index2) {
        return listMonthsImpl(format3, index2, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b2 = number % 10, output2 = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
          return number + output2;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble2() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a2[2] = withoutSuffix;
        a2[3] = +posNegDuration > 0;
        a2[4] = locale2;
        return substituteTimeAgo.apply(null, a2);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output2;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output2 = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output2 = locale2.pastFuture(+this, output2);
        }
        return locale2.postformat(output2);
      }
      var abs$1 = Math.abs;
      function sign(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble2;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array2, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array2, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min3;
      hooks.max = max3;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/svelte/internal/index.js
var require_internal = __commonJS({
  "node_modules/svelte/internal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noop3() {
    }
    var identity3 = (x2) => x2;
    function assign2(tar, src) {
      for (const k2 in src)
        tar[k2] = src[k2];
      return tar;
    }
    function is_promise2(value) {
      return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
    }
    function add_location(element3, file, line, column, char) {
      element3.__svelte_meta = {
        loc: { file, line, column, char }
      };
    }
    function run2(fn3) {
      return fn3();
    }
    function blank_object2() {
      return /* @__PURE__ */ Object.create(null);
    }
    function run_all2(fns) {
      fns.forEach(run2);
    }
    function is_function2(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal2(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
    }
    var src_url_equal_anchor2;
    function src_url_equal2(element_src, url) {
      if (!src_url_equal_anchor2) {
        src_url_equal_anchor2 = document.createElement("a");
      }
      src_url_equal_anchor2.href = url;
      return element_src === src_url_equal_anchor2.href;
    }
    function not_equal(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2;
    }
    function is_empty2(obj) {
      return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== "function") {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }
    function subscribe2(store, ...callbacks) {
      if (store == null) {
        return noop3;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value2(store) {
      let value;
      subscribe2(store, (_24) => value = _24)();
      return value;
    }
    function component_subscribe2(component, store, callback) {
      component.$$.on_destroy.push(subscribe2(store, callback));
    }
    function create_slot2(definition, ctx, $$scope, fn3) {
      if (definition) {
        const slot_ctx = get_slot_context2(definition, ctx, $$scope, fn3);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context2(definition, ctx, $$scope, fn3) {
      return definition[1] && fn3 ? assign2($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
    }
    function get_slot_changes2(definition, $$scope, dirty, fn3) {
      if (definition[2] && fn3) {
        const lets = definition[2](fn3(dirty));
        if ($$scope.dirty === void 0) {
          return lets;
        }
        if (typeof lets === "object") {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i2 = 0; i2 < len; i2 += 1) {
            merged[i2] = $$scope.dirty[i2] | lets[i2];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context2(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes2(slot_definition, $$scope, dirty, get_slot_changes_fn);
      update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }
    function get_all_dirty_from_scope2($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i2 = 0; i2 < length; i2++) {
          dirty[i2] = -1;
        }
        return dirty;
      }
      return -1;
    }
    function exclude_internal_props(props) {
      const result = {};
      for (const k2 in props)
        if (k2[0] !== "$")
          result[k2] = props[k2];
      return result;
    }
    function compute_rest_props(props, keys) {
      const rest = {};
      keys = new Set(keys);
      for (const k2 in props)
        if (!keys.has(k2) && k2[0] !== "$")
          rest[k2] = props[k2];
      return rest;
    }
    function compute_slots2(slots) {
      const result = {};
      for (const key in slots) {
        result[key] = true;
      }
      return result;
    }
    function once(fn3) {
      let ran = false;
      return function(...args) {
        if (ran)
          return;
        ran = true;
        fn3.call(this, ...args);
      };
    }
    function null_to_empty2(value) {
      return value == null ? "" : value;
    }
    function set_store_value(store, ret, value) {
      store.set(value);
      return ret;
    }
    var has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    function action_destroyer2(action_result) {
      return action_result && is_function2(action_result.destroy) ? action_result.destroy : noop3;
    }
    function split_css_unit2(value) {
      const split = typeof value === "string" && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
      return split ? [parseFloat(split[1]), split[2] || "px"] : [value, "px"];
    }
    var contenteditable_truthy_values = ["", true, 1, "true", "contenteditable"];
    var is_client2 = typeof window !== "undefined";
    exports.now = is_client2 ? () => window.performance.now() : () => Date.now();
    exports.raf = is_client2 ? (cb) => requestAnimationFrame(cb) : noop3;
    function set_now(fn3) {
      exports.now = fn3;
    }
    function set_raf(fn3) {
      exports.raf = fn3;
    }
    var tasks2 = /* @__PURE__ */ new Set();
    function run_tasks2(now2) {
      tasks2.forEach((task2) => {
        if (!task2.c(now2)) {
          tasks2.delete(task2);
          task2.f();
        }
      });
      if (tasks2.size !== 0)
        exports.raf(run_tasks2);
    }
    function clear_loops() {
      tasks2.clear();
    }
    function loop3(callback) {
      let task2;
      if (tasks2.size === 0)
        exports.raf(run_tasks2);
      return {
        promise: new Promise((fulfill) => {
          tasks2.add(task2 = { c: callback, f: fulfill });
        }),
        abort() {
          tasks2.delete(task2);
        }
      };
    }
    var is_hydrating2 = false;
    function start_hydrating2() {
      is_hydrating2 = true;
    }
    function end_hydrating2() {
      is_hydrating2 = false;
    }
    function upper_bound(low, high, key, value) {
      while (low < high) {
        const mid = low + (high - low >> 1);
        if (key(mid) <= value) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }
    function init_hydrate(target) {
      if (target.hydrate_init)
        return;
      target.hydrate_init = true;
      let children3 = target.childNodes;
      if (target.nodeName === "HEAD") {
        const myChildren = [];
        for (let i2 = 0; i2 < children3.length; i2++) {
          const node = children3[i2];
          if (node.claim_order !== void 0) {
            myChildren.push(node);
          }
        }
        children3 = myChildren;
      }
      const m = new Int32Array(children3.length + 1);
      const p2 = new Int32Array(children3.length);
      m[0] = -1;
      let longest = 0;
      for (let i2 = 0; i2 < children3.length; i2++) {
        const current = children3[i2].claim_order;
        const seqLen = (longest > 0 && children3[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, (idx) => children3[m[idx]].claim_order, current)) - 1;
        p2[i2] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        m[newLen] = i2;
        longest = Math.max(newLen, longest);
      }
      const lis = [];
      const toMove = [];
      let last5 = children3.length - 1;
      for (let cur = m[longest] + 1; cur != 0; cur = p2[cur - 1]) {
        lis.push(children3[cur - 1]);
        for (; last5 >= cur; last5--) {
          toMove.push(children3[last5]);
        }
        last5--;
      }
      for (; last5 >= 0; last5--) {
        toMove.push(children3[last5]);
      }
      lis.reverse();
      toMove.sort((a2, b2) => a2.claim_order - b2.claim_order);
      for (let i2 = 0, j2 = 0; i2 < toMove.length; i2++) {
        while (j2 < lis.length && toMove[i2].claim_order >= lis[j2].claim_order) {
          j2++;
        }
        const anchor = j2 < lis.length ? lis[j2] : null;
        target.insertBefore(toMove[i2], anchor);
      }
    }
    function append5(target, node) {
      target.appendChild(node);
    }
    function append_styles2(target, style_sheet_id, styles) {
      const append_styles_to = get_root_for_style2(target);
      if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element2("style");
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet2(append_styles_to, style);
      }
    }
    function get_root_for_style2(node) {
      if (!node)
        return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      if (root && root.host) {
        return root;
      }
      return node.ownerDocument;
    }
    function append_empty_stylesheet2(node) {
      const style_element = element2("style");
      append_stylesheet2(get_root_for_style2(node), style_element);
      return style_element.sheet;
    }
    function append_stylesheet2(node, style) {
      append5(node.head || node, style);
      return style.sheet;
    }
    function append_hydration(target, node) {
      if (is_hydrating2) {
        init_hydrate(target);
        if (target.actual_end_child === void 0 || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {
          target.actual_end_child = target.firstChild;
        }
        while (target.actual_end_child !== null && target.actual_end_child.claim_order === void 0) {
          target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
          if (node.claim_order !== void 0 || node.parentNode !== target) {
            target.insertBefore(node, target.actual_end_child);
          }
        } else {
          target.actual_end_child = node.nextSibling;
        }
      } else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
      }
    }
    function insert2(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }
    function insert_hydration(target, node, anchor) {
      if (is_hydrating2 && !anchor) {
        append_hydration(target, node);
      } else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
      }
    }
    function detach2(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
    function destroy_each2(iterations, detaching) {
      for (let i2 = 0; i2 < iterations.length; i2 += 1) {
        if (iterations[i2])
          iterations[i2].d(detaching);
      }
    }
    function element2(name) {
      return document.createElement(name);
    }
    function element_is(name, is2) {
      return document.createElement(name, { is: is2 });
    }
    function object_without_properties(obj, exclude) {
      const target = {};
      for (const k2 in obj) {
        if (has_prop(obj, k2) && exclude.indexOf(k2) === -1) {
          target[k2] = obj[k2];
        }
      }
      return target;
    }
    function svg_element(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function text2(data) {
      return document.createTextNode(data);
    }
    function space2() {
      return text2(" ");
    }
    function empty4() {
      return text2("");
    }
    function comment(content) {
      return document.createComment(content);
    }
    function listen2(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn3) {
      return function(event) {
        event.preventDefault();
        return fn3.call(this, event);
      };
    }
    function stop_propagation2(fn3) {
      return function(event) {
        event.stopPropagation();
        return fn3.call(this, event);
      };
    }
    function stop_immediate_propagation(fn3) {
      return function(event) {
        event.stopImmediatePropagation();
        return fn3.call(this, event);
      };
    }
    function self2(fn3) {
      return function(event) {
        if (event.target === this)
          fn3.call(this, event);
      };
    }
    function trusted(fn3) {
      return function(event) {
        if (event.isTrusted)
          fn3.call(this, event);
      };
    }
    function attr2(node, attribute, value) {
      if (value == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
    }
    function set_attributes2(node, attributes) {
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === "style") {
          node.style.cssText = attributes[key];
        } else if (key === "__value") {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr2(node, key, attributes[key]);
        }
      }
    }
    function set_svg_attributes(node, attributes) {
      for (const key in attributes) {
        attr2(node, key, attributes[key]);
      }
    }
    function set_custom_element_data_map2(node, data_map) {
      Object.keys(data_map).forEach((key) => {
        set_custom_element_data2(node, key, data_map[key]);
      });
    }
    function set_custom_element_data2(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
      } else {
        attr2(node, prop, value);
      }
    }
    function set_dynamic_element_data2(tag) {
      return /-/.test(tag) ? set_custom_element_data_map2 : set_attributes2;
    }
    function xlink_attr(node, attribute, value) {
      node.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
      const value = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < group.length; i2 += 1) {
        if (group[i2].checked)
          value.add(group[i2].__value);
      }
      if (!checked) {
        value.delete(__value);
      }
      return Array.from(value);
    }
    function init_binding_group(group) {
      let _inputs;
      return {
        /* push */
        p(...inputs) {
          _inputs = inputs;
          _inputs.forEach((input) => group.push(input));
        },
        /* remove */
        r() {
          _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
        }
      };
    }
    function init_binding_group_dynamic(group, indexes) {
      let _group = get_binding_group(group);
      let _inputs;
      function get_binding_group(group2) {
        for (let i2 = 0; i2 < indexes.length; i2++) {
          group2 = group2[indexes[i2]] = group2[indexes[i2]] || [];
        }
        return group2;
      }
      function push() {
        _inputs.forEach((input) => _group.push(input));
      }
      function remove() {
        _inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));
      }
      return {
        /* update */
        u(new_indexes) {
          indexes = new_indexes;
          const new_group = get_binding_group(group);
          if (new_group !== _group) {
            remove();
            _group = new_group;
            push();
          }
        },
        /* push */
        p(...inputs) {
          _inputs = inputs;
          push();
        },
        /* remove */
        r: remove
      };
    }
    function to_number2(value) {
      return value === "" ? null : +value;
    }
    function time_ranges_to_array(ranges) {
      const array2 = [];
      for (let i2 = 0; i2 < ranges.length; i2 += 1) {
        array2.push({ start: ranges.start(i2), end: ranges.end(i2) });
      }
      return array2;
    }
    function children2(element3) {
      return Array.from(element3.childNodes);
    }
    function init_claim_info(nodes) {
      if (nodes.claim_info === void 0) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
      }
    }
    function claim_node(nodes, predicate, processNode, createNode2, dontUpdateLastIndex = false) {
      init_claim_info(nodes);
      const resultNode = (() => {
        for (let i2 = nodes.claim_info.last_index; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            }
            return node;
          }
        }
        for (let i2 = nodes.claim_info.last_index - 1; i2 >= 0; i2--) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            } else if (replacement === void 0) {
              nodes.claim_info.last_index--;
            }
            return node;
          }
        }
        return createNode2();
      })();
      resultNode.claim_order = nodes.claim_info.total_claimed;
      nodes.claim_info.total_claimed += 1;
      return resultNode;
    }
    function claim_element_base(nodes, name, attributes, create_element) {
      return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j2 = 0; j2 < node.attributes.length; j2++) {
          const attribute = node.attributes[j2];
          if (!attributes[attribute.name]) {
            remove.push(attribute.name);
          }
        }
        remove.forEach((v2) => node.removeAttribute(v2));
        return void 0;
      }, () => create_element(name));
    }
    function claim_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, element2);
    }
    function claim_svg_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, svg_element);
    }
    function claim_text(nodes, data) {
      return claim_node(
        nodes,
        (node) => node.nodeType === 3,
        (node) => {
          const dataStr = "" + data;
          if (node.data.startsWith(dataStr)) {
            if (node.data.length !== dataStr.length) {
              return node.splitText(dataStr.length);
            }
          } else {
            node.data = dataStr;
          }
        },
        () => text2(data),
        true
        // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
      );
    }
    function claim_space(nodes) {
      return claim_text(nodes, " ");
    }
    function claim_comment(nodes, data) {
      return claim_node(nodes, (node) => node.nodeType === 8, (node) => {
        node.data = "" + data;
        return void 0;
      }, () => comment(data), true);
    }
    function find_comment(nodes, text3, start2) {
      for (let i2 = start2; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        if (node.nodeType === 8 && node.textContent.trim() === text3) {
          return i2;
        }
      }
      return nodes.length;
    }
    function claim_html_tag(nodes, is_svg) {
      const start_index = find_comment(nodes, "HTML_TAG_START", 0);
      const end_index = find_comment(nodes, "HTML_TAG_END", start_index);
      if (start_index === end_index) {
        return new HtmlTagHydration(void 0, is_svg);
      }
      init_claim_info(nodes);
      const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
      detach2(html_tag_nodes[0]);
      detach2(html_tag_nodes[html_tag_nodes.length - 1]);
      const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
      for (const n2 of claimed_nodes) {
        n2.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
      }
      return new HtmlTagHydration(claimed_nodes, is_svg);
    }
    function set_data2(text3, data) {
      data = "" + data;
      if (text3.data === data)
        return;
      text3.data = data;
    }
    function set_data_contenteditable(text3, data) {
      data = "" + data;
      if (text3.wholeText === data)
        return;
      text3.data = data;
    }
    function set_data_maybe_contenteditable(text3, data, attr_value) {
      if (~contenteditable_truthy_values.indexOf(attr_value)) {
        set_data_contenteditable(text3, data);
      } else {
        set_data2(text3, data);
      }
    }
    function set_input_value2(input, value) {
      input.value = value == null ? "" : value;
    }
    function set_input_type(input, type) {
      try {
        input.type = type;
      } catch (e) {
      }
    }
    function set_style2(node, key, value, important) {
      if (value === null) {
        node.style.removeProperty(key);
      } else {
        node.style.setProperty(key, value, important ? "important" : "");
      }
    }
    function select_option2(select, value, mounting) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option2 = select.options[i2];
        if (option2.__value === value) {
          option2.selected = true;
          return;
        }
      }
      if (!mounting || value !== void 0) {
        select.selectedIndex = -1;
      }
    }
    function select_options(select, value) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option2 = select.options[i2];
        option2.selected = ~value.indexOf(option2.__value);
      }
    }
    function select_value(select) {
      const selected_option = select.querySelector(":checked");
      return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
      return [].map.call(select.querySelectorAll(":checked"), (option2) => option2.__value);
    }
    var crossorigin2;
    function is_crossorigin2() {
      if (crossorigin2 === void 0) {
        crossorigin2 = false;
        try {
          if (typeof window !== "undefined" && window.parent) {
            void window.parent.document;
          }
        } catch (error2) {
          crossorigin2 = true;
        }
      }
      return crossorigin2;
    }
    function add_resize_listener2(node, fn3) {
      const computed_style = getComputedStyle(node);
      if (computed_style.position === "static") {
        node.style.position = "relative";
      }
      const iframe = element2("iframe");
      iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
      iframe.setAttribute("aria-hidden", "true");
      iframe.tabIndex = -1;
      const crossorigin3 = is_crossorigin2();
      let unsubscribe;
      if (crossorigin3) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
        unsubscribe = listen2(window, "message", (event) => {
          if (event.source === iframe.contentWindow)
            fn3();
        });
      } else {
        iframe.src = "about:blank";
        iframe.onload = () => {
          unsubscribe = listen2(iframe.contentWindow, "resize", fn3);
          fn3();
        };
      }
      append5(node, iframe);
      return () => {
        if (crossorigin3) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }
        detach2(iframe);
      };
    }
    function toggle_class2(element3, name, toggle) {
      element3.classList[toggle ? "add" : "remove"](name);
    }
    function custom_event2(type, detail, { bubbles = false, cancelable = false } = {}) {
      const e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, bubbles, cancelable, detail);
      return e;
    }
    function query_selector_all(selector, parent = document.body) {
      return Array.from(parent.querySelectorAll(selector));
    }
    function head_selector(nodeId, head6) {
      const result = [];
      let started = 0;
      for (const node of head6.childNodes) {
        if (node.nodeType === 8) {
          const comment2 = node.textContent.trim();
          if (comment2 === `HEAD_${nodeId}_END`) {
            started -= 1;
            result.push(node);
          } else if (comment2 === `HEAD_${nodeId}_START`) {
            started += 1;
            result.push(node);
          }
        } else if (started > 0) {
          result.push(node);
        }
      }
      return result;
    }
    var HtmlTag = class {
      constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
      }
      c(html) {
        this.h(html);
      }
      m(html, target, anchor = null) {
        if (!this.e) {
          if (this.is_svg)
            this.e = svg_element(target.nodeName);
          else
            this.e = element2(target.nodeType === 11 ? "TEMPLATE" : target.nodeName);
          this.t = target.tagName !== "TEMPLATE" ? target : target.content;
          this.c(html);
        }
        this.i(anchor);
      }
      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes);
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert2(this.t, this.n[i2], anchor);
        }
      }
      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
      d() {
        this.n.forEach(detach2);
      }
    };
    var HtmlTagHydration = class extends HtmlTag {
      constructor(claimed_nodes, is_svg = false) {
        super(is_svg);
        this.e = this.n = null;
        this.l = claimed_nodes;
      }
      c(html) {
        if (this.l) {
          this.n = this.l;
        } else {
          super.c(html);
        }
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert_hydration(this.t, this.n[i2], anchor);
        }
      }
    };
    function attribute_to_object(attributes) {
      const result = {};
      for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
      }
      return result;
    }
    function get_custom_elements_slots(element3) {
      const result = {};
      element3.childNodes.forEach((node) => {
        result[node.slot || "default"] = true;
      });
      return result;
    }
    function construct_svelte_component(component, props) {
      return new component(props);
    }
    var managed_styles2 = /* @__PURE__ */ new Map();
    var active2 = 0;
    function hash4(str) {
      let hash5 = 5381;
      let i2 = str.length;
      while (i2--)
        hash5 = (hash5 << 5) - hash5 ^ str.charCodeAt(i2);
      return hash5 >>> 0;
    }
    function create_style_information2(doc, node) {
      const info = { stylesheet: append_empty_stylesheet2(node), rules: {} };
      managed_styles2.set(doc, info);
      return info;
    }
    function create_rule2(node, a2, b2, duration, delay2, ease, fn3, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = "{\n";
      for (let p2 = 0; p2 <= 1; p2 += step) {
        const t3 = a2 + (b2 - a2) * ease(p2);
        keyframes += p2 * 100 + `%{${fn3(t3, 1 - t3)}}
`;
      }
      const rule = keyframes + `100% {${fn3(b2, 1 - b2)}}
}`;
      const name = `__svelte_${hash4(rule)}_${uid}`;
      const doc = get_root_for_style2(node);
      const { stylesheet, rules } = managed_styles2.get(doc) || create_style_information2(doc, node);
      if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }
      const animation = node.style.animation || "";
      node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay2}ms 1 both`;
      active2 += 1;
      return name;
    }
    function delete_rule2(node, name) {
      const previous = (node.style.animation || "").split(", ");
      const next2 = previous.filter(
        name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
        // remove all Svelte animations
      );
      const deleted = previous.length - next2.length;
      if (deleted) {
        node.style.animation = next2.join(", ");
        active2 -= deleted;
        if (!active2)
          clear_rules2();
      }
    }
    function clear_rules2() {
      exports.raf(() => {
        if (active2)
          return;
        managed_styles2.forEach((info) => {
          const { ownerNode } = info.stylesheet;
          if (ownerNode)
            detach2(ownerNode);
        });
        managed_styles2.clear();
      });
    }
    function create_animation2(node, from, fn3, params) {
      if (!from)
        return noop3;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop3;
      const {
        delay: delay2 = 0,
        duration = 300,
        easing = identity3,
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = exports.now() + delay2,
        // @ts-ignore todo:
        end: end2 = start_time + duration,
        tick: tick3 = noop3,
        css: css2
      } = fn3(node, { from, to }, params);
      let running = true;
      let started = false;
      let name;
      function start2() {
        if (css2) {
          name = create_rule2(node, 0, 1, duration, delay2, easing, css2);
        }
        if (!delay2) {
          started = true;
        }
      }
      function stop() {
        if (css2)
          delete_rule2(node, name);
        running = false;
      }
      loop3((now2) => {
        if (!started && now2 >= start_time) {
          started = true;
        }
        if (started && now2 >= end2) {
          tick3(1, 0);
          stop();
        }
        if (!running) {
          return false;
        }
        if (started) {
          const p2 = now2 - start_time;
          const t3 = 0 + 1 * easing(p2 / duration);
          tick3(t3, 1 - t3);
        }
        return true;
      });
      start2();
      tick3(0, 1);
      return stop;
    }
    function fix_position2(node) {
      const style = getComputedStyle(node);
      if (style.position !== "absolute" && style.position !== "fixed") {
        const { width, height } = style;
        const a2 = node.getBoundingClientRect();
        node.style.position = "absolute";
        node.style.width = width;
        node.style.height = height;
        add_transform2(node, a2);
      }
    }
    function add_transform2(node, a2) {
      const b2 = node.getBoundingClientRect();
      if (a2.left !== b2.left || a2.top !== b2.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === "none" ? "" : style.transform;
        node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
      }
    }
    function set_current_component2(component) {
      exports.current_component = component;
    }
    function get_current_component2() {
      if (!exports.current_component)
        throw new Error("Function called outside component initialization");
      return exports.current_component;
    }
    function beforeUpdate2(fn3) {
      get_current_component2().$$.before_update.push(fn3);
    }
    function onMount2(fn3) {
      get_current_component2().$$.on_mount.push(fn3);
    }
    function afterUpdate2(fn3) {
      get_current_component2().$$.after_update.push(fn3);
    }
    function onDestroy2(fn3) {
      get_current_component2().$$.on_destroy.push(fn3);
    }
    function createEventDispatcher2() {
      const component = get_current_component2();
      return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          const event = custom_event2(type, detail, { cancelable });
          callbacks.slice().forEach((fn3) => {
            fn3.call(component, event);
          });
          return !event.defaultPrevented;
        }
        return true;
      };
    }
    function setContext2(key, context) {
      get_current_component2().$$.context.set(key, context);
      return context;
    }
    function getContext2(key) {
      return get_current_component2().$$.context.get(key);
    }
    function getAllContexts2() {
      return get_current_component2().$$.context;
    }
    function hasContext2(key) {
      return get_current_component2().$$.context.has(key);
    }
    function bubble2(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
        callbacks.slice().forEach((fn3) => fn3.call(this, event));
      }
    }
    var dirty_components2 = [];
    var intros = { enabled: false };
    var binding_callbacks2 = [];
    var render_callbacks2 = [];
    var flush_callbacks2 = [];
    var resolved_promise2 = /* @__PURE__ */ Promise.resolve();
    var update_scheduled2 = false;
    function schedule_update2() {
      if (!update_scheduled2) {
        update_scheduled2 = true;
        resolved_promise2.then(flush2);
      }
    }
    function tick2() {
      schedule_update2();
      return resolved_promise2;
    }
    function add_render_callback2(fn3) {
      render_callbacks2.push(fn3);
    }
    function add_flush_callback2(fn3) {
      flush_callbacks2.push(fn3);
    }
    var seen_callbacks2 = /* @__PURE__ */ new Set();
    var flushidx2 = 0;
    function flush2() {
      if (flushidx2 !== 0) {
        return;
      }
      const saved_component = exports.current_component;
      do {
        try {
          while (flushidx2 < dirty_components2.length) {
            const component = dirty_components2[flushidx2];
            flushidx2++;
            set_current_component2(component);
            update2(component.$$);
          }
        } catch (e) {
          dirty_components2.length = 0;
          flushidx2 = 0;
          throw e;
        }
        set_current_component2(null);
        dirty_components2.length = 0;
        flushidx2 = 0;
        while (binding_callbacks2.length)
          binding_callbacks2.pop()();
        for (let i2 = 0; i2 < render_callbacks2.length; i2 += 1) {
          const callback = render_callbacks2[i2];
          if (!seen_callbacks2.has(callback)) {
            seen_callbacks2.add(callback);
            callback();
          }
        }
        render_callbacks2.length = 0;
      } while (dirty_components2.length);
      while (flush_callbacks2.length) {
        flush_callbacks2.pop()();
      }
      update_scheduled2 = false;
      seen_callbacks2.clear();
      set_current_component2(saved_component);
    }
    function update2($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all2($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback2);
      }
    }
    function flush_render_callbacks2(fns) {
      const filtered = [];
      const targets = [];
      render_callbacks2.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
      targets.forEach((c2) => c2());
      render_callbacks2 = filtered;
    }
    var promise2;
    function wait2() {
      if (!promise2) {
        promise2 = Promise.resolve();
        promise2.then(() => {
          promise2 = null;
        });
      }
      return promise2;
    }
    function dispatch2(node, direction, kind) {
      node.dispatchEvent(custom_event2(`${direction ? "intro" : "outro"}${kind}`));
    }
    var outroing2 = /* @__PURE__ */ new Set();
    var outros2;
    function group_outros2() {
      outros2 = {
        r: 0,
        c: [],
        p: outros2
        // parent group
      };
    }
    function check_outros2() {
      if (!outros2.r) {
        run_all2(outros2.c);
      }
      outros2 = outros2.p;
    }
    function transition_in2(block, local) {
      if (block && block.i) {
        outroing2.delete(block);
        block.i(local);
      }
    }
    function transition_out2(block, local, detach3, callback) {
      if (block && block.o) {
        if (outroing2.has(block))
          return;
        outroing2.add(block);
        outros2.c.push(() => {
          outroing2.delete(block);
          if (callback) {
            if (detach3)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      } else if (callback) {
        callback();
      }
    }
    var null_transition2 = { duration: 0 };
    function create_in_transition(node, fn3, params) {
      const options = { direction: "in" };
      let config = fn3(node, params, options);
      let running = false;
      let animation_name;
      let task2;
      let uid = 0;
      function cleanup() {
        if (animation_name)
          delete_rule2(node, animation_name);
      }
      function go() {
        const { delay: delay2 = 0, duration = 300, easing = identity3, tick: tick3 = noop3, css: css2 } = config || null_transition2;
        if (css2)
          animation_name = create_rule2(node, 0, 1, duration, delay2, easing, css2, uid++);
        tick3(0, 1);
        const start_time = exports.now() + delay2;
        const end_time = start_time + duration;
        if (task2)
          task2.abort();
        running = true;
        add_render_callback2(() => dispatch2(node, true, "start"));
        task2 = loop3((now2) => {
          if (running) {
            if (now2 >= end_time) {
              tick3(1, 0);
              dispatch2(node, true, "end");
              cleanup();
              return running = false;
            }
            if (now2 >= start_time) {
              const t3 = easing((now2 - start_time) / duration);
              tick3(t3, 1 - t3);
            }
          }
          return running;
        });
      }
      let started = false;
      return {
        start() {
          if (started)
            return;
          started = true;
          delete_rule2(node);
          if (is_function2(config)) {
            config = config(options);
            wait2().then(go);
          } else {
            go();
          }
        },
        invalidate() {
          started = false;
        },
        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }
      };
    }
    function create_out_transition(node, fn3, params) {
      const options = { direction: "out" };
      let config = fn3(node, params, options);
      let running = true;
      let animation_name;
      const group = outros2;
      group.r += 1;
      function go() {
        const { delay: delay2 = 0, duration = 300, easing = identity3, tick: tick3 = noop3, css: css2 } = config || null_transition2;
        if (css2)
          animation_name = create_rule2(node, 1, 0, duration, delay2, easing, css2);
        const start_time = exports.now() + delay2;
        const end_time = start_time + duration;
        add_render_callback2(() => dispatch2(node, false, "start"));
        loop3((now2) => {
          if (running) {
            if (now2 >= end_time) {
              tick3(0, 1);
              dispatch2(node, false, "end");
              if (!--group.r) {
                run_all2(group.c);
              }
              return false;
            }
            if (now2 >= start_time) {
              const t3 = easing((now2 - start_time) / duration);
              tick3(1 - t3, t3);
            }
          }
          return running;
        });
      }
      if (is_function2(config)) {
        wait2().then(() => {
          config = config(options);
          go();
        });
      } else {
        go();
      }
      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }
          if (running) {
            if (animation_name)
              delete_rule2(node, animation_name);
            running = false;
          }
        }
      };
    }
    function create_bidirectional_transition2(node, fn3, params, intro) {
      const options = { direction: "both" };
      let config = fn3(node, params, options);
      let t3 = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;
      function clear_animation() {
        if (animation_name)
          delete_rule2(node, animation_name);
      }
      function init7(program, duration) {
        const d2 = program.b - t3;
        duration *= Math.abs(d2);
        return {
          a: t3,
          b: program.b,
          d: d2,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }
      function go(b2) {
        const { delay: delay2 = 0, duration = 300, easing = identity3, tick: tick3 = noop3, css: css2 } = config || null_transition2;
        const program = {
          start: exports.now() + delay2,
          b: b2
        };
        if (!b2) {
          program.group = outros2;
          outros2.r += 1;
        }
        if (running_program || pending_program) {
          pending_program = program;
        } else {
          if (css2) {
            clear_animation();
            animation_name = create_rule2(node, t3, b2, duration, delay2, easing, css2);
          }
          if (b2)
            tick3(0, 1);
          running_program = init7(program, duration);
          add_render_callback2(() => dispatch2(node, b2, "start"));
          loop3((now2) => {
            if (pending_program && now2 > pending_program.start) {
              running_program = init7(pending_program, duration);
              pending_program = null;
              dispatch2(node, running_program.b, "start");
              if (css2) {
                clear_animation();
                animation_name = create_rule2(node, t3, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }
            if (running_program) {
              if (now2 >= running_program.end) {
                tick3(t3 = running_program.b, 1 - t3);
                dispatch2(node, running_program.b, "end");
                if (!pending_program) {
                  if (running_program.b) {
                    clear_animation();
                  } else {
                    if (!--running_program.group.r)
                      run_all2(running_program.group.c);
                  }
                }
                running_program = null;
              } else if (now2 >= running_program.start) {
                const p2 = now2 - running_program.start;
                t3 = running_program.a + running_program.d * easing(p2 / running_program.duration);
                tick3(t3, 1 - t3);
              }
            }
            return !!(running_program || pending_program);
          });
        }
      }
      return {
        run(b2) {
          if (is_function2(config)) {
            wait2().then(() => {
              config = config(options);
              go(b2);
            });
          } else {
            go(b2);
          }
        },
        end() {
          clear_animation();
          running_program = pending_program = null;
        }
      };
    }
    function handle_promise2(promise3, info) {
      const token = info.token = {};
      function update3(type, index2, key, value) {
        if (info.token !== token)
          return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== void 0) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block2, i2) => {
              if (i2 !== index2 && block2) {
                group_outros2();
                transition_out2(block2, 1, 1, () => {
                  if (info.blocks[i2] === block2) {
                    info.blocks[i2] = null;
                  }
                });
                check_outros2();
              }
            });
          } else {
            info.block.d(1);
          }
          block.c();
          transition_in2(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
          info.blocks[index2] = block;
        if (needs_flush) {
          flush2();
        }
      }
      if (is_promise2(promise3)) {
        const current_component2 = get_current_component2();
        promise3.then((value) => {
          set_current_component2(current_component2);
          update3(info.then, 1, info.value, value);
          set_current_component2(null);
        }, (error2) => {
          set_current_component2(current_component2);
          update3(info.catch, 2, info.error, error2);
          set_current_component2(null);
          if (!info.hasCatch) {
            throw error2;
          }
        });
        if (info.current !== info.pending) {
          update3(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update3(info.then, 1, info.value, promise3);
          return true;
        }
        info.resolved = promise3;
      }
    }
    function update_await_block_branch2(info, ctx, dirty) {
      const child_ctx = ctx.slice();
      const { resolved } = info;
      if (info.current === info.then) {
        child_ctx[info.value] = resolved;
      }
      if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
      }
      info.block.p(child_ctx, dirty);
    }
    var globals2 = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
    function destroy_block(block, lookup3) {
      block.d(1);
      lookup3.delete(block.key);
    }
    function outro_and_destroy_block2(block, lookup3) {
      transition_out2(block, 1, 1, () => {
        lookup3.delete(block.key);
      });
    }
    function fix_and_destroy_block(block, lookup3) {
      block.f();
      destroy_block(block, lookup3);
    }
    function fix_and_outro_and_destroy_block2(block, lookup3) {
      block.f();
      outro_and_destroy_block2(block, lookup3);
    }
    function update_keyed_each2(old_blocks, dirty, get_key, dynamic, ctx, list, lookup3, node, destroy2, create_each_block22, next2, get_context3) {
      let o2 = old_blocks.length;
      let n2 = list.length;
      let i2 = o2;
      const old_indexes = {};
      while (i2--)
        old_indexes[old_blocks[i2].key] = i2;
      const new_blocks = [];
      const new_lookup = /* @__PURE__ */ new Map();
      const deltas = /* @__PURE__ */ new Map();
      const updates = [];
      i2 = n2;
      while (i2--) {
        const child_ctx = get_context3(ctx, list, i2);
        const key = get_key(child_ctx);
        let block = lookup3.get(key);
        if (!block) {
          block = create_each_block22(key, child_ctx);
          block.c();
        } else if (dynamic) {
          updates.push(() => block.p(child_ctx, dirty));
        }
        new_lookup.set(key, new_blocks[i2] = block);
        if (key in old_indexes)
          deltas.set(key, Math.abs(i2 - old_indexes[key]));
      }
      const will_move = /* @__PURE__ */ new Set();
      const did_move = /* @__PURE__ */ new Set();
      function insert3(block) {
        transition_in2(block, 1);
        block.m(node, next2);
        lookup3.set(block.key, block);
        next2 = block.first;
        n2--;
      }
      while (o2 && n2) {
        const new_block = new_blocks[n2 - 1];
        const old_block = old_blocks[o2 - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          next2 = new_block.first;
          o2--;
          n2--;
        } else if (!new_lookup.has(old_key)) {
          destroy2(old_block, lookup3);
          o2--;
        } else if (!lookup3.has(new_key) || will_move.has(new_key)) {
          insert3(new_block);
        } else if (did_move.has(old_key)) {
          o2--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert3(new_block);
        } else {
          will_move.add(old_key);
          o2--;
        }
      }
      while (o2--) {
        const old_block = old_blocks[o2];
        if (!new_lookup.has(old_block.key))
          destroy2(old_block, lookup3);
      }
      while (n2)
        insert3(new_blocks[n2 - 1]);
      run_all2(updates);
      return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context3, get_key) {
      const keys = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < list.length; i2++) {
        const key = get_key(get_context3(ctx, list, i2));
        if (keys.has(key)) {
          throw new Error("Cannot have duplicate keys in a keyed each");
        }
        keys.add(key);
      }
    }
    function get_spread_update2(levels, updates) {
      const update3 = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i2 = levels.length;
      while (i2--) {
        const o2 = levels[i2];
        const n2 = updates[i2];
        if (n2) {
          for (const key in o2) {
            if (!(key in n2))
              to_null_out[key] = 1;
          }
          for (const key in n2) {
            if (!accounted_for[key]) {
              update3[key] = n2[key];
              accounted_for[key] = 1;
            }
          }
          levels[i2] = n2;
        } else {
          for (const key in o2) {
            accounted_for[key] = 1;
          }
        }
      }
      for (const key in to_null_out) {
        if (!(key in update3))
          update3[key] = void 0;
      }
      return update3;
    }
    function get_spread_object(spread_props) {
      return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
    }
    var _boolean_attributes2 = [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ];
    var boolean_attributes2 = /* @__PURE__ */ new Set([..._boolean_attributes2]);
    var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    function is_void(name) {
      return void_element_names.test(name) || name.toLowerCase() === "!doctype";
    }
    var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    function spread(args, attrs_to_add) {
      const attributes = Object.assign({}, ...args);
      if (attrs_to_add) {
        const classes_to_add = attrs_to_add.classes;
        const styles_to_add = attrs_to_add.styles;
        if (classes_to_add) {
          if (attributes.class == null) {
            attributes.class = classes_to_add;
          } else {
            attributes.class += " " + classes_to_add;
          }
        }
        if (styles_to_add) {
          if (attributes.style == null) {
            attributes.style = style_object_to_string(styles_to_add);
          } else {
            attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
          }
        }
      }
      let str = "";
      Object.keys(attributes).forEach((name) => {
        if (invalid_attribute_name_character.test(name))
          return;
        const value = attributes[name];
        if (value === true)
          str += " " + name;
        else if (boolean_attributes2.has(name.toLowerCase())) {
          if (value)
            str += " " + name;
        } else if (value != null) {
          str += ` ${name}="${value}"`;
        }
      });
      return str;
    }
    function merge_ssr_styles(style_attribute, style_directive) {
      const style_object = {};
      for (const individual_style of style_attribute.split(";")) {
        const colon_index = individual_style.indexOf(":");
        const name = individual_style.slice(0, colon_index).trim();
        const value = individual_style.slice(colon_index + 1).trim();
        if (!name)
          continue;
        style_object[name] = value;
      }
      for (const name in style_directive) {
        const value = style_directive[name];
        if (value) {
          style_object[name] = value;
        } else {
          delete style_object[name];
        }
      }
      return style_object;
    }
    var ATTR_REGEX = /[&"]/g;
    var CONTENT_REGEX = /[&<]/g;
    function escape2(value, is_attr = false) {
      const str = String(value);
      const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
      pattern.lastIndex = 0;
      let escaped = "";
      let last5 = 0;
      while (pattern.test(str)) {
        const i2 = pattern.lastIndex - 1;
        const ch = str[i2];
        escaped += str.substring(last5, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
        last5 = i2 + 1;
      }
      return escaped + str.substring(last5);
    }
    function escape_attribute_value(value) {
      const should_escape = typeof value === "string" || value && typeof value === "object";
      return should_escape ? escape2(value, true) : value;
    }
    function escape_object(obj) {
      const result = {};
      for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
      }
      return result;
    }
    function each(items, fn3) {
      let str = "";
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        str += fn3(items[i2], i2);
      }
      return str;
    }
    var missing_component = {
      $$render: () => ""
    };
    function validate_component(component, name) {
      if (!component || !component.$$render) {
        if (name === "svelte:component")
          name += " this={...}";
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);
      }
      return component;
    }
    function debug(file, line, column, values) {
      console.log(`{@debug} ${file ? file + " " : ""}(${line}:${column})`);
      console.log(values);
      return "";
    }
    var on_destroy;
    function create_ssr_component(fn3) {
      function $$render(result, props, bindings, slots, context) {
        const parent_component = exports.current_component;
        const $$ = {
          on_destroy,
          context: new Map(context || (parent_component ? parent_component.$$.context : [])),
          // these will be immediately discarded
          on_mount: [],
          before_update: [],
          after_update: [],
          callbacks: blank_object2()
        };
        set_current_component2({ $$ });
        const html = fn3(result, props, bindings, slots);
        set_current_component2(parent_component);
        return html;
      }
      return {
        render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
          on_destroy = [];
          const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
          const html = $$render(result, props, {}, $$slots, context);
          run_all2(on_destroy);
          return {
            html,
            css: {
              code: Array.from(result.css).map((css2) => css2.code).join("\n"),
              map: null
              // TODO
            },
            head: result.title + result.head
          };
        },
        $$render
      };
    }
    function add_attribute(name, value, boolean) {
      if (value == null || boolean && !value)
        return "";
      const assignment = boolean && value === true ? "" : `="${escape2(value, true)}"`;
      return ` ${name}${assignment}`;
    }
    function add_classes(classes) {
      return classes ? ` class="${classes}"` : "";
    }
    function style_object_to_string(style_object) {
      return Object.keys(style_object).filter((key) => style_object[key]).map((key) => `${key}: ${escape_attribute_value(style_object[key])};`).join(" ");
    }
    function add_styles(style_object) {
      const styles = style_object_to_string(style_object);
      return styles ? ` style="${styles}"` : "";
    }
    function bind7(component, name, callback) {
      const index2 = component.$$.props[name];
      if (index2 !== void 0) {
        component.$$.bound[index2] = callback;
        callback(component.$$.ctx[index2]);
      }
    }
    function create_component2(block) {
      block && block.c();
    }
    function claim_component(block, parent_nodes) {
      block && block.l(parent_nodes);
    }
    function mount_component2(component, target, anchor, customElement) {
      const { fragment, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      if (!customElement) {
        add_render_callback2(() => {
          const new_on_destroy = component.$$.on_mount.map(run2).filter(is_function2);
          if (component.$$.on_destroy) {
            component.$$.on_destroy.push(...new_on_destroy);
          } else {
            run_all2(new_on_destroy);
          }
          component.$$.on_mount = [];
        });
      }
      after_update.forEach(add_render_callback2);
    }
    function destroy_component2(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        flush_render_callbacks2($$.after_update);
        run_all2($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty2(component, i2) {
      if (component.$$.dirty[0] === -1) {
        dirty_components2.push(component);
        schedule_update2();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
    }
    function init6(component, options, instance114, create_fragment114, not_equal2, props, append_styles3, dirty = [-1]) {
      const parent_component = exports.current_component;
      set_current_component2(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop3,
        not_equal: not_equal2,
        bound: blank_object2(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object2(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles3 && append_styles3($$.root);
      let ready = false;
      $$.ctx = instance114 ? instance114(component, options.props || {}, (i2, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal2($$.ctx[i2], $$.ctx[i2] = value)) {
          if (!$$.skip_bound && $$.bound[i2])
            $$.bound[i2](value);
          if (ready)
            make_dirty2(component, i2);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all2($$.before_update);
      $$.fragment = create_fragment114 ? create_fragment114($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          start_hydrating2();
          const nodes = children2(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach2);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in2(component.$$.fragment);
        mount_component2(component, options.target, options.anchor, options.customElement);
        end_hydrating2();
        flush2();
      }
      set_current_component2(parent_component);
    }
    if (typeof HTMLElement === "function") {
      exports.SvelteElement = class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { on_mount } = this.$$;
          this.$$.on_disconnect = on_mount.map(run2).filter(is_function2);
          for (const key in this.$$.slotted) {
            this.appendChild(this.$$.slotted[key]);
          }
        }
        attributeChangedCallback(attr3, _oldValue, newValue) {
          this[attr3] = newValue;
        }
        disconnectedCallback() {
          run_all2(this.$$.on_disconnect);
        }
        $destroy() {
          destroy_component2(this, 1);
          this.$destroy = noop3;
        }
        $on(type, callback) {
          if (!is_function2(callback)) {
            return noop3;
          }
          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            const index2 = callbacks.indexOf(callback);
            if (index2 !== -1)
              callbacks.splice(index2, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty2($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      };
    }
    var SvelteComponent2 = class {
      $destroy() {
        destroy_component2(this, 1);
        this.$destroy = noop3;
      }
      $on(type, callback) {
        if (!is_function2(callback)) {
          return noop3;
        }
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index2 = callbacks.indexOf(callback);
          if (index2 !== -1)
            callbacks.splice(index2, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty2($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event2(type, Object.assign({ version: "3.58.0" }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append5(target, node);
    }
    function append_hydration_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append_hydration(target, node);
    }
    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert2(target, node, anchor);
    }
    function insert_hydration_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert_hydration(target, node, anchor);
    }
    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach2(node);
    }
    function detach_between_dev(before, after) {
      while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
      }
    }
    function detach_before_dev(after) {
      while (after.previousSibling) {
        detach_dev(after.previousSibling);
      }
    }
    function detach_after_dev(before) {
      while (before.nextSibling) {
        detach_dev(before.nextSibling);
      }
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
        modifiers.push("preventDefault");
      if (has_stop_propagation)
        modifiers.push("stopPropagation");
      if (has_stop_immediate_propagation)
        modifiers.push("stopImmediatePropagation");
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen2(node, event, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
      };
    }
    function attr_dev(node, attribute, value) {
      attr2(node, attribute, value);
      if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function dataset_dev(node, property, value) {
      node.dataset[property] = value;
      dispatch_dev("SvelteDOMSetDataset", { node, property, value });
    }
    function set_data_dev(text3, data) {
      data = "" + data;
      if (text3.data === data)
        return;
      dispatch_dev("SvelteDOMSetData", { node: text3, data });
      text3.data = data;
    }
    function set_data_contenteditable_dev(text3, data) {
      data = "" + data;
      if (text3.wholeText === data)
        return;
      dispatch_dev("SvelteDOMSetData", { node: text3, data });
      text3.data = data;
    }
    function set_data_maybe_contenteditable_dev(text3, data, attr_value) {
      if (~contenteditable_truthy_values.indexOf(attr_value)) {
        set_data_contenteditable_dev(text3, data);
      } else {
        set_data_dev(text3, data);
      }
    }
    function validate_each_argument(arg) {
      if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
        let msg = "{#each} only iterates over array-like objects.";
        if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
          msg += " You can use a spread to convert this iterable into an array.";
        }
        throw new Error(msg);
      }
    }
    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    function validate_dynamic_element(tag) {
      const is_string = typeof tag === "string";
      if (tag && !is_string) {
        throw new Error('<svelte:element> expects "this" attribute to be a string.');
      }
    }
    function validate_void_dynamic_element(tag) {
      if (tag && is_void(tag)) {
        console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
      }
    }
    function construct_svelte_component_dev(component, props) {
      const error_message = "this={...} of <svelte:component> should specify a Svelte component.";
      try {
        const instance114 = new component(props);
        if (!instance114.$$ || !instance114.$set || !instance114.$on || !instance114.$destroy) {
          throw new Error(error_message);
        }
        return instance114;
      } catch (err) {
        const { message } = err;
        if (typeof message === "string" && message.indexOf("is not a constructor") !== -1) {
          throw new Error(error_message);
        } else {
          throw err;
        }
      }
    }
    var SvelteComponentDev2 = class extends SvelteComponent2 {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error("'target' is a required option");
        }
        super();
      }
      $destroy() {
        super.$destroy();
        this.$destroy = () => {
          console.warn("Component was already destroyed");
        };
      }
      $capture_state() {
      }
      $inject_state() {
      }
    };
    var SvelteComponentTyped2 = class extends SvelteComponentDev2 {
      constructor(options) {
        super(options);
      }
    };
    function loop_guard(timeout) {
      const start2 = Date.now();
      return () => {
        if (Date.now() - start2 > timeout) {
          throw new Error("Infinite loop detected");
        }
      };
    }
    exports.HtmlTag = HtmlTag;
    exports.HtmlTagHydration = HtmlTagHydration;
    exports.SvelteComponent = SvelteComponent2;
    exports.SvelteComponentDev = SvelteComponentDev2;
    exports.SvelteComponentTyped = SvelteComponentTyped2;
    exports.action_destroyer = action_destroyer2;
    exports.add_attribute = add_attribute;
    exports.add_classes = add_classes;
    exports.add_flush_callback = add_flush_callback2;
    exports.add_location = add_location;
    exports.add_render_callback = add_render_callback2;
    exports.add_resize_listener = add_resize_listener2;
    exports.add_styles = add_styles;
    exports.add_transform = add_transform2;
    exports.afterUpdate = afterUpdate2;
    exports.append = append5;
    exports.append_dev = append_dev;
    exports.append_empty_stylesheet = append_empty_stylesheet2;
    exports.append_hydration = append_hydration;
    exports.append_hydration_dev = append_hydration_dev;
    exports.append_styles = append_styles2;
    exports.assign = assign2;
    exports.attr = attr2;
    exports.attr_dev = attr_dev;
    exports.attribute_to_object = attribute_to_object;
    exports.beforeUpdate = beforeUpdate2;
    exports.bind = bind7;
    exports.binding_callbacks = binding_callbacks2;
    exports.blank_object = blank_object2;
    exports.bubble = bubble2;
    exports.check_outros = check_outros2;
    exports.children = children2;
    exports.claim_comment = claim_comment;
    exports.claim_component = claim_component;
    exports.claim_element = claim_element;
    exports.claim_html_tag = claim_html_tag;
    exports.claim_space = claim_space;
    exports.claim_svg_element = claim_svg_element;
    exports.claim_text = claim_text;
    exports.clear_loops = clear_loops;
    exports.comment = comment;
    exports.component_subscribe = component_subscribe2;
    exports.compute_rest_props = compute_rest_props;
    exports.compute_slots = compute_slots2;
    exports.construct_svelte_component = construct_svelte_component;
    exports.construct_svelte_component_dev = construct_svelte_component_dev;
    exports.contenteditable_truthy_values = contenteditable_truthy_values;
    exports.createEventDispatcher = createEventDispatcher2;
    exports.create_animation = create_animation2;
    exports.create_bidirectional_transition = create_bidirectional_transition2;
    exports.create_component = create_component2;
    exports.create_in_transition = create_in_transition;
    exports.create_out_transition = create_out_transition;
    exports.create_slot = create_slot2;
    exports.create_ssr_component = create_ssr_component;
    exports.custom_event = custom_event2;
    exports.dataset_dev = dataset_dev;
    exports.debug = debug;
    exports.destroy_block = destroy_block;
    exports.destroy_component = destroy_component2;
    exports.destroy_each = destroy_each2;
    exports.detach = detach2;
    exports.detach_after_dev = detach_after_dev;
    exports.detach_before_dev = detach_before_dev;
    exports.detach_between_dev = detach_between_dev;
    exports.detach_dev = detach_dev;
    exports.dirty_components = dirty_components2;
    exports.dispatch_dev = dispatch_dev;
    exports.each = each;
    exports.element = element2;
    exports.element_is = element_is;
    exports.empty = empty4;
    exports.end_hydrating = end_hydrating2;
    exports.escape = escape2;
    exports.escape_attribute_value = escape_attribute_value;
    exports.escape_object = escape_object;
    exports.exclude_internal_props = exclude_internal_props;
    exports.fix_and_destroy_block = fix_and_destroy_block;
    exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block2;
    exports.fix_position = fix_position2;
    exports.flush = flush2;
    exports.flush_render_callbacks = flush_render_callbacks2;
    exports.getAllContexts = getAllContexts2;
    exports.getContext = getContext2;
    exports.get_all_dirty_from_scope = get_all_dirty_from_scope2;
    exports.get_binding_group_value = get_binding_group_value;
    exports.get_current_component = get_current_component2;
    exports.get_custom_elements_slots = get_custom_elements_slots;
    exports.get_root_for_style = get_root_for_style2;
    exports.get_slot_changes = get_slot_changes2;
    exports.get_spread_object = get_spread_object;
    exports.get_spread_update = get_spread_update2;
    exports.get_store_value = get_store_value2;
    exports.globals = globals2;
    exports.group_outros = group_outros2;
    exports.handle_promise = handle_promise2;
    exports.hasContext = hasContext2;
    exports.has_prop = has_prop;
    exports.head_selector = head_selector;
    exports.identity = identity3;
    exports.init = init6;
    exports.init_binding_group = init_binding_group;
    exports.init_binding_group_dynamic = init_binding_group_dynamic;
    exports.insert = insert2;
    exports.insert_dev = insert_dev;
    exports.insert_hydration = insert_hydration;
    exports.insert_hydration_dev = insert_hydration_dev;
    exports.intros = intros;
    exports.invalid_attribute_name_character = invalid_attribute_name_character;
    exports.is_client = is_client2;
    exports.is_crossorigin = is_crossorigin2;
    exports.is_empty = is_empty2;
    exports.is_function = is_function2;
    exports.is_promise = is_promise2;
    exports.is_void = is_void;
    exports.listen = listen2;
    exports.listen_dev = listen_dev;
    exports.loop = loop3;
    exports.loop_guard = loop_guard;
    exports.merge_ssr_styles = merge_ssr_styles;
    exports.missing_component = missing_component;
    exports.mount_component = mount_component2;
    exports.noop = noop3;
    exports.not_equal = not_equal;
    exports.null_to_empty = null_to_empty2;
    exports.object_without_properties = object_without_properties;
    exports.onDestroy = onDestroy2;
    exports.onMount = onMount2;
    exports.once = once;
    exports.outro_and_destroy_block = outro_and_destroy_block2;
    exports.prevent_default = prevent_default;
    exports.prop_dev = prop_dev;
    exports.query_selector_all = query_selector_all;
    exports.run = run2;
    exports.run_all = run_all2;
    exports.safe_not_equal = safe_not_equal2;
    exports.schedule_update = schedule_update2;
    exports.select_multiple_value = select_multiple_value;
    exports.select_option = select_option2;
    exports.select_options = select_options;
    exports.select_value = select_value;
    exports.self = self2;
    exports.setContext = setContext2;
    exports.set_attributes = set_attributes2;
    exports.set_current_component = set_current_component2;
    exports.set_custom_element_data = set_custom_element_data2;
    exports.set_custom_element_data_map = set_custom_element_data_map2;
    exports.set_data = set_data2;
    exports.set_data_contenteditable = set_data_contenteditable;
    exports.set_data_contenteditable_dev = set_data_contenteditable_dev;
    exports.set_data_dev = set_data_dev;
    exports.set_data_maybe_contenteditable = set_data_maybe_contenteditable;
    exports.set_data_maybe_contenteditable_dev = set_data_maybe_contenteditable_dev;
    exports.set_dynamic_element_data = set_dynamic_element_data2;
    exports.set_input_type = set_input_type;
    exports.set_input_value = set_input_value2;
    exports.set_now = set_now;
    exports.set_raf = set_raf;
    exports.set_store_value = set_store_value;
    exports.set_style = set_style2;
    exports.set_svg_attributes = set_svg_attributes;
    exports.space = space2;
    exports.split_css_unit = split_css_unit2;
    exports.spread = spread;
    exports.src_url_equal = src_url_equal2;
    exports.start_hydrating = start_hydrating2;
    exports.stop_immediate_propagation = stop_immediate_propagation;
    exports.stop_propagation = stop_propagation2;
    exports.subscribe = subscribe2;
    exports.svg_element = svg_element;
    exports.text = text2;
    exports.tick = tick2;
    exports.time_ranges_to_array = time_ranges_to_array;
    exports.to_number = to_number2;
    exports.toggle_class = toggle_class2;
    exports.transition_in = transition_in2;
    exports.transition_out = transition_out2;
    exports.trusted = trusted;
    exports.update_await_block_branch = update_await_block_branch2;
    exports.update_keyed_each = update_keyed_each2;
    exports.update_slot = update_slot;
    exports.update_slot_base = update_slot_base2;
    exports.validate_component = validate_component;
    exports.validate_dynamic_element = validate_dynamic_element;
    exports.validate_each_argument = validate_each_argument;
    exports.validate_each_keys = validate_each_keys;
    exports.validate_slots = validate_slots;
    exports.validate_store = validate_store;
    exports.validate_void_dynamic_element = validate_void_dynamic_element;
    exports.xlink_attr = xlink_attr;
  }
});

// node_modules/svelte/store/index.js
var require_store = __commonJS({
  "node_modules/svelte/store/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal = require_internal();
    var subscriber_queue2 = [];
    function readable2(value, start2) {
      return {
        subscribe: writable2(value, start2).subscribe
      };
    }
    function writable2(value, start2 = internal.noop) {
      let stop;
      const subscribers = /* @__PURE__ */ new Set();
      function set2(new_value) {
        if (internal.safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue2.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue2.push(subscriber, value);
            }
            if (run_queue) {
              for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
                subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
              }
              subscriber_queue2.length = 0;
            }
          }
        }
      }
      function update2(fn3) {
        set2(fn3(value));
      }
      function subscribe2(run2, invalidate = internal.noop) {
        const subscriber = [run2, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start2(set2) || internal.noop;
        }
        run2(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0 && stop) {
            stop();
            stop = null;
          }
        };
      }
      return { set: set2, update: update2, subscribe: subscribe2 };
    }
    function derived2(stores, fn3, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto2 = fn3.length < 2;
      return readable2(initial_value, (set2) => {
        let started = false;
        const values = [];
        let pending = 0;
        let cleanup = internal.noop;
        const sync = () => {
          if (pending) {
            return;
          }
          cleanup();
          const result = fn3(single ? values[0] : values, set2);
          if (auto2) {
            set2(result);
          } else {
            cleanup = internal.is_function(result) ? result : internal.noop;
          }
        };
        const unsubscribers = stores_array.map((store, i2) => internal.subscribe(store, (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        }, () => {
          pending |= 1 << i2;
        }));
        started = true;
        sync();
        return function stop() {
          internal.run_all(unsubscribers);
          cleanup();
          started = false;
        };
      });
    }
    function readonly(store) {
      return {
        subscribe: store.subscribe.bind(store)
      };
    }
    Object.defineProperty(exports, "get", {
      enumerable: true,
      get: function() {
        return internal.get_store_value;
      }
    });
    exports.derived = derived2;
    exports.readable = readable2;
    exports.readonly = readonly;
    exports.writable = writable2;
  }
});

// node_modules/svelte-i18next/translation-store.js
var require_translation_store = __commonJS({
  "node_modules/svelte-i18next/translation-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.I18NextTranslationStore = exports.isLoading = void 0;
    var store_1 = require_store();
    exports.isLoading = (0, store_1.writable)(true);
    var I18NextTranslationStore = class {
      constructor(i18n2) {
        this.i18n = this.createInstance(i18n2);
        this.isLoading = this.createLoadingInstance(i18n2);
      }
      createInstance(i18n2) {
        const i18nWritable = (0, store_1.writable)(i18n2);
        i18n2.on("initialized", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("loaded", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("added", () => i18nWritable.set(i18n2));
        i18n2.on("languageChanged", () => {
          i18nWritable.set(i18n2);
        });
        return i18nWritable;
      }
      createLoadingInstance(i18n2) {
        i18n2.on("loaded", (resources) => {
          Object.keys(resources).length !== 0 && exports.isLoading.set(false);
        });
        i18n2.on("failedLoading", () => {
          exports.isLoading.set(true);
        });
        return exports.isLoading;
      }
    };
    exports.I18NextTranslationStore = I18NextTranslationStore;
  }
});

// node_modules/svelte-i18next/i18n.js
var require_i18n = __commonJS({
  "node_modules/svelte-i18next/i18n.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createI18nStore = void 0;
    var translation_store_1 = require_translation_store();
    var createI18nStore2 = (i18n2) => {
      const i18nStore = new translation_store_1.I18NextTranslationStore(i18n2);
      return i18nStore.i18n;
    };
    exports.createI18nStore = createI18nStore2;
  }
});

// node_modules/svelte-i18next/index.js
var require_svelte_i18next = __commonJS({
  "node_modules/svelte-i18next/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_i18n(), exports);
    __exportStar(require_translation_store(), exports);
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProjectsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_dayjs9 = __toESM(require_dayjs_min());
var import_isoWeek = __toESM(require_isoWeek());
var import_localizedFormat = __toESM(require_localizedFormat());

// node_modules/fp-ts/es6/function.js
var function_exports = {};
__export(function_exports, {
  SK: () => SK,
  absurd: () => absurd,
  apply: () => apply,
  constFalse: () => constFalse,
  constNull: () => constNull,
  constTrue: () => constTrue,
  constUndefined: () => constUndefined,
  constVoid: () => constVoid,
  constant: () => constant,
  decrement: () => decrement,
  flip: () => flip,
  flow: () => flow,
  getBooleanAlgebra: () => getBooleanAlgebra,
  getEndomorphismMonoid: () => getEndomorphismMonoid,
  getMonoid: () => getMonoid,
  getRing: () => getRing,
  getSemigroup: () => getSemigroup,
  getSemiring: () => getSemiring,
  hole: () => hole,
  identity: () => identity,
  increment: () => increment,
  not: () => not,
  pipe: () => pipe,
  tuple: () => tuple,
  tupled: () => tupled,
  unsafeCoerce: () => unsafeCoerce,
  untupled: () => untupled
});
var getBooleanAlgebra = function(B2) {
  return function() {
    return {
      meet: function(x2, y2) {
        return function(a2) {
          return B2.meet(x2(a2), y2(a2));
        };
      },
      join: function(x2, y2) {
        return function(a2) {
          return B2.join(x2(a2), y2(a2));
        };
      },
      zero: function() {
        return B2.zero;
      },
      one: function() {
        return B2.one;
      },
      implies: function(x2, y2) {
        return function(a2) {
          return B2.implies(x2(a2), y2(a2));
        };
      },
      not: function(x2) {
        return function(a2) {
          return B2.not(x2(a2));
        };
      }
    };
  };
};
var getSemigroup = function(S2) {
  return function() {
    return {
      concat: function(f2, g2) {
        return function(a2) {
          return S2.concat(f2(a2), g2(a2));
        };
      }
    };
  };
};
var getMonoid = function(M2) {
  var getSemigroupM = getSemigroup(M2);
  return function() {
    return {
      concat: getSemigroupM().concat,
      empty: function() {
        return M2.empty;
      }
    };
  };
};
var getSemiring = function(S2) {
  return {
    add: function(f2, g2) {
      return function(x2) {
        return S2.add(f2(x2), g2(x2));
      };
    },
    zero: function() {
      return S2.zero;
    },
    mul: function(f2, g2) {
      return function(x2) {
        return S2.mul(f2(x2), g2(x2));
      };
    },
    one: function() {
      return S2.one;
    }
  };
};
var getRing = function(R2) {
  var S2 = getSemiring(R2);
  return {
    add: S2.add,
    mul: S2.mul,
    one: S2.one,
    zero: S2.zero,
    sub: function(f2, g2) {
      return function(x2) {
        return R2.sub(f2(x2), g2(x2));
      };
    }
  };
};
var apply = function(a2) {
  return function(f2) {
    return f2(a2);
  };
};
function identity(a2) {
  return a2;
}
var unsafeCoerce = identity;
function constant(a2) {
  return function() {
    return a2;
  };
}
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function flip(f2) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (args.length > 1) {
      return f2(args[1], args[0]);
    }
    return function(a2) {
      return f2(a2)(args[0]);
    };
  };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function tuple() {
  var t3 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    t3[_i] = arguments[_i];
  }
  return t3;
}
function increment(n2) {
  return n2 + 1;
}
function decrement(n2) {
  return n2 - 1;
}
function absurd(_24) {
  throw new Error("Called `absurd` function which should be uncallable");
}
function tupled(f2) {
  return function(a2) {
    return f2.apply(void 0, a2);
  };
}
function untupled(f2) {
  return function() {
    var a2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a2[_i] = arguments[_i];
    }
    return f2(a2);
  };
}
function pipe(a2, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a2;
    case 2:
      return ab(a2);
    case 3:
      return bc(ab(a2));
    case 4:
      return cd(bc(ab(a2)));
    case 5:
      return de(cd(bc(ab(a2))));
    case 6:
      return ef(de(cd(bc(ab(a2)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a2))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a2)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a2))))))));
    default: {
      var ret = arguments[0];
      for (var i2 = 1; i2 < arguments.length; i2++) {
        ret = arguments[i2](ret);
      }
      return ret;
    }
  }
}
var hole = absurd;
var SK = function(_24, b2) {
  return b2;
};
function not(predicate) {
  return function(a2) {
    return !predicate(a2);
  };
}
var getEndomorphismMonoid = function() {
  return {
    concat: function(first, second) {
      return flow(first, second);
    },
    empty: identity
  };
};

// node_modules/fp-ts/es6/internal.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNone = function(fa) {
  return fa._tag === "None";
};
var isSome = function(fa) {
  return fa._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a2) {
  return { _tag: "Some", value: a2 };
};
var isLeft = function(ma) {
  return ma._tag === "Left";
};
var isRight = function(ma) {
  return ma._tag === "Right";
};
var left = function(e) {
  return { _tag: "Left", left: e };
};
var right = function(a2) {
  return { _tag: "Right", right: a2 };
};
var singleton = function(a2) {
  return [a2];
};
var isNonEmpty = function(as) {
  return as.length > 0;
};
var head = function(as) {
  return as[0];
};
var tail = function(as) {
  return as.slice(1);
};
var emptyReadonlyArray = [];
var emptyRecord = {};
var fromReadonlyNonEmptyArray = function(as) {
  return __spreadArray([as[0]], as.slice(1), true);
};

// node_modules/fp-ts/es6/Apply.js
function ap(F, G2) {
  return function(fa) {
    return function(fab) {
      return F.ap(F.map(fab, function(gab) {
        return function(ga) {
          return G2.ap(gab, ga);
        };
      }), fa);
    };
  };
}
function apFirst(A2) {
  return function(second) {
    return function(first) {
      return A2.ap(A2.map(first, function(a2) {
        return function() {
          return a2;
        };
      }), second);
    };
  };
}
function apSecond(A2) {
  return function(second) {
    return function(first) {
      return A2.ap(A2.map(first, function() {
        return function(b2) {
          return b2;
        };
      }), second);
    };
  };
}
function apS(F) {
  return function(name, fb) {
    return function(fa) {
      return F.ap(F.map(fa, function(a2) {
        return function(b2) {
          var _a;
          return Object.assign({}, a2, (_a = {}, _a[name] = b2, _a));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F) {
  return function(S2) {
    return {
      concat: function(first, second) {
        return F.ap(F.map(first, function(x2) {
          return function(y2) {
            return S2.concat(x2, y2);
          };
        }), second);
      }
    };
  };
}

// node_modules/fp-ts/es6/Functor.js
function map(F, G2) {
  return function(f2) {
    return function(fa) {
      return F.map(fa, function(ga) {
        return G2.map(ga, f2);
      });
    };
  };
}
function flap(F) {
  return function(a2) {
    return function(fab) {
      return F.map(fab, function(f2) {
        return f2(a2);
      });
    };
  };
}
function bindTo(F) {
  return function(name) {
    return function(fa) {
      return F.map(fa, function(a2) {
        var _a;
        return _a = {}, _a[name] = a2, _a;
      });
    };
  };
}
function let_(F) {
  return function(name, f2) {
    return function(fa) {
      return F.map(fa, function(a2) {
        var _a;
        return Object.assign({}, a2, (_a = {}, _a[name] = f2(a2), _a));
      });
    };
  };
}

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F) {
  var f2 = getApplySemigroup(F);
  return function(M2) {
    return {
      concat: f2(M2).concat,
      empty: F.of(M2.empty)
    };
  };
}

// node_modules/fp-ts/es6/Array.js
var Array_exports = {};
__export(Array_exports, {
  Alt: () => Alt,
  Alternative: () => Alternative,
  Applicative: () => Applicative,
  Apply: () => Apply,
  Chain: () => Chain,
  ChainRecBreadthFirst: () => ChainRecBreadthFirst,
  ChainRecDepthFirst: () => ChainRecDepthFirst,
  Compactable: () => Compactable,
  Do: () => Do,
  Extend: () => Extend,
  Filterable: () => Filterable,
  FilterableWithIndex: () => FilterableWithIndex,
  Foldable: () => Foldable,
  FoldableWithIndex: () => FoldableWithIndex,
  FromEither: () => FromEither,
  Functor: () => Functor,
  FunctorWithIndex: () => FunctorWithIndex,
  Monad: () => Monad,
  Pointed: () => Pointed,
  Traversable: () => Traversable,
  TraversableWithIndex: () => TraversableWithIndex,
  URI: () => URI,
  Unfoldable: () => Unfoldable,
  Witherable: () => Witherable,
  Zero: () => Zero,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap2,
  apFirst: () => apFirst2,
  apS: () => apS2,
  apSecond: () => apSecond2,
  append: () => append3,
  appendW: () => appendW3,
  array: () => array,
  bind: () => bind2,
  bindTo: () => bindTo2,
  chain: () => chain,
  chainFirst: () => chainFirst2,
  chainRecBreadthFirst: () => chainRecBreadthFirst2,
  chainRecDepthFirst: () => chainRecDepthFirst2,
  chainWithIndex: () => chainWithIndex,
  chop: () => chop3,
  chunksOf: () => chunksOf3,
  compact: () => compact,
  comprehension: () => comprehension,
  concat: () => concat2,
  concatW: () => concatW,
  cons: () => cons3,
  copy: () => copy2,
  deleteAt: () => deleteAt,
  difference: () => difference,
  dropLeft: () => dropLeft,
  dropLeftWhile: () => dropLeftWhile,
  dropRight: () => dropRight,
  duplicate: () => duplicate,
  elem: () => elem2,
  empty: () => empty2,
  every: () => every2,
  exists: () => exists,
  extend: () => extend,
  filter: () => filter,
  filterE: () => filterE2,
  filterMap: () => filterMap,
  filterMapWithIndex: () => filterMapWithIndex,
  filterWithIndex: () => filterWithIndex,
  findFirst: () => findFirst2,
  findFirstMap: () => findFirstMap2,
  findIndex: () => findIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  findLastMap: () => findLastMap2,
  flap: () => flap2,
  flatten: () => flatten,
  foldLeft: () => foldLeft,
  foldMap: () => foldMap3,
  foldMapWithIndex: () => foldMapWithIndex3,
  foldRight: () => foldRight,
  fromEither: () => fromEither,
  fromEitherK: () => fromEitherK2,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate2,
  getDifferenceMagma: () => getDifferenceMagma,
  getEq: () => getEq3,
  getIntersectionSemigroup: () => getIntersectionSemigroup,
  getMonoid: () => getMonoid3,
  getOrd: () => getOrd2,
  getSemigroup: () => getSemigroup3,
  getShow: () => getShow3,
  getUnionMonoid: () => getUnionMonoid,
  getUnionSemigroup: () => getUnionSemigroup,
  guard: () => guard2,
  head: () => head5,
  init: () => init3,
  insertAt: () => insertAt,
  intercalate: () => intercalate3,
  intersection: () => intersection,
  intersperse: () => intersperse3,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty5,
  isOutOfBound: () => isOutOfBound4,
  last: () => last4,
  lefts: () => lefts,
  let: () => let_2,
  lookup: () => lookup2,
  makeBy: () => makeBy3,
  map: () => map2,
  mapWithIndex: () => mapWithIndex,
  match: () => match2,
  matchLeft: () => matchLeft,
  matchLeftW: () => matchLeftW,
  matchRight: () => matchRight,
  matchRightW: () => matchRightW,
  matchW: () => matchW2,
  modifyAt: () => modifyAt,
  of: () => of3,
  partition: () => partition,
  partitionMap: () => partitionMap,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionWithIndex: () => partitionWithIndex,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  prependToAll: () => prependToAll,
  prependW: () => prependW3,
  range: () => range3,
  reduce: () => reduce3,
  reduceRight: () => reduceRight3,
  reduceRightWithIndex: () => reduceRightWithIndex3,
  reduceWithIndex: () => reduceWithIndex3,
  replicate: () => replicate,
  reverse: () => reverse,
  rights: () => rights,
  rotate: () => rotate3,
  scanLeft: () => scanLeft,
  scanRight: () => scanRight,
  separate: () => separate,
  sequence: () => sequence,
  size: () => size,
  snoc: () => snoc3,
  some: () => some2,
  sort: () => sort2,
  sortBy: () => sortBy3,
  spanLeft: () => spanLeft,
  splitAt: () => splitAt3,
  tail: () => tail4,
  takeLeft: () => takeLeft,
  takeLeftWhile: () => takeLeftWhile,
  takeRight: () => takeRight,
  traverse: () => traverse,
  traverseWithIndex: () => traverseWithIndex,
  unfold: () => unfold,
  union: () => union3,
  uniq: () => uniq3,
  unsafeDeleteAt: () => unsafeDeleteAt,
  unsafeInsertAt: () => unsafeInsertAt3,
  unsafeUpdateAt: () => unsafeUpdateAt3,
  unzip: () => unzip,
  updateAt: () => updateAt,
  wilt: () => wilt,
  wither: () => wither,
  zero: () => zero,
  zip: () => zip,
  zipWith: () => zipWith
});

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M2) {
  return function(f2) {
    return function(first) {
      return M2.chain(first, function(a2) {
        return M2.map(f2(a2), function() {
          return a2;
        });
      });
    };
  };
}
function bind(M2) {
  return function(name, f2) {
    return function(ma) {
      return M2.chain(ma, function(a2) {
        return M2.map(f2(a2), function(b2) {
          var _a;
          return Object.assign({}, a2, (_a = {}, _a[name] = b2, _a));
        });
      });
    };
  };
}

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F) {
  return function(onNone) {
    return function(ma) {
      return F.fromEither(isNone(ma) ? left(onNone()) : right(ma.value));
    };
  };
}
function fromPredicate(F) {
  return function(predicate, onFalse) {
    return function(a2) {
      return F.fromEither(predicate(a2) ? right(a2) : left(onFalse(a2)));
    };
  };
}
function fromOptionK(F) {
  var fromOptionF = fromOption(F);
  return function(onNone) {
    var from = fromOptionF(onNone);
    return function(f2) {
      return flow(f2, from);
    };
  };
}
function chainOptionK(F, M2) {
  var fromOptionKF = fromOptionK(F);
  return function(onNone) {
    var from = fromOptionKF(onNone);
    return function(f2) {
      return function(ma) {
        return M2.chain(ma, from(f2));
      };
    };
  };
}
function fromEitherK(F) {
  return function(f2) {
    return flow(f2, F.fromEither);
  };
}
function chainEitherK(F, M2) {
  var fromEitherKF = fromEitherK(F);
  return function(f2) {
    return function(ma) {
      return M2.chain(ma, fromEitherKF(f2));
    };
  };
}
function chainFirstEitherK(F, M2) {
  return flow(fromEitherK(F), chainFirst(M2));
}
function filterOrElse(F, M2) {
  return function(predicate, onFalse) {
    return function(ma) {
      return M2.chain(ma, function(a2) {
        return F.fromEither(predicate(a2) ? right(a2) : left(onFalse(a2)));
      });
    };
  };
}

// node_modules/fp-ts/es6/Eq.js
var fromEquals = function(equals) {
  return {
    equals: function(x2, y2) {
      return x2 === y2 || equals(x2, y2);
    }
  };
};
var eqStrict = {
  equals: function(a2, b2) {
    return a2 === b2;
  }
};
var strictEqual = eqStrict.equals;

// node_modules/fp-ts/es6/Ord.js
var equalsDefault = function(compare2) {
  return function(first, second) {
    return first === second || compare2(first, second) === 0;
  };
};
var fromCompare = function(compare2) {
  return {
    equals: equalsDefault(compare2),
    compare: function(first, second) {
      return first === second ? 0 : compare2(first, second);
    }
  };
};
var getSemigroup2 = function() {
  return {
    concat: function(first, second) {
      return fromCompare(function(a2, b2) {
        var ox = first.compare(a2, b2);
        return ox !== 0 ? ox : second.compare(a2, b2);
      });
    }
  };
};
var getMonoid2 = function() {
  return {
    concat: getSemigroup2().concat,
    empty: fromCompare(function() {
      return 0;
    })
  };
};
function compare(first, second) {
  return first < second ? -1 : first > second ? 1 : 0;
}
var strictOrd = {
  equals: eqStrict.equals,
  compare
};

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty2 = isNonEmpty;
var isOutOfBound = function(i2, as) {
  return i2 < 0 || i2 >= as.length;
};
var prependW = function(head6) {
  return function(tail5) {
    return __spreadArray2([head6], tail5, true);
  };
};
var prepend = prependW;
var prependAll = function(middle) {
  return function(as) {
    var out = [middle, as[0]];
    for (var i2 = 1; i2 < as.length; i2++) {
      out.push(middle, as[i2]);
    }
    return out;
  };
};
var intersperse = function(middle) {
  return function(as) {
    var rest = tail2(as);
    return isNonEmpty2(rest) ? pipe(rest, prependAll(middle), prepend(head2(as))) : as;
  };
};
var extract = head;
var head2 = extract;
var tail2 = tail;
var last = function(as) {
  return as[as.length - 1];
};
var concatAll = function(S2) {
  return function(as) {
    return as.reduce(S2.concat);
  };
};
var intercalate = function(S2) {
  var concatAllS = concatAll(S2);
  return function(middle) {
    return flow(intersperse(middle), concatAllS);
  };
};

// node_modules/fp-ts/es6/NonEmptyArray.js
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty3 = function(as) {
  return as.length > 0;
};
var isOutOfBound2 = function(i2, as) {
  return i2 < 0 || i2 >= as.length;
};
var prependW2 = function(head6) {
  return function(tail5) {
    return __spreadArray3([head6], tail5, true);
  };
};
var prepend2 = prependW2;
var appendW = function(end2) {
  return function(init6) {
    return __spreadArray3(__spreadArray3([], init6, true), [end2], false);
  };
};
var append = appendW;
var unsafeInsertAt = function(i2, a2, as) {
  if (isNonEmpty3(as)) {
    var xs = fromReadonlyNonEmptyArray2(as);
    xs.splice(i2, 0, a2);
    return xs;
  }
  return [a2];
};
var unsafeUpdateAt = function(i2, a2, as) {
  var xs = fromReadonlyNonEmptyArray2(as);
  xs[i2] = a2;
  return xs;
};
var uniq = function(E2) {
  return function(as) {
    if (as.length === 1) {
      return copy(as);
    }
    var out = [head3(as)];
    var rest = tail3(as);
    var _loop_1 = function(a3) {
      if (out.every(function(o2) {
        return !E2.equals(o2, a3);
      })) {
        out.push(a3);
      }
    };
    for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
      var a2 = rest_1[_i];
      _loop_1(a2);
    }
    return out;
  };
};
var sortBy = function(ords) {
  if (isNonEmpty3(ords)) {
    var M2 = getMonoid2();
    return sort(ords.reduce(M2.concat, M2.empty));
  }
  return copy;
};
var union = function(E2) {
  var uniqE = uniq(E2);
  return function(second) {
    return function(first) {
      return uniqE(pipe(first, concat(second)));
    };
  };
};
var rotate = function(n2) {
  return function(as) {
    var len = as.length;
    var m = Math.round(n2) % len;
    if (isOutOfBound2(Math.abs(m), as) || m === 0) {
      return copy(as);
    }
    if (m < 0) {
      var _a = splitAt(-m)(as), f2 = _a[0], s2 = _a[1];
      return pipe(s2, concat(f2));
    } else {
      return rotate(m - len)(as);
    }
  };
};
var fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
var makeBy = function(f2) {
  return function(n2) {
    var j2 = Math.max(0, Math.floor(n2));
    var out = [f2(0)];
    for (var i2 = 1; i2 < j2; i2++) {
      out.push(f2(i2));
    }
    return out;
  };
};
var range = function(start2, end2) {
  return start2 <= end2 ? makeBy(function(i2) {
    return start2 + i2;
  })(end2 - start2 + 1) : [start2];
};
function concat(x2, y2) {
  return y2 ? x2.concat(y2) : function(y3) {
    return y3.concat(x2);
  };
}
var sort = function(O2) {
  return function(as) {
    return as.slice().sort(O2.compare);
  };
};
var copy = fromReadonlyNonEmptyArray2;
var of = function(a2) {
  return [a2];
};
var prependAll2 = function(middle) {
  return function(as) {
    var out = [middle, as[0]];
    for (var i2 = 1; i2 < as.length; i2++) {
      out.push(middle, as[i2]);
    }
    return out;
  };
};
var intersperse2 = function(middle) {
  return function(as) {
    var rest = tail3(as);
    return isNonEmpty3(rest) ? pipe(rest, prependAll2(middle), prepend2(head3(as))) : copy(as);
  };
};
var chop = function(f2) {
  return function(as) {
    var _a = f2(as), b2 = _a[0], rest = _a[1];
    var out = [b2];
    var next2 = rest;
    while (isNonEmpty3(next2)) {
      var _b = f2(next2), b_1 = _b[0], rest_2 = _b[1];
      out.push(b_1);
      next2 = rest_2;
    }
    return out;
  };
};
var splitAt = function(n2) {
  return function(as) {
    var m = Math.max(1, n2);
    return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend2(head3(as))), as.slice(m)];
  };
};
var chunksOf = function(n2) {
  return chop(splitAt(n2));
};
var head3 = head2;
var tail3 = function(as) {
  return as.slice(1);
};
var last2 = last;
var init = function(as) {
  return as.slice(0, -1);
};
function cons(head6, tail5) {
  return tail5 === void 0 ? prepend2(head6) : pipe(tail5, prepend2(head6));
}
var snoc = function(init6, end2) {
  return pipe(init6, append(end2));
};

// node_modules/fp-ts/es6/number.js
var Eq = {
  equals: function(first, second) {
    return first === second;
  }
};
var Ord = {
  equals: Eq.equals,
  compare: function(first, second) {
    return first < second ? -1 : first > second ? 1 : 0;
  }
};
var Bounded = {
  equals: Eq.equals,
  compare: Ord.compare,
  top: Infinity,
  bottom: -Infinity
};
var MagmaSub = {
  concat: function(first, second) {
    return first - second;
  }
};
var SemigroupSum = {
  concat: function(first, second) {
    return first + second;
  }
};
var SemigroupProduct = {
  concat: function(first, second) {
    return first * second;
  }
};
var MonoidSum = {
  concat: SemigroupSum.concat,
  empty: 0
};
var MonoidProduct = {
  concat: SemigroupProduct.concat,
  empty: 1
};
var Field = {
  add: SemigroupSum.concat,
  zero: 0,
  mul: SemigroupProduct.concat,
  one: 1,
  sub: MagmaSub.concat,
  degree: function(_24) {
    return 1;
  },
  div: function(first, second) {
    return first / second;
  },
  mod: function(first, second) {
    return first % second;
  }
};

// node_modules/fp-ts/es6/Separated.js
var separated = function(left6, right6) {
  return { left: left6, right: right6 };
};

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f2) {
      return F.map(traverseF(wa, f2), C.separate);
    };
  };
}
function witherDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f2) {
      return F.map(traverseF(wa, f2), C.compact);
    };
  };
}
function filterE(W2) {
  return function(F) {
    var witherF = W2.wither(F);
    return function(predicate) {
      return function(ga) {
        return witherF(ga, function(a2) {
          return F.map(predicate(a2), function(b2) {
            return b2 ? some(a2) : none;
          });
        });
      };
    };
  };
}

// node_modules/fp-ts/es6/Zero.js
function guard(F, P2) {
  return function(b2) {
    return b2 ? P2.of(void 0) : F.zero();
  };
}

// node_modules/fp-ts/es6/ReadonlyArray.js
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty4 = isNonEmpty2;
var matchW = function(onEmpty, onNonEmpty) {
  return function(as) {
    return isNonEmpty4(as) ? onNonEmpty(as) : onEmpty();
  };
};
var match = matchW;
var isOutOfBound3 = isOutOfBound;
function lookup(i2, as) {
  return as === void 0 ? function(as2) {
    return lookup(i2, as2);
  } : isOutOfBound3(i2, as) ? none : some(as[i2]);
}
var head4 = function(as) {
  return isNonEmpty4(as) ? some(head2(as)) : none;
};
var last3 = function(as) {
  return isNonEmpty4(as) ? some(last(as)) : none;
};
var findIndex = function(predicate) {
  return function(as) {
    for (var i2 = 0; i2 < as.length; i2++) {
      if (predicate(as[i2])) {
        return some(i2);
      }
    }
    return none;
  };
};
function findFirst(predicate) {
  return function(as) {
    for (var i2 = 0; i2 < as.length; i2++) {
      if (predicate(as[i2])) {
        return some(as[i2]);
      }
    }
    return none;
  };
}
var findFirstMap = function(f2) {
  return function(as) {
    for (var i2 = 0; i2 < as.length; i2++) {
      var out = f2(as[i2]);
      if (isSome(out)) {
        return out;
      }
    }
    return none;
  };
};
function findLast(predicate) {
  return function(as) {
    for (var i2 = as.length - 1; i2 >= 0; i2--) {
      if (predicate(as[i2])) {
        return some(as[i2]);
      }
    }
    return none;
  };
}
var findLastMap = function(f2) {
  return function(as) {
    for (var i2 = as.length - 1; i2 >= 0; i2--) {
      var out = f2(as[i2]);
      if (isSome(out)) {
        return out;
      }
    }
    return none;
  };
};
var findLastIndex = function(predicate) {
  return function(as) {
    for (var i2 = as.length - 1; i2 >= 0; i2--) {
      if (predicate(as[i2])) {
        return some(i2);
      }
    }
    return none;
  };
};
function elem(E2) {
  return function(a2, as) {
    if (as === void 0) {
      var elemE_1 = elem(E2);
      return function(as2) {
        return elemE_1(a2, as2);
      };
    }
    var predicate = function(element2) {
      return E2.equals(element2, a2);
    };
    var i2 = 0;
    for (; i2 < as.length; i2++) {
      if (predicate(as[i2])) {
        return true;
      }
    }
    return false;
  };
}
var _chainRecDepthFirst = function(a2, f2) {
  return pipe(a2, chainRecDepthFirst(f2));
};
var _chainRecBreadthFirst = function(a2, f2) {
  return pipe(a2, chainRecBreadthFirst(f2));
};
var foldMapWithIndex2 = function(M2) {
  return function(f2) {
    return function(fa) {
      return fa.reduce(function(b2, a2, i2) {
        return M2.concat(b2, f2(i2, a2));
      }, M2.empty);
    };
  };
};
var reduce2 = function(b2, f2) {
  return reduceWithIndex2(b2, function(_24, b3, a2) {
    return f2(b3, a2);
  });
};
var foldMap2 = function(M2) {
  var foldMapWithIndexM = foldMapWithIndex2(M2);
  return function(f2) {
    return foldMapWithIndexM(function(_24, a2) {
      return f2(a2);
    });
  };
};
var reduceWithIndex2 = function(b2, f2) {
  return function(fa) {
    var len = fa.length;
    var out = b2;
    for (var i2 = 0; i2 < len; i2++) {
      out = f2(i2, out, fa[i2]);
    }
    return out;
  };
};
var reduceRight2 = function(b2, f2) {
  return reduceRightWithIndex2(b2, function(_24, a2, b3) {
    return f2(a2, b3);
  });
};
var reduceRightWithIndex2 = function(b2, f2) {
  return function(fa) {
    return fa.reduceRight(function(b3, a2, i2) {
      return f2(i2, a2, b3);
    }, b2);
  };
};
var getShow2 = function(S2) {
  return {
    show: function(as) {
      return "[".concat(as.map(S2.show).join(", "), "]");
    }
  };
};
var getEq2 = function(E2) {
  return fromEquals(function(xs, ys) {
    return xs.length === ys.length && xs.every(function(x2, i2) {
      return E2.equals(x2, ys[i2]);
    });
  });
};
var getOrd = function(O2) {
  return fromCompare(function(a2, b2) {
    var aLen = a2.length;
    var bLen = b2.length;
    var len = Math.min(aLen, bLen);
    for (var i2 = 0; i2 < len; i2++) {
      var ordering = O2.compare(a2[i2], b2[i2]);
      if (ordering !== 0) {
        return ordering;
      }
    }
    return Ord.compare(aLen, bLen);
  });
};
var chainRecDepthFirst = function(f2) {
  return function(a2) {
    var todo = __spreadArray4([], f2(a2), true);
    var out = [];
    while (todo.length > 0) {
      var e = todo.shift();
      if (isLeft(e)) {
        todo.unshift.apply(todo, f2(e.left));
      } else {
        out.push(e.right);
      }
    }
    return out;
  };
};
var chainRecBreadthFirst = function(f2) {
  return function(a2) {
    var initial = f2(a2);
    var todo = [];
    var out = [];
    function go(e2) {
      if (isLeft(e2)) {
        f2(e2.left).forEach(function(v2) {
          return todo.push(v2);
        });
      } else {
        out.push(e2.right);
      }
    }
    for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
      var e = initial_1[_i];
      go(e);
    }
    while (todo.length > 0) {
      go(todo.shift());
    }
    return out;
  };
};
function every(predicate) {
  return function(as) {
    return as.every(predicate);
  };
}
var intercalate2 = function(M2) {
  var intercalateM = intercalate(M2);
  return function(middle) {
    return match(function() {
      return M2.empty;
    }, intercalateM(middle));
  };
};

// node_modules/fp-ts/es6/Array.js
var isEmpty = function(as) {
  return as.length === 0;
};
var isNonEmpty5 = isNonEmpty3;
var prepend3 = prepend2;
var prependW3 = prependW2;
var append3 = append;
var appendW3 = appendW;
var makeBy3 = function(n2, f2) {
  return n2 <= 0 ? [] : makeBy(f2)(n2);
};
var replicate = function(n2, a2) {
  return makeBy3(n2, function() {
    return a2;
  });
};
function fromPredicate2(predicate) {
  return function(a2) {
    return predicate(a2) ? [a2] : [];
  };
}
var fromOption2 = function(ma) {
  return isNone(ma) ? [] : [ma.value];
};
var fromEither = function(e) {
  return isLeft(e) ? [] : [e.right];
};
var matchW2 = function(onEmpty, onNonEmpty) {
  return function(as) {
    return isNonEmpty5(as) ? onNonEmpty(as) : onEmpty();
  };
};
var match2 = matchW2;
var matchLeftW = function(onEmpty, onNonEmpty) {
  return function(as) {
    return isNonEmpty5(as) ? onNonEmpty(head3(as), tail3(as)) : onEmpty();
  };
};
var matchLeft = matchLeftW;
var foldLeft = matchLeft;
var matchRightW = function(onEmpty, onNonEmpty) {
  return function(as) {
    return isNonEmpty5(as) ? onNonEmpty(init(as), last2(as)) : onEmpty();
  };
};
var matchRight = matchRightW;
var foldRight = matchRight;
var chainWithIndex = function(f2) {
  return function(as) {
    var out = [];
    for (var i2 = 0; i2 < as.length; i2++) {
      out.push.apply(out, f2(i2, as[i2]));
    }
    return out;
  };
};
var scanLeft = function(b2, f2) {
  return function(as) {
    var len = as.length;
    var out = new Array(len + 1);
    out[0] = b2;
    for (var i2 = 0; i2 < len; i2++) {
      out[i2 + 1] = f2(out[i2], as[i2]);
    }
    return out;
  };
};
var scanRight = function(b2, f2) {
  return function(as) {
    var len = as.length;
    var out = new Array(len + 1);
    out[len] = b2;
    for (var i2 = len - 1; i2 >= 0; i2--) {
      out[i2] = f2(as[i2], out[i2 + 1]);
    }
    return out;
  };
};
var size = function(as) {
  return as.length;
};
var isOutOfBound4 = isOutOfBound2;
var lookup2 = lookup;
var head5 = head4;
var last4 = last3;
var tail4 = function(as) {
  return isNonEmpty5(as) ? some(tail3(as)) : none;
};
var init3 = function(as) {
  return isNonEmpty5(as) ? some(init(as)) : none;
};
var takeLeft = function(n2) {
  return function(as) {
    return isOutOfBound4(n2, as) ? copy2(as) : as.slice(0, n2);
  };
};
var takeRight = function(n2) {
  return function(as) {
    return isOutOfBound4(n2, as) ? copy2(as) : n2 === 0 ? [] : as.slice(-n2);
  };
};
function takeLeftWhile(predicate) {
  return function(as) {
    var out = [];
    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
      var a2 = as_1[_i];
      if (!predicate(a2)) {
        break;
      }
      out.push(a2);
    }
    return out;
  };
}
var spanLeftIndex = function(as, predicate) {
  var l2 = as.length;
  var i2 = 0;
  for (; i2 < l2; i2++) {
    if (!predicate(as[i2])) {
      break;
    }
  }
  return i2;
};
function spanLeft(predicate) {
  return function(as) {
    var _a = splitAt3(spanLeftIndex(as, predicate))(as), init6 = _a[0], rest = _a[1];
    return { init: init6, rest };
  };
}
var dropLeft = function(n2) {
  return function(as) {
    return n2 <= 0 || isEmpty(as) ? copy2(as) : n2 >= as.length ? [] : as.slice(n2, as.length);
  };
};
var dropRight = function(n2) {
  return function(as) {
    return n2 <= 0 || isEmpty(as) ? copy2(as) : n2 >= as.length ? [] : as.slice(0, as.length - n2);
  };
};
function dropLeftWhile(predicate) {
  return function(as) {
    return as.slice(spanLeftIndex(as, predicate));
  };
}
var findIndex2 = findIndex;
function findFirst2(predicate) {
  return findFirst(predicate);
}
var findFirstMap2 = findFirstMap;
function findLast2(predicate) {
  return findLast(predicate);
}
var findLastMap2 = findLastMap;
var findLastIndex2 = findLastIndex;
var copy2 = function(as) {
  return as.slice();
};
var insertAt = function(i2, a2) {
  return function(as) {
    return i2 < 0 || i2 > as.length ? none : some(unsafeInsertAt3(i2, a2, as));
  };
};
var updateAt = function(i2, a2) {
  return modifyAt(i2, function() {
    return a2;
  });
};
var deleteAt = function(i2) {
  return function(as) {
    return isOutOfBound4(i2, as) ? none : some(unsafeDeleteAt(i2, as));
  };
};
var modifyAt = function(i2, f2) {
  return function(as) {
    return isOutOfBound4(i2, as) ? none : some(unsafeUpdateAt3(i2, f2(as[i2]), as));
  };
};
var reverse = function(as) {
  return isEmpty(as) ? [] : as.slice().reverse();
};
var rights = function(as) {
  var r2 = [];
  for (var i2 = 0; i2 < as.length; i2++) {
    var a2 = as[i2];
    if (a2._tag === "Right") {
      r2.push(a2.right);
    }
  }
  return r2;
};
var lefts = function(as) {
  var r2 = [];
  for (var i2 = 0; i2 < as.length; i2++) {
    var a2 = as[i2];
    if (a2._tag === "Left") {
      r2.push(a2.left);
    }
  }
  return r2;
};
var sort2 = function(O2) {
  return function(as) {
    return as.length <= 1 ? copy2(as) : as.slice().sort(O2.compare);
  };
};
var zipWith = function(fa, fb, f2) {
  var fc = [];
  var len = Math.min(fa.length, fb.length);
  for (var i2 = 0; i2 < len; i2++) {
    fc[i2] = f2(fa[i2], fb[i2]);
  }
  return fc;
};
function zip(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip(bs2, as);
    };
  }
  return zipWith(as, bs, function(a2, b2) {
    return [a2, b2];
  });
}
var unzip = function(as) {
  var fa = [];
  var fb = [];
  for (var i2 = 0; i2 < as.length; i2++) {
    fa[i2] = as[i2][0];
    fb[i2] = as[i2][1];
  }
  return [fa, fb];
};
var prependAll3 = function(middle) {
  var f2 = prependAll2(middle);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : [];
  };
};
var intersperse3 = function(middle) {
  var f2 = intersperse2(middle);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : copy2(as);
  };
};
var rotate3 = function(n2) {
  var f2 = rotate(n2);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : copy2(as);
  };
};
var elem2 = elem;
var uniq3 = function(E2) {
  var f2 = uniq(E2);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : copy2(as);
  };
};
var sortBy3 = function(ords) {
  var f2 = sortBy(ords);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : copy2(as);
  };
};
var chop3 = function(f2) {
  var g2 = chop(f2);
  return function(as) {
    return isNonEmpty5(as) ? g2(as) : [];
  };
};
var splitAt3 = function(n2) {
  return function(as) {
    return n2 >= 1 && isNonEmpty5(as) ? splitAt(n2)(as) : isEmpty(as) ? [copy2(as), []] : [[], copy2(as)];
  };
};
var chunksOf3 = function(n2) {
  var f2 = chunksOf(n2);
  return function(as) {
    return isNonEmpty5(as) ? f2(as) : [];
  };
};
var fromOptionK2 = function(f2) {
  return function() {
    var a2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a2[_i] = arguments[_i];
    }
    return fromOption2(f2.apply(void 0, a2));
  };
};
function comprehension(input, f2, g2) {
  if (g2 === void 0) {
    g2 = function() {
      return true;
    };
  }
  var go = function(scope, input2) {
    return isNonEmpty5(input2) ? pipe(head3(input2), chain(function(x2) {
      return go(pipe(scope, append3(x2)), tail3(input2));
    })) : g2.apply(void 0, scope) ? [f2.apply(void 0, scope)] : [];
  };
  return go([], input);
}
var concatW = function(second) {
  return function(first) {
    return isEmpty(first) ? copy2(second) : isEmpty(second) ? copy2(first) : first.concat(second);
  };
};
var concat2 = concatW;
function union3(E2) {
  var unionE = union(E2);
  return function(first, second) {
    if (second === void 0) {
      var unionE_1 = union3(E2);
      return function(second2) {
        return unionE_1(second2, first);
      };
    }
    return isNonEmpty5(first) && isNonEmpty5(second) ? unionE(second)(first) : isNonEmpty5(first) ? copy2(first) : copy2(second);
  };
}
function intersection(E2) {
  var elemE = elem2(E2);
  return function(xs, ys) {
    if (ys === void 0) {
      var intersectionE_1 = intersection(E2);
      return function(ys2) {
        return intersectionE_1(ys2, xs);
      };
    }
    return xs.filter(function(a2) {
      return elemE(a2, ys);
    });
  };
}
function difference(E2) {
  var elemE = elem2(E2);
  return function(xs, ys) {
    if (ys === void 0) {
      var differenceE_1 = difference(E2);
      return function(ys2) {
        return differenceE_1(ys2, xs);
      };
    }
    return xs.filter(function(a2) {
      return !elemE(a2, ys);
    });
  };
}
var _map = function(fa, f2) {
  return pipe(fa, map2(f2));
};
var _mapWithIndex = function(fa, f2) {
  return pipe(fa, mapWithIndex(f2));
};
var _ap = function(fab, fa) {
  return pipe(fab, ap2(fa));
};
var _chain = function(ma, f2) {
  return pipe(ma, chain(f2));
};
var _filter = function(fa, predicate) {
  return pipe(fa, filter(predicate));
};
var _filterMap = function(fa, f2) {
  return pipe(fa, filterMap(f2));
};
var _partition = function(fa, predicate) {
  return pipe(fa, partition(predicate));
};
var _partitionMap = function(fa, f2) {
  return pipe(fa, partitionMap(f2));
};
var _partitionWithIndex = function(fa, predicateWithIndex) {
  return pipe(fa, partitionWithIndex(predicateWithIndex));
};
var _partitionMapWithIndex = function(fa, f2) {
  return pipe(fa, partitionMapWithIndex(f2));
};
var _alt = function(fa, that) {
  return pipe(fa, alt(that));
};
var _reduce = function(fa, b2, f2) {
  return pipe(fa, reduce3(b2, f2));
};
var _foldMap = function(M2) {
  var foldMapM = foldMap3(M2);
  return function(fa, f2) {
    return pipe(fa, foldMapM(f2));
  };
};
var _reduceRight = function(fa, b2, f2) {
  return pipe(fa, reduceRight3(b2, f2));
};
var _reduceWithIndex = function(fa, b2, f2) {
  return pipe(fa, reduceWithIndex3(b2, f2));
};
var _foldMapWithIndex = function(M2) {
  var foldMapWithIndexM = foldMapWithIndex3(M2);
  return function(fa, f2) {
    return pipe(fa, foldMapWithIndexM(f2));
  };
};
var _reduceRightWithIndex = function(fa, b2, f2) {
  return pipe(fa, reduceRightWithIndex3(b2, f2));
};
var _filterMapWithIndex = function(fa, f2) {
  return pipe(fa, filterMapWithIndex(f2));
};
var _filterWithIndex = function(fa, predicateWithIndex) {
  return pipe(fa, filterWithIndex(predicateWithIndex));
};
var _extend = function(fa, f2) {
  return pipe(fa, extend(f2));
};
var _traverse = function(F) {
  var traverseF = traverse(F);
  return function(ta, f2) {
    return pipe(ta, traverseF(f2));
  };
};
var _traverseWithIndex = function(F) {
  var traverseWithIndexF = traverseWithIndex(F);
  return function(ta, f2) {
    return pipe(ta, traverseWithIndexF(f2));
  };
};
var _chainRecDepthFirst2 = _chainRecDepthFirst;
var _chainRecBreadthFirst2 = _chainRecBreadthFirst;
var of3 = of;
var zero = function() {
  return [];
};
var map2 = function(f2) {
  return function(fa) {
    return fa.map(function(a2) {
      return f2(a2);
    });
  };
};
var ap2 = function(fa) {
  return chain(function(f2) {
    return pipe(fa, map2(f2));
  });
};
var chain = function(f2) {
  return function(ma) {
    return pipe(ma, chainWithIndex(function(_24, a2) {
      return f2(a2);
    }));
  };
};
var flatten = /* @__PURE__ */ chain(identity);
var mapWithIndex = function(f2) {
  return function(fa) {
    return fa.map(function(a2, i2) {
      return f2(i2, a2);
    });
  };
};
var filterMapWithIndex = function(f2) {
  return function(fa) {
    var out = [];
    for (var i2 = 0; i2 < fa.length; i2++) {
      var optionB = f2(i2, fa[i2]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap = function(f2) {
  return filterMapWithIndex(function(_24, a2) {
    return f2(a2);
  });
};
var compact = /* @__PURE__ */ filterMap(identity);
var separate = function(fa) {
  var left6 = [];
  var right6 = [];
  for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
    var e = fa_1[_i];
    if (e._tag === "Left") {
      left6.push(e.left);
    } else {
      right6.push(e.right);
    }
  }
  return separated(left6, right6);
};
var filter = function(predicate) {
  return function(as) {
    return as.filter(predicate);
  };
};
var partition = function(predicate) {
  return partitionWithIndex(function(_24, a2) {
    return predicate(a2);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as) {
    var left6 = [];
    var right6 = [];
    for (var i2 = 0; i2 < as.length; i2++) {
      var b2 = as[i2];
      if (predicateWithIndex(i2, b2)) {
        right6.push(b2);
      } else {
        left6.push(b2);
      }
    }
    return separated(left6, right6);
  };
};
var partitionMap = function(f2) {
  return partitionMapWithIndex(function(_24, a2) {
    return f2(a2);
  });
};
var partitionMapWithIndex = function(f2) {
  return function(fa) {
    var left6 = [];
    var right6 = [];
    for (var i2 = 0; i2 < fa.length; i2++) {
      var e = f2(i2, fa[i2]);
      if (e._tag === "Left") {
        left6.push(e.left);
      } else {
        right6.push(e.right);
      }
    }
    return separated(left6, right6);
  };
};
var altW = function(that) {
  return function(fa) {
    return fa.concat(that());
  };
};
var alt = altW;
var filterWithIndex = function(predicateWithIndex) {
  return function(as) {
    return as.filter(function(b2, i2) {
      return predicateWithIndex(i2, b2);
    });
  };
};
var extend = function(f2) {
  return function(wa) {
    return wa.map(function(_24, i2) {
      return f2(wa.slice(i2));
    });
  };
};
var duplicate = /* @__PURE__ */ extend(identity);
var foldMap3 = foldMap2;
var foldMapWithIndex3 = foldMapWithIndex2;
var reduce3 = reduce2;
var reduceWithIndex3 = reduceWithIndex2;
var reduceRight3 = reduceRight2;
var reduceRightWithIndex3 = reduceRightWithIndex2;
var traverse = function(F) {
  var traverseWithIndexF = traverseWithIndex(F);
  return function(f2) {
    return traverseWithIndexF(function(_24, a2) {
      return f2(a2);
    });
  };
};
var sequence = function(F) {
  return function(ta) {
    return _reduce(ta, F.of(zero()), function(fas, fa) {
      return F.ap(F.map(fas, function(as) {
        return function(a2) {
          return pipe(as, append3(a2));
        };
      }), fa);
    });
  };
};
var traverseWithIndex = function(F) {
  return function(f2) {
    return reduceWithIndex3(F.of(zero()), function(i2, fbs, a2) {
      return F.ap(F.map(fbs, function(bs) {
        return function(b2) {
          return pipe(bs, append3(b2));
        };
      }), f2(i2, a2));
    });
  };
};
var wither = function(F) {
  var _witherF = _wither(F);
  return function(f2) {
    return function(fa) {
      return _witherF(fa, f2);
    };
  };
};
var wilt = function(F) {
  var _wiltF = _wilt(F);
  return function(f2) {
    return function(fa) {
      return _wiltF(fa, f2);
    };
  };
};
var unfold = function(b2, f2) {
  var out = [];
  var bb = b2;
  while (true) {
    var mt = f2(bb);
    if (isSome(mt)) {
      var _a = mt.value, a2 = _a[0], b_1 = _a[1];
      out.push(a2);
      bb = b_1;
    } else {
      break;
    }
  }
  return out;
};
var URI = "Array";
var getShow3 = getShow2;
var getSemigroup3 = function() {
  return {
    concat: function(first, second) {
      return first.concat(second);
    }
  };
};
var getMonoid3 = function() {
  return {
    concat: getSemigroup3().concat,
    empty: []
  };
};
var getEq3 = getEq2;
var getOrd2 = getOrd;
var getUnionSemigroup = function(E2) {
  var unionE = union3(E2);
  return {
    concat: function(first, second) {
      return unionE(second)(first);
    }
  };
};
var getUnionMonoid = function(E2) {
  return {
    concat: getUnionSemigroup(E2).concat,
    empty: []
  };
};
var getIntersectionSemigroup = function(E2) {
  var intersectionE = intersection(E2);
  return {
    concat: function(first, second) {
      return intersectionE(second)(first);
    }
  };
};
var getDifferenceMagma = function(E2) {
  var differenceE = difference(E2);
  return {
    concat: function(first, second) {
      return differenceE(second)(first);
    }
  };
};
var Functor = {
  URI,
  map: _map
};
var flap2 = /* @__PURE__ */ flap(Functor);
var Pointed = {
  URI,
  of: of3
};
var FunctorWithIndex = {
  URI,
  map: _map,
  mapWithIndex: _mapWithIndex
};
var Apply = {
  URI,
  map: _map,
  ap: _ap
};
var apFirst2 = /* @__PURE__ */ apFirst(Apply);
var apSecond2 = /* @__PURE__ */ apSecond(Apply);
var Applicative = {
  URI,
  map: _map,
  ap: _ap,
  of: of3
};
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: _chain
};
var chainFirst2 = /* @__PURE__ */ chainFirst(Chain);
var Monad = {
  URI,
  map: _map,
  ap: _ap,
  of: of3,
  chain: _chain
};
var Unfoldable = {
  URI,
  unfold
};
var Alt = {
  URI,
  map: _map,
  alt: _alt
};
var Zero = {
  URI,
  zero
};
var guard2 = /* @__PURE__ */ guard(Zero, Pointed);
var Alternative = {
  URI,
  map: _map,
  ap: _ap,
  of: of3,
  alt: _alt,
  zero
};
var Extend = {
  URI,
  map: _map,
  extend: _extend
};
var Compactable = {
  URI,
  compact,
  separate
};
var Filterable = {
  URI,
  map: _map,
  compact,
  separate,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap
};
var FilterableWithIndex = {
  URI,
  map: _map,
  mapWithIndex: _mapWithIndex,
  compact,
  separate,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap,
  partitionMapWithIndex: _partitionMapWithIndex,
  partitionWithIndex: _partitionWithIndex,
  filterMapWithIndex: _filterMapWithIndex,
  filterWithIndex: _filterWithIndex
};
var Foldable = {
  URI,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight
};
var FoldableWithIndex = {
  URI,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  reduceWithIndex: _reduceWithIndex,
  foldMapWithIndex: _foldMapWithIndex,
  reduceRightWithIndex: _reduceRightWithIndex
};
var Traversable = {
  URI,
  map: _map,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence
};
var TraversableWithIndex = {
  URI,
  map: _map,
  mapWithIndex: _mapWithIndex,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  reduceWithIndex: _reduceWithIndex,
  foldMapWithIndex: _foldMapWithIndex,
  reduceRightWithIndex: _reduceRightWithIndex,
  traverse: _traverse,
  sequence,
  traverseWithIndex: _traverseWithIndex
};
var _wither = /* @__PURE__ */ witherDefault(Traversable, Compactable);
var _wilt = /* @__PURE__ */ wiltDefault(Traversable, Compactable);
var Witherable = {
  URI,
  map: _map,
  compact,
  separate,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence,
  wither: _wither,
  wilt: _wilt
};
var chainRecDepthFirst2 = chainRecDepthFirst;
var ChainRecDepthFirst = {
  URI,
  map: _map,
  ap: _ap,
  chain: _chain,
  chainRec: _chainRecDepthFirst2
};
var chainRecBreadthFirst2 = chainRecBreadthFirst;
var ChainRecBreadthFirst = {
  URI,
  map: _map,
  ap: _ap,
  chain: _chain,
  chainRec: _chainRecBreadthFirst2
};
var filterE2 = /* @__PURE__ */ filterE(Witherable);
var FromEither = {
  URI,
  fromEither
};
var fromEitherK2 = /* @__PURE__ */ fromEitherK(FromEither);
var unsafeInsertAt3 = unsafeInsertAt;
var unsafeUpdateAt3 = function(i2, a2, as) {
  return isNonEmpty5(as) ? unsafeUpdateAt(i2, a2, as) : [];
};
var unsafeDeleteAt = function(i2, as) {
  var xs = as.slice();
  xs.splice(i2, 1);
  return xs;
};
var every2 = every;
var some2 = function(predicate) {
  return function(as) {
    return as.some(predicate);
  };
};
var exists = some2;
var intercalate3 = intercalate2;
var Do = /* @__PURE__ */ of3(emptyRecord);
var bindTo2 = /* @__PURE__ */ bindTo(Functor);
var let_2 = /* @__PURE__ */ let_(Functor);
var bind2 = /* @__PURE__ */ bind(Chain);
var apS2 = /* @__PURE__ */ apS(Apply);
var range3 = range;
var empty2 = [];
var cons3 = cons;
var snoc3 = snoc;
var prependToAll = prependAll3;
var array = {
  URI,
  compact,
  separate,
  map: _map,
  ap: _ap,
  of: of3,
  chain: _chain,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap,
  mapWithIndex: _mapWithIndex,
  partitionMapWithIndex: _partitionMapWithIndex,
  partitionWithIndex: _partitionWithIndex,
  filterMapWithIndex: _filterMapWithIndex,
  filterWithIndex: _filterWithIndex,
  alt: _alt,
  zero,
  unfold,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence,
  reduceWithIndex: _reduceWithIndex,
  foldMapWithIndex: _foldMapWithIndex,
  reduceRightWithIndex: _reduceRightWithIndex,
  traverseWithIndex: _traverseWithIndex,
  extend: _extend,
  wither: _wither,
  wilt: _wilt
};

// node_modules/fp-ts/es6/ChainRec.js
var tailRec = function(startWith, f2) {
  var ab = f2(startWith);
  while (ab._tag === "Left") {
    ab = f2(ab.left);
  }
  return ab.right;
};

// node_modules/fp-ts/es6/Predicate.js
var not2 = function(predicate) {
  return function(a2) {
    return !predicate(a2);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some3 = some;
var getLeft = function(ma) {
  return ma._tag === "Right" ? none2 : some3(ma.left);
};
var getRight = function(ma) {
  return ma._tag === "Left" ? none2 : some3(ma.right);
};

// node_modules/fp-ts/es6/Compactable.js
function compact2(F, G2) {
  return function(fga) {
    return F.map(fga, G2.compact);
  };
}
function separate2(F, C, G2) {
  var _compact = compact2(F, C);
  var _map5 = map(F, G2);
  return function(fge) {
    return separated(_compact(pipe(fge, _map5(getLeft))), _compact(pipe(fge, _map5(getRight))));
  };
}

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt2,
  ApT: () => ApT,
  Applicative: () => Applicative2,
  Apply: () => Apply2,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain2,
  ChainRec: () => ChainRec,
  Do: () => Do2,
  Extend: () => Extend2,
  Foldable: () => Foldable2,
  FromEither: () => FromEither2,
  Functor: () => Functor2,
  Monad: () => Monad2,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed2,
  Traversable: () => Traversable2,
  URI: () => URI2,
  alt: () => alt2,
  altW: () => altW2,
  ap: () => ap3,
  apFirst: () => apFirst3,
  apFirstW: () => apFirstW,
  apS: () => apS3,
  apSW: () => apSW,
  apSecond: () => apSecond3,
  apSecondW: () => apSecondW,
  apW: () => apW,
  bimap: () => bimap,
  bind: () => bind3,
  bindTo: () => bindTo3,
  bindW: () => bindW,
  chain: () => chain2,
  chainFirst: () => chainFirst3,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainOptionKW: () => chainOptionKW,
  chainW: () => chainW,
  duplicate: () => duplicate2,
  either: () => either,
  elem: () => elem3,
  exists: () => exists2,
  extend: () => extend2,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap3,
  flatten: () => flatten2,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap4,
  foldW: () => foldW,
  fromNullable: () => fromNullable,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption3,
  fromOptionK: () => fromOptionK3,
  fromPredicate: () => fromPredicate3,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid,
  getApplySemigroup: () => getApplySemigroup2,
  getCompactable: () => getCompactable,
  getEq: () => getEq4,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup4,
  getShow: () => getShow4,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left2,
  let: () => let_3,
  map: () => map3,
  mapLeft: () => mapLeft,
  match: () => match3,
  matchW: () => matchW3,
  of: () => of4,
  orElse: () => orElse,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce4,
  reduceRight: () => reduceRight4,
  right: () => right2,
  sequence: () => sequence2,
  sequenceArray: () => sequenceArray,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse2,
  traverseArray: () => traverseArray,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
var left2 = left;
var right2 = right;
var _map2 = function(fa, f2) {
  return pipe(fa, map3(f2));
};
var _ap2 = function(fab, fa) {
  return pipe(fab, ap3(fa));
};
var _chain2 = function(ma, f2) {
  return pipe(ma, chain2(f2));
};
var _reduce2 = function(fa, b2, f2) {
  return pipe(fa, reduce4(b2, f2));
};
var _foldMap2 = function(M2) {
  return function(fa, f2) {
    var foldMapM = foldMap4(M2);
    return pipe(fa, foldMapM(f2));
  };
};
var _reduceRight2 = function(fa, b2, f2) {
  return pipe(fa, reduceRight4(b2, f2));
};
var _traverse2 = function(F) {
  var traverseF = traverse2(F);
  return function(ta, f2) {
    return pipe(ta, traverseF(f2));
  };
};
var _bimap = function(fa, f2, g2) {
  return pipe(fa, bimap(f2, g2));
};
var _mapLeft = function(fa, f2) {
  return pipe(fa, mapLeft(f2));
};
var _alt2 = function(fa, that) {
  return pipe(fa, alt2(that));
};
var _extend2 = function(wa, f2) {
  return pipe(wa, extend2(f2));
};
var _chainRec = function(a2, f2) {
  return tailRec(f2(a2), function(e) {
    return isLeft2(e) ? right2(left2(e.left)) : isLeft2(e.right) ? left2(f2(e.right.left)) : right2(right2(e.right.right));
  });
};
var URI2 = "Either";
var getShow4 = function(SE, SA) {
  return {
    show: function(ma) {
      return isLeft2(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
    }
  };
};
var getEq4 = function(EL, EA) {
  return {
    equals: function(x2, y2) {
      return x2 === y2 || (isLeft2(x2) ? isLeft2(y2) && EL.equals(x2.left, y2.left) : isRight2(y2) && EA.equals(x2.right, y2.right));
    }
  };
};
var getSemigroup4 = function(S2) {
  return {
    concat: function(x2, y2) {
      return isLeft2(y2) ? x2 : isLeft2(x2) ? y2 : right2(S2.concat(x2.right, y2.right));
    }
  };
};
var getCompactable = function(M2) {
  var empty4 = left2(M2.empty);
  return {
    URI: URI2,
    _E: void 0,
    compact: function(ma) {
      return isLeft2(ma) ? ma : ma.right._tag === "None" ? empty4 : right2(ma.right.value);
    },
    separate: function(ma) {
      return isLeft2(ma) ? separated(ma, ma) : isLeft2(ma.right) ? separated(right2(ma.right.left), empty4) : separated(empty4, right2(ma.right.right));
    }
  };
};
var getFilterable = function(M2) {
  var empty4 = left2(M2.empty);
  var _a = getCompactable(M2), compact3 = _a.compact, separate3 = _a.separate;
  var filter3 = function(ma, predicate) {
    return isLeft2(ma) ? ma : predicate(ma.right) ? ma : empty4;
  };
  var partition3 = function(ma, p2) {
    return isLeft2(ma) ? separated(ma, ma) : p2(ma.right) ? separated(empty4, right2(ma.right)) : separated(right2(ma.right), empty4);
  };
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    compact: compact3,
    separate: separate3,
    filter: filter3,
    filterMap: function(ma, f2) {
      if (isLeft2(ma)) {
        return ma;
      }
      var ob = f2(ma.right);
      return ob._tag === "None" ? empty4 : right2(ob.value);
    },
    partition: partition3,
    partitionMap: function(ma, f2) {
      if (isLeft2(ma)) {
        return separated(ma, ma);
      }
      var e = f2(ma.right);
      return isLeft2(e) ? separated(right2(e.left), empty4) : separated(empty4, right2(e.right));
    }
  };
};
var getWitherable = function(M2) {
  var F_ = getFilterable(M2);
  var C = getCompactable(M2);
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    compact: F_.compact,
    separate: F_.separate,
    filter: F_.filter,
    filterMap: F_.filterMap,
    partition: F_.partition,
    partitionMap: F_.partitionMap,
    traverse: _traverse2,
    sequence: sequence2,
    reduce: _reduce2,
    foldMap: _foldMap2,
    reduceRight: _reduceRight2,
    wither: witherDefault(Traversable2, C),
    wilt: wiltDefault(Traversable2, C)
  };
};
var getApplicativeValidation = function(SE) {
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    ap: function(fab, fa) {
      return isLeft2(fab) ? isLeft2(fa) ? left2(SE.concat(fab.left, fa.left)) : fab : isLeft2(fa) ? fa : right2(fab.right(fa.right));
    },
    of: of4
  };
};
var getAltValidation = function(SE) {
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    alt: function(me, that) {
      if (isRight2(me)) {
        return me;
      }
      var ea = that();
      return isLeft2(ea) ? left2(SE.concat(me.left, ea.left)) : ea;
    }
  };
};
var map3 = function(f2) {
  return function(fa) {
    return isLeft2(fa) ? fa : right2(f2(fa.right));
  };
};
var Functor2 = {
  URI: URI2,
  map: _map2
};
var of4 = right2;
var Pointed2 = {
  URI: URI2,
  of: of4
};
var apW = function(fa) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right2(fab.right(fa.right));
  };
};
var ap3 = apW;
var Apply2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2
};
var Applicative2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  of: of4
};
var chainW = function(f2) {
  return function(ma) {
    return isLeft2(ma) ? ma : f2(ma.right);
  };
};
var chain2 = chainW;
var Chain2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  chain: _chain2
};
var Monad2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  of: of4,
  chain: _chain2
};
var reduce4 = function(b2, f2) {
  return function(fa) {
    return isLeft2(fa) ? b2 : f2(b2, fa.right);
  };
};
var foldMap4 = function(M2) {
  return function(f2) {
    return function(fa) {
      return isLeft2(fa) ? M2.empty : f2(fa.right);
    };
  };
};
var reduceRight4 = function(b2, f2) {
  return function(fa) {
    return isLeft2(fa) ? b2 : f2(fa.right, b2);
  };
};
var Foldable2 = {
  URI: URI2,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2
};
var traverse2 = function(F) {
  return function(f2) {
    return function(ta) {
      return isLeft2(ta) ? F.of(left2(ta.left)) : F.map(f2(ta.right), right2);
    };
  };
};
var sequence2 = function(F) {
  return function(ma) {
    return isLeft2(ma) ? F.of(left2(ma.left)) : F.map(ma.right, right2);
  };
};
var Traversable2 = {
  URI: URI2,
  map: _map2,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2
};
var bimap = function(f2, g2) {
  return function(fa) {
    return isLeft2(fa) ? left2(f2(fa.left)) : right2(g2(fa.right));
  };
};
var mapLeft = function(f2) {
  return function(fa) {
    return isLeft2(fa) ? left2(f2(fa.left)) : fa;
  };
};
var Bifunctor = {
  URI: URI2,
  bimap: _bimap,
  mapLeft: _mapLeft
};
var altW2 = function(that) {
  return function(fa) {
    return isLeft2(fa) ? that() : fa;
  };
};
var alt2 = altW2;
var Alt2 = {
  URI: URI2,
  map: _map2,
  alt: _alt2
};
var extend2 = function(f2) {
  return function(wa) {
    return isLeft2(wa) ? wa : right2(f2(wa));
  };
};
var Extend2 = {
  URI: URI2,
  map: _map2,
  extend: _extend2
};
var ChainRec = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  chain: _chain2,
  chainRec: _chainRec
};
var throwError = left2;
var MonadThrow = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  of: of4,
  chain: _chain2,
  throwError
};
var FromEither2 = {
  URI: URI2,
  fromEither: identity
};
var fromPredicate3 = /* @__PURE__ */ fromPredicate(FromEither2);
var fromOption3 = /* @__PURE__ */ fromOption(FromEither2);
var isLeft2 = isLeft;
var isRight2 = isRight;
var matchW3 = function(onLeft, onRight) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
  };
};
var foldW = matchW3;
var match3 = matchW3;
var fold = match3;
var getOrElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma.right;
  };
};
var getOrElse = getOrElseW;
var flap3 = /* @__PURE__ */ flap(Functor2);
var apFirst3 = /* @__PURE__ */ apFirst(Apply2);
var apFirstW = apFirst3;
var apSecond3 = /* @__PURE__ */ apSecond(Apply2);
var apSecondW = apSecond3;
var chainFirst3 = /* @__PURE__ */ chainFirst(Chain2);
var chainFirstW = chainFirst3;
var flattenW = /* @__PURE__ */ chainW(identity);
var flatten2 = flattenW;
var duplicate2 = /* @__PURE__ */ extend2(identity);
var fromOptionK3 = /* @__PURE__ */ fromOptionK(FromEither2);
var chainOptionK2 = /* @__PURE__ */ chainOptionK(FromEither2, Chain2);
var chainOptionKW = chainOptionK2;
var filterOrElse2 = /* @__PURE__ */ filterOrElse(FromEither2, Chain2);
var filterOrElseW = filterOrElse2;
var swap = function(ma) {
  return isLeft2(ma) ? right2(ma.left) : left2(ma.right);
};
var orElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma;
  };
};
var orElse = orElseW;
var fromNullable = function(e) {
  return function(a2) {
    return a2 == null ? left2(e) : right2(a2);
  };
};
var tryCatch = function(f2, onThrow) {
  try {
    return right2(f2());
  } catch (e) {
    return left2(onThrow(e));
  }
};
var tryCatchK = function(f2, onThrow) {
  return function() {
    var a2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a2[_i] = arguments[_i];
    }
    return tryCatch(function() {
      return f2.apply(void 0, a2);
    }, onThrow);
  };
};
var fromNullableK = function(e) {
  var from = fromNullable(e);
  return function(f2) {
    return flow(f2, from);
  };
};
var chainNullableK = function(e) {
  var from = fromNullableK(e);
  return function(f2) {
    return chain2(from(f2));
  };
};
var toUnion = /* @__PURE__ */ foldW(identity, identity);
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function elem3(E2) {
  return function(a2, ma) {
    if (ma === void 0) {
      var elemE_1 = elem3(E2);
      return function(ma2) {
        return elemE_1(a2, ma2);
      };
    }
    return isLeft2(ma) ? false : E2.equals(a2, ma.right);
  };
}
var exists2 = function(predicate) {
  return function(ma) {
    return isLeft2(ma) ? false : predicate(ma.right);
  };
};
var Do2 = /* @__PURE__ */ of4(emptyRecord);
var bindTo3 = /* @__PURE__ */ bindTo(Functor2);
var let_3 = /* @__PURE__ */ let_(Functor2);
var bind3 = /* @__PURE__ */ bind(Chain2);
var bindW = bind3;
var apS3 = /* @__PURE__ */ apS(Apply2);
var apSW = apS3;
var ApT = /* @__PURE__ */ of4(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
  return function(as) {
    var e = f2(0, head(as));
    if (isLeft2(e)) {
      return e;
    }
    var out = [e.right];
    for (var i2 = 1; i2 < as.length; i2++) {
      var e_1 = f2(i2, as[i2]);
      if (isLeft2(e_1)) {
        return e_1;
      }
      out.push(e_1.right);
    }
    return right2(out);
  };
};
var traverseReadonlyArrayWithIndex = function(f2) {
  var g2 = traverseReadonlyNonEmptyArrayWithIndex(f2);
  return function(as) {
    return isNonEmpty(as) ? g2(as) : ApT;
  };
};
var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
var traverseArray = function(f2) {
  return traverseReadonlyArrayWithIndex(function(_24, a2) {
    return f2(a2);
  });
};
var sequenceArray = /* @__PURE__ */ traverseArray(identity);
function parseJSON(s2, onError) {
  return tryCatch(function() {
    return JSON.parse(s2);
  }, onError);
}
var stringifyJSON = function(u2, onError) {
  return tryCatch(function() {
    var s2 = JSON.stringify(u2);
    if (typeof s2 !== "string") {
      throw new Error("Converting unsupported structure to JSON");
    }
    return s2;
  }, onError);
};
var either = {
  URI: URI2,
  map: _map2,
  of: of4,
  ap: _ap2,
  chain: _chain2,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2,
  bimap: _bimap,
  mapLeft: _mapLeft,
  alt: _alt2,
  extend: _extend2,
  chainRec: _chainRec,
  throwError
};
var getApplySemigroup2 = /* @__PURE__ */ getApplySemigroup(Apply2);
var getApplyMonoid = /* @__PURE__ */ getApplicativeMonoid(Applicative2);
var getValidationSemigroup = function(SE, SA) {
  return getApplySemigroup(getApplicativeValidation(SE))(SA);
};
var getValidationMonoid = function(SE, MA) {
  return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
};
function getValidation(SE) {
  var ap7 = getApplicativeValidation(SE).ap;
  var alt5 = getAltValidation(SE).alt;
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    of: of4,
    chain: _chain2,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce2,
    foldMap: _foldMap2,
    reduceRight: _reduceRight2,
    extend: _extend2,
    traverse: _traverse2,
    sequence: sequence2,
    chainRec: _chainRec,
    throwError,
    ap: ap7,
    alt: alt5
  };
}

// node_modules/fp-ts/es6/EitherT.js
function right3(F) {
  return flow(right2, F.of);
}
function left3(F) {
  return flow(left2, F.of);
}
function rightF(F) {
  return function(fa) {
    return F.map(fa, right2);
  };
}
function leftF(F) {
  return function(fe) {
    return F.map(fe, left2);
  };
}
function fromNullable2(F) {
  return function(e) {
    return flow(fromNullable(e), F.of);
  };
}
function fromNullableK2(F) {
  var fromNullableF = fromNullable2(F);
  return function(e) {
    var fromNullableFE = fromNullableF(e);
    return function(f2) {
      return flow(f2, fromNullableFE);
    };
  };
}
function chainNullableK2(M2) {
  var chainM = chain3(M2);
  var fromNullableKM = fromNullableK2(M2);
  return function(e) {
    var fromNullableKMe = fromNullableKM(e);
    return function(f2) {
      return chainM(fromNullableKMe(f2));
    };
  };
}
function map4(F) {
  return map(F, Functor2);
}
function ap4(F) {
  return ap(F, Apply2);
}
function chain3(M2) {
  return function(f2) {
    return function(ma) {
      return M2.chain(ma, function(e) {
        return isLeft2(e) ? M2.of(e) : f2(e.right);
      });
    };
  };
}
function alt3(M2) {
  return function(second) {
    return function(first) {
      return M2.chain(first, function(e) {
        return isLeft2(e) ? second() : M2.of(e);
      });
    };
  };
}
function bimap2(F) {
  return function(f2, g2) {
    return function(fea) {
      return F.map(fea, bimap(f2, g2));
    };
  };
}
function mapLeft2(F) {
  return function(f2) {
    return function(fea) {
      return F.map(fea, mapLeft(f2));
    };
  };
}
function altValidation(M2, S2) {
  return function(second) {
    return function(first) {
      return M2.chain(first, match3(function(e1) {
        return M2.map(second(), mapLeft(function(e2) {
          return S2.concat(e1, e2);
        }));
      }, right3(M2)));
    };
  };
}
function match4(F) {
  return function(onLeft, onRight) {
    return function(ma) {
      return F.map(ma, match3(onLeft, onRight));
    };
  };
}
function matchE(M2) {
  return function(onLeft, onRight) {
    return function(ma) {
      return M2.chain(ma, match3(onLeft, onRight));
    };
  };
}
function getOrElse2(M2) {
  return function(onLeft) {
    return function(ma) {
      return M2.chain(ma, match3(onLeft, M2.of));
    };
  };
}
function orElse2(M2) {
  return function(onLeft) {
    return function(ma) {
      return M2.chain(ma, function(e) {
        return isLeft2(e) ? onLeft(e.left) : M2.of(e);
      });
    };
  };
}
function orElseFirst(M2) {
  var orElseM = orElse2(M2);
  return function(onLeft) {
    return orElseM(function(e) {
      return M2.map(onLeft(e), function(eb) {
        return isLeft2(eb) ? eb : left2(e);
      });
    });
  };
}
function orLeft(M2) {
  return function(onLeft) {
    return function(ma) {
      return M2.chain(ma, match3(function(e) {
        return M2.map(onLeft(e), left2);
      }, function(a2) {
        return M2.of(right2(a2));
      }));
    };
  };
}
function swap2(F) {
  return function(ma) {
    return F.map(ma, swap);
  };
}
function toUnion2(F) {
  return function(fa) {
    return F.map(fa, toUnion);
  };
}

// node_modules/fp-ts/es6/Filterable.js
function filter2(F, G2) {
  return function(predicate) {
    return function(fga) {
      return F.map(fga, function(ga) {
        return G2.filter(ga, predicate);
      });
    };
  };
}
function filterMap2(F, G2) {
  return function(f2) {
    return function(fga) {
      return F.map(fga, function(ga) {
        return G2.filterMap(ga, f2);
      });
    };
  };
}
function partition2(F, G2) {
  var _filter2 = filter2(F, G2);
  return function(predicate) {
    var left6 = _filter2(not2(predicate));
    var right6 = _filter2(predicate);
    return function(fgb) {
      return separated(left6(fgb), right6(fgb));
    };
  };
}
function partitionMap2(F, G2) {
  var _filterMap2 = filterMap2(F, G2);
  return function(f2) {
    return function(fga) {
      return separated(pipe(fga, _filterMap2(function(a2) {
        return getLeft(f2(a2));
      })), pipe(fga, _filterMap2(function(a2) {
        return getRight(f2(a2));
      })));
    };
  };
}

// node_modules/fp-ts/es6/FromIO.js
function fromIOK(F) {
  return function(f2) {
    return flow(f2, F.fromIO);
  };
}
function chainIOK(F, M2) {
  return function(f2) {
    var g2 = flow(f2, F.fromIO);
    return function(first) {
      return M2.chain(first, g2);
    };
  };
}
function chainFirstIOK(F, M2) {
  var chainFirstM = chainFirst(M2);
  return function(f2) {
    return chainFirstM(flow(f2, F.fromIO));
  };
}

// node_modules/fp-ts/es6/FromTask.js
function fromTaskK(F) {
  return function(f2) {
    return flow(f2, F.fromTask);
  };
}
function chainTaskK(F, M2) {
  return function(f2) {
    var g2 = flow(f2, F.fromTask);
    return function(first) {
      return M2.chain(first, g2);
    };
  };
}
function chainFirstTaskK(F, M2) {
  var chainFirstM = chainFirst(M2);
  return function(f2) {
    return chainFirstM(flow(f2, F.fromTask));
  };
}

// node_modules/fp-ts/es6/Task.js
var Task_exports = {};
__export(Task_exports, {
  ApT: () => ApT2,
  ApplicativePar: () => ApplicativePar,
  ApplicativeSeq: () => ApplicativeSeq,
  ApplyPar: () => ApplyPar,
  ApplySeq: () => ApplySeq,
  Chain: () => Chain3,
  Do: () => Do3,
  FromIO: () => FromIO,
  FromTask: () => FromTask,
  Functor: () => Functor3,
  Monad: () => Monad3,
  MonadIO: () => MonadIO,
  MonadTask: () => MonadTask,
  Pointed: () => Pointed3,
  URI: () => URI3,
  ap: () => ap5,
  apFirst: () => apFirst4,
  apS: () => apS4,
  apSecond: () => apSecond4,
  bind: () => bind4,
  bindTo: () => bindTo4,
  chain: () => chain4,
  chainFirst: () => chainFirst4,
  chainFirstIOK: () => chainFirstIOK2,
  chainIOK: () => chainIOK2,
  delay: () => delay,
  flap: () => flap4,
  flatten: () => flatten3,
  fromIO: () => fromIO,
  fromIOK: () => fromIOK2,
  fromTask: () => fromTask,
  getMonoid: () => getMonoid4,
  getRaceMonoid: () => getRaceMonoid,
  getSemigroup: () => getSemigroup5,
  let: () => let_4,
  map: () => map5,
  never: () => never,
  of: () => of5,
  sequenceArray: () => sequenceArray2,
  sequenceSeqArray: () => sequenceSeqArray,
  task: () => task,
  taskSeq: () => taskSeq,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex2,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyArrayWithIndexSeq: () => traverseReadonlyArrayWithIndexSeq,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndexSeq: () => traverseReadonlyNonEmptyArrayWithIndexSeq,
  traverseSeqArray: () => traverseSeqArray,
  traverseSeqArrayWithIndex: () => traverseSeqArrayWithIndex
});
var fromIO = function(ma) {
  return function() {
    return Promise.resolve().then(ma);
  };
};
function delay(millis) {
  return function(ma) {
    return function() {
      return new Promise(function(resolve3) {
        setTimeout(function() {
          Promise.resolve().then(ma).then(resolve3);
        }, millis);
      });
    };
  };
}
var _map3 = function(fa, f2) {
  return pipe(fa, map5(f2));
};
var _apPar = function(fab, fa) {
  return pipe(fab, ap5(fa));
};
var _apSeq = function(fab, fa) {
  return pipe(fab, chain4(function(f2) {
    return pipe(fa, map5(f2));
  }));
};
var _chain3 = function(ma, f2) {
  return pipe(ma, chain4(f2));
};
var map5 = function(f2) {
  return function(fa) {
    return function() {
      return Promise.resolve().then(fa).then(f2);
    };
  };
};
var ap5 = function(fa) {
  return function(fab) {
    return function() {
      return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function(_a) {
        var f2 = _a[0], a2 = _a[1];
        return f2(a2);
      });
    };
  };
};
var of5 = function(a2) {
  return function() {
    return Promise.resolve(a2);
  };
};
var chain4 = function(f2) {
  return function(ma) {
    return function() {
      return Promise.resolve().then(ma).then(function(a2) {
        return f2(a2)();
      });
    };
  };
};
var flatten3 = /* @__PURE__ */ chain4(identity);
var URI3 = "Task";
function getRaceMonoid() {
  return {
    concat: function(x2, y2) {
      return function() {
        return Promise.race([Promise.resolve().then(x2), Promise.resolve().then(y2)]);
      };
    },
    empty: never
  };
}
var Functor3 = {
  URI: URI3,
  map: _map3
};
var flap4 = /* @__PURE__ */ flap(Functor3);
var Pointed3 = {
  URI: URI3,
  of: of5
};
var ApplyPar = {
  URI: URI3,
  map: _map3,
  ap: _apPar
};
var apFirst4 = /* @__PURE__ */ apFirst(ApplyPar);
var apSecond4 = /* @__PURE__ */ apSecond(ApplyPar);
var ApplicativePar = {
  URI: URI3,
  map: _map3,
  ap: _apPar,
  of: of5
};
var ApplySeq = {
  URI: URI3,
  map: _map3,
  ap: _apSeq
};
var ApplicativeSeq = {
  URI: URI3,
  map: _map3,
  ap: _apSeq,
  of: of5
};
var Chain3 = {
  URI: URI3,
  map: _map3,
  ap: _apPar,
  chain: _chain3
};
var Monad3 = {
  URI: URI3,
  map: _map3,
  of: of5,
  ap: _apPar,
  chain: _chain3
};
var MonadIO = {
  URI: URI3,
  map: _map3,
  of: of5,
  ap: _apPar,
  chain: _chain3,
  fromIO
};
var fromTask = identity;
var MonadTask = {
  URI: URI3,
  map: _map3,
  of: of5,
  ap: _apPar,
  chain: _chain3,
  fromIO,
  fromTask
};
var chainFirst4 = /* @__PURE__ */ chainFirst(Chain3);
var FromIO = {
  URI: URI3,
  fromIO
};
var fromIOK2 = /* @__PURE__ */ fromIOK(FromIO);
var chainIOK2 = /* @__PURE__ */ chainIOK(FromIO, Chain3);
var chainFirstIOK2 = /* @__PURE__ */ chainFirstIOK(FromIO, Chain3);
var FromTask = {
  URI: URI3,
  fromIO,
  fromTask
};
var never = function() {
  return new Promise(function(_24) {
    return void 0;
  });
};
var Do3 = /* @__PURE__ */ of5(emptyRecord);
var bindTo4 = /* @__PURE__ */ bindTo(Functor3);
var let_4 = /* @__PURE__ */ let_(Functor3);
var bind4 = /* @__PURE__ */ bind(Chain3);
var apS4 = /* @__PURE__ */ apS(ApplyPar);
var ApT2 = /* @__PURE__ */ of5(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex2 = function(f2) {
  return function(as) {
    return function() {
      return Promise.all(as.map(function(a2, i2) {
        return Promise.resolve().then(function() {
          return f2(i2, a2)();
        });
      }));
    };
  };
};
var traverseReadonlyArrayWithIndex2 = function(f2) {
  var g2 = traverseReadonlyNonEmptyArrayWithIndex2(f2);
  return function(as) {
    return isNonEmpty(as) ? g2(as) : ApT2;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
  return function(as) {
    return function() {
      return tail(as).reduce(function(acc, a2, i2) {
        return acc.then(function(bs) {
          return Promise.resolve().then(f2(i2 + 1, a2)).then(function(b2) {
            bs.push(b2);
            return bs;
          });
        });
      }, Promise.resolve().then(f2(0, head(as))).then(singleton));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq = function(f2) {
  var g2 = traverseReadonlyNonEmptyArrayWithIndexSeq(f2);
  return function(as) {
    return isNonEmpty(as) ? g2(as) : ApT2;
  };
};
var traverseArrayWithIndex2 = traverseReadonlyArrayWithIndex2;
var traverseArray2 = function(f2) {
  return traverseReadonlyArrayWithIndex2(function(_24, a2) {
    return f2(a2);
  });
};
var sequenceArray2 = /* @__PURE__ */ traverseArray2(identity);
var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;
var traverseSeqArray = function(f2) {
  return traverseReadonlyArrayWithIndexSeq(function(_24, a2) {
    return f2(a2);
  });
};
var sequenceSeqArray = /* @__PURE__ */ traverseSeqArray(identity);
var task = {
  URI: URI3,
  map: _map3,
  of: of5,
  ap: _apPar,
  chain: _chain3,
  fromIO,
  fromTask
};
var taskSeq = {
  URI: URI3,
  map: _map3,
  of: of5,
  ap: _apSeq,
  chain: _chain3,
  fromIO,
  fromTask
};
var getSemigroup5 = /* @__PURE__ */ getApplySemigroup(ApplySeq);
var getMonoid4 = /* @__PURE__ */ getApplicativeMonoid(ApplicativeSeq);

// node_modules/fp-ts/es6/TaskEither.js
var TaskEither_exports = {};
__export(TaskEither_exports, {
  Alt: () => Alt3,
  ApT: () => ApT3,
  ApplicativePar: () => ApplicativePar2,
  ApplicativeSeq: () => ApplicativeSeq2,
  ApplyPar: () => ApplyPar2,
  ApplySeq: () => ApplySeq2,
  Bifunctor: () => Bifunctor2,
  Chain: () => Chain4,
  Do: () => Do4,
  FromEither: () => FromEither3,
  FromIO: () => FromIO2,
  FromTask: () => FromTask2,
  Functor: () => Functor4,
  Monad: () => Monad4,
  MonadIO: () => MonadIO2,
  MonadTask: () => MonadTask2,
  MonadThrow: () => MonadThrow2,
  Pointed: () => Pointed4,
  URI: () => URI4,
  alt: () => alt4,
  altW: () => altW3,
  ap: () => ap6,
  apFirst: () => apFirst5,
  apFirstW: () => apFirstW2,
  apS: () => apS5,
  apSW: () => apSW2,
  apSecond: () => apSecond5,
  apSecondW: () => apSecondW2,
  apW: () => apW2,
  bimap: () => bimap3,
  bind: () => bind5,
  bindTo: () => bindTo5,
  bindW: () => bindW2,
  bracket: () => bracket,
  bracketW: () => bracketW,
  chain: () => chain5,
  chainEitherK: () => chainEitherK2,
  chainEitherKW: () => chainEitherKW,
  chainFirst: () => chainFirst5,
  chainFirstEitherK: () => chainFirstEitherK2,
  chainFirstEitherKW: () => chainFirstEitherKW,
  chainFirstIOK: () => chainFirstIOK3,
  chainFirstTaskK: () => chainFirstTaskK2,
  chainFirstW: () => chainFirstW2,
  chainIOEitherK: () => chainIOEitherK,
  chainIOEitherKW: () => chainIOEitherKW,
  chainIOK: () => chainIOK3,
  chainNullableK: () => chainNullableK3,
  chainOptionK: () => chainOptionK3,
  chainOptionKW: () => chainOptionKW2,
  chainTaskK: () => chainTaskK2,
  chainTaskOptionK: () => chainTaskOptionK,
  chainTaskOptionKW: () => chainTaskOptionKW,
  chainW: () => chainW2,
  filterOrElse: () => filterOrElse3,
  filterOrElseW: () => filterOrElseW2,
  flap: () => flap5,
  flatten: () => flatten4,
  flattenW: () => flattenW2,
  fold: () => fold2,
  foldW: () => foldW2,
  fromEither: () => fromEither2,
  fromEitherK: () => fromEitherK3,
  fromIO: () => fromIO2,
  fromIOEither: () => fromIOEither,
  fromIOEitherK: () => fromIOEitherK,
  fromIOK: () => fromIOK3,
  fromNullable: () => fromNullable3,
  fromNullableK: () => fromNullableK3,
  fromOption: () => fromOption4,
  fromOptionK: () => fromOptionK4,
  fromPredicate: () => fromPredicate4,
  fromTask: () => fromTask2,
  fromTaskK: () => fromTaskK2,
  fromTaskOption: () => fromTaskOption,
  fromTaskOptionK: () => fromTaskOptionK,
  getAltTaskValidation: () => getAltTaskValidation,
  getApplicativeTaskValidation: () => getApplicativeTaskValidation,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getCompactable: () => getCompactable2,
  getFilterable: () => getFilterable2,
  getOrElse: () => getOrElse3,
  getOrElseW: () => getOrElseW2,
  getSemigroup: () => getSemigroup6,
  getTaskValidation: () => getTaskValidation,
  left: () => left4,
  leftIO: () => leftIO,
  leftTask: () => leftTask,
  let: () => let_5,
  map: () => map6,
  mapLeft: () => mapLeft3,
  match: () => match5,
  matchE: () => matchE2,
  matchEW: () => matchEW,
  matchW: () => matchW4,
  of: () => of6,
  orElse: () => orElse3,
  orElseFirst: () => orElseFirst2,
  orElseFirstIOK: () => orElseFirstIOK,
  orElseFirstTaskK: () => orElseFirstTaskK,
  orElseFirstW: () => orElseFirstW,
  orElseW: () => orElseW2,
  orLeft: () => orLeft2,
  right: () => right4,
  rightIO: () => rightIO,
  rightTask: () => rightTask,
  sequenceArray: () => sequenceArray3,
  sequenceSeqArray: () => sequenceSeqArray2,
  swap: () => swap3,
  taskEither: () => taskEither,
  taskEitherSeq: () => taskEitherSeq,
  taskify: () => taskify,
  throwError: () => throwError2,
  toUnion: () => toUnion3,
  traverseArray: () => traverseArray3,
  traverseArrayWithIndex: () => traverseArrayWithIndex3,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex3,
  traverseReadonlyArrayWithIndexSeq: () => traverseReadonlyArrayWithIndexSeq2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex3,
  traverseReadonlyNonEmptyArrayWithIndexSeq: () => traverseReadonlyNonEmptyArrayWithIndexSeq2,
  traverseSeqArray: () => traverseSeqArray2,
  traverseSeqArrayWithIndex: () => traverseSeqArrayWithIndex2,
  tryCatch: () => tryCatch2,
  tryCatchK: () => tryCatchK2
});
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_24)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t3 = _24.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t3[1]) {
              _24.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _24.label < t3[2]) {
              _24.label = t3[2];
              _24.ops.push(op);
              break;
            }
            if (t3[2])
              _24.ops.pop();
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var left4 = /* @__PURE__ */ left3(Pointed3);
var right4 = /* @__PURE__ */ right3(Pointed3);
var rightTask = /* @__PURE__ */ rightF(Functor3);
var leftTask = /* @__PURE__ */ leftF(Functor3);
var rightIO = /* @__PURE__ */ flow(fromIO, rightTask);
var leftIO = /* @__PURE__ */ flow(fromIO, leftTask);
var fromIO2 = rightIO;
var fromTask2 = rightTask;
var fromEither2 = of5;
var fromIOEither = fromIO;
var fromTaskOption = function(onNone) {
  return map5(fromOption3(onNone));
};
var match5 = /* @__PURE__ */ match4(Functor3);
var matchW4 = match5;
var matchE2 = /* @__PURE__ */ matchE(Monad3);
var fold2 = matchE2;
var matchEW = matchE2;
var foldW2 = matchEW;
var getOrElse3 = /* @__PURE__ */ getOrElse2(Monad3);
var getOrElseW2 = getOrElse3;
var tryCatch2 = function(f2, onRejected) {
  return function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var reason_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, f2().then(right)];
          case 1:
            return [2, _a.sent()];
          case 2:
            reason_1 = _a.sent();
            return [2, left(onRejected(reason_1))];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
};
var tryCatchK2 = function(f2, onRejected) {
  return function() {
    var a2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a2[_i] = arguments[_i];
    }
    return tryCatch2(function() {
      return f2.apply(void 0, a2);
    }, onRejected);
  };
};
var toUnion3 = /* @__PURE__ */ toUnion2(Functor3);
var fromNullable3 = /* @__PURE__ */ fromNullable2(Pointed3);
var fromNullableK3 = /* @__PURE__ */ fromNullableK2(Pointed3);
var chainNullableK3 = /* @__PURE__ */ chainNullableK2(Monad3);
var orElse3 = /* @__PURE__ */ orElse2(Monad3);
var orElseW2 = orElse3;
var orElseFirst2 = /* @__PURE__ */ orElseFirst(Monad3);
var orElseFirstW = orElseFirst2;
var orElseFirstIOK = function(onLeft) {
  return orElseFirst2(fromIOK3(onLeft));
};
var orElseFirstTaskK = function(onLeft) {
  return orElseFirst2(fromTaskK2(onLeft));
};
var orLeft2 = /* @__PURE__ */ orLeft(Monad3);
var swap3 = /* @__PURE__ */ swap2(Functor3);
var fromTaskOptionK = function(onNone) {
  var from = fromTaskOption(onNone);
  return function(f2) {
    return flow(f2, from);
  };
};
var chainTaskOptionKW = function(onNone) {
  return function(f2) {
    return function(ma) {
      return pipe(ma, chain5(fromTaskOptionK(onNone)(f2)));
    };
  };
};
var chainTaskOptionK = chainTaskOptionKW;
var fromIOEitherK = function(f2) {
  return flow(f2, fromIOEither);
};
var chainIOEitherKW = function(f2) {
  return chainW2(fromIOEitherK(f2));
};
var chainIOEitherK = chainIOEitherKW;
var _map4 = function(fa, f2) {
  return pipe(fa, map6(f2));
};
var _apPar2 = function(fab, fa) {
  return pipe(fab, ap6(fa));
};
var _apSeq2 = function(fab, fa) {
  return pipe(fab, chain5(function(f2) {
    return pipe(fa, map6(f2));
  }));
};
var _chain4 = function(ma, f2) {
  return pipe(ma, chain5(f2));
};
var _bimap2 = function(fa, f2, g2) {
  return pipe(fa, bimap3(f2, g2));
};
var _mapLeft2 = function(fa, f2) {
  return pipe(fa, mapLeft3(f2));
};
var _alt3 = function(fa, that) {
  return pipe(fa, alt4(that));
};
var map6 = /* @__PURE__ */ map4(Functor3);
var bimap3 = /* @__PURE__ */ bimap2(Functor3);
var mapLeft3 = /* @__PURE__ */ mapLeft2(Functor3);
var ap6 = /* @__PURE__ */ ap4(ApplyPar);
var apW2 = ap6;
var chain5 = /* @__PURE__ */ chain3(Monad3);
var chainW2 = chain5;
var flattenW2 = /* @__PURE__ */ chainW2(identity);
var flatten4 = flattenW2;
var alt4 = /* @__PURE__ */ alt3(Monad3);
var altW3 = alt4;
var of6 = right4;
var throwError2 = left4;
var URI4 = "TaskEither";
function getApplicativeTaskValidation(A2, S2) {
  var ap7 = ap(A2, getApplicativeValidation(S2));
  return {
    URI: URI4,
    _E: void 0,
    map: _map4,
    ap: function(fab, fa) {
      return pipe(fab, ap7(fa));
    },
    of: of6
  };
}
function getAltTaskValidation(S2) {
  var alt5 = altValidation(Monad3, S2);
  return {
    URI: URI4,
    _E: void 0,
    map: _map4,
    alt: function(fa, that) {
      return pipe(fa, alt5(that));
    }
  };
}
var getCompactable2 = function(M2) {
  var C = getCompactable(M2);
  return {
    URI: URI4,
    _E: void 0,
    compact: compact2(Functor3, C),
    separate: separate2(Functor3, C, Functor2)
  };
};
function getFilterable2(M2) {
  var F = getFilterable(M2);
  var C = getCompactable2(M2);
  var filter3 = filter2(Functor3, F);
  var filterMap3 = filterMap2(Functor3, F);
  var partition3 = partition2(Functor3, F);
  var partitionMap3 = partitionMap2(Functor3, F);
  return {
    URI: URI4,
    _E: void 0,
    map: _map4,
    compact: C.compact,
    separate: C.separate,
    filter: function(fa, predicate) {
      return pipe(fa, filter3(predicate));
    },
    filterMap: function(fa, f2) {
      return pipe(fa, filterMap3(f2));
    },
    partition: function(fa, predicate) {
      return pipe(fa, partition3(predicate));
    },
    partitionMap: function(fa, f2) {
      return pipe(fa, partitionMap3(f2));
    }
  };
}
var Functor4 = {
  URI: URI4,
  map: _map4
};
var flap5 = /* @__PURE__ */ flap(Functor4);
var Pointed4 = {
  URI: URI4,
  of: of6
};
var ApplyPar2 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2
};
var apFirst5 = /* @__PURE__ */ apFirst(ApplyPar2);
var apFirstW2 = apFirst5;
var apSecond5 = /* @__PURE__ */ apSecond(ApplyPar2);
var apSecondW2 = apSecond5;
var ApplicativePar2 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  of: of6
};
var ApplySeq2 = {
  URI: URI4,
  map: _map4,
  ap: _apSeq2
};
var ApplicativeSeq2 = {
  URI: URI4,
  map: _map4,
  ap: _apSeq2,
  of: of6
};
var Chain4 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  chain: _chain4
};
var Monad4 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  chain: _chain4,
  of: of6
};
var MonadIO2 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  chain: _chain4,
  of: of6,
  fromIO: fromIO2
};
var MonadTask2 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  chain: _chain4,
  of: of6,
  fromIO: fromIO2,
  fromTask: fromTask2
};
var MonadThrow2 = {
  URI: URI4,
  map: _map4,
  ap: _apPar2,
  chain: _chain4,
  of: of6,
  throwError: throwError2
};
var chainFirst5 = /* @__PURE__ */ chainFirst(Chain4);
var chainFirstW2 = chainFirst5;
var Bifunctor2 = {
  URI: URI4,
  bimap: _bimap2,
  mapLeft: _mapLeft2
};
var Alt3 = {
  URI: URI4,
  map: _map4,
  alt: _alt3
};
var FromEither3 = {
  URI: URI4,
  fromEither: fromEither2
};
var fromOption4 = /* @__PURE__ */ fromOption(FromEither3);
var fromOptionK4 = /* @__PURE__ */ fromOptionK(FromEither3);
var chainOptionK3 = /* @__PURE__ */ chainOptionK(FromEither3, Chain4);
var chainOptionKW2 = chainOptionK3;
var chainEitherK2 = /* @__PURE__ */ chainEitherK(FromEither3, Chain4);
var chainEitherKW = chainEitherK2;
var chainFirstEitherK2 = /* @__PURE__ */ chainFirstEitherK(FromEither3, Chain4);
var chainFirstEitherKW = chainFirstEitherK2;
var fromPredicate4 = /* @__PURE__ */ fromPredicate(FromEither3);
var filterOrElse3 = /* @__PURE__ */ filterOrElse(FromEither3, Chain4);
var filterOrElseW2 = filterOrElse3;
var fromEitherK3 = /* @__PURE__ */ fromEitherK(FromEither3);
var FromIO2 = {
  URI: URI4,
  fromIO: fromIO2
};
var fromIOK3 = /* @__PURE__ */ fromIOK(FromIO2);
var chainIOK3 = /* @__PURE__ */ chainIOK(FromIO2, Chain4);
var chainFirstIOK3 = /* @__PURE__ */ chainFirstIOK(FromIO2, Chain4);
var FromTask2 = {
  URI: URI4,
  fromIO: fromIO2,
  fromTask: fromTask2
};
var fromTaskK2 = /* @__PURE__ */ fromTaskK(FromTask2);
var chainTaskK2 = /* @__PURE__ */ chainTaskK(FromTask2, Chain4);
var chainFirstTaskK2 = /* @__PURE__ */ chainFirstTaskK(FromTask2, Chain4);
function taskify(f2) {
  return function() {
    var args = Array.prototype.slice.call(arguments);
    return function() {
      return new Promise(function(resolve3) {
        var cbResolver = function(e, r2) {
          return e != null ? resolve3(left(e)) : resolve3(right(r2));
        };
        f2.apply(null, args.concat(cbResolver));
      });
    };
  };
}
var bracket = function(acquire, use2, release) {
  return bracketW(acquire, use2, release);
};
var bracketW = function(acquire, use2, release) {
  return pipe(acquire, chainW2(function(a2) {
    return pipe(use2(a2), chain4(function(e) {
      return pipe(release(a2, e), chainW2(function() {
        return of5(e);
      }));
    }));
  }));
};
var Do4 = /* @__PURE__ */ of6(emptyRecord);
var bindTo5 = /* @__PURE__ */ bindTo(Functor4);
var let_5 = /* @__PURE__ */ let_(Functor4);
var bind5 = /* @__PURE__ */ bind(Chain4);
var bindW2 = bind5;
var apS5 = /* @__PURE__ */ apS(ApplyPar2);
var apSW2 = apS5;
var ApT3 = /* @__PURE__ */ of6(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex3 = function(f2) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex2(f2), map5(traverseReadonlyNonEmptyArrayWithIndex(SK)));
};
var traverseReadonlyArrayWithIndex3 = function(f2) {
  var g2 = traverseReadonlyNonEmptyArrayWithIndex3(f2);
  return function(as) {
    return isNonEmpty(as) ? g2(as) : ApT3;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq2 = function(f2) {
  return function(as) {
    return function() {
      return tail(as).reduce(function(acc, a2, i2) {
        return acc.then(function(ebs) {
          return isLeft(ebs) ? acc : f2(i2 + 1, a2)().then(function(eb) {
            if (isLeft(eb)) {
              return eb;
            }
            ebs.right.push(eb.right);
            return ebs;
          });
        });
      }, f2(0, head(as))().then(map3(singleton)));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq2 = function(f2) {
  var g2 = traverseReadonlyNonEmptyArrayWithIndexSeq2(f2);
  return function(as) {
    return isNonEmpty(as) ? g2(as) : ApT3;
  };
};
var traverseArrayWithIndex3 = traverseReadonlyArrayWithIndex3;
var traverseArray3 = function(f2) {
  return traverseReadonlyArrayWithIndex3(function(_24, a2) {
    return f2(a2);
  });
};
var sequenceArray3 = /* @__PURE__ */ traverseArray3(identity);
var traverseSeqArrayWithIndex2 = traverseReadonlyArrayWithIndexSeq2;
var traverseSeqArray2 = function(f2) {
  return traverseReadonlyArrayWithIndexSeq2(function(_24, a2) {
    return f2(a2);
  });
};
var sequenceSeqArray2 = /* @__PURE__ */ traverseSeqArray2(identity);
var taskEither = {
  URI: URI4,
  bimap: _bimap2,
  mapLeft: _mapLeft2,
  map: _map4,
  of: of6,
  ap: _apPar2,
  chain: _chain4,
  alt: _alt3,
  fromIO: fromIO2,
  fromTask: fromTask2,
  throwError: throwError2
};
var taskEitherSeq = {
  URI: URI4,
  bimap: _bimap2,
  mapLeft: _mapLeft2,
  map: _map4,
  of: of6,
  ap: _apSeq2,
  chain: _chain4,
  alt: _alt3,
  fromIO: fromIO2,
  fromTask: fromTask2,
  throwError: throwError2
};
var getApplySemigroup3 = /* @__PURE__ */ getApplySemigroup(ApplySeq2);
var getApplyMonoid2 = /* @__PURE__ */ getApplicativeMonoid(ApplicativeSeq2);
var getSemigroup6 = function(S2) {
  return getApplySemigroup(ApplySeq)(getSemigroup4(S2));
};
function getTaskValidation(SE) {
  var applicativeTaskValidation = getApplicativeTaskValidation(ApplicativePar, SE);
  var altTaskValidation = getAltTaskValidation(SE);
  return {
    URI: URI4,
    _E: void 0,
    map: _map4,
    ap: applicativeTaskValidation.ap,
    of: of6,
    chain: _chain4,
    bimap: _bimap2,
    mapLeft: _mapLeft2,
    alt: altTaskValidation.alt,
    fromIO: fromIO2,
    fromTask: fromTask2,
    throwError: throwError2
  };
}

// src/main.ts
var import_function14 = __toESM(require_function());
var import_obsidian56 = require("obsidian");
var import_obsidian_dataview3 = __toESM(require_lib());

// src/lib/data-api.ts
var import_dayjs = __toESM(require_dayjs_min());

// node_modules/immer/dist/immer.esm.mjs
function n(n2) {
  for (var r2 = arguments.length, t3 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++)
    t3[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, t3) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t3.length ? " " + t3.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t3 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t3 === Object || "function" == typeof t3 && Function.toString.call(t3) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
}
function i(n2, r2, t3) {
  void 0 === t3 && (t3 = false), 0 === o(n2) ? (t3 ? Object.keys : nn)(n2).forEach(function(e) {
    t3 && "symbol" == typeof e || r2(e, n2[e], n2);
  }) : n2.forEach(function(t4, e) {
    return r2(e, t4, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t3) {
  var e = o(n2);
  2 === e ? n2.set(r2, t3) : 3 === e ? n2.add(t3) : n2[r2] = t3;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t3 = nn(r2), e = 0; e < t3.length; e++) {
    var i2 = t3[e], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return void 0 === e && (e = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true)), n2;
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t3 = tn[r2];
  return t3 || n(18, r2), t3;
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e.h.O || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (g(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), g(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t3) {
  if (y(r2))
    return r2;
  var e = r2[Q];
  if (!e)
    return i(r2, function(i2, o3) {
      return A(n2, e, r2, i2, o3, t3);
    }, true), r2;
  if (e.A !== n2)
    return r2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u2 = o2, a2 = false;
    3 === e.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
      return A(n2, e, o2, r3, i2, t3, a2);
    }), x(n2, o2, false), t3 && n2.u && b("Patches").N(e, t3, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2, v2) {
  if (c2 === o2 && n(5), r(c2)) {
    var p2 = M(e, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, p2), !r(p2))
      return;
    e.m = false;
  } else
    v2 && o2.add(c2);
  if (t(c2) && !y(c2)) {
    if (!e.h.D && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t3) {
  void 0 === t3 && (t3 = false), !n2.l && n2.h.D && n2.m && d(r2, t3);
}
function z(n2, r2) {
  var t3 = n2[Q];
  return (t3 ? p(t3) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t3 = Object.getPrototypeOf(n2); t3; ) {
      var e = Object.getOwnPropertyDescriptor(t3, r2);
      if (e)
        return e;
      t3 = Object.getPrototypeOf(t3);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function N(n2, r2, t3) {
  var e = s(r2) ? b("MapSet").F(r2, t3) : v(r2) ? b("MapSet").T(r2, t3) : n2.O ? function(n3, r3) {
    var t4 = Array.isArray(n3), e2 = { i: t4 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t4 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  }(r2, t3) : b("ES5").J(r2, t3);
  return (t3 ? t3.A : _()).p.push(e), e;
}
function R(e) {
  return r(e) || n(22, e), function n2(r2) {
    if (!t(r2))
      return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = D(r2, c2), u2.I = false;
    } else
      e2 = D(r2, c2);
    return i(e2, function(r3, t3) {
      u2 && a(u2.t, r3) === t3 || f(e2, r3, n2(t3));
    }), 3 === c2 ? new Set(e2) : e2;
  }(e);
}
function D(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function K(n2) {
  return n2;
}
function $(n2) {
  return n2;
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t3) {
    r2[t3] = Object.getOwnPropertyDescriptor(n2, t3);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, r2))
    return function(n3, r3, t3) {
      var e2, i3 = I(r3, t3);
      return i3 ? "value" in i3 ? i3.value : null === (e2 = i3.get) || void 0 === e2 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t3) {
  var e = I(p(n2), r2);
  if (null == e ? void 0 : e.set)
    return e.set.call(n2.k, t3), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t3)
      return n2.o[r2] = t3, n2.R[r2] = false, true;
    if (c(t3, i2) && (void 0 !== t3 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t3 && (void 0 !== t3 || r2 in n2.o) || Number.isNaN(t3) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t3, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t3 = p(n2), e = Reflect.getOwnPropertyDescriptor(t3, r2);
  return e ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e.enumerable, value: t3[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t3) {
  return isNaN(parseInt(t3)) && n(13), on.set.call(this, r2, t3, void 0);
}, on.set = function(r2, t3, e) {
  return "length" !== t3 && isNaN(parseInt(t3)) && n(14), en.set.call(this, r2[0], t3, e, r2[0]);
};
var un = function() {
  function e(r2) {
    var e2 = this;
    this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t3 = arguments.length, e3 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t4;
            return (t4 = i3).call.apply(t4, [r4, n3].concat(e3));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e2), s2 = N(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw g(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e2.D && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t4 = arguments.length, i4 = Array(t4 > 1 ? t4 - 1 : 0), o3 = 1; o3 < t4; o3++)
            i4[o3 - 1] = arguments[o3];
          return e2.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t3, i3, o2 = e2.produce(n2, r3, function(n3, r4) {
        t3 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t3, i3];
      }) : [o2, t3, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = R(e2));
    var i3 = w(this), o2 = N(this, e2, void 0);
    return o2[Q].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t3) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t3), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.O = r2;
  }, i2.applyPatches = function(n2, t3) {
    var e2;
    for (e2 = t3.length - 1; e2 >= 0; e2--) {
      var i3 = t3[e2];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t3 = t3.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t3) : this.produce(n2, function(n3) {
      return o2(n3, t3);
    });
  }, e;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// src/lib/data-api.ts
var import_moment = __toESM(require_moment());

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity2 = (x2) => x2;
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
}
function run(fn3) {
  return fn3();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_24) => value = _24)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn3) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn3);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn3) {
  return definition[1] && fn3 ? assign($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn3) {
  if (definition[2] && fn3) {
    const lets = definition[2](fn3(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task2) => {
    if (!task2.c(now2)) {
      tasks.delete(task2);
      task2.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task2;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task2 = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task2);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append4(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append4(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty3() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn3) {
  return function(event) {
    event.stopPropagation();
    return fn3.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option2 = select.options[i2];
    if (option2.__value === value) {
      option2.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
var crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = false;
    try {
      if (typeof window !== "undefined" && window.parent) {
        void window.parent.document;
      }
    } catch (error2) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_resize_listener(node, fn3) {
  const computed_style = getComputedStyle(node);
  if (computed_style.position === "static") {
    node.style.position = "relative";
  }
  const iframe = element("iframe");
  iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
  iframe.setAttribute("aria-hidden", "true");
  iframe.tabIndex = -1;
  const crossorigin2 = is_crossorigin();
  let unsubscribe;
  if (crossorigin2) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
    unsubscribe = listen(window, "message", (event) => {
      if (event.source === iframe.contentWindow)
        fn3();
    });
  } else {
    iframe.src = "about:blank";
    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, "resize", fn3);
      fn3();
    };
  }
  append4(node, iframe);
  return () => {
    if (crossorigin2) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash4 = 5381;
  let i2 = str.length;
  while (i2--)
    hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i2);
  return hash4 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a2, b2, duration, delay2, ease, fn3, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t3 = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn3(t3, 1 - t3)}}
`;
  }
  const rule = keyframes + `100% {${fn3(b2, 1 - b2)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next2 = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next2.length;
  if (deleted) {
    node.style.animation = next2.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn3, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay: delay2 = 0,
    duration = 300,
    easing = identity2,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay2,
    // @ts-ignore todo:
    end: end2 = start_time + duration,
    tick: tick2 = noop,
    css: css2
  } = fn3(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start2() {
    if (css2) {
      name = create_rule(node, 0, 1, duration, delay2, easing, css2);
    }
    if (!delay2) {
      started = true;
    }
  }
  function stop() {
    if (css2)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end2) {
      tick2(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p2 = now2 - start_time;
      const t3 = 0 + 1 * easing(p2 / duration);
      tick2(t3, 1 - t3);
    }
    return true;
  });
  start2();
  tick2(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a2 = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a2);
  }
}
function add_transform(node, a2) {
  const b2 = node.getBoundingClientRect();
  if (a2.left !== b2.left || a2.top !== b2.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
  }
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn3) {
  get_current_component().$$.on_mount.push(fn3);
}
function onDestroy(fn3) {
  get_current_component().$$.on_destroy.push(fn3);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn3) => {
        fn3.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn3) => fn3.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn3) {
  render_callbacks.push(fn3);
}
function add_flush_callback(fn3) {
  flush_callbacks.push(fn3);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn3, params, intro) {
  const options = { direction: "both" };
  let config = fn3(node, params, options);
  let t3 = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init6(program, duration) {
    const d2 = program.b - t3;
    duration *= Math.abs(d2);
    return {
      a: t3,
      b: program.b,
      d: d2,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b2) {
    const { delay: delay2 = 0, duration = 300, easing = identity2, tick: tick2 = noop, css: css2 } = config || null_transition;
    const program = {
      start: now() + delay2,
      b: b2
    };
    if (!b2) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css2) {
        clear_animation();
        animation_name = create_rule(node, t3, b2, duration, delay2, easing, css2);
      }
      if (b2)
        tick2(0, 1);
      running_program = init6(program, duration);
      add_render_callback(() => dispatch(node, b2, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init6(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css2) {
            clear_animation();
            animation_name = create_rule(node, t3, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t3 = running_program.b, 1 - t3);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p2 = now2 - running_program.start;
            t3 = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick2(t3, 1 - t3);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b2) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b2);
        });
      } else {
        go(b2);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update2(type, index2, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index2 && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index2] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then((value) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error2) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error2);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error2;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup3) {
  transition_out(block, 1, 1, () => {
    lookup3.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup3) {
  block.f();
  outro_and_destroy_block(block, lookup3);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup3, node, destroy2, create_each_block22, next2, get_context3) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context3(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup3.get(key);
    if (!block) {
      block = create_each_block22(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next2);
    lookup3.set(block.key, block);
    next2 = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next2 = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy2(old_block, lookup3);
      o2--;
    } else if (!lookup3.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key))
      destroy2(old_block, lookup3);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o2) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o2) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function bind6(component, name, callback) {
  const index2 = component.$$.props[name];
  if (index2 !== void 0) {
    component.$$.bound[index2] = callback;
    callback(component.$$.ctx[index2]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init4(component, options, instance114, create_fragment114, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance114 ? instance114(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment114 ? create_fragment114($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn3) {
    set2(fn3(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn3, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto2 = fn3.length < 2;
  return readable(initial_value, (set2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn3(single ? values[0] : values, set2);
      if (auto2) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// src/lib/data.ts
function isOptionalDataValue(value) {
  switch (typeof value) {
    case "string":
      return true;
    case "number":
      return true;
    case "boolean":
      return true;
    default:
      return false;
  }
}
function isRepeatedDataValue(value) {
  if (Array.isArray(value)) {
    return value.every(isOptionalDataValue);
  }
  return false;
}
var emptyDataFrame = {
  records: [],
  fields: []
};
var DataSource = class {
  constructor(project, preferences) {
    this.project = project;
    this.preferences = preferences;
  }
  /**
   * readonly returns whether the data source is read-only.
   *
   * Read-only data sources are typically derived records where the data
   * source can't determine the original names of the fields.
   */
  readonly() {
    return false;
  }
};
function isBoolean(value) {
  return typeof value === "boolean";
}
function isString(value) {
  return typeof value === "string";
}
function isList(value) {
  return Array.isArray(value);
}
function isNumber(value) {
  return typeof value === "number";
}
function isDate(value) {
  return value instanceof Date;
}
function isOptional(value) {
  return value === null || value === void 0;
}
function isOptionalBoolean(value) {
  return isBoolean(value) || isOptional(value);
}
function isOptionalString(value) {
  return isString(value) || isOptional(value);
}
function isOptionalList(value) {
  return isList(value) || isOptional(value);
}
function isOptionalNumber(value) {
  return isNumber(value) || isOptional(value);
}
function isOptionalDate(value) {
  return isDate(value) || isOptional(value);
}

// src/lib/helpers.ts
var import_obsidian = require("obsidian");

// src/lib/stores/obsidian.ts
var app2 = writable();
var view = writable();
var plugin = writable();

// src/lib/helpers.ts
function notEmpty(value) {
  return value !== null && value !== void 0;
}
function notUndefined(value) {
  return value !== void 0;
}
function uniquify(name, exists4) {
  if (!exists4(name)) {
    return name;
  }
  let num = 1;
  while (exists4(name + " " + num)) {
    num++;
  }
  return name + " " + num;
}
function nextUniqueFileName(path, name) {
  return uniquify(name, (name2) => {
    return get_store_value(app2).vault.getAbstractFileByPath(
      (0, import_obsidian.normalizePath)(path + "/" + name2 + ".md")
    ) instanceof import_obsidian.TFile;
  });
}
function nextUniqueProjectName(projects, name) {
  return uniquify(name, (candidate) => {
    return !!projects.find((project) => project.name === candidate);
  });
}
function nextUniqueViewName(views, name) {
  return uniquify(name, (candidate) => {
    return !!views.find((view2) => view2.name === candidate);
  });
}
function getNameFromPath(path) {
  const start2 = path.lastIndexOf("/") + 1;
  const end2 = path.lastIndexOf(".");
  return path.substring(start2, end2);
}

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy4.range = this.range.slice();
    return copy4;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = visit_(i2, node.items[i2], visitor, path);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function visitAsync(node, visitor) {
  return __async(this, null, function* () {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = yield visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      yield visitAsync_(null, node, visitor_, Object.freeze([]));
  });
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
function visitAsync_(key, node, visitor, path) {
  return __async(this, null, function* () {
    const ctrl = yield callVisitor(key, node, visitor, path);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i2 = 0; i2 < node.items.length; ++i2) {
          const ci = yield visitAsync_(i2, node.items[i2], visitor, path);
          if (typeof ci === "number")
            i2 = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i2, 1);
            i2 -= 1;
          }
        }
      } else if (isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = yield visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = yield visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  });
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn2) => tn2.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy4 = new Directives(this.yaml, this.tags);
    copy4.docStart = this.docStart;
    return copy4;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle2, prefix] = parts;
        this.tags[handle2] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version2] = parts;
        if (version2 === "1.1" || version2 === "1.2") {
          this.yaml.version = version2;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version2);
          onError(6, `Unsupported YAML version ${version2}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle2];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle2 === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle2, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle2 + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle2, prefix] of tagEntries) {
      if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn2) => tn2.startsWith(prefix)))
        lines.push(`%TAG ${handle2} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name = `${prefix}${i2}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c2 = getAliasCount(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i2) => toJS(v2, String(i2), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match6 = tags.filter((t3) => t3.tag === tagName);
    const tagObj = (_a = match6.find((t3) => !t3.format)) != null ? _a : match6[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t3) => {
    var _a2;
    return ((_a2 = t3.identify) == null ? void 0 : _a2.call(t3, value)) && !t3.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map8 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map8.items.push(value);
    return map8;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v2 = value;
  for (let i2 = path.length - 1; i2 >= 0; --i2) {
    const k2 = path[i2];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a2 = [];
      a2[k2] = v2;
      v2 = a2;
    } else {
      v2 = /* @__PURE__ */ new Map([[k2, v2]]);
    }
  }
  return createNode(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy4.schema = schema4;
    copy4.items = copy4.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy4.range = this.range.slice();
    return copy4;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n2 = node.value;
      return n2 == null || allowScalar && isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text2, i2);
    if (i2 !== -1)
      end2 = i2 + endStep;
  }
  for (let ch; ch = text2[i2 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text2[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text2, i2);
      end2 = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next2 = text2[i2 + 1];
        if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
          split = i2;
      }
      if (i2 >= end2) {
        if (split) {
          folds.push(split);
          end2 = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i2 += 1];
            overflow = true;
          }
          const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text2;
          folds.push(j2);
          escapedFolds[j2] = true;
          end2 = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold3 = folds[i3];
    const end3 = folds[i3 + 1] || text2.length;
    if (fold3 === 0)
      res = `
${indent}${text2.slice(0, end3)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold3])
        res += `${text2[fold3]}\\`;
      res += `
${indent}${text2.slice(fold3 + 1, end3)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i2) {
  let ch = text2[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text2[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text2[i2 + 1];
  }
  return i2;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start2 = 0; i2 < strLen; ++i2) {
    if (str[i2] === "\n") {
      if (i2 - start2 > limit)
        return true;
      start2 = i2 + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start2 = 0;
  for (let i2 = 0, ch = json[i2]; ch; ch = json[++i2]) {
    if (ch === " " && json[i2 + 1] === "\\" && json[i2 + 2] === "n") {
      str += json.slice(start2, i2) + "\\ ";
      i2 += 1;
      start2 = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i2 + 1]) {
        case "u":
          {
            str += json.slice(start2, i2);
            const code = json.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i2, 6);
            }
            i2 += 5;
            start2 = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i2 + 2] === '"' || json.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str += json.slice(start2, i2) + "\n\n";
            while (json[i2 + 2] === "\\" && json[i2 + 3] === "n" && json[i2 + 4] !== '"') {
              str += "\n";
              i2 += 2;
            }
            str += indent;
            if (json[i2 + 2] === " ")
              str += "\\";
            i2 += 1;
            start2 = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str = start2 ? str + json.slice(start2) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end2 = value.substring(endStart);
  const endNlPos = end2.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end2 || endNlPos !== end2.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end2) {
    value = value.slice(0, -end2.length);
    if (end2[end2.length - 1] === "\n")
      end2 = end2.slice(0, -1);
    end2 = end2.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value = value.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start2}${value}${end2}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start2}${value}${end2}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t3 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t3);
    if (res === null)
      throw new Error(`Unsupported default string type ${t3}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match6 = tags.filter((t3) => t3.tag === item.tag);
    if (match6.length > 0)
      return (_a = match6.find((t3) => t3.format === item.format)) != null ? _a : match6[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match6 = tags.filter((t3) => {
      var _a2;
      return (_a2 = t3.identify) == null ? void 0 : _a2.call(t3, obj);
    });
    tagObj = (_b = match6.find((t3) => t3.format === item.format)) != null ? _b : match6.find((t3) => !t3.format);
  } else {
    obj = item;
    tagObj = tags.find((t3) => t3.nodeClass && obj instanceof t3.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify2(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o2) => tagObj = o2 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow2 = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow2) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map8, { key, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map8, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map8, it);
    else
      mergeToJSMap(ctx, map8, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map8 instanceof Map) {
      map8.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map8 instanceof Set) {
      map8.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map8)
        Object.defineProperty(map8, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map8[stringKey] = jsValue;
    }
  }
  return map8;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map8, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map8 instanceof Map) {
      if (!map8.has(key))
        map8.set(key, value2);
    } else if (map8 instanceof Set) {
      map8.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map8, key)) {
      Object.defineProperty(map8, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map8;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v2 = createNode(value, void 0, ctx);
  return new Pair(k2, v2);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_24, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow2 = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify5 = flow2 ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify5(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify2(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line = lines[i2];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify2(item, itemCtx, () => comment2 = null);
    if (i2 < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start: start2, end: end2 } = flowChars;
  if (lines.length === 0) {
    str = start2 + end2;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start2;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end2}`;
    } else {
      str = `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k2 = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k2)
        return it;
      if (isScalar(it.key) && it.key.value === k2)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i2 === -1)
        this.items.push(_pair);
      else
        this.items.splice(i2, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_24, ctx, Type) {
    const map8 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map8);
    for (const item of this.items)
      addPairToJSMap(ctx, map8, item);
    return map8;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map8 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map8.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map8.items.sort(schema4.sortMapEntries);
  }
  return map8;
}
var map7 = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map8, onError) {
    if (!isMap(map8))
      onError("Expected a mapping for this tag");
    return map8;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_24, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i2 = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i2++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i2 = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i2++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i2 = n2.indexOf(".");
    if (i2 < 0) {
      i2 = n2.length;
      n2 += ".";
    }
    let d2 = minFractionDigits - (n2.length - i2 - 1);
    while (d2-- > 0)
      n2 += "0";
  }
  return n2;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset2, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset2), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map7,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON2 = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON2
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON2
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON2
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON2
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map7, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i2 = 0; i2 < str.length; ++i2)
        buffer[i2] = str.charCodeAt(i2);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s2 = "";
      for (let i2 = 0; i2 < buf.length; ++i2)
        s2 += String.fromCharCode(buf[i2]);
      str = btoa(s2);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n2 = Math.ceil(str.length / lineWidth);
      const lines = new Array(n2);
      for (let i2 = 0, o2 = 0; i2 < n2; ++i2, o2 += lineWidth) {
        lines[i2] = str.substr(o2, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i2 = 0; i2 < seq2.items.length; ++i2) {
      let item = seq2.items[i2];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn2 = (_a = pair.value) != null ? _a : pair.key;
          cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i2] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i2++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_24, ctx) {
    if (!ctx)
      return super.toJSON(_24);
    const map8 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map8);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map8.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map8.set(key, value);
    }
    return map8;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f2 = str.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node.minFractionDigits = f2.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset2, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset2 += 1;
  str = str.substring(offset2).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_24, ctx) {
    return super.toJSON(_24, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map8, onError) {
    if (isMap(map8)) {
      if (map8.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map8);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map8;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n2) => n2;
  if (typeof value === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n2) => n2 < 10 ? "0" + String(n2) : String(n2)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match6 = str.match(timestamp.test);
    if (!match6)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match6.map(Number);
    const millisec = match6[7] ? Number((match6[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match6[8];
    if (tz && tz !== "Z") {
      let d2 = parseSexagesimal(tz, false);
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map7,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map7, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map: map7,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a2, b2) => a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map7 });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy4 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy4.tags = this.tags.slice();
    return copy4;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify2(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len = val.length; i2 < len; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version: version2 } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version2 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version2 });
    this.setSchema(version2, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy4 = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy4.commentBefore = this.commentBefore;
    copy4.comment = this.comment;
    copy4.errors = this.errors.slice();
    copy4.warnings = this.warnings.slice();
    copy4.options = Object.assign({}, this.options);
    if (this.directives)
      copy4.directives = this.directives.clone();
    copy4.schema = this.schema.clone();
    copy4.contents = isNode(this.contents) ? this.contents.clone(copy4.schema) : this.contents;
    if (this.range)
      copy4.range = this.range.slice();
    return copy4;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow: flow2, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow2 && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k2 = this.createNode(key, null, options);
    const v2 = this.createNode(value, null, options);
    return new Pair(k2, v2);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version2, options = {}) {
    if (typeof version2 === "number")
      version2 = String(version2);
    let opt;
    switch (version2) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version2;
        else
          this.directives = new Directives({ version: version2 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version2);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify: stringify2
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s2 = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s2}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error2) => {
  if (error2.pos[0] === -1)
    return;
  error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error2.linePos[0];
  error2.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end2 = error2.linePos[1];
    if (end2 && end2.line === line && end2.col > col) {
      count = Math.min(end2.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error2.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow: flow2, indicator, next: next2, offset: offset2, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start2 = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow2 && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow2 != null ? flow2 : "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow2) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow2}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last5 = tokens[tokens.length - 1];
  const end2 = last5 ? last5.offset + last5.source.length : offset2;
  if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== ""))
    onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end: end2,
    start: start2 != null ? start2 : end2
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end2 = fc.end[0];
    if (end2.indent === indent && (end2.source === "]" || end2.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end2, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b2) => a2 === b2 || isScalar(a2) && isScalar(b2) && a2.value === b2.value && !(a2.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map8 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start: start2, key, sep, value } = collItem;
    const keyProps = resolveProps(start2, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset2, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map8.comment)
            map8.comment += "\n" + keyProps.comment;
          else
            map8.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset2, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map8.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset2 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset2, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset2 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map8.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map8.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset2)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map8.range = [bm.offset, offset2, commentEnd != null ? commentEnd : offset2];
  return map8;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bs.offset;
  let commentEnd = null;
  for (const { start: start2, value } of bs.items) {
    const props = resolveProps(start2, {
      indicator: "seq-item-ind",
      next: value,
      offset: offset2,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset2, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start2, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset2 = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset2, commentEnd != null ? commentEnd : offset2];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end2, offset2, reqSpace, onError) {
  let comment = "";
  if (end2) {
    let hasSpace = false;
    let sep = "";
    for (const token of end2) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset2 += source.length;
    }
  }
  return { comment, offset: offset2 };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  var _a;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset2 = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start: start2, key, sep, value } = collItem;
    const props = resolveProps(start2, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset2 = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start2) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_a = prev.value) != null ? _a : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset2 = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map8 = coll;
        if (mapIncludes(ctx, map8.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map8.items.push(pair);
      } else {
        const map8 = new YAMLMap(ctx.schema);
        map8.flow = true;
        map8.items.push(pair);
        coll.items.push(map8);
      }
      offset2 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset2;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset2, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end2 = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end2.comment) {
      if (coll.comment)
        coll.comment += "\n" + end2.comment;
      else
        coll.comment = end2.comment;
    }
    coll.range = [fc.offset, cePos, end2.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t3) => t3.collection === expType && t3.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start2 = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start2, start2, start2] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end3 = start2 + header.length;
    if (scalar.source)
      end3 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start2, end3, end3] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset2 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset2 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i2;
      break;
    }
    offset2 += indent.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent, content] = lines[i2];
    offset2 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset2 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value += "\n" + lines[i2][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end2 = start2 + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start2, end2, end2] };
}
function parseBlockScalarHeader({ offset: offset2, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error2 === -1)
        error2 = offset2 + i2;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token = props[i2];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset2, type, source, end: end2 } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset2 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset2, offset2 + source.length, offset2 + source.length]
      };
  }
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end2, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset2, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_24) {
    first = new RegExp("(.*?)[ \\t]*\\r?\\n", "sy");
    line = new RegExp("[ \\t]*(.*?)[ \\t]*\\r?\\n", "sy");
  }
  let match6 = first.exec(source);
  if (!match6)
    return source;
  let res = match6[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match6 = line.exec(source)) {
    if (match6[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match6[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last5 = new RegExp("[ \\t]*(.*)", "sy");
  last5.lastIndex = pos;
  match6 = last5.exec(source);
  return res + sep + ((_a = match6 == null ? void 0 : match6[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold: fold3, offset: offset2 } = foldNewline(source, i2);
      res += fold3;
      i2 = offset2;
    } else if (ch === "\\") {
      let next2 = source[++i2];
      const cc = escapeCodes[next2];
      if (cc)
        res += cc;
      else if (next2 === "\n") {
        next2 = source[i2 + 1];
        while (next2 === " " || next2 === "	")
          next2 = source[++i2 + 1];
      } else if (next2 === "\r" && source[i2 + 1] === "\n") {
        next2 = source[++i2 + 1];
        while (next2 === " " || next2 === "	")
          next2 = source[++i2 + 1];
      } else if (next2 === "x" || next2 === "u" || next2 === "U") {
        const length = { x: 2, u: 4, U: 8 }[next2];
        res += parseCharCode(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next2 = source[i2 + 1];
      while (next2 === " " || next2 === "	")
        next2 = source[++i2 + 1];
      if (next2 !== "\n" && !(next2 === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset2) {
  let fold3 = "";
  let ch = source[offset2 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset2 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold3 += "\n";
    offset2 += 1;
    ch = source[offset2 + 1];
  }
  if (!fold3)
    fold3 = " ";
  return { fold: fold3, offset: offset2 };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset2, length, onError) {
  const cc = source.substr(offset2, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset2 - 2, length + 2);
    onError(offset2 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range: range4 } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range4;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset2, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset2 -= st.source.length;
          continue;
      }
      st = before[++i2];
      while ((st == null ? void 0 : st.type) === "space") {
        offset2 += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset2;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset2, before, pos, { spaceBefore, comment, anchor, tag, end: end2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset2, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end2;
  }
  return node;
}
function composeAlias({ options }, { offset: offset2, source, end: end2 }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset2, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset2 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end2, valueEnd, options.strict, onError);
  alias.range = [offset2, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset: offset2, start: start2, value, end: end2 }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start2, {
    indicator: "doc-start",
    next: value != null ? value : end2 == null ? void 0 : end2[0],
    offset: offset2,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start2, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end2, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset2, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset: offset2, source } = src;
  return [offset2, offset2 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i2 + 1]) == null ? void 0 : _a[0]) !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset2, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset2;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error2 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error2);
        else
          this.doc.errors.push(error2);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end2 = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end2.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
        }
        this.doc.range[2] = end2.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index2] of path) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i2 = 0; i2 < token.items.length; ++i2) {
        const ci = _visit(Object.freeze(path.concat([[field, i2]])), token.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty2(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next2 = (_a = this.next) != null ? _a : "stream";
    while (next2 && (incomplete || this.hasChars(1)))
      next2 = yield* this.parseNext(next2);
  }
  atLineEnd() {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i2];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i2 + 1] === "\n";
    return false;
  }
  charAt(n2) {
    return this.buffer[this.pos + n2];
  }
  continueScalar(offset2) {
    let ch = this.buffer[offset2];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset2];
      if (ch === "\r") {
        const next2 = this.buffer[indent + offset2 + 1];
        if (next2 === "\n" || !next2 && !this.atEnd)
          return offset2 + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset2 + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset2, 3);
      if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset2 + 3]))
        return -1;
    }
    return offset2;
  }
  getLine() {
    let end2 = this.lineEndPos;
    if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
      end2 = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end2;
    }
    if (end2 === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end2 - 1] === "\r")
      end2 -= 1;
    return this.buffer.substring(this.pos, end2);
  }
  hasChars(n2) {
    return this.pos + n2 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n2) {
    return this.buffer.substr(this.pos, n2);
  }
  *parseNext(next2) {
    switch (next2) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n2);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s2 = this.peek(3);
      if (s2 === "---" && isEmpty2(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s2 === "..." && isEmpty2(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
      const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n2;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n2 = yield* this.pushIndicators();
    switch (line[n2]) {
      case "#":
        yield* this.pushCount(line.length - n2);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n2 += yield* this.parseBlockScalarHeader();
        n2 += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n2);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n2 = 0;
    while (line[n2] === ",") {
      n2 += yield* this.pushCount(1);
      n2 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n2 += yield* this.pushIndicators();
    switch (line[n2]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n2);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next2 = this.charAt(1);
        if (this.flowKey || isEmpty2(next2) || next2 === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end2 = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end2 !== -1 && this.buffer[end2 + 1] === "'")
        end2 = this.buffer.indexOf("'", end2 + 2);
    } else {
      while (end2 !== -1) {
        let n2 = 0;
        while (this.buffer[end2 - 1 - n2] === "\\")
          n2 += 1;
        if (n2 % 2 === 0)
          break;
        end2 = this.buffer.indexOf('"', end2 + 1);
      }
    }
    const qb = this.buffer.substring(0, end2);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end2 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end2 === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end2 = this.buffer.length;
    }
    yield* this.pushToIndex(end2 + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i2 = this.pos;
    while (true) {
      const ch = this.buffer[++i2];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i2;
            indent = 0;
            break;
          case "\r": {
            const next2 = this.buffer[i2 + 1];
            if (!next2 && !this.atEnd)
              return this.setNext("block-scalar");
            if (next2 === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end2 = this.pos - 1;
    let i2 = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i2]) {
      if (ch === ":") {
        const next2 = this.buffer[i2 + 1];
        if (isEmpty2(next2) || inFlow && next2 === ",")
          break;
        end2 = i2;
      } else if (isEmpty2(ch)) {
        let next2 = this.buffer[i2 + 1];
        if (ch === "\r") {
          if (next2 === "\n") {
            i2 += 1;
            ch = "\n";
            next2 = this.buffer[i2 + 1];
          } else
            end2 = i2;
        }
        if (next2 === "#" || inFlow && invalidFlowScalarChars.includes(next2))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i2 + 1);
          if (cs === -1)
            break;
          i2 = Math.max(i2, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end2 = i2;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end2 + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n2) {
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos += n2;
      return n2;
    }
    return 0;
  }
  *pushToIndex(i2, allowEmpty) {
    const s2 = this.buffer.slice(this.pos, i2);
    if (s2) {
      yield s2;
      this.pos += s2.length;
      return s2.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty2(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i2 = this.pos + 2;
      let ch = this.buffer[i2];
      while (!isEmpty2(ch) && ch !== ">")
        ch = this.buffer[++i2];
      return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
    } else {
      let i2 = this.pos + 1;
      let ch = this.buffer[i2];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i2];
        else if (ch === "%" && hexDigits.includes(this.buffer[i2 + 1]) && hexDigits.includes(this.buffer[i2 + 2])) {
          ch = this.buffer[i2 += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i2, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i2 = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i2];
    } while (ch === " " || allowTabs && ch === "	");
    const n2 = i2 - this.pos;
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos = i2;
    }
    return n2;
  }
  *pushUntil(test) {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (!test(ch))
      ch = this.buffer[++i2];
    return yield* this.pushToIndex(i2, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset2) => this.lineStarts.push(offset2);
    this.linePos = (offset2) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset2)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset2)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset2 };
      const start2 = this.lineStarts[low - 1];
      return { line: low, col: offset2 - start2 + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i2 = 0; i2 < list.length; ++i2)
    if (list[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i2 = 0; i2 < list.length; ++i2) {
    switch (list[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i2]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top2 = this.peek(1);
    if (this.type === "doc-end" && (!top2 || top2.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top2)
      return yield* this.stream();
    switch (top2.type) {
      case "document":
        return yield* this.document(top2);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top2);
      case "block-scalar":
        return yield* this.blockScalar(top2);
      case "block-map":
        return yield* this.blockMap(top2);
      case "block-seq":
        return yield* this.blockSequence(top2);
      case "flow-collection":
        return yield* this.flowCollection(top2);
      case "doc-end":
        return yield* this.documentEnd(top2);
    }
    yield* this.pop();
  }
  peek(n2) {
    return this.stack[this.stack.length - n2];
  }
  *pop(error2) {
    const token = error2 != null ? error2 : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top2 = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top2 ? top2.indent : 0;
      } else if (token.type === "flow-collection" && top2.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top2.type) {
        case "document":
          top2.value = token;
          break;
        case "block-scalar":
          top2.props.push(token);
          break;
        case "block-map": {
          const it = top2.items[top2.items.length - 1];
          if (it.value) {
            top2.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top2.items[top2.items.length - 1];
          if (it.value)
            top2.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top2.items[top2.items.length - 1];
          if (!it || it.value)
            top2.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top2.type === "document" || top2.type === "block-map" || top2.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last5 = token.items[token.items.length - 1];
        if (last5 && !last5.sep && !last5.value && last5.start.length > 0 && findNonEmptyIndex(last5.start) === -1 && (token.indent === 0 || last5.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top2.type === "document")
            top2.end = last5.start;
          else
            top2.items.push({ start: last5.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start2 = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map8 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start: start2, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map8;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map8) {
    var _a;
    const it = map8.items[map8.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last5 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last5 == null ? void 0 : last5.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            map8.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map8.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map8.indent)) {
            const prev = map8.items[map8.items.length - 2];
            const end2 = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              map8.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map8.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map8.indent && it.sep;
      let start2 = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i2 = 0; i2 < it.sep.length; ++i2) {
          const st = it.sep[i2];
          switch (st.type) {
            case "newline":
              nl.push(i2);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map8.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start2 = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start2.push(this.sourceToken);
            map8.items.push({ start: start2 });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start2.push(this.sourceToken);
            map8.items.push({ start: start2 });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start3 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map8.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start3 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start3, key, sep }]
              });
            } else if (start2.length > 0) {
              it.sep = it.sep.concat(start2, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map8.items.push({ start: start2, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map8.items.push({ start: start2, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map8);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map8.items.push({ start: start2 });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last5 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last5 == null ? void 0 : last5.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end2 = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top2;
      do {
        yield* this.pop();
        top2 = this.peek(1);
      } while (top2 && top2.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map8 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start: start2, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map8;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        start2.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start2, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start2.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify4(value, replacer, options) {
  var _a;
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = (_a = options != null ? options : replacer) != null ? _a : {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options).toString(options);
}

// src/lib/metadata/decode.ts
function decodeFrontMatter(data) {
  const delim = "---";
  const startPosition = data.indexOf(delim) + delim.length;
  const endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const isStart = data.slice(0, startPosition).trim() === delim;
  const hasFrontMatter = isStart && endPosition > startPosition;
  return hasFrontMatter ? parseYaml(data.slice(startPosition, endPosition)) : Either_exports.right({});
}
function parseYaml(data) {
  return function_exports.pipe(
    data,
    (data2) => Either_exports.right(preprocessYaml(data2)),
    Either_exports.chain(parseRawYaml)
  );
}
function parseRawYaml(data) {
  return Either_exports.tryCatch(
    () => parse(data, (_key, value) => {
      if (typeof value === "string") {
        return unquoteInternalLinks(value);
      }
      return value;
    }) || {},
    (e) => e instanceof Error ? e : new Error("unknown error")
  );
}
function preprocessYaml(data) {
  const internalLinks = /(\"?\!?\[\[.*\]\]\"?)/g;
  const quoteInternalLinks = (line) => line.replace(internalLinks, (_match, p1) => {
    if (p1.startsWith('"') && p1.endsWith('"')) {
      return p1;
    }
    return '"' + p1 + '"';
  });
  return data.split("\n").map(quoteInternalLinks).join("\n");
}
function unquoteInternalLinks(value) {
  return value.replace(/\"(\!?\[\[.*\]\])\"/g, (_match, p1) => p1);
}

// src/lib/metadata/encode.ts
function encodeFrontMatter(data, frontmatter, defaultStringType) {
  const delim = "---";
  const startPosition = data.indexOf(delim) + delim.length;
  const endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const isStart = data.slice(0, startPosition).trim() === delim;
  const hasFrontMatter = isStart && endPosition > startPosition;
  return function_exports.pipe(
    parseYaml(data.slice(startPosition, endPosition)),
    Either_exports.map((existing) => Object.assign({}, existing, frontmatter)),
    Either_exports.map((fm) => {
      if (Object.entries(fm).length) {
        const d2 = stringifyYaml(fm, defaultStringType);
        return hasFrontMatter ? data.slice(0, startPosition + 1) + d2 + data.slice(endPosition) : delim + "\n" + d2 + delim + "\n\n" + data;
      }
      return hasFrontMatter ? data.slice(0, startPosition - delim.length) + data.slice(endPosition + delim.length + 1) : data;
    })
  );
}
function stringifyYaml(value, defaultStringType = "PLAIN") {
  return function_exports.pipe(
    value,
    (value2) => stringify4(value2, {
      lineWidth: 0,
      nullStr: "",
      defaultStringType,
      defaultKeyType: "PLAIN"
    })
  );
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance114, Constructor) {
  if (!(instance114 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toArray.js
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

// node_modules/i18next/dist/esm/i18next.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init6(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone2(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on3(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off2(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve3, reject) {
    res = resolve3;
    rej = reject;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy3(a2, s2, t3) {
  a2.forEach(function(m) {
    if (s2[m])
      t3[m] = s2[m];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path, newValue, concat3) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat3)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat3)
    obj[k2].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current)
      return void 0;
    if (typeof current[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i2]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i2, i2 + j2).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i2 + j2) {
        j2++;
        p2 = paths.slice(i2, i2 + j2).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i2]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy3(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage2(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists4(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;
      if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy4 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy4[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy4[m] === deepKey)
                copy4[m] = res[m];
            }
          }
          res = copy4;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve3(keys) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = "defaultValue";
      for (var option2 in options) {
        if (Object.prototype.hasOwnProperty.call(options, option2) && prefix === option2.substring(0, prefix.length) && void 0 !== options[option2]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _2(n2) {
    return Number(n2 > 1);
  },
  2: function _3(n2) {
    return Number(n2 != 1);
  },
  3: function _4(n2) {
    return 0;
  },
  4: function _5(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _6(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _9(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _10(n2) {
    return Number(n2 >= 2);
  },
  10: function _11(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _12(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _13(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _14(n2) {
    return Number(n2 !== 0);
  },
  14: function _15(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _17(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _18(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _19(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _21(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _22(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _23(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set2) {
    set2.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init6() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match6;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match6 = todo.regex.exec(str)) {
          var matchedVar = match6[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match6, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match6[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match6[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match6[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match6;
      var value;
      var clonedOptions = _objectSpread$3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match6 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match6[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match6[1])) {
          var r2 = match6[1].split(this.formatSeparator).map(function(elem4) {
            return elem4.trim();
          });
          match6[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match6[1].trim(), clonedOptions), clonedOptions);
        if (value && match6[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match6[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match6[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match6[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn3) {
  var cache = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache[key];
    if (!formatter) {
      formatter = fn3(lng, options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function(lng, options2) {
        var formatter = new Intl.NumberFormat(lng, options2);
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng, options2) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options2), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng, options2) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$4({}, options2));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng, options2) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options2));
        return function(val) {
          return formatter.format(val, options2.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng, options2) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$4({}, options2));
        return function(val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init6(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng, options) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = {};
            var loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loaded2[l2][ns2] === void 0)
                  loaded2[l2][ns2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait: wait2,
          callback
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next2 = _this3.waitingReads.shift();
          _this3.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
        }
        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait2 * 2, callback);
          }, wait2);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop2() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init6() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop2;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t3) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t3);
          callback(err, t3);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources2(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append5 = function append6(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append5(l2);
          });
        } else {
          append5(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append5(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources2(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop2;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use2(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage2(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT2(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t3() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists4() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace2(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone2.logger = clone2.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone2[m] = _this8[m];
      });
      clone2.services = _objectSpread$6({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var init5 = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t2 = instance.t;
var exists3 = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;
var i18next_default = instance;

// src/lib/stores/i18n.ts
var import_svelte_i18next = __toESM(require_svelte_i18next());
i18next_default.init({
  // lng: moment.locale(),
  lng: "en",
  resources: {
    en: {
      translation: {
        "data-types": {
          string: "Text",
          number: "Number",
          boolean: "True or false",
          date: "Date",
          unknown: "Unknown data type",
          repeated: "Repeated field"
        },
        commands: {
          "show-projects": {
            name: "Show projects"
          },
          "create-project": {
            name: "Create new project"
          },
          "create-note": {
            name: "Create new note"
          }
        },
        menus: {
          project: {
            create: {
              title: "Create project in folder"
            }
          }
        },
        modals: {
          project: {
            create: {
              "short-title": "New project",
              untitled: "Untitled project",
              title: "Create new project",
              cta: "Create project",
              "existing-name-error": "A project with that name already exists.",
              "empty-name-error": "Project name can't be empty."
            },
            edit: {
              "short-title": "Edit project",
              title: "Edit project",
              cta: "Save"
            },
            duplicate: {
              title: "Duplicate project"
            },
            delete: {
              "short-title": "Delete project",
              title: "Delete project",
              message: 'Are you sure you want to delete "{{project}}"?',
              cta: "Delete"
            },
            name: {
              name: "Name",
              description: ""
            },
            default: {
              name: "Set as default",
              description: "Enable to open this project by default."
            },
            path: {
              name: "Path",
              description: "Path to the folder you want to manage. Leave empty to use root folder."
            },
            tag: {
              name: "Tag",
              description: "Include all notes that have this tag."
            },
            dataview: {
              name: "Use Dataview",
              description: "Use Dataview to query read-only data instead of using paths.",
              error: {
                title: "Dataview is disabled",
                message: "Enable the Dataview plugin to continue using this project."
              }
            },
            query: {
              name: "Query",
              description: "Only supports TABLE queries."
            },
            recursive: {
              name: "Include subfolders",
              description: "Manage notes inside subfolders within the project path."
            },
            templates: {
              name: "Templates",
              description: "Templates to choose from when you create new notes."
            },
            exclude: {
              name: "Excluded notes",
              description: "Notes to exclude even if they would otherwise be part of the project."
            },
            newNotesFolder: {
              name: "Location for new notes",
              description: "Folder where all new notes are placed."
            },
            defaultName: {
              name: "Default name for new notes",
              description: "Supports {{date:YYYY-MM-DD}} and {{time:HHmm}} templates variables.",
              invalid: "Contains illegal characters."
            }
          },
          view: {
            create: {
              "short-title": "New view",
              title: "Add new view",
              optional: "Optional",
              type: {
                name: "Type",
                description: ""
              },
              name: {
                name: "Name",
                description: ""
              },
              cta: "Add view",
              "existing-name-error": "A view with that name already exists."
            },
            delete: {
              "short-title": "Delete view",
              title: "Delete view",
              message: "Are you sure you want to delete the view?",
              cta: "Delete"
            }
          },
          note: {
            create: {
              "short-title": "New note",
              title: "Create new note",
              name: {
                name: "Name",
                description: ""
              },
              templatePath: {
                name: "Template",
                description: "",
                none: "None"
              },
              project: {
                name: "Project",
                description: ""
              },
              "name-taken-error": "A note with that name already exists.",
              "empty-name-error": "Name can't be empty.",
              "dot-start-error": "File name must not start with a dot.",
              create: "Create note",
              readonly: {
                title: "Read-only project",
                message: "{{project}} is a read-only project. Select another project to create a note."
              },
              untitled: "Untitled note"
            },
            edit: {
              "short-title": "Edit note",
              title: "Edit note",
              save: "Save",
              "no-editable-fields": {
                title: "No editable fields",
                message: "This note has no editable fields."
              }
            }
          },
          input: {
            cancel: "Cancel"
          },
          confirm: {
            delete: "Delete",
            cancel: "Cancel"
          }
        },
        views: {
          developer: {
            name: "Developer"
          },
          table: {
            name: "Table",
            "hide-fields": "Hide fields",
            "rename-field": "Rename field",
            rename: "Rename"
          },
          board: {
            name: "Board",
            "no-status": "No status",
            fields: {
              status: "Status",
              priority: "Priority",
              none: "None"
            },
            unprioritized: "Unprioritized",
            note: {
              add: "Add note"
            }
          },
          calendar: {
            name: "Calendar",
            "new-note": "New note",
            fields: {
              date: "Date",
              check: "Check",
              none: "None"
            },
            today: "Today",
            weekday: "{{value, datetime}}",
            date: "{{value, datetime}}",
            interval: "{{from, datetime}} \u2013 {{to, datetime}}",
            intervals: {
              month_one: "Month",
              month_other: "Months",
              monthWithCount_one: "{{count}} month",
              monthWithCount_other: "{{count}} months",
              week_one: "Week",
              week_other: "Weeks",
              weekWithCount_one: "{{count}} week",
              weekWithCount_other: "{{count}} weeks",
              day_one: "Day",
              day_other: "Days",
              dayWithCount_one: "{{count}} day",
              dayWithCount_other: "{{count}} days"
            }
          },
          gallery: {
            name: "Gallery",
            fields: {
              cover: "Cover",
              none: "None"
            },
            empty: "This view is empty."
          }
        },
        components: {
          "data-grid": {
            column: {
              configure: "Configure field",
              rename: "Rename field",
              delete: "Delete field",
              hide: "Hide field"
            },
            row: {
              add: "Add note",
              edit: "Edit note",
              delete: "Delete note"
            },
            cell: {
              clear: "Clear value"
            },
            sort: {
              asc: "Sort A \u2192 Z",
              desc: "Sort Z \u2192 A"
            },
            sortDate: {
              asc: "Sort Old \u2192 New",
              desc: "Sort New \u2192 Old"
            }
          }
        },
        toolbar: {
          new: "New",
          view: {
            add: "Add view"
          },
          projects: {
            none: "No projects",
            options: "More options"
          },
          "read-only": "Read-only",
          "read-only-desc": "You can't create or edit notes in read-only projects."
        },
        errors: {
          missingDataview: {
            title: "Dataview is disabled",
            message: "Enable the Dataview plugin to continue using this project."
          }
        }
      }
    }
  },
  interpolation: {
    escapeValue: false
    // not needed for svelte as it escapes by default
  }
});
var i18n = (0, import_svelte_i18next.createI18nStore)(i18next_default);

// src/settings/base/settings.ts
function isStringFilterOperator(op) {
  return ["is", "is-not", "contains", "not-contains"].includes(op);
}
function isNumberFilterOperator(op) {
  return ["eq", "neq", "lt", "gt", "lte", "gte"].includes(op);
}
function isBooleanFilterOperator(op) {
  return ["is-checked", "is-not-checked"].includes(op);
}
var filterOperatorTypes = {
  "is-empty": "unary",
  "is-not-empty": "unary",
  is: "binary",
  "is-not": "binary",
  contains: "binary",
  "not-contains": "binary",
  eq: "binary",
  neq: "binary",
  lt: "binary",
  gt: "binary",
  lte: "binary",
  gte: "binary",
  "is-checked": "unary",
  "is-not-checked": "unary"
};
var DEFAULT_VIEW = {
  config: {},
  filter: { conditions: [] },
  colors: { conditions: [] }
};

// src/settings/v1/settings.ts
var DEFAULT_SETTINGS = {
  version: 1,
  projects: [],
  preferences: {
    projectSizeLimit: 1e3,
    frontmatter: {
      quoteStrings: "PLAIN"
    },
    commands: []
  }
};
var DEFAULT_PROJECT = {
  path: "",
  recursive: false,
  fieldConfig: {},
  defaultName: "",
  templates: [],
  dataview: false,
  query: "",
  excludedNotes: [],
  isDefault: false
};
function resolve(unresolved) {
  var _a, _b;
  return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_SETTINGS), unresolved), {
    projects: (_b = (_a = unresolved.projects) == null ? void 0 : _a.map(resolveProject)) != null ? _b : []
  });
}
function resolveProject(unresolved) {
  var _a, _b;
  const { name, id } = unresolved;
  if (name && id) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PROJECT), unresolved), {
      name,
      id,
      views: (_b = (_a = unresolved.views) == null ? void 0 : _a.map(resolveView)) != null ? _b : []
    });
  }
  throw new Error("Invalid project definition");
}
function resolveView(unresolved) {
  const { name, id, type } = unresolved;
  if (name && id && type) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_VIEW), unresolved), {
      name,
      id,
      type
    });
  }
  throw new Error("Invalid view definition");
}

// src/settings/v2/settings.ts
var DEFAULT_PROJECT2 = {
  fieldConfig: {},
  defaultName: "",
  templates: [],
  excludedNotes: [],
  isDefault: false,
  dataSource: {
    kind: "folder",
    config: {
      path: "",
      recursive: false
    }
  },
  newNotesFolder: "",
  views: []
};
var DEFAULT_SETTINGS2 = {
  version: 2,
  projects: [],
  preferences: {
    projectSizeLimit: 1e3,
    frontmatter: {
      quoteStrings: "PLAIN"
    },
    commands: []
  }
};
function resolve2(unresolved) {
  var _a, _b, _c;
  return {
    version: 2,
    projects: (_b = (_a = unresolved.projects) == null ? void 0 : _a.map(resolveProject2)) != null ? _b : [],
    preferences: resolvePreferences((_c = unresolved.preferences) != null ? _c : {})
  };
}
function resolveProject2(unresolved) {
  var _a, _b;
  const { name, id } = unresolved;
  if (name && id) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PROJECT2), unresolved), {
      name,
      id,
      views: (_b = (_a = unresolved.views) == null ? void 0 : _a.map(resolveView2)) != null ? _b : []
    });
  }
  throw new Error("Invalid project definition");
}
function resolveView2(unresolved) {
  const { name, id, type } = unresolved;
  if (name && id && type) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_VIEW), unresolved), {
      name,
      id,
      type
    });
  }
  throw new Error("Invalid view definition");
}
var DEFAULT_PREFERENCES = {
  projectSizeLimit: 1e3,
  frontmatter: {
    quoteStrings: "PLAIN"
  },
  commands: []
};
function resolvePreferences(unresolved) {
  return __spreadValues(__spreadValues({}, DEFAULT_PREFERENCES), unresolved);
}

// src/settings/settings.ts
var DEFAULT_SETTINGS3 = DEFAULT_SETTINGS2;
var DEFAULT_PROJECT3 = DEFAULT_PROJECT2;
var DEFAULT_VIEW2 = DEFAULT_VIEW;
function migrateSettings(settings2) {
  if (!settings2) {
    return Either_exports.right(Object.assign({}, DEFAULT_SETTINGS2));
  }
  if ("version" in settings2 && typeof settings2.version === "number") {
    if (settings2.version === 1) {
      return Either_exports.right(migrate(resolve(settings2)));
    } else if (settings2.version === 2) {
      return Either_exports.right(resolve2(settings2));
    } else {
      return Either_exports.left(new Error("Unknown settings version"));
    }
  }
  return Either_exports.left(new Error("Missing settings version"));
}
function migrate(v1settings) {
  return {
    version: 2,
    projects: v1settings.projects.map(migrateProject),
    preferences: v1settings.preferences
  };
}
function migrateProject(v1project) {
  const {
    name,
    id,
    fieldConfig,
    templates,
    defaultName,
    excludedNotes,
    isDefault,
    views
  } = v1project;
  const common = {
    name,
    id,
    fieldConfig,
    defaultName,
    templates,
    excludedNotes,
    isDefault,
    views
  };
  return __spreadProps(__spreadValues({}, common), {
    newNotesFolder: "",
    dataSource: migrateDataSource(v1project)
  });
}
function migrateDataSource(project) {
  if (project.dataview) {
    return {
      kind: "dataview",
      config: {
        query: project.query
      }
    };
  }
  return {
    kind: "folder",
    config: {
      path: project.path,
      recursive: project.recursive
    }
  };
}

// src/lib/stores/settings.ts
function createSettings() {
  const { set: set2, update: update2, subscribe: subscribe2 } = writable(
    Object.assign({}, DEFAULT_SETTINGS3)
  );
  return {
    set: set2,
    subscribe: subscribe2,
    addProject(project) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          if (project.isDefault) {
            draft.projects = draft.projects.map((project2) => __spreadProps(__spreadValues({}, project2), {
              isDefault: false
            }));
          }
          draft.projects.push(project);
        })
      );
    },
    updatePreferences(prefs) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.preferences = prefs;
        })
      );
    },
    updateProject(project) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          if (project.isDefault) {
            draft.projects = draft.projects.map((project2) => __spreadProps(__spreadValues({}, project2), {
              isDefault: false
            }));
          }
          draft.projects = draft.projects.map(
            (w2) => w2.id === project.id ? project : w2
          );
        })
      );
    },
    duplicateProject(projectId) {
      const newId = v4_default();
      update2(
        (state) => immer_esm_default(state, (draft) => {
          const project = draft.projects.find((p2) => p2.id === projectId);
          if (project) {
            draft.projects.push(__spreadProps(__spreadValues({}, project), {
              id: newId,
              name: nextUniqueProjectName(
                draft.projects,
                project.name + " Copy"
              ),
              views: project.views.map((v2) => __spreadProps(__spreadValues({}, v2), { id: v4_default() }))
            }));
          }
        })
      );
      return newId;
    },
    deleteProject(projectId) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.filter((w2) => w2.id !== projectId);
        })
      );
    },
    addView(projectId, view2) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((ws) => ws.id === projectId);
          if (idx >= 0) {
            const ws = draft.projects[idx];
            if (ws) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
                views: [...ws.views, view2]
              }));
            }
          }
          return draft;
        })
      );
    },
    sortViews(projectId, viewIds) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.map(
            (p2) => p2.id !== projectId ? p2 : immer_esm_default(p2, (draft2) => {
              draft2.views = viewIds.map((id) => draft2.views.find((v2) => v2.id === id)).filter(notEmpty);
            })
          );
        })
      );
    },
    renameView(projectId, viewId, name) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((p2) => p2.id === projectId);
          if (idx >= 0) {
            const p2 = draft.projects[idx];
            if (p2) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, p2), {
                views: p2.views.map(
                  (view2) => view2.id === viewId ? __spreadProps(__spreadValues({}, view2), { name }) : view2
                )
              }));
            }
          }
        })
      );
    },
    duplicateView(projectId, viewId) {
      const newId = v4_default();
      update2(
        (state) => immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((ws) => ws.id === projectId);
          if (idx >= 0) {
            const p2 = draft.projects[idx];
            if (p2) {
              const view2 = p2.views.find((v2) => v2.id === viewId);
              if (view2) {
                draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, p2), {
                  views: [
                    ...p2.views,
                    __spreadProps(__spreadValues({}, view2), {
                      id: newId,
                      name: nextUniqueViewName(p2.views, view2.name + " Copy")
                    })
                  ]
                }));
              }
            }
          }
          return draft;
        })
      );
      return newId;
    },
    deleteView(projectId, viewId) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          const idx = draft.projects.findIndex((ws) => ws.id === projectId);
          if (idx >= 0) {
            const ws = draft.projects[idx];
            if (ws) {
              draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
                views: ws.views.filter((view2) => view2.id !== viewId)
              }));
            }
          }
        })
      );
    },
    updateView(projectId, updatedView) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.map((project) => {
            if (project.id === projectId) {
              return __spreadProps(__spreadValues({}, project), {
                views: project.views.map((view2) => {
                  if (view2.id === updatedView.id) {
                    return updatedView;
                  }
                  return view2;
                })
              });
            }
            return project;
          });
        })
      );
    },
    updateViewConfig(projectId, viewId, config) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.projects = draft.projects.map((project) => {
            if (project.id === projectId) {
              return __spreadProps(__spreadValues({}, project), {
                views: project.views.map((view2) => {
                  if (view2.id === viewId) {
                    return __spreadProps(__spreadValues({}, view2), {
                      config
                    });
                  }
                  return view2;
                })
              });
            }
            return project;
          });
        })
      );
    }
  };
}
var settings = createSettings();

// src/lib/templates/index.ts
function interpolateTemplate(template, data) {
  return template.replace(/\{\{\s*(.*?)\s*\}\}/g, (_24, name) => {
    const [func8, arg] = name.split(new RegExp(":(.*)", "s"));
    const f2 = data[func8];
    return f2 ? f2(arg) : "";
  });
}

// src/lib/data-api.ts
var import_obsidian3 = require("obsidian");
var DataApi = class {
  constructor(fileSystem2) {
    this.fileSystem = fileSystem2;
  }
  updateRecord(fields, record) {
    return __async(this, null, function* () {
      const file = this.fileSystem.getFile(record.id);
      if (file) {
        yield this.updateFile(
          file,
          (data) => doUpdateRecord(data, fields, record)
        )();
      }
    });
  }
  renameField(paths, from, to) {
    return __async(this, null, function* () {
      Promise.all(
        paths.map((path) => this.fileSystem.getFile(path)).filter(notEmpty).map(
          (file) => this.updateFile(file, (data) => doRenameField(data, from, to))()
        )
      );
    });
  }
  deleteField(paths, name) {
    return __async(this, null, function* () {
      Promise.all(
        paths.map((path) => this.fileSystem.getFile(path)).filter(notEmpty).map(
          (file) => this.updateFile(file, (data) => doDeleteField(data, name))()
        )
      );
    });
  }
  createNote(record, templatePath) {
    return __async(this, null, function* () {
      let content = "";
      if (templatePath) {
        const file2 = this.fileSystem.getFile(templatePath);
        if (file2) {
          content = yield file2.read();
          content = interpolateTemplate(content, {
            title: () => getNameFromPath(record.id),
            date: (format2) => (0, import_moment.default)().format(format2 || "YYYY-MM-DD"),
            time: (format2) => (0, import_moment.default)().format(format2 || "HH:mm")
          });
        }
      }
      const file = yield this.fileSystem.create(record.id, content);
      yield this.updateFile(file, (data) => doUpdateRecord(data, [], record))();
    });
  }
  updateFile(file, cb) {
    return function_exports.pipe(
      TaskEither_exports.tryCatch(() => file.read(), Either_exports.toError),
      TaskEither_exports.map(cb),
      TaskEither_exports.chain(TaskEither_exports.fromEither),
      TaskEither_exports.chain((result) => TaskEither_exports.tryCatch(() => file.write(result), Either_exports.toError)),
      Task_exports.map(
        Either_exports.fold(
          (err) => {
            throw err;
          },
          () => {
          }
        )
      )
    );
  }
  deleteRecord(path) {
    return __async(this, null, function* () {
      const file = this.fileSystem.getFile(path);
      if (file) {
        file.delete();
      }
    });
  }
};
function doUpdateRecord(data, fields, record) {
  return function_exports.pipe(
    data,
    decodeFrontMatter,
    Either_exports.map((frontmatter) => {
      return Object.fromEntries(
        Object.entries(__spreadValues(__spreadValues({}, frontmatter), record.values)).map(
          (entry) => isDate(entry[1]) ? immer_esm_default(entry, (draft) => {
            draft[1] = (0, import_dayjs.default)(entry[1]).format("YYYY-MM-DD");
          }) : entry
        ).filter(
          (entry) => !fields.find((field) => field.name === entry[0] && field.derived)
        )
      );
    }),
    Either_exports.chain(
      (updated) => encodeFrontMatter(data, updated, getDefaultStringType())
    )
  );
}
function doDeleteField(data, field) {
  return function_exports.pipe(
    data,
    decodeFrontMatter,
    Either_exports.map((frontmatter) => __spreadProps(__spreadValues({}, frontmatter), {
      [field]: void 0
    })),
    Either_exports.chain(
      (frontmatter) => encodeFrontMatter(data, frontmatter, getDefaultStringType())
    )
  );
}
function doRenameField(data, from, to) {
  return function_exports.pipe(
    data,
    decodeFrontMatter,
    Either_exports.map((frontmatter) => __spreadProps(__spreadValues({}, frontmatter), {
      [to]: frontmatter[from],
      [from]: void 0
    })),
    Either_exports.chain(
      (frontmatter) => encodeFrontMatter(data, frontmatter, getDefaultStringType())
    )
  );
}
function createProject() {
  return Object.assign({}, DEFAULT_PROJECT3, {
    id: v4_default(),
    name: nextUniqueProjectName(
      get_store_value(settings).projects,
      get_store_value(i18n).t("modals.project.create.untitled")
    ),
    views: [
      Object.assign({}, DEFAULT_VIEW2, {
        id: v4_default(),
        name: get_store_value(i18n).t("views.table.name"),
        type: "table"
      })
    ]
  });
}
function createDataRecord(name, project, values) {
  let path = "";
  if (project.dataSource.kind === "folder") {
    path = project.dataSource.config.path;
  }
  if (project.newNotesFolder) {
    path = project.newNotesFolder;
  }
  return {
    id: (0, import_obsidian3.normalizePath)(path + "/" + name + ".md"),
    values: values != null ? values : {}
  };
}
function getDefaultStringType() {
  var _a, _b, _c;
  return (_c = (_b = (_a = get_store_value(settings).preferences) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.quoteStrings) != null ? _c : "PLAIN";
}

// src/lib/filesystem/obsidian/obsidian.ts
var import_obsidian4 = require("obsidian");

// src/lib/filesystem/filesystem.ts
var IFile = class {
  readValue(field) {
    return __async(this, null, function* () {
      const values = yield this.readValues();
      return values[field];
    });
  }
  writeValue(field, value) {
    return __async(this, null, function* () {
      this.writeValues(
        immer_esm_default(yield this.readValues(), (draft) => {
          draft[field] = value;
        })
      );
    });
  }
  readValues() {
    return __async(this, null, function* () {
      const data = yield this.read();
      const values = decodeFrontMatter(data);
      return Either_exports.isRight(values) ? values.right : {};
    });
  }
  writeValues(values) {
    return __async(this, null, function* () {
      const data = yield this.read();
      const updatedData = encodeFrontMatter(data, values, "PLAIN");
      if (Either_exports.isRight(updatedData)) {
        this.write(updatedData.right);
      }
    });
  }
};

// src/lib/filesystem/obsidian/obsidian.ts
var ObsidianFile = class extends IFile {
  constructor(file, app3) {
    super();
    this.file = file;
    this.app = app3;
  }
  static of(path, app3) {
    const file = app3.vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(path));
    if (file instanceof import_obsidian4.TFile) {
      return new ObsidianFile(file, app3);
    }
    throw new Error("Not a file");
  }
  get basename() {
    return this.file.basename;
  }
  get path() {
    return this.file.path;
  }
  read() {
    return this.app.vault.read(this.file);
  }
  write(content) {
    return this.app.vault.modify(this.file, content);
  }
  delete() {
    return this.app.vault.trash(this.file, true);
  }
  readTags() {
    const cache = this.app.metadataCache.getFileCache(this.file);
    if (cache) {
      return parseTags(cache);
    }
    return /* @__PURE__ */ new Set();
  }
};
var ObsidianFileSystem = class {
  constructor(app3) {
    this.app = app3;
  }
  create(path, content) {
    return __async(this, null, function* () {
      const file = yield this.app.vault.create((0, import_obsidian4.normalizePath)(path), content);
      return new ObsidianFile(file, this.app);
    });
  }
  read(path) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(path));
      if (file instanceof import_obsidian4.TFile) {
        return this.app.vault.cachedRead(file);
      }
      return "";
    });
  }
  write(path, content) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(path));
      if (file instanceof import_obsidian4.TFile) {
        return this.app.vault.modify(file, content);
      }
    });
  }
  delete(path) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(path));
      if (file instanceof import_obsidian4.TFile) {
        return this.app.vault.trash(file, true);
      }
    });
  }
  getFile(path) {
    if (this.app.vault.getAbstractFileByPath(path)) {
      return ObsidianFile.of(path, this.app);
    }
    return null;
  }
  getAllFiles() {
    return this.app.vault.getMarkdownFiles().map((file) => new ObsidianFile(file, this.app));
  }
};
var ObsidianFileSystemWatcher = class {
  constructor(plugin2) {
    this.plugin = plugin2;
  }
  onCreate(callback) {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian4.TFile) {
          callback(new ObsidianFile(file, app));
        }
      })
    );
  }
  onChange(callback) {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        if (file instanceof import_obsidian4.TFile) {
          callback(new ObsidianFile(file, app));
        }
      })
    );
  }
  onDelete(callback) {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian4.TFile) {
          callback(new ObsidianFile(file, app));
        }
      })
    );
  }
  onRename(callback) {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian4.TFile) {
          callback(new ObsidianFile(file, app), oldPath);
        }
      })
    );
  }
};
function parseTags(cache) {
  var _a, _b, _c, _d;
  const allTags = /* @__PURE__ */ new Set();
  const markdownTags = (_b = (_a = cache.tags) == null ? void 0 : _a.map((tag) => tag.tag)) != null ? _b : [];
  markdownTags.forEach((tag) => allTags.add(tag));
  parseFrontMatterTags((_c = cache.frontmatter) == null ? void 0 : _c["tags"]).forEach(
    (tag) => allTags.add(tag)
  );
  parseFrontMatterTags((_d = cache.frontmatter) == null ? void 0 : _d["tag"]).forEach(
    (tag) => allTags.add(tag)
  );
  return allTags;
}
function parseFrontMatterTags(property) {
  const res = [];
  if (typeof property === "string") {
    property.split(",").map((tag) => "#" + tag.trim()).forEach((tag) => res.push(tag));
  } else if (Array.isArray(property)) {
    property.filter(notEmpty).map((tag) => "#" + tag.toString()).forEach((tag) => res.push(tag));
  }
  return res;
}

// src/lib/stores/fileSystem.ts
var fileSystem = derived(app2, ($app) => new ObsidianFileSystem($app));

// src/lib/stores/api.ts
var api = derived(
  fileSystem,
  ($fileSystem) => new DataApi($fileSystem)
);

// src/modals/create-note-modal.ts
var import_moment2 = __toESM(require_moment());
var import_obsidian12 = require("obsidian");

// src/modals/components/CreateNote.svelte
var import_obsidian9 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right5 = "right";
var left5 = "left";
var auto = "auto";
var basePlacements = [top, bottom, right5, left5];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle2(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min3, value, max3) {
  return max2(min3, min2(value, max3));
}
function withinMaxClamp(min3, value, max3) {
  var v2 = within(min3, value, max3);
  return v2 > max3 ? max3 : v2;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left5, right5].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left5;
  var maxProp = axis === "y" ? bottom : right5;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min3, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left5;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left5 || placement === right5) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left5 || (placement === top || placement === bottom) && variation === end) {
      sideX = right5;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance114 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance114.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance114.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance114.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance114.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element2),
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x2 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right5:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left5:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right5, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right5 : left5 : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right5, bottom, left5].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left5, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left5, right5].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left5;
    var altSide = mainAxis === "y" ? bottom : right5;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min3 = offset2 + overflow[mainSide];
    var max3 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min3, tetherMin) : min3, offset2, tether ? max2(max3, tetherMax) : max3);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left5;
    var _altSide = mainAxis === "x" ? bottom : right5;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left5].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map8 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map8.set(modifier.name, modifier);
  });
  function sort4(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map8.get(dep);
        if (depModifier) {
          sort4(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort4(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve3) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve3(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c2) {
    return p2.replace(/%s/, c2);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
      return self2.indexOf(value) === index2;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
            return '"' + s2 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn3) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance114 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance114.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance: instance114
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve3) {
          instance114.forceUpdate();
          resolve3(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance114;
    }
    instance114.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance114,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance114;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-portal/src/Portal.svelte
function create_fragment(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      div.hidden = true;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(
          null,
          div,
          /*target*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*target*/
      1)
        portal_action.update.call(
          null,
          /*target*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function portal(el, target = "body") {
  let targetEl;
  function update2(newTarget) {
    return __async(this, null, function* () {
      target = newTarget;
      if (typeof target === "string") {
        targetEl = document.querySelector(target);
        if (targetEl === null) {
          yield tick();
          targetEl = document.querySelector(target);
        }
        if (targetEl === null) {
          throw new Error(`No element found matching css selector: "${target}"`);
        }
      } else if (target instanceof HTMLElement) {
        targetEl = target;
      } else {
        throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
      }
      targetEl.appendChild(el);
      el.hidden = false;
    });
  }
  function destroy2() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update2(target);
  return { update: update2, destroy: destroy2 };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { target = "body" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance2, create_fragment, safe_not_equal, { target: 0 });
  }
};
var Portal_default = Portal;

// node_modules/svelte-portal/src/main.es.js
var main_es_default = Portal_default;

// node_modules/obsidian-svelte/Popover/useClickOutside.js
function useClickOutside(element2, { onClickOutside, anchorEl, open }) {
  function onClick(event) {
    if (open && !anchorEl.contains(event.target) && !element2.contains(event.target)) {
      onClickOutside();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(props) {
      onClickOutside = props.onClickOutside;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// node_modules/obsidian-svelte/Popover/Popover.svelte
function add_css(target) {
  append_styles(target, "svelte-1xg3ic1", ".layer.svelte-1xg3ic1{z-index:var(--layer-popover)}");
}
function create_if_block(ctx) {
  let portal2;
  let current;
  portal2 = new main_es_default({
    props: {
      target: document.body,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & /*$$scope, className, popperEl, open, anchorEl*/
      527) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal2, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div;
  let div_class_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = null_to_empty(
        /*className*/
        ctx[2]
      ) + " svelte-1xg3ic1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useClickOutside_action = useClickOutside.call(null, div, {
          open: (
            /*open*/
            ctx[0]
          ),
          anchorEl: (
            /*anchorEl*/
            ctx[1]
          ),
          onClickOutside: (
            /*useClickOutside_function*/
            ctx[8]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      4 && div_class_value !== (div_class_value = null_to_empty(
        /*className*/
        ctx2[2]
      ) + " svelte-1xg3ic1")) {
        attr(div, "class", div_class_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & /*open, anchorEl*/
      3)
        useClickOutside_action.update.call(null, {
          open: (
            /*open*/
            ctx2[0]
          ),
          anchorEl: (
            /*anchorEl*/
            ctx2[1]
          ),
          onClickOutside: (
            /*useClickOutside_function*/
            ctx2[8]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { className = "popover layer" } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  let popperEl;
  let popper2 = null;
  const params = {
    placement,
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 4] }
      }
    ]
  };
  onDestroy(() => {
    if (popper2) {
      popper2.destroy();
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popperEl = $$value;
      $$invalidate(3, popperEl);
    });
  }
  const useClickOutside_function = () => $$invalidate(0, open = false);
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(1, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("onClose" in $$props2)
      $$invalidate(4, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(5, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*anchorEl, popperEl*/
    10) {
      $: {
        if (anchorEl && popperEl) {
          popper2 = createPopper(anchorEl, popperEl, params);
        }
      }
    }
    if ($$self.$$.dirty & /*open, onClose*/
    17) {
      $:
        if (!open) {
          onClose();
        }
    }
  };
  return [
    open,
    anchorEl,
    className,
    popperEl,
    onClose,
    placement,
    slots,
    div_binding,
    useClickOutside_function,
    $$scope
  ];
}
var Popover = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance3,
      create_fragment2,
      safe_not_equal,
      {
        anchorEl: 1,
        open: 0,
        className: 2,
        onClose: 4,
        placement: 5
      },
      add_css
    );
  }
};
var Popover_default = Popover;

// node_modules/obsidian-svelte/Popover/Menu.svelte
function add_css2(target) {
  append_styles(target, "svelte-1d9uueh", ".overflow.svelte-1d9uueh{max-height:300px;overflow-y:auto}");
}
function create_default_slot2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "overflow svelte-1d9uueh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: (
        /*anchorEl*/
        ctx[0]
      ),
      open: (
        /*open*/
        ctx[1]
      ),
      placement: (
        /*placement*/
        ctx[3]
      ),
      className: "menu",
      onClose: (
        /*onClose*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & /*anchorEl*/
      1)
        popover_changes.anchorEl = /*anchorEl*/
        ctx2[0];
      if (dirty & /*open*/
      2)
        popover_changes.open = /*open*/
        ctx2[1];
      if (dirty & /*placement*/
      8)
        popover_changes.placement = /*placement*/
        ctx2[3];
      if (dirty & /*onClose*/
      4)
        popover_changes.onClose = /*onClose*/
        ctx2[2];
      if (dirty & /*$$scope*/
      32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Menu = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance4,
      create_fragment3,
      safe_not_equal,
      {
        anchorEl: 0,
        open: 1,
        onClose: 2,
        placement: 3
      },
      add_css2
    );
  }
};
var Menu_default = Menu;

// node_modules/obsidian-svelte/Switch/Switch.svelte
function add_css3(target) {
  append_styles(target, "svelte-1i6m2hn", ".disabled.svelte-1i6m2hn{opacity:0.6}");
}
function create_fragment4(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<input type="checkbox"/>`;
      attr(div, "class", "checkbox-container svelte-1i6m2hn");
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*disabled*/
      2) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  let { disabled = false } = $$props;
  let ref;
  const dispatch2 = createEventDispatcher();
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const click_handler = () => {
    if (!disabled) {
      $$invalidate(0, checked = !checked);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    1) {
      $:
        dispatch2("check", checked);
    }
    if ($$self.$$.dirty & /*ref, checked*/
    5) {
      $: {
        if (ref) {
          if (checked) {
            ref.classList.add("is-enabled");
          } else {
            ref.classList.remove("is-enabled");
          }
        }
      }
    }
  };
  return [checked, disabled, ref, keypress_handler, div_binding, click_handler];
}
var Switch = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance5, create_fragment4, safe_not_equal, { checked: 0, disabled: 1 }, add_css3);
  }
};
var Switch_default = Switch;

// node_modules/obsidian-svelte/Icon/Icon.svelte
function add_css4(target) {
  append_styles(target, "svelte-s7qdhh", "span.svelte-s7qdhh{color:var(--icon-color);fill:var(--icon-color);opacity:var(--icon-opacity);display:flex;flex:0 1 auto}.icon-xs.svelte-s7qdhh{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-s7qdhh{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-s7qdhh{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-s7qdhh{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}.accent.svelte-s7qdhh{color:var(--text-on-accent);fill:var(--text-on-accent)}");
}
function create_fragment5(ctx) {
  let span;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(
        span,
        "aria-label",
        /*tooltip*/
        ctx[3]
      );
      attr(span, "class", "svelte-s7qdhh");
      toggle_class(
        span,
        "accent",
        /*accent*/
        ctx[2]
      );
      toggle_class(
        span,
        "icon-xs",
        /*size*/
        ctx[1] === "xs"
      );
      toggle_class(
        span,
        "icon-sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        span,
        "icon-md",
        /*size*/
        ctx[1] === "md"
      );
      toggle_class(
        span,
        "icon-lg",
        /*size*/
        ctx[1] === "lg"
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(
          null,
          span,
          /*name*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tooltip*/
      8) {
        attr(
          span,
          "aria-label",
          /*tooltip*/
          ctx2[3]
        );
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & /*name*/
      1)
        useIcon_action.update.call(
          null,
          /*name*/
          ctx2[0]
        );
      if (dirty & /*accent*/
      4) {
        toggle_class(
          span,
          "accent",
          /*accent*/
          ctx2[2]
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          span,
          "icon-xs",
          /*size*/
          ctx2[1] === "xs"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          span,
          "icon-sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          span,
          "icon-md",
          /*size*/
          ctx2[1] === "md"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          span,
          "icon-lg",
          /*size*/
          ctx2[1] === "lg"
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { size: size2 = "md" } = $$props;
  let { accent = false } = $$props;
  let { tooltip = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("size" in $$props2)
      $$invalidate(1, size2 = $$props2.size);
    if ("accent" in $$props2)
      $$invalidate(2, accent = $$props2.accent);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
  };
  return [name, size2, accent, tooltip];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance6, create_fragment5, safe_not_equal, { name: 0, size: 1, accent: 2, tooltip: 3 }, add_css4);
  }
};
var Icon_default = Icon;

// node_modules/obsidian-svelte/Icon/IconButton.svelte
function add_css5(target) {
  append_styles(target, "svelte-r9r5oc", ".nopadding.svelte-r9r5oc{padding:0}.icon-xs.svelte-r9r5oc{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-r9r5oc{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-r9r5oc{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-r9r5oc{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}");
}
function create_fragment6(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "clickable-icon svelte-r9r5oc");
      attr(
        div,
        "aria-label",
        /*tooltip*/
        ctx[3]
      );
      attr(
        div,
        "aria-disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div,
        "nopadding",
        /*nopadding*/
        ctx[4]
      );
      toggle_class(
        div,
        "is-active",
        /*active*/
        ctx[2]
      );
      toggle_class(
        div,
        "icon-xs",
        /*size*/
        ctx[1] === "xs"
      );
      toggle_class(
        div,
        "icon-sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        div,
        "icon-md",
        /*size*/
        ctx[1] === "md"
      );
      toggle_class(
        div,
        "icon-lg",
        /*size*/
        ctx[1] === "lg"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useIcon_action = useIcon.call(
            null,
            div,
            /*icon*/
            ctx[0]
          )),
          listen(
            div,
            "click",
            /*handleClick*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tooltip*/
      8) {
        attr(
          div,
          "aria-label",
          /*tooltip*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled*/
      32) {
        attr(
          div,
          "aria-disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & /*icon*/
      1)
        useIcon_action.update.call(
          null,
          /*icon*/
          ctx2[0]
        );
      if (dirty & /*nopadding*/
      16) {
        toggle_class(
          div,
          "nopadding",
          /*nopadding*/
          ctx2[4]
        );
      }
      if (dirty & /*active*/
      4) {
        toggle_class(
          div,
          "is-active",
          /*active*/
          ctx2[2]
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          div,
          "icon-xs",
          /*size*/
          ctx2[1] === "xs"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          div,
          "icon-sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          div,
          "icon-md",
          /*size*/
          ctx2[1] === "md"
        );
      }
      if (dirty & /*size*/
      2) {
        toggle_class(
          div,
          "icon-lg",
          /*size*/
          ctx2[1] === "lg"
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { size: size2 = "md" } = $$props;
  let { active: active2 = false } = $$props;
  let { tooltip = "" } = $$props;
  let { nopadding = false } = $$props;
  let { disabled = false } = $$props;
  let { onClick = () => {
  } } = $$props;
  function handleClick(event) {
    if (!disabled) {
      onClick(event);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(1, size2 = $$props2.size);
    if ("active" in $$props2)
      $$invalidate(2, active2 = $$props2.active);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("nopadding" in $$props2)
      $$invalidate(4, nopadding = $$props2.nopadding);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("onClick" in $$props2)
      $$invalidate(7, onClick = $$props2.onClick);
  };
  return [icon, size2, active2, tooltip, nopadding, disabled, handleClick, onClick];
}
var IconButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance7,
      create_fragment6,
      safe_not_equal,
      {
        icon: 0,
        size: 1,
        active: 2,
        tooltip: 3,
        nopadding: 4,
        disabled: 5,
        onClick: 7
      },
      add_css5
    );
  }
};
var IconButton_default = IconButton;

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian7 = require("obsidian");
function useIcon(node, name) {
  (0, import_obsidian7.setIcon)(node, name);
  return {
    update(name2) {
      (0, import_obsidian7.setIcon)(node, name2);
    }
  };
}

// node_modules/obsidian-svelte/Popover/MenuItem.svelte
function create_if_block_1(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({ props: { checked: (
    /*checked*/
    ctx[0]
  ) } });
  switch_1.$on(
    "check",
    /*check_handler*/
    ctx[6]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & /*checked*/
      1)
        switch_1_changes.checked = /*checked*/
        ctx2[0];
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "menu-item-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(
          null,
          div,
          /*icon*/
          ctx[2]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & /*icon*/
      4)
        useIcon_action.update.call(
          null,
          /*icon*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment7(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let t22;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*checked*/
    ctx[0] !== void 0 && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*icon*/
    ctx[2] && create_if_block2(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      t22 = text(
        /*label*/
        ctx[1]
      );
      attr(div0, "class", "menu-item-title");
      attr(div1, "class", "menu-item");
      toggle_class(
        div1,
        "selected",
        /*selected*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append4(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append4(div1, t1);
      append4(div1, div0);
      append4(div0, t22);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7]
          ),
          listen(
            div1,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8]
          ),
          listen(
            div1,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*checked*/
        ctx2[0] !== void 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*checked*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*icon*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*label*/
      2)
        set_data(
          t22,
          /*label*/
          ctx2[1]
        );
      if (!current || dirty & /*selected*/
      8) {
        toggle_class(
          div1,
          "selected",
          /*selected*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let selected = false;
  let { icon = "" } = $$props;
  let { checked = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const check_handler = ({ detail: enabled }) => $$invalidate(0, checked = enabled);
  const mouseenter_handler = () => $$invalidate(3, selected = true);
  const mouseleave_handler = () => $$invalidate(3, selected = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    1) {
      $:
        dispatch2("check", checked);
    }
  };
  return [
    checked,
    label,
    icon,
    selected,
    click_handler,
    keypress_handler,
    check_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var MenuItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance8, create_fragment7, safe_not_equal, { label: 1, icon: 2, checked: 0 });
  }
};
var MenuItem_default = MenuItem;

// node_modules/obsidian-svelte/Popover/Suggestion.svelte
function create_default_slot3(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "suggestion");
      set_style(div, "max-height", "300px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: (
        /*anchorEl*/
        ctx[0]
      ),
      open: (
        /*open*/
        ctx[1]
      ),
      placement: (
        /*placement*/
        ctx[3]
      ),
      className: "suggestion-container",
      onClose: (
        /*onClose*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & /*anchorEl*/
      1)
        popover_changes.anchorEl = /*anchorEl*/
        ctx2[0];
      if (dirty & /*open*/
      2)
        popover_changes.open = /*open*/
        ctx2[1];
      if (dirty & /*placement*/
      8)
        popover_changes.placement = /*placement*/
        ctx2[3];
      if (dirty & /*onClose*/
      4)
        popover_changes.onClose = /*onClose*/
        ctx2[2];
      if (dirty & /*$$scope*/
      32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Suggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance9, create_fragment8, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Suggestion_default = Suggestion;

// node_modules/obsidian-svelte/Popover/SuggestionItem.svelte
function create_fragment9(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t22;
  let t3;
  let div3;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      t22 = text(
        /*description*/
        ctx[2]
      );
      t3 = space();
      div3 = element("div");
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-note");
      attr(div2, "class", "suggestion-content");
      attr(div3, "class", "suggestion-aux");
      attr(div4, "class", "suggestion-item mod-complex");
      toggle_class(
        div4,
        "is-selected",
        /*selected*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append4(div4, div2);
      append4(div2, div0);
      append4(div0, t0);
      append4(div2, t1);
      append4(div2, div1);
      append4(div1, t22);
      append4(div4, t3);
      append4(div4, div3);
      ctx[5](div4);
      if (!mounted) {
        dispose = [
          listen(
            div4,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[6]
          ),
          listen(
            div4,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[7]
          ),
          listen(
            div4,
            "mousedown",
            /*mousedown_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*label*/
      2)
        set_data(
          t0,
          /*label*/
          ctx2[1]
        );
      if (dirty & /*description*/
      4)
        set_data(
          t22,
          /*description*/
          ctx2[2]
        );
      if (dirty & /*selected*/
      1) {
        toggle_class(
          div4,
          "is-selected",
          /*selected*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { description = "" } = $$props;
  let { selected = false } = $$props;
  const dispatch2 = createEventDispatcher();
  let ref;
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const mouseenter_handler = () => {
    $$invalidate(0, selected = true);
  };
  const mouseleave_handler = () => $$invalidate(0, selected = false);
  const mousedown_handler = () => dispatch2("click");
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected*/
    1) {
      $:
        dispatch2("select", selected);
    }
    if ($$self.$$.dirty & /*selected, ref*/
    9) {
      $: {
        if (selected && ref) {
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }
    }
  };
  return [
    selected,
    label,
    description,
    ref,
    dispatch2,
    div4_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousedown_handler
  ];
}
var SuggestionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance10, create_fragment9, safe_not_equal, { label: 1, description: 2, selected: 0 });
  }
};
var SuggestionItem_default = SuggestionItem;

// node_modules/obsidian-svelte/Input/Input.svelte
function add_css6(target) {
  append_styles(target, "svelte-su9mt0", ".embed.svelte-su9mt0{all:unset;box-sizing:border-box;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal)}.embed.svelte-su9mt0:focus{box-shadow:none}.noPadding.svelte-su9mt0{padding:0}.error.svelte-su9mt0{border-color:var(--background-modifier-error)}.error.svelte-su9mt0:hover{border-color:var(--background-modifier-error-hover)}.error.svelte-su9mt0:focus{box-shadow:0 0 0 2px var(--background-modifier-error);border-color:var(--background-modifier-error)}small.svelte-su9mt0{margin-top:var(--size-4-1);font-size:var(--font-ui-smaller);color:var(--text-muted);display:block}.errorText.svelte-su9mt0{color:var(--text-error)}");
}
function create_if_block3(ctx) {
  let small;
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(
        /*helperText*/
        ctx[9]
      );
      attr(small, "class", "svelte-su9mt0");
      toggle_class(
        small,
        "errorText",
        /*error*/
        ctx[6]
      );
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append4(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*helperText*/
      512)
        set_data(
          t3,
          /*helperText*/
          ctx2[9]
        );
      if (dirty & /*error*/
      64) {
        toggle_class(
          small,
          "errorText",
          /*error*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment10(ctx) {
  let div;
  let input;
  let input_style_value;
  let t3;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = !!/*helperText*/
  ctx[9] && create_if_block3(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t3 = space();
      if (if_block)
        if_block.c();
      input.value = /*value*/
      ctx[2];
      attr(
        input,
        "type",
        /*type*/
        ctx[1]
      );
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      input.readOnly = /*readonly*/
      ctx[3];
      attr(input, "style", input_style_value = `width: ${/*width*/
      ctx[5]}`);
      attr(input, "class", "svelte-su9mt0");
      toggle_class(
        input,
        "error",
        /*error*/
        ctx[6]
      );
      toggle_class(
        input,
        "embed",
        /*embed*/
        ctx[7]
      );
      toggle_class(
        input,
        "noPadding",
        /*noPadding*/
        ctx[8]
      );
      attr(div, "style", div_style_value = `width: ${/*width*/
      ctx[5]}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, input);
      ctx[16](input);
      append4(div, t3);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[11]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[12]
          ),
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[13]
          ),
          listen(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[14]
          ),
          listen(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      4 && input.value !== /*value*/
      ctx2[2]) {
        input.value = /*value*/
        ctx2[2];
      }
      if (dirty & /*type*/
      2) {
        attr(
          input,
          "type",
          /*type*/
          ctx2[1]
        );
      }
      if (dirty & /*placeholder*/
      16) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (dirty & /*readonly*/
      8) {
        input.readOnly = /*readonly*/
        ctx2[3];
      }
      if (dirty & /*width*/
      32 && input_style_value !== (input_style_value = `width: ${/*width*/
      ctx2[5]}`)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & /*error*/
      64) {
        toggle_class(
          input,
          "error",
          /*error*/
          ctx2[6]
        );
      }
      if (dirty & /*embed*/
      128) {
        toggle_class(
          input,
          "embed",
          /*embed*/
          ctx2[7]
        );
      }
      if (dirty & /*noPadding*/
      256) {
        toggle_class(
          input,
          "noPadding",
          /*noPadding*/
          ctx2[8]
        );
      }
      if (!!/*helperText*/
      ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*width*/
      32 && div_style_value !== (div_style_value = `width: ${/*width*/
      ctx2[5]}`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  onMount(() => {
    if (autoFocus && ref) {
      ref.focus();
    }
  });
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(10, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    4) {
      $:
        dispatch2("input", value);
    }
  };
  return [
    ref,
    type,
    value,
    readonly,
    placeholder,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    autoFocus,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    input_binding
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance11,
      create_fragment10,
      safe_not_equal,
      {
        type: 1,
        value: 2,
        ref: 0,
        readonly: 3,
        placeholder: 4,
        autoFocus: 10,
        width: 5,
        error: 6,
        embed: 7,
        noPadding: 8,
        helperText: 9
      },
      add_css6
    );
  }
};
var Input_default = Input;

// node_modules/obsidian-svelte/Input/TextInput.svelte
function create_fragment11(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "text",
    readonly: (
      /*readonly*/
      ctx[2]
    ),
    noPadding: (
      /*noPadding*/
      ctx[9]
    ),
    placeholder: (
      /*placeholder*/
      ctx[3]
    ),
    autoFocus: (
      /*autoFocus*/
      ctx[4]
    ),
    width: (
      /*width*/
      ctx[5]
    ),
    embed: (
      /*embed*/
      ctx[8]
    ),
    error: (
      /*error*/
      ctx[6]
    ),
    helperText: (
      /*helperText*/
      ctx[7]
    )
  };
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    input_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    input_props.value = /*value*/
    ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind6(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind6(input, "value", input_value_binding));
  input.$on(
    "input",
    /*handleInput*/
    ctx[10]
  );
  input.$on(
    "focus",
    /*focus_handler*/
    ctx[13]
  );
  input.$on(
    "blur",
    /*blur_handler*/
    ctx[14]
  );
  input.$on(
    "keydown",
    /*keydown_handler*/
    ctx[15]
  );
  input.$on(
    "keyup",
    /*keyup_handler*/
    ctx[16]
  );
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & /*readonly*/
      4)
        input_changes.readonly = /*readonly*/
        ctx2[2];
      if (dirty & /*noPadding*/
      512)
        input_changes.noPadding = /*noPadding*/
        ctx2[9];
      if (dirty & /*placeholder*/
      8)
        input_changes.placeholder = /*placeholder*/
        ctx2[3];
      if (dirty & /*autoFocus*/
      16)
        input_changes.autoFocus = /*autoFocus*/
        ctx2[4];
      if (dirty & /*width*/
      32)
        input_changes.width = /*width*/
        ctx2[5];
      if (dirty & /*embed*/
      256)
        input_changes.embed = /*embed*/
        ctx2[8];
      if (dirty & /*error*/
      64)
        input_changes.error = /*error*/
        ctx2[6];
      if (dirty & /*helperText*/
      128)
        input_changes.helperText = /*helperText*/
        ctx2[7];
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        input_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { helperText = "" } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { ref = null } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.value);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("helperText" in $$props2)
      $$invalidate(7, helperText = $$props2.helperText);
    if ("embed" in $$props2)
      $$invalidate(8, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(9, noPadding = $$props2.noPadding);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        dispatch2("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    helperText,
    embed,
    noPadding,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance12, create_fragment11, safe_not_equal, {
      value: 0,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      helperText: 7,
      embed: 8,
      noPadding: 9,
      ref: 1
    });
  }
};
var TextInput_default = TextInput;

// node_modules/obsidian-svelte/Input/NumberInput.svelte
function create_fragment12(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "number",
    readonly: (
      /*readonly*/
      ctx[2]
    ),
    placeholder: (
      /*placeholder*/
      ctx[3]
    ),
    autoFocus: (
      /*autoFocus*/
      ctx[4]
    ),
    width: (
      /*width*/
      ctx[5]
    ),
    embed: (
      /*embed*/
      ctx[7]
    ),
    noPadding: (
      /*noPadding*/
      ctx[8]
    ),
    error: (
      /*error*/
      ctx[6]
    ),
    helperText: (
      /*helperText*/
      ctx[9]
    )
  };
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    input_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    input_props.value = /*value*/
    ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind6(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind6(input, "value", input_value_binding));
  input.$on(
    "input",
    /*handleInput*/
    ctx[10]
  );
  input.$on(
    "focus",
    /*focus_handler*/
    ctx[13]
  );
  input.$on(
    "blur",
    /*blur_handler*/
    ctx[14]
  );
  input.$on(
    "keydown",
    /*keydown_handler*/
    ctx[15]
  );
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & /*readonly*/
      4)
        input_changes.readonly = /*readonly*/
        ctx2[2];
      if (dirty & /*placeholder*/
      8)
        input_changes.placeholder = /*placeholder*/
        ctx2[3];
      if (dirty & /*autoFocus*/
      16)
        input_changes.autoFocus = /*autoFocus*/
        ctx2[4];
      if (dirty & /*width*/
      32)
        input_changes.width = /*width*/
        ctx2[5];
      if (dirty & /*embed*/
      128)
        input_changes.embed = /*embed*/
        ctx2[7];
      if (dirty & /*noPadding*/
      256)
        input_changes.noPadding = /*noPadding*/
        ctx2[8];
      if (dirty & /*error*/
      64)
        input_changes.error = /*error*/
        ctx2[6];
      if (dirty & /*helperText*/
      512)
        input_changes.helperText = /*helperText*/
        ctx2[9];
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        input_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        dispatch2("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler
  ];
}
var NumberInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance13, create_fragment12, safe_not_equal, {
      value: 0,
      ref: 1,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    });
  }
};
var NumberInput_default = NumberInput;

// node_modules/obsidian-svelte/Autocomplete/Autocomplete.svelte
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2].label;
  child_ctx[24] = list[i2].description;
  child_ctx[26] = i2;
  return child_ctx;
}
function create_if_block4(ctx) {
  let suggestionitem;
  let current;
  suggestionitem = new SuggestionItem_default({
    props: { label: "", description: "No options" }
  });
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_each_block(ctx) {
  let suggestionitem;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[20](
        /*i*/
        ctx[26]
      )
    );
  }
  function select_handler(...args) {
    return (
      /*select_handler*/
      ctx[21](
        /*i*/
        ctx[26],
        ...args
      )
    );
  }
  suggestionitem = new SuggestionItem_default({
    props: {
      label: (
        /*label*/
        ctx[23]
      ),
      description: (
        /*description*/
        ctx[24]
      ),
      selected: (
        /*selected*/
        ctx[8] === /*i*/
        ctx[26]
      )
    }
  });
  suggestionitem.$on("click", click_handler);
  suggestionitem.$on("select", select_handler);
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const suggestionitem_changes = {};
      if (dirty & /*filteredOptions*/
      1024)
        suggestionitem_changes.label = /*label*/
        ctx[23];
      if (dirty & /*filteredOptions*/
      1024)
        suggestionitem_changes.description = /*description*/
        ctx[24];
      if (dirty & /*selected*/
      256)
        suggestionitem_changes.selected = /*selected*/
        ctx[8] === /*i*/
        ctx[26];
      suggestionitem.$set(suggestionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let t3;
  let each_1_anchor;
  let current;
  let if_block = !/*filteredOptions*/
  ctx[10].length && create_if_block4(ctx);
  let each_value = (
    /*filteredOptions*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*filteredOptions*/
      ctx2[10].length) {
        if (if_block) {
          if (dirty & /*filteredOptions*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*filteredOptions, selected, value, dispatch*/
      3329) {
        each_value = /*filteredOptions*/
        ctx2[10];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment13(ctx) {
  let textinput;
  let updating_value;
  let updating_ref;
  let t3;
  let suggestion;
  let current;
  function textinput_value_binding(value) {
    ctx[14](value);
  }
  function textinput_ref_binding(value) {
    ctx[15](value);
  }
  let textinput_props = {
    readonly: (
      /*readonly*/
      ctx[2]
    ),
    width: (
      /*width*/
      ctx[4]
    ),
    placeholder: (
      /*placeholder*/
      ctx[3]
    ),
    autoFocus: (
      /*autoFocus*/
      ctx[6]
    ),
    embed: (
      /*embed*/
      ctx[5]
    )
  };
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    textinput_props.value = /*value*/
    ctx[0];
  }
  if (
    /*inputRef*/
    ctx[9] !== void 0
  ) {
    textinput_props.ref = /*inputRef*/
    ctx[9];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind6(textinput, "value", textinput_value_binding));
  binding_callbacks.push(() => bind6(textinput, "ref", textinput_ref_binding));
  textinput.$on(
    "focus",
    /*focus_handler*/
    ctx[16]
  );
  textinput.$on(
    "blur",
    /*blur_handler*/
    ctx[17]
  );
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[18]
  );
  textinput.$on(
    "keydown",
    /*keydown_handler*/
    ctx[19]
  );
  suggestion = new Suggestion_default({
    props: {
      anchorEl: (
        /*inputRef*/
        ctx[9]
      ),
      open: (
        /*open*/
        ctx[1]
      ),
      onClose: (
        /*func*/
        ctx[22]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
      t3 = space();
      create_component(suggestion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t3, anchor);
      mount_component(suggestion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*readonly*/
      4)
        textinput_changes.readonly = /*readonly*/
        ctx2[2];
      if (dirty & /*width*/
      16)
        textinput_changes.width = /*width*/
        ctx2[4];
      if (dirty & /*placeholder*/
      8)
        textinput_changes.placeholder = /*placeholder*/
        ctx2[3];
      if (dirty & /*autoFocus*/
      64)
        textinput_changes.autoFocus = /*autoFocus*/
        ctx2[6];
      if (dirty & /*embed*/
      32)
        textinput_changes.embed = /*embed*/
        ctx2[5];
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        textinput_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_ref && dirty & /*inputRef*/
      512) {
        updating_ref = true;
        textinput_changes.ref = /*inputRef*/
        ctx2[9];
        add_flush_callback(() => updating_ref = false);
      }
      textinput.$set(textinput_changes);
      const suggestion_changes = {};
      if (dirty & /*inputRef*/
      512)
        suggestion_changes.anchorEl = /*inputRef*/
        ctx2[9];
      if (dirty & /*open*/
      2)
        suggestion_changes.open = /*open*/
        ctx2[1];
      if (dirty & /*open*/
      2)
        suggestion_changes.onClose = /*func*/
        ctx2[22];
      if (dirty & /*$$scope, filteredOptions, selected, value*/
      134219009) {
        suggestion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suggestion.$set(suggestion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(suggestion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(suggestion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t3);
      destroy_component(suggestion, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let filteredOptions;
  let { value } = $$props;
  let { options } = $$props;
  let { maxItems = 50 } = $$props;
  let { open = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { embed = false } = $$props;
  let { autoFocus = false } = $$props;
  let selected = -1;
  let inputRef;
  const dispatch2 = createEventDispatcher();
  let willClose = false;
  function textinput_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textinput_ref_binding(value2) {
    inputRef = value2;
    $$invalidate(9, inputRef);
  }
  const focus_handler = () => $$invalidate(1, open = true);
  const blur_handler = (event) => {
    $$invalidate(1, open = false);
    dispatch2("change", value);
    dispatch2("blur", event);
  };
  const input_handler = () => $$invalidate(1, open = true);
  const keydown_handler = (event) => {
    var _a, _b;
    if (open) {
      switch (event.key) {
        case "ArrowUp":
          const prev = selected - 1;
          $$invalidate(8, selected = prev < 0 ? filteredOptions.length - 1 : prev);
          event.stopPropagation();
          break;
        case "ArrowDown":
          const next2 = selected + 1;
          $$invalidate(8, selected = next2 > filteredOptions.length - 1 ? 0 : next2);
          event.stopPropagation();
          break;
        case "Enter":
          $$invalidate(0, value = (_b = (_a = filteredOptions[selected]) == null ? void 0 : _a.label) != null ? _b : value);
          $$invalidate(7, willClose = true);
          break;
      }
    }
  };
  const click_handler = (i2) => {
    var _a, _b;
    $$invalidate(0, value = (_b = (_a = filteredOptions[i2]) == null ? void 0 : _a.label) != null ? _b : value);
    dispatch2("change", value);
  };
  const select_handler = (i2, { detail }) => {
    if (detail) {
      $$invalidate(8, selected = i2);
    }
  };
  const func8 = () => $$invalidate(1, open = false);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("options" in $$props2)
      $$invalidate(12, options = $$props2.options);
    if ("maxItems" in $$props2)
      $$invalidate(13, maxItems = $$props2.maxItems);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("embed" in $$props2)
      $$invalidate(5, embed = $$props2.embed);
    if ("autoFocus" in $$props2)
      $$invalidate(6, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*options, value, maxItems*/
    12289) {
      $:
        $$invalidate(10, filteredOptions = options.filter((option2) => !value || option2.label.toLocaleLowerCase().contains(value.toLocaleLowerCase())).slice(0, Math.min(maxItems, options.length)));
    }
    if ($$self.$$.dirty & /*willClose*/
    128) {
      $:
        if (willClose) {
          $$invalidate(1, open = false);
          $$invalidate(7, willClose = false);
        }
    }
  };
  return [
    value,
    open,
    readonly,
    placeholder,
    width,
    embed,
    autoFocus,
    willClose,
    selected,
    inputRef,
    filteredOptions,
    dispatch2,
    options,
    maxItems,
    textinput_value_binding,
    textinput_ref_binding,
    focus_handler,
    blur_handler,
    input_handler,
    keydown_handler,
    click_handler,
    select_handler,
    func8
  ];
}
var Autocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance14, create_fragment13, safe_not_equal, {
      value: 0,
      options: 12,
      maxItems: 13,
      open: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      embed: 5,
      autoFocus: 6
    });
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/obsidian-svelte/Autocomplete/FileAutocomplete.svelte
function create_fragment14(ctx) {
  let autocomplete;
  let updating_value;
  let updating_options;
  let current;
  function autocomplete_value_binding(value) {
    ctx[10](value);
  }
  function autocomplete_options_binding(value) {
    ctx[11](value);
  }
  let autocomplete_props = {
    readonly: (
      /*readonly*/
      ctx[2]
    ),
    placeholder: (
      /*placeholder*/
      ctx[3]
    ),
    width: (
      /*width*/
      ctx[4]
    ),
    embed: (
      /*embed*/
      ctx[1]
    ),
    autoFocus: (
      /*autoFocus*/
      ctx[5]
    )
  };
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    autocomplete_props.value = /*value*/
    ctx[0];
  }
  if (
    /*options*/
    ctx[6] !== void 0
  ) {
    autocomplete_props.options = /*options*/
    ctx[6];
  }
  autocomplete = new Autocomplete_default({ props: autocomplete_props });
  binding_callbacks.push(() => bind6(autocomplete, "value", autocomplete_value_binding));
  binding_callbacks.push(() => bind6(autocomplete, "options", autocomplete_options_binding));
  autocomplete.$on(
    "change",
    /*change_handler*/
    ctx[12]
  );
  autocomplete.$on(
    "blur",
    /*blur_handler*/
    ctx[13]
  );
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const autocomplete_changes = {};
      if (dirty & /*readonly*/
      4)
        autocomplete_changes.readonly = /*readonly*/
        ctx2[2];
      if (dirty & /*placeholder*/
      8)
        autocomplete_changes.placeholder = /*placeholder*/
        ctx2[3];
      if (dirty & /*width*/
      16)
        autocomplete_changes.width = /*width*/
        ctx2[4];
      if (dirty & /*embed*/
      2)
        autocomplete_changes.embed = /*embed*/
        ctx2[1];
      if (dirty & /*autoFocus*/
      32)
        autocomplete_changes.autoFocus = /*autoFocus*/
        ctx2[5];
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        autocomplete_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_options && dirty & /*options*/
      64) {
        updating_options = true;
        autocomplete_changes.options = /*options*/
        ctx2[6];
        add_flush_callback(() => updating_options = false);
      }
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let options;
  let { value } = $$props;
  let { files } = $$props;
  let { getLabel = (file) => file.name } = $$props;
  let { getDescription = () => "" } = $$props;
  let { embed = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { autoFocus = false } = $$props;
  function autocomplete_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function autocomplete_options_binding(value2) {
    options = value2;
    $$invalidate(6, options), $$invalidate(7, files), $$invalidate(8, getLabel), $$invalidate(9, getDescription);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("files" in $$props2)
      $$invalidate(7, files = $$props2.files);
    if ("getLabel" in $$props2)
      $$invalidate(8, getLabel = $$props2.getLabel);
    if ("getDescription" in $$props2)
      $$invalidate(9, getDescription = $$props2.getDescription);
    if ("embed" in $$props2)
      $$invalidate(1, embed = $$props2.embed);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("autoFocus" in $$props2)
      $$invalidate(5, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*files, getLabel, getDescription*/
    896) {
      $:
        $$invalidate(6, options = files.map((file) => ({
          label: getLabel(file),
          description: getDescription(file)
        })));
    }
  };
  return [
    value,
    embed,
    readonly,
    placeholder,
    width,
    autoFocus,
    options,
    files,
    getLabel,
    getDescription,
    autocomplete_value_binding,
    autocomplete_options_binding,
    change_handler,
    blur_handler
  ];
}
var FileAutocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance15, create_fragment14, safe_not_equal, {
      value: 0,
      files: 7,
      getLabel: 8,
      getDescription: 9,
      embed: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      autoFocus: 5
    });
  }
};
var FileAutocomplete_default = FileAutocomplete;

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css7(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment15(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*tooltip*/
        ctx[3]
      );
      button.disabled = /*disabled*/
      ctx[2];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(
        button,
        "mod-cta",
        /*variant*/
        ctx[1] === "primary"
      );
      toggle_class(
        button,
        "mod-warning",
        /*variant*/
        ctx[1] === "destructive"
      );
      toggle_class(
        button,
        "mod-plain",
        /*variant*/
        ctx[1] === "plain"
      );
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tooltip*/
      8) {
        attr(
          button,
          "aria-label",
          /*tooltip*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        button.disabled = /*disabled*/
        ctx2[2];
      }
      if (!current || dirty & /*variant*/
      2) {
        toggle_class(
          button,
          "mod-cta",
          /*variant*/
          ctx2[1] === "primary"
        );
      }
      if (!current || dirty & /*variant*/
      2) {
        toggle_class(
          button,
          "mod-warning",
          /*variant*/
          ctx2[1] === "destructive"
        );
      }
      if (!current || dirty & /*variant*/
      2) {
        toggle_class(
          button,
          "mod-plain",
          /*variant*/
          ctx2[1] === "plain"
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        toggle_class(
          button,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  let { ref = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [ref, variant, disabled, tooltip, $$scope, slots, click_handler, button_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance16,
      create_fragment15,
      safe_not_equal,
      {
        variant: 1,
        disabled: 2,
        tooltip: 3,
        ref: 0
      },
      add_css7
    );
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/Callout/Callout.svelte
function create_fragment16(ctx) {
  let div4;
  let div2;
  let div0;
  let useIcon_action;
  let t0;
  let div1;
  let t1;
  let t22;
  let div3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(
        /*title*/
        ctx[0]
      );
      t22 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "callout-icon");
      attr(div1, "class", "callout-title-inner");
      attr(div2, "class", "callout-title");
      attr(div3, "class", "callout-content");
      attr(div4, "data-callout-metadata", "");
      attr(div4, "data-callout-fold", "");
      attr(
        div4,
        "data-callout",
        /*variant*/
        ctx[2]
      );
      attr(div4, "class", "callout");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append4(div4, div2);
      append4(div2, div0);
      append4(div2, t0);
      append4(div2, div1);
      append4(div1, t1);
      append4(div4, t22);
      append4(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(
          null,
          div0,
          /*icon*/
          ctx[1]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & /*icon*/
      2)
        useIcon_action.update.call(
          null,
          /*icon*/
          ctx2[1]
        );
      if (!current || dirty & /*title*/
      1)
        set_data(
          t1,
          /*title*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*variant*/
      4) {
        attr(
          div4,
          "data-callout",
          /*variant*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { icon } = $$props;
  let { variant } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [title, icon, variant, $$scope, slots];
}
var Callout = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance17, create_fragment16, safe_not_equal, { title: 0, icon: 1, variant: 2 });
  }
};
var Callout_default = Callout;

// node_modules/obsidian-svelte/Checkbox/Checkbox.svelte
function create_fragment17(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      input.checked = /*checked*/
      ctx[0];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "dblclick", stop_propagation(
            /*dblclick_handler*/
            ctx[2]
          )),
          listen(input, "click", stop_propagation(
            /*click_handler*/
            ctx[3]
          )),
          listen(
            input,
            "change",
            /*handleChange*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, checked = event.currentTarget.checked);
    }
  }
  function dblclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    1) {
      $:
        dispatch2("check", checked);
    }
  };
  return [checked, handleChange, dblclick_handler, click_handler];
}
var Checkbox = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance18, create_fragment17, safe_not_equal, { checked: 0 });
  }
};
var Checkbox_default = Checkbox;

// node_modules/obsidian-svelte/ColorInput/ColorInput.svelte
function create_fragment18(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "color");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[1]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { value } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, input_handler, change_handler, input_input_handler];
}
var ColorInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance19, create_fragment18, safe_not_equal, { value: 0 });
  }
};
var ColorInput_default = ColorInput;

// node_modules/obsidian-svelte/DateInput/DateInput.svelte
var import_dayjs2 = __toESM(require_dayjs_min());
function add_css8(target) {
  append_styles(target, "svelte-2qn54x", "input.svelte-2qn54x{border-radius:9999px;border:0;background-color:var(--background-modifier-hover);font-family:var(--font-default);padding:0.1em 0.6em}.embed.svelte-2qn54x{margin:0 8px}");
}
function create_fragment19(ctx) {
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "date");
      input.value = input_value_value = /*value*/
      ctx[0] ? (0, import_dayjs2.default)(
        /*value*/
        ctx[0]
      ).format("YYYY-MM-DD") : null;
      attr(input, "class", "svelte-2qn54x");
      toggle_class(
        input,
        "embed",
        /*embed*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*handleChange*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && input_value_value !== (input_value_value = /*value*/
      ctx2[0] ? (0, import_dayjs2.default)(
        /*value*/
        ctx2[0]
      ).format("YYYY-MM-DD") : null)) {
        input.value = input_value_value;
      }
      if (dirty & /*embed*/
      2) {
        toggle_class(
          input,
          "embed",
          /*embed*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { embed = false } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      dispatch2("change", event.currentTarget.value ? (0, import_dayjs2.default)(event.currentTarget.value).toDate() : null);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("embed" in $$props2)
      $$invalidate(1, embed = $$props2.embed);
  };
  return [value, embed, handleChange];
}
var DateInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance20, create_fragment19, safe_not_equal, { value: 0, embed: 1 }, add_css8);
  }
};
var DateInput_default = DateInput;

// node_modules/obsidian-svelte/Link/InternalLink.svelte
function add_css9(target) {
  append_styles(target, "svelte-u3bamg", ".is-unresolved.svelte-u3bamg{opacity:0.5}");
}
function create_fragment20(ctx) {
  let a2;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let a_levels = [
    { href: (
      /*linkText*/
      ctx[0]
    ) },
    { "data-href": (
      /*linkText*/
      ctx[0]
    ) },
    { class: a_class_value = `internal-link` },
    { target: "_blank" },
    { rel: "noopener" },
    /*aria*/
    ctx[3]
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign(a_data, a_levels[i2]);
  }
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a2, a_data);
      toggle_class(a2, "is-unresolved", !/*resolved*/
      ctx[2]);
      toggle_class(a2, "svelte-u3bamg", true);
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          a2,
          "click",
          /*click_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a2, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*linkText*/
        1) && { href: (
          /*linkText*/
          ctx2[0]
        ) },
        (!current || dirty & /*linkText*/
        1) && { "data-href": (
          /*linkText*/
          ctx2[0]
        ) },
        { class: a_class_value },
        { target: "_blank" },
        { rel: "noopener" },
        dirty & /*aria*/
        8 && /*aria*/
        ctx2[3]
      ]));
      toggle_class(a2, "is-unresolved", !/*resolved*/
      ctx2[2]);
      toggle_class(a2, "svelte-u3bamg", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { linkText } = $$props;
  let { sourcePath } = $$props;
  let { tooltip = "" } = $$props;
  let { resolved } = $$props;
  const dispatch2 = createEventDispatcher();
  let aria = {};
  if (tooltip) {
    aria = {
      "aria-label": tooltip,
      "aria-label-position": "top"
    };
  }
  const click_handler = (event) => {
    event.stopPropagation();
    dispatch2("open", {
      linkText,
      sourcePath,
      newLeaf: event.ctrlKey || event.metaKey
    });
  };
  $$self.$$set = ($$props2) => {
    if ("linkText" in $$props2)
      $$invalidate(0, linkText = $$props2.linkText);
    if ("sourcePath" in $$props2)
      $$invalidate(1, sourcePath = $$props2.sourcePath);
    if ("tooltip" in $$props2)
      $$invalidate(5, tooltip = $$props2.tooltip);
    if ("resolved" in $$props2)
      $$invalidate(2, resolved = $$props2.resolved);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    linkText,
    sourcePath,
    resolved,
    aria,
    dispatch2,
    tooltip,
    $$scope,
    slots,
    click_handler
  ];
}
var InternalLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance21,
      create_fragment20,
      safe_not_equal,
      {
        linkText: 0,
        sourcePath: 1,
        tooltip: 5,
        resolved: 2
      },
      add_css9
    );
  }
};
var InternalLink_default = InternalLink;

// node_modules/svelte/easing/index.mjs
function cubicOut(t3) {
  const f2 = t3 - 1;
  return f2 * f2 * f2 + 1;
}

// node_modules/svelte/transition/index.mjs
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity2 } = {}) {
  const o2 = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t3) => `opacity: ${t3 * o2}`
  };
}
function slide(node, { delay: delay2 = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
  return {
    delay: delay2,
    duration,
    easing,
    css: (t3) => `overflow: hidden;opacity: ${Math.min(t3 * 20, 1) * opacity};${primary_property}: ${t3 * primary_property_value}px;padding-${secondary_properties[0]}: ${t3 * padding_start_value}px;padding-${secondary_properties[1]}: ${t3 * padding_end_value}px;margin-${secondary_properties[0]}: ${t3 * margin_start_value}px;margin-${secondary_properties[1]}: ${t3 * margin_end_value}px;border-${secondary_properties[0]}-width: ${t3 * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t3 * border_width_end_value}px;`
  };
}

// node_modules/obsidian-svelte/Loading/Loading.svelte
function create_fragment21(ctx) {
  let div9;
  let div9_transition;
  let current;
  return {
    c() {
      div9 = element("div");
      div9.innerHTML = `<div class="sk-cube sk-cube1"></div> 
	<div class="sk-cube sk-cube2"></div> 
	<div class="sk-cube sk-cube3"></div> 
	<div class="sk-cube sk-cube4"></div> 
	<div class="sk-cube sk-cube5"></div> 
	<div class="sk-cube sk-cube6"></div> 
	<div class="sk-cube sk-cube7"></div> 
	<div class="sk-cube sk-cube8"></div> 
	<div class="sk-cube sk-cube9"></div>`;
      attr(div9, "class", "loader-cube");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!div9_transition)
          div9_transition = create_bidirectional_transition(div9, fade, { duration: 200 }, true);
        div9_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div9_transition)
        div9_transition = create_bidirectional_transition(div9, fade, { duration: 200 }, false);
      div9_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      if (detaching && div9_transition)
        div9_transition.end();
    }
  };
}
var Loading = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, null, create_fragment21, safe_not_equal, {});
  }
};
var Loading_default = Loading;

// node_modules/obsidian-svelte/Modal/ModalButtonGroup.svelte
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-button-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalButtonGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance22, create_fragment22, safe_not_equal, {});
  }
};
var ModalButtonGroup_default = ModalButtonGroup;

// node_modules/obsidian-svelte/Modal/ModalContent.svelte
function create_fragment23(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance23, create_fragment23, safe_not_equal, {});
  }
};
var ModalContent_default = ModalContent;

// node_modules/obsidian-svelte/Modal/ModalLayout.svelte
function create_fragment24(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t0);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
var ModalLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance24, create_fragment24, safe_not_equal, { title: 0 });
  }
};
var ModalLayout_default = ModalLayout;

// node_modules/obsidian-svelte/Select/SelectItem.svelte
function create_fragment25(ctx) {
  let option2;
  let t_value = (
    /*text*/
    (ctx[0] || /*value*/
    ctx[1]) + ""
  );
  let t3;
  return {
    c() {
      option2 = element("option");
      t3 = text(t_value);
      option2.__value = /*value*/
      ctx[1];
      option2.value = option2.__value;
      option2.disabled = /*disabled*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, option2, anchor);
      append4(option2, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text, value*/
      3 && t_value !== (t_value = /*text*/
      (ctx2[0] || /*value*/
      ctx2[1]) + ""))
        set_data(t3, t_value);
      if (dirty & /*value*/
      2) {
        option2.__value = /*value*/
        ctx2[1];
        option2.value = option2.__value;
      }
      if (dirty & /*disabled*/
      4) {
        option2.disabled = /*disabled*/
        ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(option2);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [text2, value, disabled];
}
var SelectItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance25, create_fragment25, safe_not_equal, { text: 0, value: 1, disabled: 2 });
  }
};
var SelectItem_default = SelectItem;

// node_modules/obsidian-svelte/Select/Select.svelte
function get_each_context2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: (
        /*placeholder*/
        ctx[2]
      ),
      value: "",
      disabled: true
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & /*placeholder*/
      4)
        selectitem_changes.text = /*placeholder*/
        ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: { text: (
      /*placeholder*/
      ctx[2]
    ), value: "" }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & /*placeholder*/
      4)
        selectitem_changes.text = /*placeholder*/
        ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: (
        /*option*/
        ctx[8].label
      ),
      value: (
        /*option*/
        ctx[8].value
      )
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & /*options*/
      1)
        selectitem_changes.text = /*option*/
        ctx2[8].label;
      if (dirty & /*options*/
      1)
        selectitem_changes.value = /*option*/
        ctx2[8].value;
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_fragment26(ctx) {
  let select;
  let if_block0_anchor;
  let if_block1_anchor;
  let select_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*options*/
  ctx[0].length && /*placeholder*/
  ctx[2] && create_if_block_12(ctx);
  let if_block1 = (
    /*allowEmpty*/
    ctx[3] && create_if_block5(ctx)
  );
  let each_value = (
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      select = element("select");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty3();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty3();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(
        select,
        "aria-label",
        /*tooltip*/
        ctx[5]
      );
      select.disabled = select_disabled_value = /*disabled*/
      ctx[4] || !/*options*/
      ctx[0].length && !!/*placeholder*/
      ctx[2];
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block0)
        if_block0.m(select, null);
      append4(select, if_block0_anchor);
      if (if_block1)
        if_block1.m(select, null);
      append4(select, if_block1_anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*value*/
        ctx[1]
      );
      current = true;
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*handleChange*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*options*/
      ctx2[0].length && /*placeholder*/
      ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*options, placeholder*/
          5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(select, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*allowEmpty*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*allowEmpty*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(select, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & /*options*/
      1) {
        each_value = /*options*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(select, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & /*tooltip*/
      32) {
        attr(
          select,
          "aria-label",
          /*tooltip*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*disabled, options, placeholder*/
      21 && select_disabled_value !== (select_disabled_value = /*disabled*/
      ctx2[4] || !/*options*/
      ctx2[0].length && !!/*placeholder*/
      ctx2[2])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & /*value*/
      2) {
        select_option(
          select,
          /*value*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { value } = $$props;
  let { placeholder = "" } = $$props;
  let { allowEmpty = false } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLSelectElement) {
      dispatch2("change", event.currentTarget.value);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("allowEmpty" in $$props2)
      $$invalidate(3, allowEmpty = $$props2.allowEmpty);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(5, tooltip = $$props2.tooltip);
  };
  return [options, value, placeholder, allowEmpty, disabled, tooltip, handleChange];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance26, create_fragment26, safe_not_equal, {
      options: 0,
      value: 1,
      placeholder: 2,
      allowEmpty: 3,
      disabled: 4,
      tooltip: 5
    });
  }
};
var Select_default = Select;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css10(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment27(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = (
    /*name*/
    ((_a = ctx[0]) != null ? _a : "") + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*description*/
    ((_b = ctx[1]) != null ? _b : "") + ""
  );
  let t22;
  let t3;
  let div3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t22 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(
        div3,
        "vertical-control",
        /*vertical*/
        ctx[2]
      );
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(
        div4,
        "vertical",
        /*vertical*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append4(div4, div2);
      append4(div2, div0);
      append4(div0, t0);
      append4(div2, t1);
      append4(div2, div1);
      append4(div1, t22);
      append4(div4, t3);
      append4(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & /*name*/
      1) && t0_value !== (t0_value = /*name*/
      ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & /*description*/
      2) && t2_value !== (t2_value = /*description*/
      ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t22, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*vertical*/
      4) {
        toggle_class(
          div3,
          "vertical-control",
          /*vertical*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*vertical*/
      4) {
        toggle_class(
          div4,
          "vertical",
          /*vertical*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, description, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance27, create_fragment27, safe_not_equal, { name: 0, description: 1, vertical: 2 }, add_css10);
  }
};
var SettingItem_default = SettingItem;

// node_modules/obsidian-svelte/Tag/Tag.svelte
function add_css11(target) {
  append_styles(target, "svelte-ehq9e", "div.svelte-ehq9e{background-color:var(--tag-background);border:var(--tag-border-width) solid var(--tag-border-color);border-radius:var(--tag-radius);color:var(--tag-color);font-size:var(--tag-size);text-decoration:var(--tag-decoration);padding:var(--tag-padding-y) var(--tag-padding-x);line-height:1;display:inline-flex;align-items:center;gap:var(--size-4-1)}");
}
function create_fragment28(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-ehq9e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Tag = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance28, create_fragment28, safe_not_equal, {}, add_css11);
  }
};
var Tag_default = Tag;

// node_modules/obsidian-svelte/TextArea/TextArea.svelte
function add_css12(target) {
  append_styles(target, "svelte-1yhxf9x", "textarea.svelte-1yhxf9x{font-family:var(--font-monospace-default)}");
}
function create_fragment29(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(
        textarea,
        "rows",
        /*rows*/
        ctx[1]
      );
      attr(textarea, "style", textarea_style_value = `width: ${/*width*/
      ctx[2]}`);
      attr(
        textarea,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(textarea, "class", "svelte-1yhxf9x");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*rows*/
      2) {
        attr(
          textarea,
          "rows",
          /*rows*/
          ctx2[1]
        );
      }
      if (dirty & /*width*/
      4 && textarea_style_value !== (textarea_style_value = `width: ${/*width*/
      ctx2[2]}`)) {
        attr(textarea, "style", textarea_style_value);
      }
      if (dirty & /*placeholder*/
      8) {
        attr(
          textarea,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { rows } = $$props;
  let { width = "auto" } = $$props;
  let { placeholder = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("rows" in $$props2)
      $$invalidate(1, rows = $$props2.rows);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        dispatch2("input", value);
    }
  };
  return [value, rows, width, placeholder, textarea_input_handler];
}
var TextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance29,
      create_fragment29,
      safe_not_equal,
      {
        value: 0,
        rows: 1,
        width: 2,
        placeholder: 3
      },
      add_css12
    );
  }
};
var TextArea_default = TextArea;

// node_modules/obsidian-svelte/Typography/Typography.svelte
function add_css13(target) {
  append_styles(target, "svelte-1wyn8wx", ".nomargin.svelte-1wyn8wx{margin:0}");
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      svelte_element = element(
        /*elements*/
        ctx[2][
          /*variant*/
          ctx[0]
        ]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*elements*/
        ctx[2][
          /*variant*/
          ctx[0]
        ]
      )(svelte_element, { class: "svelte-1wyn8wx" });
      toggle_class(
        svelte_element,
        "nomargin",
        /*nomargin*/
        ctx[1]
      );
      toggle_class(
        svelte_element,
        "setting-item-name",
        /*variant*/
        ctx[0] === "label"
      );
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*nomargin*/
      2) {
        toggle_class(
          svelte_element,
          "nomargin",
          /*nomargin*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*variant*/
      1) {
        toggle_class(
          svelte_element,
          "setting-item-name",
          /*variant*/
          ctx2[0] === "label"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment30(ctx) {
  let previous_tag = (
    /*elements*/
    ctx[2][
      /*variant*/
      ctx[0]
    ]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*elements*/
    ctx[2][
      /*variant*/
      ctx[0]
    ] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty3();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*elements*/
        ctx2[2][
          /*variant*/
          ctx2[0]
        ]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*elements*/
          ctx2[2][
            /*variant*/
            ctx2[0]
          ];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*elements*/
          ctx2[2][
            /*variant*/
            ctx2[0]
          ]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*elements*/
          ctx2[2][
            /*variant*/
            ctx2[0]
          ];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*elements*/
        ctx2[2][
          /*variant*/
          ctx2[0]
        ];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o(local) {
      transition_out(svelte_element);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant } = $$props;
  let { nomargin = false } = $$props;
  const elements = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    body: "p",
    label: "p"
  };
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("nomargin" in $$props2)
      $$invalidate(1, nomargin = $$props2.nomargin);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, nomargin, elements, $$scope, slots];
}
var Typography = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance30, create_fragment30, safe_not_equal, { variant: 0, nomargin: 1 }, add_css13);
  }
};
var Typography_default = Typography;

// node_modules/obsidian-svelte/useClickOutside.js
function useClickOutside2(element2, callbackFunction) {
  function onClick(event) {
    if (!element2.contains(event.target)) {
      callbackFunction();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(newCallbackFunction) {
      callbackFunction = newCallbackFunction;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// src/lib/obsidian.ts
var import_obsidian8 = require("obsidian");
function getFilesInFolder(folder) {
  const result = [];
  import_obsidian8.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian8.TFile) {
      result.push(file);
    }
  });
  return result;
}
function getFoldersInFolder(folder) {
  const result = [];
  import_obsidian8.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian8.TFolder) {
      result.push(file);
    }
  });
  return result;
}
function isValidPath(path) {
  const expr = getIllegalCharacterSet();
  if (!expr) {
    return true;
  }
  return !expr.test(path);
}
function getIllegalCharacterSet() {
  if (import_obsidian8.Platform.isMacOS) {
    return /[\\\/\|\#\^\[\]]/;
  } else if (import_obsidian8.Platform.isDesktopApp) {
    return /[\\\/\|\:\<\>\*\"\?]/;
  }
  return void 0;
}

// src/modals/components/CreateNote.svelte
function create_default_slot_6(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (
        /*name*/
        ctx[0]
      ),
      autoFocus: true,
      error: !!/*nameError*/
      ctx[4],
      helperText: (
        /*nameError*/
        ctx[4]
      )
    }
  });
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[7]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*name*/
      1)
        textinput_changes.value = /*name*/
        ctx2[0];
      if (dirty & /*nameError*/
      16)
        textinput_changes.error = !!/*nameError*/
        ctx2[4];
      if (dirty & /*nameError*/
      16)
        textinput_changes.helperText = /*nameError*/
        ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_5(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*project*/
        ctx[1].id
      ),
      options: (
        /*$settings*/
        ctx[6].projects.map(func)
      )
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[8]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*project*/
      2)
        select_changes.value = /*project*/
        ctx2[1].id;
      if (dirty & /*$settings*/
      64)
        select_changes.options = /*$settings*/
        ctx2[6].projects.map(func);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block6(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[5].t("modals.note.create.templatePath.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[5].t("modals.note.create.templatePath.description")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & /*$i18n*/
      32)
        settingitem_changes.name = /*$i18n*/
        ctx2[5].t("modals.note.create.templatePath.name");
      if (dirty & /*$i18n*/
      32)
        settingitem_changes.description = /*$i18n*/
        (_a2 = ctx2[5].t("modals.note.create.templatePath.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, templatePath, project, $i18n*/
      8234) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  var _a;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*templatePath*/
        ctx[3]
      ),
      options: (
        /*project*/
        ctx[1].templates.map(func_1)
      ),
      placeholder: (
        /*$i18n*/
        (_a = ctx[5].t("modals.note.create.templatePath.none")) != null ? _a : ""
      ),
      allowEmpty: true
    }
  });
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[9]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const select_changes = {};
      if (dirty & /*templatePath*/
      8)
        select_changes.value = /*templatePath*/
        ctx2[3];
      if (dirty & /*project*/
      2)
        select_changes.options = /*project*/
        ctx2[1].templates.map(func_1);
      if (dirty & /*$i18n*/
      32)
        select_changes.placeholder = /*$i18n*/
        (_a2 = ctx2[5].t("modals.note.create.templatePath.none")) != null ? _a2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  var _a, _b;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let if_block_anchor;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[5].t("modals.note.create.name.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[5].t("modals.note.create.name.description")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[5].t("modals.note.create.project.name")
      ),
      description: (
        /*$i18n*/
        (_b = ctx[5].t("modals.note.create.project.description")) != null ? _b : ""
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*project*/
    ctx[1].templates.length && create_if_block6(ctx)
  );
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const settingitem0_changes = {};
      if (dirty & /*$i18n*/
      32)
        settingitem0_changes.name = /*$i18n*/
        ctx2[5].t("modals.note.create.name.name");
      if (dirty & /*$i18n*/
      32)
        settingitem0_changes.description = /*$i18n*/
        (_a2 = ctx2[5].t("modals.note.create.name.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, name, nameError*/
      8209) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$i18n*/
      32)
        settingitem1_changes.name = /*$i18n*/
        ctx2[5].t("modals.note.create.project.name");
      if (dirty & /*$i18n*/
      32)
        settingitem1_changes.description = /*$i18n*/
        (_b2 = ctx2[5].t("modals.note.create.project.description")) != null ? _b2 : "";
      if (dirty & /*$$scope, project, $settings*/
      8258) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*project*/
        ctx2[1].templates.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*project*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_2(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[5].t("modals.note.create.create") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      32 && t_value !== (t_value = /*$i18n*/
      ctx2[5].t("modals.note.create.create") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!/*nameError*/
      ctx[4],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*nameError*/
      16)
        button_changes.disabled = !!/*nameError*/
        ctx2[4];
      if (dirty & /*$$scope, $i18n*/
      8224) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot5(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, $i18n, templatePath, project, $settings, name, nameError*/
      8315) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, nameError, onSave, name, templatePath, project, $i18n*/
      8255) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment31(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*$i18n*/
        ctx[5].t("modals.note.create.title")
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*$i18n*/
      32)
        modallayout_changes.title = /*$i18n*/
        ctx2[5].t("modals.note.create.title");
      if (dirty & /*$$scope, nameError, onSave, name, templatePath, project, $i18n, $settings*/
      8319) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function getNewNotesFolder(project) {
  if (project.newNotesFolder) {
    return project.newNotesFolder;
  }
  if (project.dataSource.kind === "folder") {
    return project.dataSource.config.path;
  }
  return "";
}
var func = (project) => ({ label: project.name, value: project.id });
var func_1 = (path) => ({ label: path, value: path });
function instance31($$self, $$props, $$invalidate) {
  let nameError;
  let $i18n;
  let $app;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(11, $app = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(6, $settings = $$value));
  let { name } = $$props;
  let { project } = $$props;
  let { onSave } = $$props;
  let templatePath = "";
  function validateName(name2) {
    if (name2.trim() === "") {
      return $i18n.t("modals.note.create.empty-name-error");
    }
    const existingFile = $app.vault.getAbstractFileByPath((0, import_obsidian9.normalizePath)(getNewNotesFolder(project) + "/" + name2 + ".md"));
    if (existingFile instanceof import_obsidian9.TFile) {
      return $i18n.t("modals.note.create.name-taken-error");
    }
    if (!isValidPath(name2)) {
      return $i18n.t("modals.project.defaultName.invalid");
    }
    if (name2.startsWith(".")) {
      return $i18n.t("modals.note.create.dot-start-error");
    }
    return "";
  }
  const input_handler = ({ detail: value }) => $$invalidate(0, name = value);
  const change_handler = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(1, project = res);
    }
  };
  const change_handler_1 = ({ detail: value }) => $$invalidate(3, templatePath = value);
  const click_handler = () => {
    onSave(name, templatePath, project);
  };
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("onSave" in $$props2)
      $$invalidate(2, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*name*/
    1) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    name,
    project,
    onSave,
    templatePath,
    nameError,
    $i18n,
    $settings,
    input_handler,
    change_handler,
    change_handler_1,
    click_handler
  ];
}
var CreateNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance31, create_fragment31, safe_not_equal, { name: 0, project: 1, onSave: 2 });
  }
};
var CreateNote_default = CreateNote;

// src/modals/create-note-modal.ts
var CreateNoteModal = class extends import_obsidian12.Modal {
  constructor(app3, project, onSave) {
    super(app3);
    this.project = project;
    this.onSave = onSave;
  }
  getNewNotesFolder(project) {
    if (project.newNotesFolder) {
      return project.newNotesFolder;
    }
    if (project.dataSource.kind === "folder") {
      return project.dataSource.config.path;
    }
    return "";
  }
  onOpen() {
    this.component = new CreateNote_default({
      target: this.contentEl,
      props: {
        name: this.project.defaultName ? interpolateTemplate(this.project.defaultName, {
          date: (format2) => (0, import_moment2.default)().format(format2 || "YYYY-MM-DD"),
          time: (format2) => (0, import_moment2.default)().format(format2 || "HH:mm")
        }) : nextUniqueFileName(
          this.getNewNotesFolder(this.project),
          get_store_value(i18n).t("modals.note.create.untitled")
        ),
        project: this.project,
        onSave: (name, templatePath, project) => {
          this.onSave(name, templatePath, project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/create-project-modal.ts
var import_obsidian18 = require("obsidian");

// src/modals/components/CreateProject.svelte
var import_moment3 = __toESM(require_moment());

// src/components/FileListInput/FileListInput.svelte
function add_css14(target) {
  append_styles(target, "svelte-biiywl", "div.svelte-biiywl{display:flex;align-items:center;justify-content:space-between;gap:4px;padding-bottom:4px;width:100%}div.svelte-biiywl:first-child{flex:1}");
}
function get_each_context3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let fileautocomplete;
  let t3;
  let iconbutton;
  let current;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[4](
        /*i*/
        ctx[9],
        ...args
      )
    );
  }
  fileautocomplete = new FileAutocomplete_default({
    props: {
      value: (
        /*path*/
        ctx[7]
      ),
      files: getFilesInFolder(
        /*$app*/
        ctx[3].vault.getRoot()
      ),
      getLabel: func2,
      width: "100%"
    }
  });
  fileautocomplete.$on("change", change_handler);
  function func_15() {
    return (
      /*func_1*/
      ctx[5](
        /*i*/
        ctx[9]
      )
    );
  }
  iconbutton = new IconButton_default({ props: { icon: "x", onClick: func_15 } });
  return {
    c() {
      div = element("div");
      create_component(fileautocomplete.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "class", "svelte-biiywl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(fileautocomplete, div, null);
      append4(div, t3);
      mount_component(iconbutton, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fileautocomplete_changes = {};
      if (dirty & /*paths*/
      1)
        fileautocomplete_changes.value = /*path*/
        ctx[7];
      if (dirty & /*$app*/
      8)
        fileautocomplete_changes.files = getFilesInFolder(
          /*$app*/
          ctx[3].vault.getRoot()
        );
      fileautocomplete.$set(fileautocomplete_changes);
      const iconbutton_changes = {};
      if (dirty & /*onPathsChange, paths*/
      3)
        iconbutton_changes.onClick = func_15;
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(fileautocomplete);
      destroy_component(iconbutton);
    }
  };
}
function create_default_slot6(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*buttonText*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*buttonText*/
      4)
        set_data(
          t3,
          /*buttonText*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment32(ctx) {
  let t3;
  let button;
  let current;
  let each_value = (
    /*paths*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*onPathsChange, paths, getFilesInFolder, $app, produce*/
      11) {
        each_value = /*paths*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty & /*$$scope, buttonText*/
      1028) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button, detaching);
    }
  };
}
var func2 = (file) => file.path;
function instance32($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app2, ($$value) => $$invalidate(3, $app = $$value));
  let { paths } = $$props;
  let { onPathsChange } = $$props;
  let { buttonText } = $$props;
  const change_handler = (i2, { detail: value }) => {
    onPathsChange(immer_esm_default(paths, (draft) => {
      draft[i2] = value;
      return draft;
    }));
  };
  const func_15 = (i2) => {
    onPathsChange(paths.filter((_24, j2) => j2 !== i2));
  };
  const click_handler = () => {
    onPathsChange([...paths, ""]);
  };
  $$self.$$set = ($$props2) => {
    if ("paths" in $$props2)
      $$invalidate(0, paths = $$props2.paths);
    if ("onPathsChange" in $$props2)
      $$invalidate(1, onPathsChange = $$props2.onPathsChange);
    if ("buttonText" in $$props2)
      $$invalidate(2, buttonText = $$props2.buttonText);
  };
  return [paths, onPathsChange, buttonText, $app, change_handler, func_15, click_handler];
}
var FileListInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance32,
      create_fragment32,
      safe_not_equal,
      {
        paths: 0,
        onPathsChange: 1,
        buttonText: 2
      },
      add_css14
    );
  }
};
var FileListInput_default = FileListInput;

// src/components/Accordion/Accordion.svelte
function create_fragment33(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Accordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance33, create_fragment33, safe_not_equal, {});
  }
};
var Accordion_default = Accordion;

// src/components/Accordion/AccordionItem.svelte
function add_css15(target) {
  append_styles(target, "svelte-cg7s7f", "section.svelte-cg7s7f{border-top:1px solid var(--background-modifier-border)}div.svelte-cg7s7f{padding:8px;background-color:var(--background-secondary)}header.svelte-cg7s7f{display:flex;align-items:center;gap:4px;padding:8px;justify-content:space-between}");
}
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block7(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-cg7s7f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_fragment34(ctx) {
  let section;
  let header;
  let t0;
  let icon;
  let t1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[2].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_header_slot_context
  );
  icon = new Icon_default({
    props: {
      name: (
        /*open*/
        ctx[0] ? "chevron-up" : "chevron-down"
      )
    }
  });
  let if_block = (
    /*open*/
    ctx[0] && create_if_block7(ctx)
  );
  return {
    c() {
      section = element("section");
      header = element("header");
      if (header_slot)
        header_slot.c();
      t0 = space();
      create_component(icon.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(header, "class", "svelte-cg7s7f");
      attr(section, "class", "svelte-cg7s7f");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append4(section, header);
      if (header_slot) {
        header_slot.m(header, null);
      }
      append4(header, t0);
      mount_component(icon, header, null);
      append4(section, t1);
      if (if_block)
        if_block.m(section, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            header,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            header,
            "keypress",
            /*keypress_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      const icon_changes = {};
      if (dirty & /*open*/
      1)
        icon_changes.name = /*open*/
        ctx2[0] ? "chevron-up" : "chevron-down";
      icon.$set(icon_changes);
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(section, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (header_slot)
        header_slot.d(detaching);
      destroy_component(icon);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let open = false;
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => $$invalidate(0, open = !open);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [open, $$scope, slots, keypress_handler, click_handler];
}
var AccordionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance34, create_fragment34, safe_not_equal, {}, add_css15);
  }
};
var AccordionItem_default = AccordionItem;

// src/lib/stores/capabilities.ts
var import_obsidian_dataview = __toESM(require_lib());
var capabilities = derived(app2, ($app) => {
  return {
    dataview: (0, import_obsidian_dataview.isPluginEnabled)($app)
  };
});

// src/modals/components/CreateProject.svelte
function add_css16(target) {
  append_styles(target, "svelte-6mkdkz", "small.svelte-6mkdkz{font-size:var(--font-ui-smaller);color:var(--text-accent);font-weight:var(--font-semibold)}.error.svelte-6mkdkz{color:var(--text-error)}");
}
function create_default_slot_17(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (
        /*project*/
        ctx[0].name
      ),
      autoFocus: true,
      error: !!/*nameError*/
      ctx[4],
      helperText: (
        /*nameError*/
        ctx[4]
      )
    }
  });
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[14]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*project*/
      1)
        textinput_changes.value = /*project*/
        ctx2[0].name;
      if (dirty & /*nameError*/
      16)
        textinput_changes.error = !!/*nameError*/
        ctx2[4];
      if (dirty & /*nameError*/
      16)
        textinput_changes.helperText = /*nameError*/
        ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_16(ctx) {
  var _a;
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: (
        /*project*/
        (_a = ctx[0].isDefault) != null ? _a : false
      )
    }
  });
  switch_1.$on(
    "check",
    /*check_handler*/
    ctx[15]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const switch_1_changes = {};
      if (dirty & /*project*/
      1)
        switch_1_changes.checked = /*project*/
        (_a2 = ctx2[0].isDefault) != null ? _a2 : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*project*/
        ctx[0].dataSource.kind
      ),
      options: (
        /*dataSourceOptions*/
        ctx[9]
      )
    }
  });
  select.$on(
    "change",
    /*handleDataSourceChange*/
    ctx[10]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*project*/
      1)
        select_changes.value = /*project*/
        ctx2[0].dataSource.kind;
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  var _a, _b;
  let settingitem0;
  let t3;
  let settingitem1;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.path.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.project.path.description")) != null ? _a : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.recursive.name")
      ),
      description: (
        /*$i18n*/
        (_b = ctx[6].t("modals.project.recursive.description")) != null ? _b : ""
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const settingitem0_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.path.name");
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.project.path.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, $app, project*/
      268435713) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.recursive.name");
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.description = /*$i18n*/
        (_b2 = ctx2[6].t("modals.project.recursive.description")) != null ? _b2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_default_slot_14(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getFoldersInFolder(
        /*$app*/
        ctx[8].vault.getRoot()
      ),
      value: (
        /*project*/
        ctx[0].dataSource.config.path
      ),
      getLabel: func3,
      placeholder: "/",
      width: "100%"
    }
  });
  fileautocomplete.$on(
    "change",
    /*change_handler*/
    ctx[16]
  );
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & /*$app*/
      256)
        fileautocomplete_changes.files = getFoldersInFolder(
          /*$app*/
          ctx2[8].vault.getRoot()
        );
      if (dirty & /*project*/
      1)
        fileautocomplete_changes.value = /*project*/
        ctx2[0].dataSource.config.path;
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_default_slot_13(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: (
        /*project*/
        ctx[0].dataSource.config.recursive
      )
    }
  });
  switch_1.$on(
    "check",
    /*check_handler_1*/
    ctx[17]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & /*project*/
      1)
        switch_1_changes.checked = /*project*/
        ctx2[0].dataSource.config.recursive;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.tag.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.project.tag.description")) != null ? _a : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.tag.name");
      if (dirty & /*$i18n*/
      64)
        settingitem_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.project.tag.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      placeholder: "#tag",
      value: (
        /*project*/
        (_a = ctx[0].dataSource.config.tag) != null ? _a : ""
      ),
      width: "100%"
    }
  });
  textinput.$on(
    "input",
    /*input_handler_1*/
    ctx[18]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & /*project*/
      1)
        textinput_changes.value = /*project*/
        (_a2 = ctx2[0].dataSource.config.tag) != null ? _a2 : "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$capabilities*/
      ctx2[7].dataview
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: (
        /*$i18n*/
        ctx[6].t("modals.project.dataview.error.title")
      ),
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & /*$i18n*/
      64)
        callout_changes.title = /*$i18n*/
        ctx2[6].t("modals.project.dataview.error.title");
      if (dirty & /*$$scope, $i18n*/
      268435520) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.query.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.project.query.description")) != null ? _a : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.query.name");
      if (dirty & /*$i18n*/
      64)
        settingitem_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.project.query.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[6].t("modals.project.dataview.error.message") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      64 && t_value !== (t_value = /*$i18n*/
      ctx2[6].t("modals.project.dataview.error.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_10(ctx) {
  var _a;
  let textarea;
  let current;
  textarea = new TextArea_default({
    props: {
      placeholder: `TABLE status AS "Status" FROM "Work"`,
      value: (
        /*project*/
        (_a = ctx[0].dataSource.config.query) != null ? _a : ""
      ),
      rows: 6,
      width: "100%"
    }
  });
  textarea.$on(
    "input",
    /*input_handler_2*/
    ctx[19]
  );
  return {
    c() {
      create_component(textarea.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textarea_changes = {};
      if (dirty & /*project*/
      1)
        textarea_changes.value = /*project*/
        (_a2 = ctx2[0].dataSource.config.query) != null ? _a2 : "";
      textarea.$set(textarea_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textarea, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getFoldersInFolder(
        /*$app*/
        ctx[8].vault.getRoot()
      ),
      value: (
        /*project*/
        ctx[0].newNotesFolder
      ),
      placeholder: (
        /*project*/
        ctx[0].dataSource.kind === "folder" ? (
          /*project*/
          ctx[0].dataSource.config.path
        ) : "/"
      ),
      getLabel: func_12
    }
  });
  fileautocomplete.$on(
    "change",
    /*change_handler_1*/
    ctx[20]
  );
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & /*$app*/
      256)
        fileautocomplete_changes.files = getFoldersInFolder(
          /*$app*/
          ctx2[8].vault.getRoot()
        );
      if (dirty & /*project*/
      1)
        fileautocomplete_changes.value = /*project*/
        ctx2[0].newNotesFolder;
      if (dirty & /*project*/
      1)
        fileautocomplete_changes.placeholder = /*project*/
        ctx2[0].dataSource.kind === "folder" ? (
          /*project*/
          ctx2[0].dataSource.config.path
        ) : "/";
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_if_block8(ctx) {
  let small;
  let t_value = (
    /*$i18n*/
    ctx[6].t("modals.project.defaultName.invalid") + ""
  );
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(t_value);
      attr(small, "class", "error svelte-6mkdkz");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append4(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      64 && t_value !== (t_value = /*$i18n*/
      ctx2[6].t("modals.project.defaultName.invalid") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_default_slot_8(ctx) {
  var _a;
  let textinput;
  let t0;
  let small;
  let t1;
  let t22;
  let show_if = !isValidPath(
    /*defaultName*/
    ctx[5]
  );
  let if_block_anchor;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (
        /*project*/
        (_a = ctx[0].defaultName) != null ? _a : ""
      ),
      width: "100%"
    }
  });
  textinput.$on(
    "input",
    /*input_handler_3*/
    ctx[21]
  );
  let if_block = show_if && create_if_block8(ctx);
  return {
    c() {
      create_component(textinput.$$.fragment);
      t0 = space();
      small = element("small");
      t1 = text(
        /*defaultName*/
        ctx[5]
      );
      t22 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
      attr(small, "class", "svelte-6mkdkz");
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, small, anchor);
      append4(small, t1);
      insert(target, t22, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & /*project*/
      1)
        textinput_changes.value = /*project*/
        (_a2 = ctx2[0].defaultName) != null ? _a2 : "";
      textinput.$set(textinput_changes);
      if (!current || dirty & /*defaultName*/
      32)
        set_data(
          t1,
          /*defaultName*/
          ctx2[5]
        );
      if (dirty & /*defaultName*/
      32)
        show_if = !isValidPath(
          /*defaultName*/
          ctx2[5]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(small);
      if (detaching)
        detach(t22);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_7(ctx) {
  var _a;
  let filelistinput;
  let current;
  filelistinput = new FileListInput_default({
    props: {
      buttonText: "Add template",
      paths: (
        /*project*/
        (_a = ctx[0].templates) != null ? _a : []
      ),
      onPathsChange: (
        /*func_2*/
        ctx[22]
      )
    }
  });
  return {
    c() {
      create_component(filelistinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filelistinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const filelistinput_changes = {};
      if (dirty & /*project*/
      1)
        filelistinput_changes.paths = /*project*/
        (_a2 = ctx2[0].templates) != null ? _a2 : [];
      if (dirty & /*project*/
      1)
        filelistinput_changes.onPathsChange = /*func_2*/
        ctx2[22];
      filelistinput.$set(filelistinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filelistinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filelistinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filelistinput, detaching);
    }
  };
}
function create_default_slot_62(ctx) {
  var _a;
  let filelistinput;
  let current;
  filelistinput = new FileListInput_default({
    props: {
      buttonText: "Add note",
      paths: (
        /*project*/
        (_a = ctx[0].excludedNotes) != null ? _a : []
      ),
      onPathsChange: (
        /*func_3*/
        ctx[23]
      )
    }
  });
  return {
    c() {
      create_component(filelistinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filelistinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const filelistinput_changes = {};
      if (dirty & /*project*/
      1)
        filelistinput_changes.paths = /*project*/
        (_a2 = ctx2[0].excludedNotes) != null ? _a2 : [];
      if (dirty & /*project*/
      1)
        filelistinput_changes.onPathsChange = /*func_3*/
        ctx2[23];
      filelistinput.$set(filelistinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filelistinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filelistinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filelistinput, detaching);
    }
  };
}
function create_default_slot_52(ctx) {
  var _a, _b, _c, _d;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let settingitem2;
  let t22;
  let settingitem3;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.newNotesFolder.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.project.newNotesFolder.description")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.defaultName.name")
      ),
      description: (
        /*$i18n*/
        (_b = ctx[6].t("modals.project.defaultName.description")) != null ? _b : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.templates.name")
      ),
      description: (
        /*$i18n*/
        (_c = ctx[6].t("modals.project.templates.description")) != null ? _c : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  settingitem3 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.exclude.name")
      ),
      description: (
        /*$i18n*/
        (_d = ctx[6].t("modals.project.exclude.description")) != null ? _d : ""
      ),
      vertical: true,
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      create_component(settingitem2.$$.fragment);
      t22 = space();
      create_component(settingitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem2, target, anchor);
      insert(target, t22, anchor);
      mount_component(settingitem3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      const settingitem0_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.newNotesFolder.name");
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.project.newNotesFolder.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, $app, project*/
      268435713) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.defaultName.name");
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.description = /*$i18n*/
        (_b2 = ctx2[6].t("modals.project.defaultName.description")) != null ? _b2 : "";
      if (dirty & /*$$scope, $i18n, defaultName, project*/
      268435553) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem2_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.templates.name");
      if (dirty & /*$i18n*/
      64)
        settingitem2_changes.description = /*$i18n*/
        (_c2 = ctx2[6].t("modals.project.templates.description")) != null ? _c2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      const settingitem3_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem3_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.exclude.name");
      if (dirty & /*$i18n*/
      64)
        settingitem3_changes.description = /*$i18n*/
        (_d2 = ctx2[6].t("modals.project.exclude.description")) != null ? _d2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem3.$set(settingitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(settingitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(settingitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem2, detaching);
      if (detaching)
        detach(t22);
      destroy_component(settingitem3, detaching);
    }
  };
}
function create_header_slot(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="setting-item-name">More settings</div>`;
      attr(div1, "slot", "header");
      attr(div1, "class", "setting-item-info");
      set_style(div1, "margin-top", `8px`);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_42(ctx) {
  let accordionitem;
  let current;
  accordionitem = new AccordionItem_default({
    props: {
      $$slots: {
        header: [create_header_slot],
        default: [create_default_slot_52]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordionitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordionitem_changes = {};
      if (dirty & /*$$scope, $i18n, project, defaultName, $app*/
      268435809) {
        accordionitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionitem.$set(accordionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordionitem, detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  var _a, _b;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let settingitem2;
  let t22;
  let t3;
  let t4;
  let t5;
  let accordion;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.name.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.project.name.description")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.project.default.name")
      ),
      description: (
        /*$i18n*/
        (_b = ctx[6].t("modals.project.default.description")) != null ? _b : ""
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: "Data source",
      description: "Choose how you want to define which notes to include.",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*project*/
    ctx[0].dataSource.kind === "folder" && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*project*/
    ctx[0].dataSource.kind === "tag" && create_if_block_3(ctx)
  );
  let if_block2 = (
    /*project*/
    ctx[0].dataSource.kind === "dataview" && create_if_block_13(ctx)
  );
  accordion = new Accordion_default({
    props: {
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      create_component(settingitem2.$$.fragment);
      t22 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem2, target, anchor);
      insert(target, t22, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t5, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const settingitem0_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.name.name");
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.project.name.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, project, nameError*/
      268435473) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.name = /*$i18n*/
        ctx2[6].t("modals.project.default.name");
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.description = /*$i18n*/
        (_b2 = ctx2[6].t("modals.project.default.description")) != null ? _b2 : "";
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & /*$$scope, project*/
      268435457) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      if (
        /*project*/
        ctx2[0].dataSource.kind === "folder"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*project*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*project*/
        ctx2[0].dataSource.kind === "tag"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*project*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t4.parentNode, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*project*/
        ctx2[0].dataSource.kind === "dataview"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*project*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t5.parentNode, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const accordion_changes = {};
      if (dirty & /*$$scope, $i18n, project, defaultName, $app*/
      268435809) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem2, detaching);
      if (detaching)
        detach(t22);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t5);
      destroy_component(accordion, detaching);
    }
  };
}
function create_default_slot_22(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*cta*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*cta*/
      4)
        set_data(
          t3,
          /*cta*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_18(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!/*nameError*/
      ctx[4],
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[24]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*nameError*/
      16)
        button_changes.disabled = !!/*nameError*/
        ctx2[4];
      if (dirty & /*$$scope, cta*/
      268435460) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot7(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, $i18n, project, defaultName, $app, $capabilities, nameError*/
      268435953) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, nameError, onSave, project, cta*/
      268435485) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment35(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*title*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*title*/
      2)
        modallayout_changes.title = /*title*/
        ctx2[1];
      if (dirty & /*$$scope, nameError, onSave, project, cta, $i18n, defaultName, $app, $capabilities*/
      268435965) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func3 = (file) => file.path;
var func_12 = (file) => file.path;
function instance35($$self, $$props, $$invalidate) {
  let projects;
  let defaultName;
  let name;
  let nameError;
  let $i18n;
  let $capabilities;
  let $settings;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, capabilities, ($$value) => $$invalidate(7, $capabilities = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(13, $settings = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(8, $app = $$value));
  var _a;
  let { title } = $$props;
  let { cta } = $$props;
  let { onSave } = $$props;
  let { project } = $$props;
  let originalName = project.name;
  const dataSourceOptions = [{ label: "Folder", value: "folder" }, { label: "Tag", value: "tag" }];
  if ($capabilities.dataview) {
    dataSourceOptions.push({ label: "Dataview", value: "dataview" });
  }
  function handleDataSourceChange({ detail: value }) {
    switch (value) {
      case "folder":
        $$invalidate(0, project = Object.assign(Object.assign({}, project), {
          dataSource: {
            kind: "folder",
            config: { path: "", recursive: false }
          }
        }));
        break;
      case "tag":
        $$invalidate(0, project = Object.assign(Object.assign({}, project), {
          dataSource: { kind: "tag", config: { tag: "" } }
        }));
        break;
      case "dataview":
        $$invalidate(0, project = Object.assign(Object.assign({}, project), {
          dataSource: { kind: "dataview", config: { query: "" } }
        }));
        break;
    }
  }
  function validateName(name2) {
    if (name2 === originalName) {
      return "";
    }
    if (name2.trim() === "") {
      return $i18n.t("modals.project.create.empty-name-error");
    }
    if (projects.find((project2) => project2.name === name2)) {
      return $i18n.t("modals.project.create.existing-name-error");
    }
    return "";
  }
  const input_handler = ({ detail: name2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { name: name2 }));
  const check_handler = ({ detail: isDefault }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { isDefault }));
  const change_handler = ({ detail: path }) => {
    if (project.dataSource.kind === "folder") {
      $$invalidate(0, project = __spreadProps(__spreadValues({}, project), {
        dataSource: {
          kind: project.dataSource.kind,
          config: __spreadProps(__spreadValues({}, project.dataSource.config), { path })
        }
      }));
    }
  };
  const check_handler_1 = ({ detail: recursive }) => {
    if (project.dataSource.kind === "folder") {
      $$invalidate(0, project = __spreadProps(__spreadValues({}, project), {
        dataSource: {
          kind: project.dataSource.kind,
          config: __spreadProps(__spreadValues({}, project.dataSource.config), { recursive })
        }
      }));
    }
  };
  const input_handler_1 = ({ detail: tag }) => {
    if (project.dataSource.kind === "tag") {
      $$invalidate(0, project = __spreadProps(__spreadValues({}, project), {
        dataSource: {
          kind: project.dataSource.kind,
          config: __spreadProps(__spreadValues({}, project.dataSource.config), { tag })
        }
      }));
    }
  };
  const input_handler_2 = ({ detail: query }) => {
    if (project.dataSource.kind === "dataview") {
      $$invalidate(0, project = __spreadProps(__spreadValues({}, project), {
        dataSource: {
          kind: project.dataSource.kind,
          config: __spreadProps(__spreadValues({}, project.dataSource.config), { query })
        }
      }));
    }
  };
  const change_handler_1 = ({ detail: newNotesFolder }) => {
    $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { newNotesFolder }));
  };
  const input_handler_3 = ({ detail: defaultName2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { defaultName: defaultName2 }));
  const func_2 = (templates) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { templates }));
  const func_3 = (excludedNotes) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { excludedNotes }));
  const click_handler = () => {
    var _a2, _b;
    onSave(__spreadProps(__spreadValues({}, project), {
      templates: (_b = (_a2 = project.templates) == null ? void 0 : _a2.filter(notEmpty)) != null ? _b : []
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSave" in $$props2)
      $$invalidate(3, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$settings*/
    8192) {
      $:
        projects = $settings.projects;
    }
    if ($$self.$$.dirty & /*project, _a*/
    2049) {
      $:
        $$invalidate(5, defaultName = interpolateTemplate(
          $$invalidate(11, _a = project.defaultName) !== null && _a !== void 0 ? _a : "",
          {
            date: (format2) => (0, import_moment3.default)().format(format2 || "YYYY-MM-DD"),
            time: (format2) => (0, import_moment3.default)().format(format2 || "HH:mm")
          }
        ));
    }
    if ($$self.$$.dirty & /*project*/
    1) {
      $:
        $$invalidate(12, { name } = project, name);
    }
    if ($$self.$$.dirty & /*name*/
    4096) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    title,
    cta,
    onSave,
    nameError,
    defaultName,
    $i18n,
    $capabilities,
    $app,
    dataSourceOptions,
    handleDataSourceChange,
    _a,
    name,
    $settings,
    input_handler,
    check_handler,
    change_handler,
    check_handler_1,
    input_handler_1,
    input_handler_2,
    change_handler_1,
    input_handler_3,
    func_2,
    func_3,
    click_handler
  ];
}
var CreateProject = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance35, create_fragment35, safe_not_equal, { title: 1, cta: 2, onSave: 3, project: 0 }, add_css16);
  }
};
var CreateProject_default = CreateProject;

// src/modals/create-project-modal.ts
var CreateProjectModal = class extends import_obsidian18.Modal {
  constructor(app3, title, cta, onSave, defaults2) {
    super(app3);
    this.title = title;
    this.cta = cta;
    this.onSave = onSave;
    this.defaults = defaults2;
  }
  onOpen() {
    this.component = new CreateProject_default({
      target: this.contentEl,
      props: {
        title: this.title,
        cta: this.cta,
        project: this.defaults,
        onSave: (project) => {
          this.onSave(project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/lib/stores/dataframe.ts
var dataSource = writable();
var dataFrame = createDataFrame();
function createDataFrame() {
  const { update: update2, set: set2, subscribe: subscribe2 } = writable({
    fields: [],
    records: []
  });
  return {
    set: set2,
    subscribe: subscribe2,
    addRecord(record) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.records.push(record);
        })
      );
    },
    updateRecord(record) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.records = K(
            draft.records.map($).map((r2) => r2.id === record.id ? record : r2)
          );
        })
      );
    },
    deleteRecord(id) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.records = draft.records.filter((record) => record.id !== id);
        })
      );
    },
    updateField(updated, oldName) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.fields = draft.fields.map((field) => field.name === oldName ? updated : field).filter((field) => field.name !== oldName);
          draft.records = draft.records.map(
            (record) => immer_esm_default(record, (draft2) => {
              if (oldName) {
                draft2.values[updated.name] = draft2.values[oldName];
                delete draft2.values[oldName];
              }
            })
          );
        })
      );
    },
    deleteField(fieldName) {
      update2(
        (state) => immer_esm_default(state, (draft) => {
          draft.fields = draft.fields.filter(
            (field) => field.name !== fieldName
          );
        })
      );
    },
    merge(updated) {
      update2(
        (existing) => immer_esm_default(existing, (draft) => {
          var _a, _b, _c;
          const recordSet = Object.fromEntries(
            existing.records.map((record) => [record.id, record])
          );
          updated.records.forEach((record) => {
            recordSet[record.id] = record;
          });
          draft.records = K(Object.values(recordSet));
          updated.fields.forEach((newField) => {
            const existingField = existing.fields.find(
              (f2) => f2.name === newField.name
            );
            if (existingField) {
              if (existingField.type !== newField.type) {
                const existingFieldIndex = existing.fields.findIndex(
                  (field) => field.name === newField.name
                );
                draft.fields[existingFieldIndex] = __spreadProps(__spreadValues({}, newField), {
                  type: "string" /* String */
                });
              }
            } else {
              draft.fields.push(newField);
            }
          });
          draft.fields = draft.fields.filter(
            (field) => draft.records.some((record) => {
              return (
                // @ts-ignore
                record.values[field.name] !== void 0 && record.values[field.name] !== null
              );
            })
          );
          const updatedIds = updated.records.map((record) => record.id);
          draft.errors = (_b = (_a = draft.errors) == null ? void 0 : _a.filter((err) => !updatedIds.includes(err.recordId))) != null ? _b : [];
          draft.errors = [...draft.errors, ...(_c = updated.errors) != null ? _c : []];
        })
      );
    }
  };
}

// src/lib/datasources/helpers.ts
var import_dayjs3 = __toESM(require_dayjs_min());
function parseRecords(records, fields) {
  for (const field of fields) {
    for (const record of records) {
      const value = record.values[field.name];
      switch (field.type) {
        case "date" /* Date */:
          if (typeof value === "string") {
            record.values[field.name] = (0, import_dayjs3.default)(value).toDate();
          }
          break;
        case "number" /* Number */:
          if (typeof value === "string") {
            record.values[field.name] = parseFloat(value);
          }
          break;
        case "boolean" /* Boolean */:
          if (typeof value === "string") {
            record.values[field.name] = stringToBoolean(value);
          }
          break;
        case "string" /* String */:
          if (typeof value !== "object") {
            record.values[field.name] = value == null ? void 0 : value.toLocaleString();
          }
          break;
      }
    }
  }
  return records;
}
function detectFields(records) {
  const valuesByField = {};
  records.forEach((record) => {
    Object.entries(record.values).forEach(([field, value]) => {
      var _a;
      valuesByField[field] = [...(_a = valuesByField[field]) != null ? _a : [], value];
    });
  });
  return Object.entries(valuesByField).map(([field, values]) => ({
    name: field,
    type: typeFromValues(values),
    identifier: false,
    derived: false,
    repeated: values.some(Array.isArray),
    typeConfig: {}
  }));
}
function typeFromValues(values) {
  const types = values.map((value) => detectCellType(value));
  if (types.every((t3) => t3 === "unknown" /* Unknown */)) {
    return "string" /* String */;
  }
  const result = {};
  for (const type of types) {
    if (!result[type]) {
      result[type] = 0;
    }
    result[type]++;
  }
  const detectedTypes = Object.keys(result).filter(
    (type) => type !== "unknown" /* Unknown */
  );
  if (detectedTypes.length === 1) {
    return detectedTypes[0];
  } else if (detectedTypes.length > 1) {
    return "string" /* String */;
  } else {
    return "unknown" /* Unknown */;
  }
}
function detectCellType(value) {
  if (typeof value === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
      return "date" /* Date */;
    }
    return "string" /* String */;
  } else if (typeof value === "number") {
    return "number" /* Number */;
  } else if (typeof value === "boolean") {
    return "boolean" /* Boolean */;
  }
  if (Array.isArray(value)) {
    return typeFromValues(value);
  }
  if (value === null) {
    return "unknown" /* Unknown */;
  }
  return "unknown" /* Unknown */;
}
function stringToBoolean(stringValue) {
  var _a;
  switch ((_a = stringValue == null ? void 0 : stringValue.toLowerCase()) == null ? void 0 : _a.trim()) {
    case "true":
    case "yes":
    case "1":
      return true;
    case "false":
    case "no":
    case "0":
    case null:
    case void 0:
      return false;
    default:
      return !!stringValue;
  }
}
var TooManyNotesError = class extends Error {
  constructor(n2, limit) {
    const message = `This project contains ${Intl.NumberFormat().format(
      n2
    )} notes, which is more than the maximum project size (${Intl.NumberFormat().format(
      limit
    )}). You can increase the default limit in the plugin settings, but be aware that doing so may lead to a poor experience, or even cause the plugin to stop responding.`;
    super(message);
    this.name = "Too many notes";
  }
};

// src/lib/datasources/dataview/dataview-helpers.ts
var import_dayjs4 = __toESM(require_dayjs_min());
function standardizeValues(values) {
  const res = {};
  Object.keys(values).forEach((field) => {
    const value = values[field];
    if (!value) {
      return;
    }
    if (isRepeatedDataValue(value)) {
      res[field] = value;
    } else if (typeof value === "object") {
      if ("path" in value && "display" in value) {
        res[field] = value.toString();
      }
      if ("ts" in value) {
        res[field] = (0, import_dayjs4.default)(value.ts).format("YYYY-MM-DD");
      }
    } else {
      res[field] = value;
    }
  });
  return res;
}

// src/lib/datasources/dataview/dataview.ts
var UnsupportedCapability = class extends Error {
  constructor(message) {
    super(message);
    this.name = get_store_value(i18n).t("errors.missingDataview.title");
  }
};
var DataviewDataSource = class extends DataSource {
  constructor(fileSystem2, project, preferences, api2) {
    super(project, preferences);
    this.fileSystem = fileSystem2;
    this.api = api2;
  }
  queryOne() {
    return __async(this, null, function* () {
      return this.queryAll();
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      var _a;
      if (this.project.dataSource.kind !== "dataview") {
        return emptyDataFrame;
      }
      const result = yield this.api.query(
        (_a = this.project.dataSource.config.query) != null ? _a : "",
        void 0,
        {
          forceId: true
        }
      );
      if (!(result == null ? void 0 : result.successful) || result.value.type !== "table") {
        throw new Error("dataview query failed");
      }
      const rows = parseTableResult(result.value);
      const standardizedRecords = this.standardizeRecords(rows);
      let fields = this.sortFields(
        detectSchema(standardizedRecords),
        result.value.headers
      );
      for (const f2 in this.project.fieldConfig) {
        fields = fields.map(
          (field) => {
            var _a2;
            return field.name !== f2 ? field : __spreadProps(__spreadValues({}, field), {
              typeConfig: __spreadValues(__spreadValues({}, (_a2 = this.project.fieldConfig) == null ? void 0 : _a2[f2]), field.typeConfig)
            });
          }
        );
      }
      const records = parseRecords(standardizedRecords, fields);
      return { fields, records };
    });
  }
  sortFields(fields, headers) {
    return immer_esm_default(fields, (draft) => {
      draft.sort((a2, b2) => {
        const aval = headers.indexOf(a2.name);
        const bval = headers.indexOf(b2.name);
        const distance = aval - bval;
        if (distance !== 0) {
          return distance;
        }
        return a2.name.localeCompare(b2.name);
      });
    });
  }
  includes(path) {
    var _a;
    return !((_a = this.project.excludedNotes) == null ? void 0 : _a.includes(path));
  }
  readonly() {
    return true;
  }
  standardizeRecords(rows) {
    const records = [];
    rows.map((row) => ({ id: row["File"], row })).forEach(
      ({ id, row }) => records.push({ id: id.path, values: standardizeValues(row) })
    );
    return records;
  }
};
function parseTableResult(value) {
  const headers = value.headers;
  const rows = [];
  value.values.forEach((row) => {
    const values = {};
    headers.forEach((header, index2) => {
      const value2 = row[index2];
      values[header] = value2;
    });
    rows.push(values);
  });
  return rows;
}
function detectSchema(records) {
  return detectFields(records).map((field) => __spreadProps(__spreadValues({}, field), { derived: true })).map(
    (field) => field.name === "File" ? immer_esm_default(field, (draft) => {
      var _a;
      draft.identifier = true;
      draft.typeConfig = immer_esm_default((_a = draft.typeConfig) != null ? _a : {}, (draft2) => {
        draft2.richText = true;
      });
    }) : field
  );
}

// src/events.ts
function withDataSource(cb) {
  const source = get_store_value(dataSource);
  if (!source) {
    return;
  }
  if (source instanceof DataviewDataSource) {
    dataSource.set(source);
    return;
  }
  return cb(source);
}
function registerFileEvents(watcher) {
  watcher.onCreate((file) => __async(this, null, function* () {
    withDataSource((source) => __async(this, null, function* () {
      if (source.includes(file.path)) {
        dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
      }
    }));
  }));
  watcher.onRename((file, oldPath) => __async(this, null, function* () {
    withDataSource((source) => __async(this, null, function* () {
      if (source.includes(file.path)) {
        dataFrame.deleteRecord(oldPath);
        dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
      }
    }));
  }));
  watcher.onDelete((file) => __async(this, null, function* () {
    withDataSource((source) => __async(this, null, function* () {
      if (source.includes(file.path)) {
        dataFrame.deleteRecord(file.path);
      }
    }));
  }));
  watcher.onChange((file) => __async(this, null, function* () {
    withDataSource((source) => __async(this, null, function* () {
      const recordExists = !!get_store_value(dataFrame).records.find(
        (record) => record.id === file.path
      );
      if (source.includes(file.path)) {
        dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
      } else if (recordExists) {
        dataFrame.deleteRecord(file.path);
      }
    }));
  }));
}

// src/settings.ts
var import_obsidian19 = require("obsidian");
var ProjectsSettingTab = class extends import_obsidian19.PluginSettingTab {
  constructor(app3, plugin2) {
    super(app3, plugin2);
    this.plugin = plugin2;
  }
  display() {
    const { projects } = get_store_value(settings);
    let { preferences } = get_store_value(settings);
    const save2 = (prefs) => {
      preferences = prefs;
      settings.updatePreferences(prefs);
    };
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian19.Setting(containerEl).setName("Project size limit").setDesc("Avoid accidentally loading too many notes. Increasing ").addText(
      (text2) => text2.setValue(preferences.projectSizeLimit.toString()).setPlaceholder("1000").onChange((value) => {
        save2(__spreadProps(__spreadValues({}, preferences), {
          projectSizeLimit: parseInt(value) || 1e3
        }));
      })
    );
    new import_obsidian19.Setting(containerEl).setName("Front matter").setHeading();
    new import_obsidian19.Setting(containerEl).setName("Quote strings").addDropdown(
      (dropdown) => dropdown.addOption("PLAIN", "If needed").addOption("QUOTE_DOUBLE", "Always").setValue(preferences.frontmatter.quoteStrings).onChange((value) => {
        if (value === "PLAIN" || value === "QUOTE_DOUBLE") {
          save2(__spreadProps(__spreadValues({}, preferences), {
            frontmatter: {
              quoteStrings: value
            }
          }));
        }
      })
    );
    new import_obsidian19.Setting(containerEl).setName("Commands").setDesc("Add commands for your favorite projects and views.").setHeading();
    projects.forEach((project) => {
      new import_obsidian19.Setting(containerEl).setName(project.name).setDesc("Project").addToggle(
        (toggle) => toggle.setValue(
          !!preferences.commands.find(
            (command) => command.project == project.id && !command.view
          )
        ).onChange((value) => {
          save2(
            immer_esm_default(preferences, (draft) => {
              if (value) {
                draft.commands.push({
                  project: project.id
                });
              } else {
                draft.commands = draft.commands.filter(
                  (command) => !(command.project === project.id && !command.view)
                );
              }
            })
          );
        })
      );
      project.views.forEach((view2) => {
        new import_obsidian19.Setting(containerEl).setName(`${project.name}: ${view2.name}`).setDesc("View").addToggle(
          (toggle) => toggle.setValue(
            !!preferences.commands.find(
              (command) => command.project == project.id && command.view === view2.id
            )
          ).onChange((value) => {
            save2(
              immer_esm_default(preferences, (draft) => {
                if (value) {
                  draft.commands.push({
                    project: project.id,
                    view: view2.id
                  });
                } else {
                  draft.commands = draft.commands.filter(
                    (command) => !(command.project === project.id && command.view === view2.id)
                  );
                }
              })
            );
          })
        );
      });
    });
  }
};

// src/view.ts
var import_obsidian54 = require("obsidian");

// src/lib/view-api.ts
var ViewApi = class {
  constructor(dataSource2, dataApi) {
    this.dataSource = dataSource2;
    this.dataApi = dataApi;
  }
  addRecord(record, templatePath) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.addRecord(record);
    }
    this.dataApi.createNote(record, templatePath);
  }
  updateRecord(record, fields) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.updateRecord(record);
    }
    this.dataApi.updateRecord(fields, record);
  }
  deleteRecord(recordId) {
    if (this.dataSource.includes(recordId)) {
      dataFrame.deleteRecord(recordId);
    }
    this.dataApi.deleteRecord(recordId);
  }
  updateField(field, oldName) {
    dataFrame.updateField(field, oldName);
    if (oldName) {
      this.dataApi.renameField(
        get_store_value(dataFrame).records.map((record) => record.id),
        oldName,
        field.name
      );
    }
  }
  deleteField(field) {
    dataFrame.deleteField(field);
    this.dataApi.deleteField(
      get_store_value(dataFrame).records.map((record) => record.id),
      field
    );
  }
};

// src/components/Layout/ViewToolbar.svelte
function add_css17(target) {
  append_styles(target, "svelte-1n16ix8", ".container.svelte-1n16ix8.svelte-1n16ix8{display:flex;justify-content:space-between;padding:var(--size-4-2);gap:var(--size-4-2);border-bottom:1px solid var(--background-modifier-border);align-items:center}.middle.svelte-1n16ix8.svelte-1n16ix8{flex:1;overflow-x:auto;text-align:center;min-width:200px}.right.svelte-1n16ix8.svelte-1n16ix8{display:flex;align-items:center;gap:var(--size-4-2);flex-wrap:wrap}.isMobile.svelte-1n16ix8.svelte-1n16ix8{flex-direction:column;align-items:stretch}.isMobile.svelte-1n16ix8 .right.svelte-1n16ix8{align-items:stretch}.primary.svelte-1n16ix8.svelte-1n16ix8{background-color:var(--tab-background-active)}.secondary.svelte-1n16ix8.svelte-1n16ix8{background-color:var(--background-secondary)}");
}
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_middle_slot_changes = (dirty) => ({});
var get_middle_slot_context = (ctx) => ({});
var get_info_slot_changes = (dirty) => ({});
var get_info_slot_context = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_fragment36(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div1;
  let t22;
  let div2;
  let div3_resize_listener;
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[4].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_left_slot_context
  );
  const info_slot_template = (
    /*#slots*/
    ctx[4].info
  );
  const info_slot = create_slot(
    info_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_info_slot_context
  );
  const middle_slot_template = (
    /*#slots*/
    ctx[4].middle
  );
  const middle_slot = create_slot(
    middle_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_middle_slot_context
  );
  const right_slot_template = (
    /*#slots*/
    ctx[4].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_right_slot_context
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (left_slot)
        left_slot.c();
      t0 = space();
      if (info_slot)
        info_slot.c();
      t1 = space();
      div1 = element("div");
      if (middle_slot)
        middle_slot.c();
      t22 = space();
      div2 = element("div");
      if (right_slot)
        right_slot.c();
      attr(div0, "class", "left");
      attr(div1, "class", "middle svelte-1n16ix8");
      attr(div2, "class", "right svelte-1n16ix8");
      attr(div3, "class", "container svelte-1n16ix8");
      add_render_callback(() => (
        /*div3_elementresize_handler*/
        ctx[5].call(div3)
      ));
      toggle_class(
        div3,
        "primary",
        /*variant*/
        ctx[0] === "primary"
      );
      toggle_class(
        div3,
        "secondary",
        /*variant*/
        ctx[0] === "secondary"
      );
      toggle_class(
        div3,
        "isMobile",
        /*isMobile*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append4(div3, div0);
      if (left_slot) {
        left_slot.m(div0, null);
      }
      append4(div3, t0);
      if (info_slot) {
        info_slot.m(div3, null);
      }
      append4(div3, t1);
      append4(div3, div1);
      if (middle_slot) {
        middle_slot.m(div1, null);
      }
      append4(div3, t22);
      append4(div3, div2);
      if (right_slot) {
        right_slot.m(div2, null);
      }
      div3_resize_listener = add_resize_listener(
        div3,
        /*div3_elementresize_handler*/
        ctx[5].bind(div3)
      );
      current = true;
    },
    p(ctx2, [dirty]) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
      if (info_slot) {
        if (info_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            info_slot,
            info_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              info_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_info_slot_changes
            ),
            get_info_slot_context
          );
        }
      }
      if (middle_slot) {
        if (middle_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            middle_slot,
            middle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              middle_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_middle_slot_changes
            ),
            get_middle_slot_context
          );
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
      if (!current || dirty & /*variant*/
      1) {
        toggle_class(
          div3,
          "primary",
          /*variant*/
          ctx2[0] === "primary"
        );
      }
      if (!current || dirty & /*variant*/
      1) {
        toggle_class(
          div3,
          "secondary",
          /*variant*/
          ctx2[0] === "secondary"
        );
      }
      if (!current || dirty & /*isMobile*/
      4) {
        toggle_class(
          div3,
          "isMobile",
          /*isMobile*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left_slot, local);
      transition_in(info_slot, local);
      transition_in(middle_slot, local);
      transition_in(right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(left_slot, local);
      transition_out(info_slot, local);
      transition_out(middle_slot, local);
      transition_out(right_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (left_slot)
        left_slot.d(detaching);
      if (info_slot)
        info_slot.d(detaching);
      if (middle_slot)
        middle_slot.d(detaching);
      if (right_slot)
        right_slot.d(detaching);
      div3_resize_listener();
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let isMobile;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant } = $$props;
  let clientWidth;
  function div3_elementresize_handler() {
    clientWidth = this.clientWidth;
    $$invalidate(1, clientWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*clientWidth*/
    2) {
      $:
        $$invalidate(2, isMobile = clientWidth < 480);
    }
  };
  return [variant, clientWidth, isMobile, $$scope, slots, div3_elementresize_handler];
}
var ViewToolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance36, create_fragment36, safe_not_equal, { variant: 0 }, add_css17);
  }
};
var ViewToolbar_default = ViewToolbar;

// src/components/HorizontalGroup/HorizontalGroup.svelte
function add_css18(target) {
  append_styles(target, "svelte-j9o14g", "div.svelte-j9o14g{display:flex;gap:8px}.padding.svelte-j9o14g{padding:8px}.fullWidth.svelte-j9o14g{width:100%;justify-content:space-between}");
}
function create_fragment37(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "style", div_style_value = `align-items: ${/*alignItems*/
      ctx[1]}`);
      attr(div, "class", "svelte-j9o14g");
      toggle_class(
        div,
        "padding",
        /*padding*/
        ctx[2]
      );
      toggle_class(
        div,
        "fullWidth",
        /*fullWidth*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*alignItems*/
      2 && div_style_value !== (div_style_value = `align-items: ${/*alignItems*/
      ctx2[1]}`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & /*padding*/
      4) {
        toggle_class(
          div,
          "padding",
          /*padding*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*fullWidth*/
      1) {
        toggle_class(
          div,
          "fullWidth",
          /*fullWidth*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { fullWidth = false } = $$props;
  let { alignItems = "center" } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fullWidth" in $$props2)
      $$invalidate(0, fullWidth = $$props2.fullWidth);
    if ("alignItems" in $$props2)
      $$invalidate(1, alignItems = $$props2.alignItems);
    if ("padding" in $$props2)
      $$invalidate(2, padding = $$props2.padding);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [fullWidth, alignItems, padding, $$scope, slots];
}
var HorizontalGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance37, create_fragment37, safe_not_equal, { fullWidth: 0, alignItems: 1, padding: 2 }, add_css18);
  }
};
var HorizontalGroup_default = HorizontalGroup;

// src/components/FilterSettings/FilterSettings.svelte
function get_each_context4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[15] = i2;
  const constants_0 = (
    /*getFieldByName*/
    child_ctx[8](
      /*condition*/
      child_ctx[12].field
    )
  );
  child_ctx[13] = constants_0;
  return child_ctx;
}
function create_if_block9(ctx) {
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_if_block_22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*filter*/
    1)
      show_if = null;
    if (dirty & /*filter*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isStringFilterOperator(
        /*condition*/
        ctx2[12].operator
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isNumberFilterOperator(
        /*condition*/
        ctx2[12].operator
      );
    if (show_if_1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_22(ctx) {
  var _a;
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      value: parseFloat(
        /*condition*/
        (_a = ctx[12].value) != null ? _a : ""
      )
    }
  });
  numberinput.$on(
    "blur",
    /*handleValueChange*/
    ctx[4](
      /*i*/
      ctx[15]
    )
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const numberinput_changes = {};
      if (dirty & /*filter*/
      1)
        numberinput_changes.value = parseFloat(
          /*condition*/
          (_a2 = ctx2[12].value) != null ? _a2 : ""
        );
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: { value: (
      /*condition*/
      (_a = ctx[12].value) != null ? _a : ""
    ) }
  });
  textinput.$on(
    "blur",
    /*handleValueChange*/
    ctx[4](
      /*i*/
      ctx[15]
    )
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & /*filter*/
      1)
        textinput_changes.value = /*condition*/
        (_a2 = ctx2[12].value) != null ? _a2 : "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_23(ctx) {
  var _a, _b;
  let div;
  let t0_value = (
    /*i*/
    ctx[15] === 0 ? "Where" : "and"
  );
  let t0;
  let t1;
  let select0;
  let t22;
  let select1;
  let t3;
  let t4;
  let checkbox;
  let t5;
  let iconbutton;
  let current;
  select0 = new Select_default({
    props: {
      value: (
        /*condition*/
        ctx[12].field
      ),
      options: (
        /*fieldOptions*/
        ctx[1]
      )
    }
  });
  select0.$on(
    "change",
    /*handleFieldChange*/
    ctx[2](
      /*i*/
      ctx[15]
    )
  );
  select1 = new Select_default({
    props: {
      value: (
        /*condition*/
        ctx[12].operator
      ),
      options: (
        /*field*/
        ctx[13] ? (
          /*getOperatorsByField*/
          ctx[9](
            /*field*/
            ctx[13]
          )
        ) : []
      )
    }
  });
  select1.$on(
    "change",
    /*handleOperatorChange*/
    ctx[3](
      /*i*/
      ctx[15]
    )
  );
  let if_block = filterOperatorTypes[
    /*condition*/
    ctx[12].operator
  ] === "binary" && create_if_block9(ctx);
  checkbox = new Checkbox_default({
    props: {
      checked: (
        /*condition*/
        (_b = (_a = ctx[12]) == null ? void 0 : _a.enabled) != null ? _b : true
      )
    }
  });
  checkbox.$on(
    "check",
    /*handleStatusChange*/
    ctx[5](
      /*i*/
      ctx[15]
    )
  );
  iconbutton = new IconButton_default({
    props: {
      icon: "trash",
      onClick: (
        /*handleConditionRemove*/
        ctx[6](
          /*i*/
          ctx[15]
        )
      )
    }
  });
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      create_component(select0.$$.fragment);
      t22 = space();
      create_component(select1.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      create_component(checkbox.$$.fragment);
      t5 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "class", "setting-item-name");
      set_style(div, "width", "5ch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t0);
      insert(target, t1, anchor);
      mount_component(select0, target, anchor);
      insert(target, t22, anchor);
      mount_component(select1, target, anchor);
      insert(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(checkbox, target, anchor);
      insert(target, t5, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const select0_changes = {};
      if (dirty & /*filter*/
      1)
        select0_changes.value = /*condition*/
        ctx2[12].field;
      if (dirty & /*fieldOptions*/
      2)
        select0_changes.options = /*fieldOptions*/
        ctx2[1];
      select0.$set(select0_changes);
      const select1_changes = {};
      if (dirty & /*filter*/
      1)
        select1_changes.value = /*condition*/
        ctx2[12].operator;
      if (dirty & /*filter*/
      1)
        select1_changes.options = /*field*/
        ctx2[13] ? (
          /*getOperatorsByField*/
          ctx2[9](
            /*field*/
            ctx2[13]
          )
        ) : [];
      select1.$set(select1_changes);
      if (filterOperatorTypes[
        /*condition*/
        ctx2[12].operator
      ] === "binary") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*filter*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t4.parentNode, t4);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const checkbox_changes = {};
      if (dirty & /*filter*/
      1)
        checkbox_changes.checked = /*condition*/
        (_b2 = (_a2 = ctx2[12]) == null ? void 0 : _a2.enabled) != null ? _b2 : true;
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select0.$$.fragment, local);
      transition_in(select1.$$.fragment, local);
      transition_in(if_block);
      transition_in(checkbox.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select0.$$.fragment, local);
      transition_out(select1.$$.fragment, local);
      transition_out(if_block);
      transition_out(checkbox.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(select0, detaching);
      if (detaching)
        detach(t22);
      destroy_component(select1, detaching);
      if (detaching)
        detach(t3);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t4);
      destroy_component(checkbox, detaching);
      if (detaching)
        detach(t5);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block4(ctx) {
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & /*$$scope, filter, fieldOptions*/
      65539) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_default_slot_19(ctx) {
  let icon;
  let t3;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t3 = text("Add condition");
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot8(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*handleConditionAdd*/
    ctx[7]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_fragment38(ctx) {
  let div;
  let t3;
  let horizontalgroup;
  let current;
  let each_value = (
    /*filter*/
    ctx[0].conditions
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
      set_style(div, "display", "flex");
      set_style(div, "flex-direction", "column");
      set_style(div, "gap", "8px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append4(div, t3);
      mount_component(horizontalgroup, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*handleConditionRemove, filter, handleStatusChange, handleValueChange, isStringFilterOperator, parseFloat, isNumberFilterOperator, filterOperatorTypes, getFieldByName, getOperatorsByField, handleOperatorChange, fieldOptions, handleFieldChange*/
      895) {
        each_value = /*filter*/
        ctx2[0].conditions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const horizontalgroup_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      destroy_component(horizontalgroup);
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let fieldOptions;
  let { filter: filter3 } = $$props;
  let { fields } = $$props;
  let { onFilterChange } = $$props;
  const handleFieldChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), { field: detail, operator: "is-empty" }));
    }));
    onFilterChange(filter3);
  };
  const handleOperatorChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), { operator: detail }));
    }));
    onFilterChange(filter3);
  };
  const handleValueChange = (i2) => (event) => {
    if (event.currentTarget instanceof HTMLInputElement) {
      const inputValue = event.currentTarget.value;
      $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
        draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), { value: inputValue }));
      }));
      onFilterChange(filter3);
    }
  };
  const handleStatusChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), { enabled: detail }));
    }));
    onFilterChange(filter3);
  };
  const handleConditionRemove = (i2) => (event) => {
    event.stopPropagation();
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions.splice(i2, 1);
    }));
    onFilterChange(filter3);
  };
  function handleConditionAdd() {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      var _a, _b;
      draft.conditions.push({
        field: (_b = (_a = fields.at(0)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "",
        operator: "is-not-empty",
        enabled: true
      });
    }));
    onFilterChange(filter3);
  }
  function getFieldByName(fieldName) {
    return fields.find((field) => field.name === fieldName);
  }
  function getOperatorsByField(field) {
    const baseOperators = [
      {
        label: "is not empty",
        value: "is-not-empty"
      },
      { label: "is empty", value: "is-empty" }
    ];
    if (field.repeated) {
      return baseOperators;
    }
    switch (field.type) {
      case "string" /* String */:
        const stringOps = [
          { label: "is", value: "is" },
          { label: "is not", value: "is-not" },
          { label: "contains", value: "contains" },
          {
            label: "does not contain",
            value: "not-contains"
          }
        ];
        return [...baseOperators, ...stringOps];
      case "boolean" /* Boolean */:
        const booleanOps = [
          { label: "is checked", value: "is-checked" },
          {
            label: "is not checked",
            value: "is-not-checked"
          }
        ];
        return [...baseOperators, ...booleanOps];
      case "number" /* Number */:
        const numberOps = [
          { label: "=", value: "eq" },
          { label: "\u2260", value: "neq" },
          { label: "<", value: "lt" },
          { label: ">", value: "gt" },
          { label: "\u2264", value: "lte" },
          { label: "\u2265", value: "gte" }
        ];
        return [...baseOperators, ...numberOps];
    }
    return baseOperators;
  }
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(0, filter3 = $$props2.filter);
    if ("fields" in $$props2)
      $$invalidate(10, fields = $$props2.fields);
    if ("onFilterChange" in $$props2)
      $$invalidate(11, onFilterChange = $$props2.onFilterChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fields*/
    1024) {
      $:
        $$invalidate(1, fieldOptions = fields.map((field) => ({ label: field.name, value: field.name })));
    }
  };
  return [
    filter3,
    fieldOptions,
    handleFieldChange,
    handleOperatorChange,
    handleValueChange,
    handleStatusChange,
    handleConditionRemove,
    handleConditionAdd,
    getFieldByName,
    getOperatorsByField,
    fields,
    onFilterChange
  ];
}
var FilterSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance38, create_fragment38, safe_not_equal, {
      filter: 0,
      fields: 10,
      onFilterChange: 11
    });
  }
};
var FilterSettings_default = FilterSettings;

// src/components/FilterSettings/ColorFilterSettings.svelte
function get_each_context5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  child_ctx[16] = i2;
  const constants_0 = (
    /*getFieldByName*/
    child_ctx[9](
      /*condition*/
      child_ctx[13].condition.field
    )
  );
  child_ctx[14] = constants_0;
  return child_ctx;
}
function create_if_block10(ctx) {
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_15, create_if_block_23];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*filter*/
    1)
      show_if = null;
    if (dirty & /*filter*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isStringFilterOperator(
        /*condition*/
        ctx2[13].condition.operator
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isNumberFilterOperator(
        /*condition*/
        ctx2[13].condition.operator
      );
    if (show_if_1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_23(ctx) {
  var _a;
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      value: parseFloat(
        /*condition*/
        (_a = ctx[13].condition.value) != null ? _a : ""
      )
    }
  });
  numberinput.$on(
    "blur",
    /*handleValueChange*/
    ctx[5](
      /*i*/
      ctx[16]
    )
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const numberinput_changes = {};
      if (dirty & /*filter*/
      1)
        numberinput_changes.value = parseFloat(
          /*condition*/
          (_a2 = ctx2[13].condition.value) != null ? _a2 : ""
        );
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (
        /*condition*/
        (_a = ctx[13].condition.value) != null ? _a : ""
      )
    }
  });
  textinput.$on(
    "blur",
    /*handleValueChange*/
    ctx[5](
      /*i*/
      ctx[16]
    )
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & /*filter*/
      1)
        textinput_changes.value = /*condition*/
        (_a2 = ctx2[13].condition.value) != null ? _a2 : "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_24(ctx) {
  var _a, _b;
  let colorinput;
  let t0;
  let div;
  let t22;
  let select0;
  let t3;
  let select1;
  let t4;
  let t5;
  let checkbox;
  let t6;
  let iconbutton;
  let current;
  colorinput = new ColorInput_default({
    props: { value: (
      /*condition*/
      ctx[13].color
    ) }
  });
  colorinput.$on(
    "change",
    /*handleColorChange*/
    ctx[2](
      /*i*/
      ctx[16]
    )
  );
  select0 = new Select_default({
    props: {
      value: (
        /*condition*/
        ctx[13].condition.field
      ),
      options: (
        /*fieldOptions*/
        ctx[1]
      )
    }
  });
  select0.$on(
    "change",
    /*handleFieldChange*/
    ctx[3](
      /*i*/
      ctx[16]
    )
  );
  select1 = new Select_default({
    props: {
      value: (
        /*condition*/
        ctx[13].condition.operator
      ),
      options: (
        /*field*/
        ctx[14] ? (
          /*getOperatorsByField*/
          ctx[10](
            /*field*/
            ctx[14]
          )
        ) : []
      )
    }
  });
  select1.$on(
    "change",
    /*handleOperatorChange*/
    ctx[4](
      /*i*/
      ctx[16]
    )
  );
  let if_block = filterOperatorTypes[
    /*condition*/
    ctx[13].condition.operator
  ] === "binary" && create_if_block10(ctx);
  checkbox = new Checkbox_default({
    props: {
      checked: (
        /*condition*/
        (_b = (_a = ctx[13].condition) == null ? void 0 : _a.enabled) != null ? _b : true
      )
    }
  });
  checkbox.$on(
    "check",
    /*handleStatusChange*/
    ctx[6](
      /*i*/
      ctx[16]
    )
  );
  iconbutton = new IconButton_default({
    props: {
      icon: "trash",
      onClick: (
        /*handleConditionRemove*/
        ctx[7](
          /*i*/
          ctx[16]
        )
      )
    }
  });
  return {
    c() {
      create_component(colorinput.$$.fragment);
      t0 = space();
      div = element("div");
      div.textContent = "Where";
      t22 = space();
      create_component(select0.$$.fragment);
      t3 = space();
      create_component(select1.$$.fragment);
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      create_component(checkbox.$$.fragment);
      t6 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "class", "setting-item-name");
      set_style(div, "width", "5ch");
    },
    m(target, anchor) {
      mount_component(colorinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      insert(target, t22, anchor);
      mount_component(select0, target, anchor);
      insert(target, t3, anchor);
      mount_component(select1, target, anchor);
      insert(target, t4, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t5, anchor);
      mount_component(checkbox, target, anchor);
      insert(target, t6, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const colorinput_changes = {};
      if (dirty & /*filter*/
      1)
        colorinput_changes.value = /*condition*/
        ctx2[13].color;
      colorinput.$set(colorinput_changes);
      const select0_changes = {};
      if (dirty & /*filter*/
      1)
        select0_changes.value = /*condition*/
        ctx2[13].condition.field;
      if (dirty & /*fieldOptions*/
      2)
        select0_changes.options = /*fieldOptions*/
        ctx2[1];
      select0.$set(select0_changes);
      const select1_changes = {};
      if (dirty & /*filter*/
      1)
        select1_changes.value = /*condition*/
        ctx2[13].condition.operator;
      if (dirty & /*filter*/
      1)
        select1_changes.options = /*field*/
        ctx2[14] ? (
          /*getOperatorsByField*/
          ctx2[10](
            /*field*/
            ctx2[14]
          )
        ) : [];
      select1.$set(select1_changes);
      if (filterOperatorTypes[
        /*condition*/
        ctx2[13].condition.operator
      ] === "binary") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*filter*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t5.parentNode, t5);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const checkbox_changes = {};
      if (dirty & /*filter*/
      1)
        checkbox_changes.checked = /*condition*/
        (_b2 = (_a2 = ctx2[13].condition) == null ? void 0 : _a2.enabled) != null ? _b2 : true;
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(colorinput.$$.fragment, local);
      transition_in(select0.$$.fragment, local);
      transition_in(select1.$$.fragment, local);
      transition_in(if_block);
      transition_in(checkbox.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(colorinput.$$.fragment, local);
      transition_out(select0.$$.fragment, local);
      transition_out(select1.$$.fragment, local);
      transition_out(if_block);
      transition_out(checkbox.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(colorinput, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (detaching)
        detach(t22);
      destroy_component(select0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(select1, detaching);
      if (detaching)
        detach(t4);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t5);
      destroy_component(checkbox, detaching);
      if (detaching)
        detach(t6);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block5(ctx) {
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & /*$$scope, filter, fieldOptions*/
      131075) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_default_slot_110(ctx) {
  let icon;
  let t3;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t3 = text("Add color");
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot9(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*handleConditionAdd*/
    ctx[8]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_fragment39(ctx) {
  let div;
  let t3;
  let horizontalgroup;
  let current;
  let each_value = (
    /*filter*/
    ctx[0].conditions
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block5(get_each_context5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
      set_style(div, "display", "flex");
      set_style(div, "flex-direction", "column");
      set_style(div, "gap", "8px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append4(div, t3);
      mount_component(horizontalgroup, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*handleConditionRemove, filter, handleStatusChange, handleValueChange, isStringFilterOperator, parseFloat, isNumberFilterOperator, filterOperatorTypes, getFieldByName, getOperatorsByField, handleOperatorChange, fieldOptions, handleFieldChange, handleColorChange*/
      1791) {
        each_value = /*filter*/
        ctx2[0].conditions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const horizontalgroup_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      destroy_component(horizontalgroup);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let fieldOptions;
  let { filter: filter3 } = $$props;
  let { fields } = $$props;
  let { onFilterChange } = $$props;
  const handleColorChange = (i2) => (event) => {
    if (event.currentTarget instanceof HTMLInputElement) {
      const inputValue = event.currentTarget.value;
      $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
        draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), { color: inputValue }));
      }));
      onFilterChange(filter3);
    }
  };
  const handleFieldChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), {
        condition: Object.assign(Object.assign({}, cond.condition), { field: detail, operator: "is-empty" })
      }));
    }));
    onFilterChange(filter3);
  };
  const handleOperatorChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), {
        condition: Object.assign(Object.assign({}, cond.condition), { operator: detail })
      }));
    }));
    onFilterChange(filter3);
  };
  const handleValueChange = (i2) => (event) => {
    if (event.currentTarget instanceof HTMLInputElement) {
      const inputValue = event.currentTarget.value;
      $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
        draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), {
          condition: Object.assign(Object.assign({}, cond.condition), { value: inputValue })
        }));
      }));
      onFilterChange(filter3);
    }
  };
  const handleStatusChange = (i2) => ({ detail }) => {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions = draft.conditions.map((cond, idx) => idx !== i2 ? cond : Object.assign(Object.assign({}, cond), {
        condition: Object.assign(Object.assign({}, cond.condition), { enabled: detail })
      }));
    }));
    onFilterChange(filter3);
  };
  const handleConditionRemove = (i2) => (event) => {
    event.stopPropagation();
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      draft.conditions.splice(i2, 1);
    }));
    onFilterChange(filter3);
  };
  function handleConditionAdd() {
    $$invalidate(0, filter3 = immer_esm_default(filter3, (draft) => {
      var _a, _b;
      draft.conditions.push({
        color: "#a882ff",
        condition: {
          field: (_b = (_a = fields.at(0)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "",
          operator: "is-not-empty",
          enabled: true
        }
      });
    }));
    onFilterChange(filter3);
  }
  function getFieldByName(fieldName) {
    return fields.find((field) => field.name === fieldName);
  }
  function getOperatorsByField(field) {
    const baseOperators = [
      {
        label: "is not empty",
        value: "is-not-empty"
      },
      { label: "is empty", value: "is-empty" }
    ];
    if (field.repeated) {
      return baseOperators;
    }
    switch (field.type) {
      case "string" /* String */:
        const stringOps = [
          { label: "is", value: "is" },
          { label: "is not", value: "is-not" },
          { label: "contains", value: "contains" },
          {
            label: "does not contain",
            value: "not-contains"
          }
        ];
        return [...baseOperators, ...stringOps];
      case "boolean" /* Boolean */:
        const booleanOps = [
          { label: "is checked", value: "is-checked" },
          {
            label: "is not checked",
            value: "is-not-checked"
          }
        ];
        return [...baseOperators, ...booleanOps];
      case "number" /* Number */:
        const numberOps = [
          { label: "=", value: "eq" },
          { label: "\u2260", value: "neq" },
          { label: "<", value: "lt" },
          { label: ">", value: "gt" },
          { label: "\u2264", value: "lte" },
          { label: "\u2265", value: "gte" }
        ];
        return [...baseOperators, ...numberOps];
    }
    return baseOperators;
  }
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(0, filter3 = $$props2.filter);
    if ("fields" in $$props2)
      $$invalidate(11, fields = $$props2.fields);
    if ("onFilterChange" in $$props2)
      $$invalidate(12, onFilterChange = $$props2.onFilterChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fields*/
    2048) {
      $:
        $$invalidate(1, fieldOptions = fields.map((field) => ({ label: field.name, value: field.name })));
    }
  };
  return [
    filter3,
    fieldOptions,
    handleColorChange,
    handleFieldChange,
    handleOperatorChange,
    handleValueChange,
    handleStatusChange,
    handleConditionRemove,
    handleConditionAdd,
    getFieldByName,
    getOperatorsByField,
    fields,
    onFilterChange
  ];
}
var ColorFilterSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance39, create_fragment39, safe_not_equal, {
      filter: 0,
      fields: 11,
      onFilterChange: 12
    });
  }
};
var ColorFilterSettings_default = ColorFilterSettings;

// src/modals/add-view-modal.ts
var import_obsidian20 = require("obsidian");

// src/lib/stores/custom-views.ts
var customViews = writable({});

// src/modals/components/AddView.svelte
function create_default_slot_63(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*type*/
        ctx[3]
      ),
      options: (
        /*options*/
        ctx[8]
      )
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*type*/
      8)
        select_changes.value = /*type*/
        ctx2[3];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_53(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (
        /*name*/
        ctx[2]
      ),
      placeholder: (
        /*$i18n*/
        (_a = ctx[6].t("modals.view.create.optional")) != null ? _a : ""
      ),
      error: !!/*nameError*/
      ctx[4],
      helperText: (
        /*nameError*/
        ctx[4]
      )
    }
  });
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[10]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & /*name*/
      4)
        textinput_changes.value = /*name*/
        ctx2[2];
      if (dirty & /*$i18n*/
      64)
        textinput_changes.placeholder = /*$i18n*/
        (_a2 = ctx2[6].t("modals.view.create.optional")) != null ? _a2 : "";
      if (dirty & /*nameError*/
      16)
        textinput_changes.error = !!/*nameError*/
        ctx2[4];
      if (dirty & /*nameError*/
      16)
        textinput_changes.helperText = /*nameError*/
        ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_43(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*project*/
        ctx[0].id
      ),
      options: (
        /*$settings*/
        ctx[7].projects.map(func4)
      )
    }
  });
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[11]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*project*/
      1)
        select_changes.value = /*project*/
        ctx2[0].id;
      if (dirty & /*$settings*/
      128)
        select_changes.options = /*$settings*/
        ctx2[7].projects.map(func4);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_33(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let settingitem2;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.view.create.type.name")
      ),
      description: (
        /*$i18n*/
        (_a = ctx[6].t("modals.view.create.type.description")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot_63] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.view.create.name.name")
      ),
      description: (
        /*$i18n*/
        (_b = ctx[6].t("modals.view.create.name.description")) != null ? _b : ""
      ),
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: (
        /*$i18n*/
        ctx[6].t("modals.note.create.project.name")
      ),
      description: (
        /*$i18n*/
        (_c = ctx[6].t("modals.note.create.project.description")) != null ? _c : ""
      ),
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      create_component(settingitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.name = /*$i18n*/
        ctx2[6].t("modals.view.create.type.name");
      if (dirty & /*$i18n*/
      64)
        settingitem0_changes.description = /*$i18n*/
        (_a2 = ctx2[6].t("modals.view.create.type.description")) != null ? _a2 : "";
      if (dirty & /*$$scope, type*/
      32776) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.name = /*$i18n*/
        ctx2[6].t("modals.view.create.name.name");
      if (dirty & /*$i18n*/
      64)
        settingitem1_changes.description = /*$i18n*/
        (_b2 = ctx2[6].t("modals.view.create.name.description")) != null ? _b2 : "";
      if (dirty & /*$$scope, name, $i18n, nameError*/
      32852) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & /*$i18n*/
      64)
        settingitem2_changes.name = /*$i18n*/
        ctx2[6].t("modals.note.create.project.name");
      if (dirty & /*$i18n*/
      64)
        settingitem2_changes.description = /*$i18n*/
        (_c2 = ctx2[6].t("modals.note.create.project.description")) != null ? _c2 : "";
      if (dirty & /*$$scope, project, $settings*/
      32897) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem2, detaching);
    }
  };
}
function create_default_slot_25(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[6].t("modals.view.create.cta") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      64 && t_value !== (t_value = /*$i18n*/
      ctx2[6].t("modals.view.create.cta") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_111(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      32832) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot10(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_111] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, $i18n, project, $settings, name, nameError, type*/
      32989) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onSave, project, name, selectedOption, type, $i18n*/
      32879) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment40(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*$i18n*/
        ctx[6].t("modals.view.create.title")
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*$i18n*/
      64)
        modallayout_changes.title = /*$i18n*/
        ctx2[6].t("modals.view.create.title");
      if (dirty & /*$$scope, onSave, project, name, selectedOption, type, $i18n, $settings, nameError*/
      33023) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func4 = (project) => ({ label: project.name, value: project.id });
function instance40($$self, $$props, $$invalidate) {
  let selectedOption;
  let nameError;
  let $i18n;
  let $customViews;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, customViews, ($$value) => $$invalidate(13, $customViews = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(7, $settings = $$value));
  let { onSave } = $$props;
  let { project } = $$props;
  let name = "";
  let type = "table";
  const options = Object.values($customViews).map((view2) => {
    return {
      label: view2.getDisplayName(),
      value: view2.getViewType()
    };
  });
  function validateName(name2) {
    if (project.views.find((view2) => view2.name === name2)) {
      return $i18n.t("modals.view.create.existing-name-error");
    }
    return "";
  }
  const change_handler = ({ detail: value }) => {
    $$invalidate(3, type = value);
  };
  const input_handler = ({ detail: value }) => $$invalidate(2, name = value);
  const change_handler_1 = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(0, project = res);
    }
  };
  const click_handler = () => {
    var _a;
    onSave(project.id, Object.assign({}, DEFAULT_VIEW2, {
      id: v4_default(),
      name: name || nextUniqueViewName(project.views, (_a = selectedOption == null ? void 0 : selectedOption.label) != null ? _a : type),
      type
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*type*/
    8) {
      $:
        $$invalidate(5, selectedOption = options.find((option2) => option2.value === type));
    }
    if ($$self.$$.dirty & /*name*/
    4) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    onSave,
    name,
    type,
    nameError,
    selectedOption,
    $i18n,
    $settings,
    options,
    change_handler,
    input_handler,
    change_handler_1,
    click_handler
  ];
}
var AddView = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance40, create_fragment40, safe_not_equal, { onSave: 1, project: 0 });
  }
};
var AddView_default = AddView;

// src/modals/add-view-modal.ts
var AddViewModal = class extends import_obsidian20.Modal {
  constructor(app3, project, onSave) {
    super(app3);
    this.project = project;
    this.onSave = onSave;
  }
  onOpen() {
    this.component = new AddView_default({
      target: this.contentEl,
      props: {
        project: this.project,
        onSave: (projectId, view2) => {
          this.onSave(projectId, view2);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/confirm-dialog.ts
var import_obsidian21 = require("obsidian");

// src/modals/components/ConfirmDialog.svelte
function create_default_slot_54(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*message*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*message*/
      2)
        set_data(
          t3,
          /*message*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_44(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & /*$$scope, message*/
      258) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_default_slot_34(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*cta*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*cta*/
      4)
        set_data(
          t3,
          /*cta*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_26(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[5].t("modals.confirm.cancel") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      32 && t_value !== (t_value = /*$i18n*/
      ctx2[5].t("modals.confirm.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_112(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: (
        /*cta*/
        ctx[2] === /*$i18n*/
        ctx[5].t("modals.confirm.delete") ? "destructive" : "primary"
      ),
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[7]
  );
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*cta, $i18n*/
      36)
        button0_changes.variant = /*cta*/
        ctx2[2] === /*$i18n*/
        ctx2[5].t("modals.confirm.delete") ? "destructive" : "primary";
      if (dirty & /*$$scope, cta*/
      260) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope, $i18n*/
      288) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot11(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, message*/
      258) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onCancel, $i18n, cta, onConfirm*/
      316) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment41(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*title*/
      1)
        modallayout_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*$$scope, onCancel, $i18n, cta, onConfirm, message*/
      318) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  let { title } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onConfirm } = $$props;
  let { onCancel } = $$props;
  const click_handler = () => {
    onConfirm();
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onConfirm" in $$props2)
      $$invalidate(3, onConfirm = $$props2.onConfirm);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    title,
    message,
    cta,
    onConfirm,
    onCancel,
    $i18n,
    click_handler,
    click_handler_1
  ];
}
var ConfirmDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance41, create_fragment41, safe_not_equal, {
      title: 0,
      message: 1,
      cta: 2,
      onConfirm: 3,
      onCancel: 4
    });
  }
};
var ConfirmDialog_default = ConfirmDialog;

// src/modals/confirm-dialog.ts
var ConfirmDialogModal = class extends import_obsidian21.Modal {
  constructor(app3, title, message, cta, onConfirm) {
    super(app3);
    this.title = title;
    this.message = message;
    this.cta = cta;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    this.component = new ConfirmDialog_default({
      target: this.contentEl,
      props: {
        title: this.title,
        message: this.message,
        cta: this.cta,
        onConfirm: () => {
          this.onConfirm();
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/app/toolbar/Flair.svelte
function add_css19(target) {
  append_styles(target, "svelte-1xmg436", "span.svelte-1xmg436{color:var(--text-on-accent);display:flex;align-items:center;gap:var(--size-4-1)}.error.svelte-1xmg436{background-color:var(--background-modifier-error)}");
}
function create_fragment42(ctx) {
  let span;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(
        span,
        "aria-label",
        /*tooltip*/
        ctx[1]
      );
      attr(span, "class", "flair svelte-1xmg436");
      toggle_class(
        span,
        "mod-pop",
        /*variant*/
        ctx[0] === "primary"
      );
      toggle_class(
        span,
        "error",
        /*variant*/
        ctx[0] === "error"
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            span,
            "keypress",
            /*keypress_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tooltip*/
      2) {
        attr(
          span,
          "aria-label",
          /*tooltip*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*variant*/
      1) {
        toggle_class(
          span,
          "mod-pop",
          /*variant*/
          ctx2[0] === "primary"
        );
      }
      if (!current || dirty & /*variant*/
      1) {
        toggle_class(
          span,
          "error",
          /*variant*/
          ctx2[0] === "error"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant } = $$props;
  let { tooltip = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("tooltip" in $$props2)
      $$invalidate(1, tooltip = $$props2.tooltip);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [variant, tooltip, $$scope, slots, click_handler, keypress_handler];
}
var Flair = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance42, create_fragment42, safe_not_equal, { variant: 0, tooltip: 1 }, add_css19);
  }
};
var Flair_default = Flair;

// src/app/toolbar/ProjectSelect.svelte
var import_obsidian22 = require("obsidian");
function add_css20(target) {
  append_styles(target, "svelte-h4e1e6", "span.svelte-h4e1e6{display:flex;align-items:center;gap:4px}");
}
function create_if_block11(ctx) {
  var _a;
  let flair;
  let current;
  flair = new Flair_default({
    props: {
      variant: "primary",
      tooltip: (
        /*$i18n*/
        (_a = ctx[5].t("toolbar.read-only-desc")) != null ? _a : ""
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(flair.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flair, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const flair_changes = {};
      if (dirty & /*$i18n*/
      32)
        flair_changes.tooltip = /*$i18n*/
        (_a2 = ctx2[5].t("toolbar.read-only-desc")) != null ? _a2 : "";
      if (dirty & /*$$scope, $i18n*/
      1056) {
        flair_changes.$$scope = { dirty, ctx: ctx2 };
      }
      flair.$set(flair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flair, detaching);
    }
  };
}
function create_default_slot12(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[5].t("toolbar.read-only") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      32 && t_value !== (t_value = /*$i18n*/
      ctx2[5].t("toolbar.read-only") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment43(ctx) {
  var _a, _b, _c;
  let span;
  let select;
  let t0;
  let iconbutton0;
  let t1;
  let iconbutton1;
  let t22;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*projectId*/
        (_a = ctx[0]) != null ? _a : ""
      ),
      options: immer_esm_default(
        /*projects*/
        ctx[1].map(func5),
        func_13
      ),
      placeholder: (
        /*$i18n*/
        (_b = ctx[5].t("toolbar.projects.none")) != null ? _b : ""
      )
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[7]
  );
  iconbutton0 = new IconButton_default({
    props: {
      icon: "more-vertical",
      size: "sm",
      disabled: !/*projects*/
      ctx[1].length,
      tooltip: (
        /*$i18n*/
        ctx[5].t("toolbar.projects.options")
      ),
      onClick: (
        /*func_2*/
        ctx[8]
      )
    }
  });
  iconbutton1 = new IconButton_default({
    props: {
      icon: "folder-plus",
      size: "md",
      tooltip: (
        /*$i18n*/
        ctx[5].t("modals.project.create.title")
      ),
      onClick: (
        /*func_3*/
        ctx[9]
      )
    }
  });
  let if_block = (
    /*project*/
    ((_c = ctx[4]) == null ? void 0 : _c.dataSource.kind) === "dataview" && create_if_block11(ctx)
  );
  return {
    c() {
      span = element("span");
      create_component(select.$$.fragment);
      t0 = space();
      create_component(iconbutton0.$$.fragment);
      t1 = space();
      create_component(iconbutton1.$$.fragment);
      t22 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "svelte-h4e1e6");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(select, span, null);
      append4(span, t0);
      mount_component(iconbutton0, span, null);
      append4(span, t1);
      mount_component(iconbutton1, span, null);
      append4(span, t22);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & /*projectId*/
      1)
        select_changes.value = /*projectId*/
        (_a2 = ctx2[0]) != null ? _a2 : "";
      if (dirty & /*projects*/
      2)
        select_changes.options = immer_esm_default(
          /*projects*/
          ctx2[1].map(func5),
          func_13
        );
      if (dirty & /*$i18n*/
      32)
        select_changes.placeholder = /*$i18n*/
        (_b2 = ctx2[5].t("toolbar.projects.none")) != null ? _b2 : "";
      select.$set(select_changes);
      const iconbutton0_changes = {};
      if (dirty & /*projects*/
      2)
        iconbutton0_changes.disabled = !/*projects*/
        ctx2[1].length;
      if (dirty & /*$i18n*/
      32)
        iconbutton0_changes.tooltip = /*$i18n*/
        ctx2[5].t("toolbar.projects.options");
      if (dirty & /*$i18n, project, $app, projectId, onProjectChange*/
      117)
        iconbutton0_changes.onClick = /*func_2*/
        ctx2[8];
      iconbutton0.$set(iconbutton0_changes);
      const iconbutton1_changes = {};
      if (dirty & /*$i18n*/
      32)
        iconbutton1_changes.tooltip = /*$i18n*/
        ctx2[5].t("modals.project.create.title");
      if (dirty & /*onProjectAdd*/
      8)
        iconbutton1_changes.onClick = /*func_3*/
        ctx2[9];
      iconbutton1.$set(iconbutton1_changes);
      if (
        /*project*/
        ((_c2 = ctx2[4]) == null ? void 0 : _c2.dataSource.kind) === "dataview"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*project*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      transition_in(iconbutton0.$$.fragment, local);
      transition_in(iconbutton1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(iconbutton0.$$.fragment, local);
      transition_out(iconbutton1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(select);
      destroy_component(iconbutton0);
      destroy_component(iconbutton1);
      if (if_block)
        if_block.d();
    }
  };
}
var func5 = (project) => ({ label: project.name, value: project.id });
var func_13 = (draft) => {
  draft.sort((a2, b2) => a2.label.localeCompare(b2.label));
};
function instance43($$self, $$props, $$invalidate) {
  let project;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(6, $app = $$value));
  let { projectId } = $$props;
  let { projects } = $$props;
  let { onProjectChange } = $$props;
  let { onProjectAdd } = $$props;
  const change_handler = ({ detail: value }) => onProjectChange(value);
  const func_2 = (event) => {
    const menu = new import_obsidian22.Menu();
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.edit.short-title")).setIcon("edit").onClick(() => {
        if (project) {
          new CreateProjectModal($app, $i18n.t("modals.project.edit.title"), $i18n.t("modals.project.edit.cta"), settings.updateProject, project).open();
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.duplicate.title")).setIcon("copy").onClick(() => {
        if (projectId) {
          const id = settings.duplicateProject(projectId);
          onProjectChange(id);
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.delete.short-title")).setIcon("trash").onClick(() => {
        var _a;
        new ConfirmDialogModal(
          $app,
          $i18n.t("modals.project.delete.title"),
          $i18n.t("modals.project.delete.message", { project: (_a = project == null ? void 0 : project.name) != null ? _a : "" }),
          $i18n.t("modals.project.delete.cta"),
          () => {
            if (projectId) {
              settings.deleteProject(projectId);
            }
          }
        ).open();
      });
    });
    menu.showAtMouseEvent(event);
  };
  const func_3 = () => onProjectAdd();
  $$self.$$set = ($$props2) => {
    if ("projectId" in $$props2)
      $$invalidate(0, projectId = $$props2.projectId);
    if ("projects" in $$props2)
      $$invalidate(1, projects = $$props2.projects);
    if ("onProjectChange" in $$props2)
      $$invalidate(2, onProjectChange = $$props2.onProjectChange);
    if ("onProjectAdd" in $$props2)
      $$invalidate(3, onProjectAdd = $$props2.onProjectAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*projects, projectId*/
    3) {
      $:
        $$invalidate(4, project = projects.find((project2) => project2.id === projectId));
    }
  };
  return [
    projectId,
    projects,
    onProjectChange,
    onProjectAdd,
    project,
    $i18n,
    $app,
    change_handler,
    func_2,
    func_3
  ];
}
var ProjectSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance43,
      create_fragment43,
      safe_not_equal,
      {
        projectId: 0,
        projects: 1,
        onProjectChange: 2,
        onProjectAdd: 3
      },
      add_css20
    );
  }
};
var ProjectSelect_default = ProjectSelect;

// src/app/toolbar/ViewItem.svelte
var import_obsidian24 = require("obsidian");
function add_css21(target) {
  append_styles(target, "svelte-3t9vh7", "div.svelte-3t9vh7{display:inline-flex;align-items:center;gap:4px;height:1.8rem;padding:0 8px;min-width:min-content;font-size:var(--font-ui-small);border-radius:var(--radius-s);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;border:1px solid transparent}div.svelte-3t9vh7:hover{background-color:var(--background-modifier-hover)}.active.svelte-3t9vh7{background-color:var(--background-modifier-hover)}.error.svelte-3t9vh7{border:1px solid var(--background-modifier-error)}");
}
function create_if_block_24(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({ props: { name: (
    /*icon*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & /*icon*/
      8)
        icon_1_changes.name = /*icon*/
        ctx2[3];
      icon_1.$set(icon_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function create_else_block2(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*label*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      1)
        set_data(
          t3,
          /*label*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_if_block_16(ctx) {
  let textinput;
  let updating_ref;
  let updating_value;
  let current;
  function textinput_ref_binding(value) {
    ctx[12](value);
  }
  function textinput_value_binding(value) {
    ctx[13](value);
  }
  let textinput_props = {
    noPadding: true,
    embed: true,
    width: (
      /*label*/
      ctx[0].length + "ch"
    )
  };
  if (
    /*inputRef*/
    ctx[5] !== void 0
  ) {
    textinput_props.ref = /*inputRef*/
    ctx[5];
  }
  if (
    /*label*/
    ctx[0] !== void 0
  ) {
    textinput_props.value = /*label*/
    ctx[0];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind6(textinput, "ref", textinput_ref_binding));
  binding_callbacks.push(() => bind6(textinput, "value", textinput_value_binding));
  textinput.$on(
    "keydown",
    /*keydown_handler*/
    ctx[14]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*label*/
      1)
        textinput_changes.width = /*label*/
        ctx2[0].length + "ch";
      if (!updating_ref && dirty & /*inputRef*/
      32) {
        updating_ref = true;
        textinput_changes.ref = /*inputRef*/
        ctx2[5];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & /*label*/
      1) {
        updating_value = true;
        textinput_changes.value = /*label*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block12(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: {
      icon: "chevron-down",
      size: "sm",
      nopadding: true,
      onClick: (
        /*func*/
        ctx[15]
      )
    }
  });
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_fragment44(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*icon*/
    ctx[3] && create_if_block_24(ctx)
  );
  const if_block_creators = [create_if_block_16, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editing*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*active*/
    ctx[2] && create_if_block12(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(
        div,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr(div, "class", "svelte-3t9vh7");
      toggle_class(
        div,
        "active",
        /*active*/
        ctx[2]
      );
      toggle_class(
        div,
        "error",
        /*error*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append4(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append4(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "blur",
            /*blur_handler*/
            ctx[16]
          ),
          listen(
            div,
            "dblclick",
            /*dblclick_handler*/
            ctx[17]
          ),
          listen(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[11]
          ),
          action_destroyer(useClickOutside_action = useClickOutside2.call(
            null,
            div,
            /*useClickOutside_function*/
            ctx[18]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*icon*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*icon*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (
        /*active*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*active*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block12(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*id*/
      2) {
        attr(
          div,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & /*editing*/
      16)
        useClickOutside_action.update.call(
          null,
          /*useClickOutside_function*/
          ctx2[18]
        );
      if (!current || dirty & /*active*/
      4) {
        toggle_class(
          div,
          "active",
          /*active*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      128) {
        toggle_class(
          div,
          "error",
          /*error*/
          ctx2[7]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let error2;
  let { label } = $$props;
  let { id } = $$props;
  let { active: active2 = false } = $$props;
  let { icon = "" } = $$props;
  let { onValidate } = $$props;
  let fallback = label;
  function rollback() {
    $$invalidate(0, label = fallback);
  }
  let editing = false;
  let inputRef;
  const dispatch2 = createEventDispatcher();
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textinput_ref_binding(value) {
    inputRef = value;
    $$invalidate(5, inputRef);
  }
  function textinput_value_binding(value) {
    label = value;
    $$invalidate(0, label);
  }
  const keydown_handler = (event) => {
    if (event.key === "Enter") {
      $$invalidate(4, editing = false);
      if (!error2) {
        $$invalidate(6, fallback = label);
        dispatch2("rename", label);
      } else {
        rollback();
      }
    }
  };
  const func8 = (event) => {
    const menu = new import_obsidian24.Menu();
    menu.addItem((item) => {
      item.setTitle("Duplicate view");
      item.setIcon("copy");
      item.onClick(() => {
        dispatch2("duplicate");
      });
    });
    menu.addItem((item) => {
      item.setTitle("Delete view");
      item.setIcon("trash");
      item.onClick(() => {
        dispatch2("delete");
      });
    });
    menu.showAtMouseEvent(event);
  };
  const blur_handler = () => {
    $$invalidate(4, editing = false);
    rollback();
  };
  const dblclick_handler = () => $$invalidate(4, editing = true);
  const useClickOutside_function = () => {
    $$invalidate(4, editing = false);
    rollback();
  };
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("active" in $$props2)
      $$invalidate(2, active2 = $$props2.active);
    if ("icon" in $$props2)
      $$invalidate(3, icon = $$props2.icon);
    if ("onValidate" in $$props2)
      $$invalidate(10, onValidate = $$props2.onValidate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inputRef, editing*/
    48) {
      $:
        if (inputRef && editing) {
          inputRef.focus();
          inputRef.select();
        }
    }
    if ($$self.$$.dirty & /*onValidate, label*/
    1025) {
      $:
        $$invalidate(7, error2 = !onValidate(label));
    }
  };
  return [
    label,
    id,
    active2,
    icon,
    editing,
    inputRef,
    fallback,
    error2,
    rollback,
    dispatch2,
    onValidate,
    mousedown_handler,
    textinput_ref_binding,
    textinput_value_binding,
    keydown_handler,
    func8,
    blur_handler,
    dblclick_handler,
    useClickOutside_function
  ];
}
var ViewItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance44,
      create_fragment44,
      safe_not_equal,
      {
        label: 0,
        id: 1,
        active: 2,
        icon: 3,
        onValidate: 10
      },
      add_css21
    );
  }
};
var ViewItem_default = ViewItem;

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on2(el, event, fn3) {
  el.addEventListener(event, fn3, !IE11OrLess && captureMode);
}
function off(el, event, fn3) {
  el.removeEventListener(event, fn3, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_24) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
    if (iterator) {
      for (; i2 < n2; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left6, bottom2, right6, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left6 = elRect.left;
    bottom2 = elRect.bottom;
    right6 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left6 = 0;
    bottom2 = window.innerHeight;
    right6 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left6 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right6 = left6 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left6 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right6 = left6 + width;
    }
  }
  return {
    top: top2,
    left: left6,
    bottom: bottom2,
    right: right6,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i2 = 0, children2 = el.children;
  while (i2 < children2.length) {
    if (children2[i2].style.display !== "none" && children2[i2] !== Sortable.ghost && (includeDragEl || children2[i2] !== Sortable.dragged) && closest(children2[i2], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children2[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last5 = el.lastElementChild;
  while (last5 && (last5 === Sortable.ghost || css(last5, "display") === "none" || selector && !matches(last5, selector))) {
    last5 = last5.previousElementSibling;
  }
  return last5 || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem4 = el;
  var gotSelf = false;
  do {
    if (elem4.clientWidth < elem4.scrollWidth || elem4.clientHeight < elem4.scrollHeight) {
      var elemCSS = css(elem4);
      if (elem4.clientWidth < elem4.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem4.clientHeight < elem4.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem4.getBoundingClientRect || elem4 === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem4;
        gotSelf = true;
      }
    }
  } while (elem4 = elem4.parentNode);
  return getWindowScrollingElement();
}
function extend3(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children2 = [].slice.call(this.el.children);
      children2.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin2) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin2)) {
        plugin2[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin2.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin2.pluginName, " more than once");
      }
    });
    plugins.push(plugin2);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (sortable[plugin2.pluginName][eventNameGlobal]) {
        sortable[plugin2.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin2.pluginName] && sortable[plugin2.pluginName][eventName]) {
        sortable[plugin2.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin2) {
      var pluginName = plugin2.pluginName;
      if (!sortable.options[pluginName] && !plugin2.initializeByDefault)
        return;
      var initialized = new plugin2(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin2) {
      if (typeof plugin2.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin2.eventProperties.call(sortable[plugin2.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (plugin2.optionListeners && typeof plugin2.optionListeners[name] === "function") {
        modifiedValue = plugin2.optionListeners[name].call(sortable[plugin2.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof2(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event[i2] = evt[i2];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn3 in this) {
    if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
      this[fn3] = this[fn3].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on2(el, "pointerdown", this._onTapStart);
  } else {
    on2(el, "mousedown", this._onTapStart);
    on2(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on2(el, "dragover", this);
    on2(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter3 = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter3 === "function") {
      if (filter3.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter3) {
      filter3 = filter3.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter3) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on2(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mouseup", _this._onDrop);
      on2(ownerDocument, "touchend", _this._onDrop);
      on2(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on2(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on2(ownerDocument, "touchend", _this._disableDelayedDrag);
        on2(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on2(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on2(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on2(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on2(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on2(document, "touchmove", this._onTouchMove);
      } else {
        on2(document, "mousemove", this._onTouchMove);
      }
    } else {
      on2(dragEl, "dragend", this);
      on2(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on2(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on2(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on2(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order2 = [], el, children2 = this.el.children, i2 = 0, n2 = children2.length, options = this.options;
    for (; i2 < n2; i2++) {
      el = children2[i2];
      if (closest(el, options.draggable, this.el, false)) {
        order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort3(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn3) {
  return setTimeout(fn3, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on2(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on2,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend3,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin2) {
    if (!plugin2.prototype || !plugin2.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin2));
    }
    if (plugin2.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin2.utils);
    PluginManager.mount(plugin2);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn3 in this) {
      if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
        this[fn3] = this[fn3].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on2(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on2(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on2(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on2(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem4 = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem4, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem4, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem4, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem4, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left6 = rect.left, right6 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right6 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left6 - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// src/app/toolbar/ViewItemList.svelte
function add_css22(target) {
  append_styles(target, "svelte-1msv9tc", "div.svelte-1msv9tc{display:flex;justify-content:center;gap:var(--size-4-1);min-width:min-content}section.svelte-1msv9tc{overflow-x:auto}section.svelte-1msv9tc::-webkit-scrollbar{display:none}");
}
function create_fragment45(ctx) {
  let section;
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      section = element("section");
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1msv9tc");
      attr(section, "class", "svelte-1msv9tc");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append4(section, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onSort } = $$props;
  let ref;
  let sortable;
  onMount(() => {
    sortable = sortable_esm_default.create(ref, {
      direction: () => "horizontal",
      animation: 100,
      dataIdAttr: "data-id",
      forceFallback: true,
      onSort: () => onSort(sortable.toArray())
    });
  });
  onDestroy(() => {
    sortable.destroy();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("onSort" in $$props2)
      $$invalidate(1, onSort = $$props2.onSort);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [ref, onSort, $$scope, slots, div_binding];
}
var ViewItemList = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance45, create_fragment45, safe_not_equal, { onSort: 1 }, add_css22);
  }
};
var ViewItemList_default = ViewItemList;

// src/app/toolbar/ViewSelect.svelte
function add_css23(target) {
  append_styles(target, "svelte-t4ijng", "span.svelte-t4ijng{display:inline-flex;align-items:center;gap:4px}");
}
function get_each_context6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_else_block3(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_113] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[17]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      4194816) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block13(ctx) {
  let span;
  let viewitemlist;
  let t3;
  let iconbutton;
  let current;
  viewitemlist = new ViewItemList_default({
    props: {
      onSort: (
        /*onViewSort*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot13] },
      $$scope: { ctx }
    }
  });
  iconbutton = new IconButton_default({
    props: {
      icon: "plus",
      size: "sm",
      onClick: (
        /*func_1*/
        ctx[16]
      ),
      tooltip: (
        /*$i18n*/
        ctx[9].t("toolbar.view.add")
      )
    }
  });
  return {
    c() {
      span = element("span");
      create_component(viewitemlist.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
      attr(span, "class", "svelte-t4ijng");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(viewitemlist, span, null);
      append4(span, t3);
      mount_component(iconbutton, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const viewitemlist_changes = {};
      if (dirty & /*onViewSort*/
      128)
        viewitemlist_changes.onSort = /*onViewSort*/
        ctx2[7];
      if (dirty & /*$$scope, views, viewId, viewExists, onViewChange, onViewRename, onViewDelete, onViewDuplicate*/
      4194671) {
        viewitemlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewitemlist.$set(viewitemlist_changes);
      const iconbutton_changes = {};
      if (dirty & /*onViewAdd*/
      16)
        iconbutton_changes.onClick = /*func_1*/
        ctx2[16];
      if (dirty & /*$i18n*/
      512)
        iconbutton_changes.tooltip = /*$i18n*/
        ctx2[9].t("toolbar.view.add");
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitemlist.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitemlist.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(viewitemlist);
      destroy_component(iconbutton);
    }
  };
}
function create_default_slot_113(ctx) {
  let icon;
  let t0;
  let t1_value = (
    /*$i18n*/
    ctx[9].t("toolbar.view.add") + ""
  );
  let t1;
  let current;
  icon = new Icon_default({ props: { name: "plus", size: "sm" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$i18n*/
      512) && t1_value !== (t1_value = /*$i18n*/
      ctx2[9].t("toolbar.view.add") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block6(key_1, ctx) {
  let first;
  let viewitem;
  let current;
  function func8(...args) {
    return (
      /*func*/
      ctx[11](
        /*v*/
        ctx[19],
        ...args
      )
    );
  }
  function mousedown_handler() {
    return (
      /*mousedown_handler*/
      ctx[12](
        /*v*/
        ctx[19]
      )
    );
  }
  function rename_handler(...args) {
    return (
      /*rename_handler*/
      ctx[13](
        /*v*/
        ctx[19],
        ...args
      )
    );
  }
  function delete_handler() {
    return (
      /*delete_handler*/
      ctx[14](
        /*v*/
        ctx[19]
      )
    );
  }
  function duplicate_handler() {
    return (
      /*duplicate_handler*/
      ctx[15](
        /*v*/
        ctx[19]
      )
    );
  }
  viewitem = new ViewItem_default({
    props: {
      id: (
        /*v*/
        ctx[19].id
      ),
      active: (
        /*viewId*/
        ctx[0] === /*v*/
        ctx[19].id
      ),
      label: (
        /*v*/
        ctx[19].name
      ),
      icon: (
        /*iconFromViewType*/
        ctx[10](
          /*v*/
          ctx[19].type
        )
      ),
      onValidate: func8
    }
  });
  viewitem.$on("mousedown", mousedown_handler);
  viewitem.$on("rename", rename_handler);
  viewitem.$on("delete", delete_handler);
  viewitem.$on("duplicate", duplicate_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(viewitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(viewitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const viewitem_changes = {};
      if (dirty & /*views*/
      2)
        viewitem_changes.id = /*v*/
        ctx[19].id;
      if (dirty & /*viewId, views*/
      3)
        viewitem_changes.active = /*viewId*/
        ctx[0] === /*v*/
        ctx[19].id;
      if (dirty & /*views*/
      2)
        viewitem_changes.label = /*v*/
        ctx[19].name;
      if (dirty & /*views*/
      2)
        viewitem_changes.icon = /*iconFromViewType*/
        ctx[10](
          /*v*/
          ctx[19].type
        );
      if (dirty & /*views, viewExists*/
      258)
        viewitem_changes.onValidate = func8;
      viewitem.$set(viewitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(viewitem, detaching);
    }
  };
}
function create_key_block(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = (
    /*views*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*v*/
    ctx2[19].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block6(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*views, viewId, iconFromViewType, viewExists, onViewChange, onViewRename, onViewDelete, onViewDuplicate*/
      1391) {
        each_value = /*views*/
        ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block6, each_1_anchor, get_each_context6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot13(ctx) {
  let previous_key = (
    /*views*/
    ctx[1]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty3();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*views*/
      2 && safe_not_equal(previous_key, previous_key = /*views*/
      ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_fragment46(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block13, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*views*/
      ctx2[1].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let $customViews;
  let $i18n;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(18, $customViews = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  let { viewId } = $$props;
  let { views } = $$props;
  let { onViewChange } = $$props;
  let { onViewDelete } = $$props;
  let { onViewAdd } = $$props;
  let { onViewDuplicate } = $$props;
  let { onViewRename } = $$props;
  let { onViewSort } = $$props;
  let { viewExists } = $$props;
  function iconFromViewType(type) {
    var _a, _b;
    return (_b = (_a = $customViews[type]) === null || _a === void 0 ? void 0 : _a.getIcon()) !== null && _b !== void 0 ? _b : "";
  }
  const func8 = (v2, name) => {
    if (name === v2.name) {
      return true;
    }
    return name !== "" && !viewExists(name);
  };
  const mousedown_handler = (v2) => onViewChange(v2.id);
  const rename_handler = (v2, { detail: name }) => {
    onViewRename(v2.id, name);
  };
  const delete_handler = (v2) => {
    onViewDelete(v2.id);
  };
  const duplicate_handler = (v2) => {
    onViewDuplicate(v2.id);
  };
  const func_15 = () => {
    onViewAdd();
  };
  const click_handler = () => {
    onViewAdd();
  };
  $$self.$$set = ($$props2) => {
    if ("viewId" in $$props2)
      $$invalidate(0, viewId = $$props2.viewId);
    if ("views" in $$props2)
      $$invalidate(1, views = $$props2.views);
    if ("onViewChange" in $$props2)
      $$invalidate(2, onViewChange = $$props2.onViewChange);
    if ("onViewDelete" in $$props2)
      $$invalidate(3, onViewDelete = $$props2.onViewDelete);
    if ("onViewAdd" in $$props2)
      $$invalidate(4, onViewAdd = $$props2.onViewAdd);
    if ("onViewDuplicate" in $$props2)
      $$invalidate(5, onViewDuplicate = $$props2.onViewDuplicate);
    if ("onViewRename" in $$props2)
      $$invalidate(6, onViewRename = $$props2.onViewRename);
    if ("onViewSort" in $$props2)
      $$invalidate(7, onViewSort = $$props2.onViewSort);
    if ("viewExists" in $$props2)
      $$invalidate(8, viewExists = $$props2.viewExists);
  };
  return [
    viewId,
    views,
    onViewChange,
    onViewDelete,
    onViewAdd,
    onViewDuplicate,
    onViewRename,
    onViewSort,
    viewExists,
    $i18n,
    iconFromViewType,
    func8,
    mousedown_handler,
    rename_handler,
    delete_handler,
    duplicate_handler,
    func_15,
    click_handler
  ];
}
var ViewSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance46,
      create_fragment46,
      safe_not_equal,
      {
        viewId: 0,
        views: 1,
        onViewChange: 2,
        onViewDelete: 3,
        onViewAdd: 4,
        onViewDuplicate: 5,
        onViewRename: 6,
        onViewSort: 7,
        viewExists: 8
      },
      add_css23
    );
  }
};
var ViewSelect_default = ViewSelect;

// src/modals/inspector.ts
var import_obsidian26 = require("obsidian");

// src/views/Board/components/Board/board-helpers.ts
function getPrioritizedRecords(records, groupByPriority) {
  const res = records.filter((record) => {
    if (!groupByPriority) {
      return false;
    }
    return isNumber(record.values[groupByPriority.name]) || isDate(record.values[groupByPriority.name]);
  });
  res.sort((a2, b2) => {
    if (groupByPriority) {
      const aval = a2.values[groupByPriority.name];
      const bval = b2.values[groupByPriority.name];
      if (isNumber(aval) && isNumber(bval)) {
        const value = aval - bval;
        if (value) {
          return value;
        }
      }
      if (isDate(aval) && isDate(bval)) {
        const value = aval.getTime() - bval.getTime();
        if (value) {
          return value;
        }
      }
      return a2.id.localeCompare(b2.id);
    }
    return 0;
  });
  return res;
}
function getUnprioritizedRecords(records, groupByPriority) {
  const res = records.filter((record) => {
    if (!groupByPriority) {
      return false;
    }
    return !(isNumber(record.values[groupByPriority.name]) || isDate(record.values[groupByPriority.name]));
  });
  res.sort((a2, b2) => {
    if (groupByPriority) {
      const aval = a2.id;
      const bval = b2.id;
      return aval.localeCompare(bval);
    }
    return 0;
  });
  return res;
}
function getDisplayName(recordId) {
  const basename = getBasename(recordId);
  return basename.slice(0, basename.lastIndexOf("."));
}
function getBasename(str) {
  const lastSlash = str.lastIndexOf("/");
  if (lastSlash < 0) {
    return str;
  }
  return str.slice(lastSlash + 1);
}

// src/modals/components/Inspector.svelte
function add_css24(target) {
  append_styles(target, "svelte-1lhlmf3", "pre.svelte-1lhlmf3{overflow:scroll}span.svelte-1lhlmf3{display:flex;gap:8px;align-items:center}");
}
function get_each_context7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_default_slot_64(ctx) {
  let pre;
  let t0_value = (
    /*error*/
    ctx[7].err + ""
  );
  let t0;
  let t1;
  return {
    c() {
      pre = element("pre");
      t0 = text(t0_value);
      t1 = space();
      attr(pre, "class", "svelte-1lhlmf3");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append4(pre, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*errors*/
      2 && t0_value !== (t0_value = /*error*/
      ctx2[7].err + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(pre);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_55(ctx) {
  let t3;
  return {
    c() {
      t3 = text("error");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_header_slot2(ctx) {
  let div3;
  let span;
  let flair;
  let iconbutton;
  let t0;
  let div2;
  let div0;
  let t1_value = getDisplayName(
    /*error*/
    ctx[7].recordId
  ) + "";
  let t1;
  let t22;
  let div1;
  let t3_value = getFolder(
    /*error*/
    ctx[7].recordId
  ) + "";
  let t3;
  let t4;
  let current;
  flair = new Flair_default({
    props: {
      variant: "error",
      $$slots: { default: [create_default_slot_55] },
      $$scope: { ctx }
    }
  });
  function func8(...args) {
    return (
      /*func*/
      ctx[5](
        /*error*/
        ctx[7],
        ...args
      )
    );
  }
  iconbutton = new IconButton_default({ props: { icon: "search", onClick: func8 } });
  return {
    c() {
      div3 = element("div");
      span = element("span");
      create_component(flair.$$.fragment);
      create_component(iconbutton.$$.fragment);
      t0 = space();
      div2 = element("div");
      div0 = element("div");
      t1 = text(t1_value);
      t22 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(span, "class", "svelte-1lhlmf3");
      attr(div3, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append4(div3, span);
      mount_component(flair, span, null);
      mount_component(iconbutton, span, null);
      append4(span, t0);
      append4(span, div2);
      append4(div2, div0);
      append4(div0, t1);
      append4(div2, t22);
      append4(div2, div1);
      append4(div1, t3);
      append4(div3, t4);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const flair_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        flair_changes.$$scope = { dirty, ctx };
      }
      flair.$set(flair_changes);
      const iconbutton_changes = {};
      if (dirty & /*$app, errors, onCancel*/
      14)
        iconbutton_changes.onClick = func8;
      iconbutton.$set(iconbutton_changes);
      if ((!current || dirty & /*errors*/
      2) && t1_value !== (t1_value = getDisplayName(
        /*error*/
        ctx[7].recordId
      ) + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*errors*/
      2) && t3_value !== (t3_value = getFolder(
        /*error*/
        ctx[7].recordId
      ) + ""))
        set_data(t3, t3_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(flair.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flair.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(flair);
      destroy_component(iconbutton);
    }
  };
}
function create_each_block7(ctx) {
  let accordionitem;
  let current;
  accordionitem = new AccordionItem_default({
    props: {
      $$slots: {
        header: [create_header_slot2],
        default: [create_default_slot_64]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordionitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordionitem_changes = {};
      if (dirty & /*$$scope, errors, $app, onCancel*/
      1038) {
        accordionitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionitem.$set(accordionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordionitem, detaching);
    }
  };
}
function create_default_slot_45(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*errors*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block7(get_each_context7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*getFolder, errors, getDisplayName, $app, onCancel*/
      14) {
        each_value = /*errors*/
        ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_35(ctx) {
  let p2;
  let t1;
  let accordion;
  let current;
  accordion = new Accordion_default({
    props: {
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Issues marked as errors don't show up in your views. Fix the reported\n      issue to include them.";
      t1 = space();
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t1, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty & /*$$scope, errors, $app, onCancel*/
      1038) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t1);
      destroy_component(accordion, detaching);
    }
  };
}
function create_default_slot_27(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[4].t("modals.input.cancel") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      16 && t_value !== (t_value = /*$i18n*/
      ctx2[4].t("modals.input.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_114(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      1040) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot14(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_114] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, errors, $app, onCancel*/
      1038) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onCancel, $i18n*/
      1044) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*title*/
      1)
        modallayout_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*$$scope, onCancel, $i18n, errors, $app*/
      1054) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function getFolder(recordId) {
  const idx = recordId.lastIndexOf("/");
  if (idx < 0) {
    return "/";
  }
  return recordId.slice(0, idx);
}
function instance47($$self, $$props, $$invalidate) {
  let $app;
  let $i18n;
  component_subscribe($$self, app2, ($$value) => $$invalidate(3, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(4, $i18n = $$value));
  let { title } = $$props;
  let { errors } = $$props;
  let { onCancel } = $$props;
  const func8 = (error2, event) => {
    $app.workspace.openLinkText(error2.recordId, "", true);
    event.stopPropagation();
    onCancel();
  };
  const click_handler = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("errors" in $$props2)
      $$invalidate(1, errors = $$props2.errors);
    if ("onCancel" in $$props2)
      $$invalidate(2, onCancel = $$props2.onCancel);
  };
  return [title, errors, onCancel, $app, $i18n, func8, click_handler];
}
var Inspector = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance47, create_fragment47, safe_not_equal, { title: 0, errors: 1, onCancel: 2 }, add_css24);
  }
};
var Inspector_default = Inspector;

// src/modals/inspector.ts
var InspectorModal = class extends import_obsidian26.Modal {
  constructor(app3, title, errors) {
    super(app3);
    this.title = title;
    this.errors = errors;
  }
  onOpen() {
    this.component = new Inspector_default({
      target: this.contentEl,
      props: {
        title: this.title,
        errors: this.errors,
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/app/toolbar/Toolbar.svelte
function get_context(ctx) {
  var _a, _b;
  const constants_0 = (
    /*projects*/
    (_b = (_a = ctx[1].find((project) => project.id === /*projectId*/
    ctx[0])) == null ? void 0 : _a.views) == null ? void 0 : _b.find((view2) => view2.id === /*viewId*/
    ctx[3])
  );
  ctx[33] = constants_0;
}
function create_if_block_32(ctx) {
  let flair;
  let current;
  flair = new Flair_default({
    props: {
      variant: "error",
      $$slots: { default: [create_default_slot_65] },
      $$scope: { ctx }
    }
  });
  flair.$on(
    "click",
    /*click_handler_2*/
    ctx[32]
  );
  return {
    c() {
      create_component(flair.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flair, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const flair_changes = {};
      if (dirty[0] & /*errors*/
      2048 | dirty[1] & /*$$scope*/
      8) {
        flair_changes.$$scope = { dirty, ctx: ctx2 };
      }
      flair.$set(flair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flair, detaching);
    }
  };
}
function create_default_slot_65(ctx) {
  let t_value = `${/*errors*/
  ctx[11].length} ${/*errors*/
  ctx[11].length === 1 ? "error" : "errors"}`;
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*errors*/
      2048 && t_value !== (t_value = `${/*errors*/
      ctx2[11].length} ${/*errors*/
      ctx2[11].length === 1 ? "error" : "errors"}`))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_info_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*errors*/
    ctx[11].length && create_if_block_32(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*errors*/
        ctx2[11].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*errors*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_32(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_left_slot(ctx) {
  let projectselect;
  let current;
  projectselect = new ProjectSelect_default({
    props: {
      slot: "left",
      projectId: (
        /*projectId*/
        ctx[0]
      ),
      projects: (
        /*projects*/
        ctx[1]
      ),
      onProjectChange: (
        /*onProjectChange*/
        ctx[2]
      ),
      onProjectAdd: (
        /*func_12*/
        ctx[31]
      )
    }
  });
  return {
    c() {
      create_component(projectselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(projectselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const projectselect_changes = {};
      if (dirty[0] & /*projectId*/
      1)
        projectselect_changes.projectId = /*projectId*/
        ctx2[0];
      if (dirty[0] & /*projects*/
      2)
        projectselect_changes.projects = /*projects*/
        ctx2[1];
      if (dirty[0] & /*onProjectChange*/
      4)
        projectselect_changes.onProjectChange = /*onProjectChange*/
        ctx2[2];
      if (dirty[0] & /*$app, $i18n, projectId, onProjectChange*/
      24581)
        projectselect_changes.onProjectAdd = /*func_12*/
        ctx2[31];
      projectselect.$set(projectselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(projectselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(projectselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(projectselect, detaching);
    }
  };
}
function create_if_block_25(ctx) {
  let viewselect;
  let current;
  viewselect = new ViewSelect_default({
    props: {
      viewId: (
        /*viewId*/
        ctx[3]
      ),
      views: (
        /*views*/
        ctx[12]
      ),
      viewExists: (
        /*func_6*/
        ctx[25]
      ),
      onViewSort: (
        /*func_7*/
        ctx[26]
      ),
      onViewAdd: (
        /*func_8*/
        ctx[27]
      ),
      onViewRename: (
        /*func_9*/
        ctx[28]
      ),
      onViewChange: (
        /*onViewChange*/
        ctx[4]
      ),
      onViewDuplicate: (
        /*func_10*/
        ctx[29]
      ),
      onViewDelete: (
        /*func_11*/
        ctx[30]
      )
    }
  });
  return {
    c() {
      create_component(viewselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewselect_changes = {};
      if (dirty[0] & /*viewId*/
      8)
        viewselect_changes.viewId = /*viewId*/
        ctx2[3];
      if (dirty[0] & /*views*/
      4096)
        viewselect_changes.views = /*views*/
        ctx2[12];
      if (dirty[0] & /*project*/
      32)
        viewselect_changes.viewExists = /*func_6*/
        ctx2[25];
      if (dirty[0] & /*projectId*/
      1)
        viewselect_changes.onViewSort = /*func_7*/
        ctx2[26];
      if (dirty[0] & /*project, $app, onViewChange*/
      8240)
        viewselect_changes.onViewAdd = /*func_8*/
        ctx2[27];
      if (dirty[0] & /*projectId*/
      1)
        viewselect_changes.onViewRename = /*func_9*/
        ctx2[28];
      if (dirty[0] & /*onViewChange*/
      16)
        viewselect_changes.onViewChange = /*onViewChange*/
        ctx2[4];
      if (dirty[0] & /*projectId, onViewChange*/
      17)
        viewselect_changes.onViewDuplicate = /*func_10*/
        ctx2[29];
      if (dirty[0] & /*$app, $i18n, projectId*/
      24577)
        viewselect_changes.onViewDelete = /*func_11*/
        ctx2[30];
      viewselect.$set(viewselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewselect, detaching);
    }
  };
}
function create_middle_slot(ctx) {
  let div;
  let current;
  let if_block = (
    /*project*/
    ctx[5] && create_if_block_25(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "middle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*project*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*project*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_17(ctx) {
  let flair;
  let current;
  flair = new Flair_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_56] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(flair.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flair, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const flair_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11 | dirty[1] & /*$$scope*/
      8) {
        flair_changes.$$scope = { dirty, ctx: ctx2 };
      }
      flair.$set(flair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flair, detaching);
    }
  };
}
function create_default_slot_56(ctx) {
  var _a;
  let t_value = (
    /*view*/
    ((_a = ctx[33]) == null ? void 0 : _a.colors.conditions.length) + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*projects, projectId, viewId*/
      11 && t_value !== (t_value = /*view*/
      ((_a2 = ctx2[33]) == null ? void 0 : _a2.colors.conditions.length) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_46(ctx) {
  var _a;
  let icon;
  let t3;
  let if_block_anchor;
  let current;
  icon = new Icon_default({ props: { name: "palette" } });
  let if_block = (
    /*view*/
    ((_a = ctx[33]) == null ? void 0 : _a.colors.conditions.length) && create_if_block_17(ctx)
  );
  return {
    c() {
      create_component(icon.$$.fragment);
      t3 = text("\n      Color\n      ");
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (
        /*view*/
        (_a2 = ctx2[33]) == null ? void 0 : _a2.colors.conditions.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*projects, projectId, viewId*/
          11) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t3);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_36(ctx) {
  var _a, _b;
  let colorfiltersettings;
  let current;
  colorfiltersettings = new ColorFilterSettings_default({
    props: {
      filter: (
        /*view*/
        (_b = (_a = ctx[33]) == null ? void 0 : _a.colors) != null ? _b : { conditions: [] }
      ),
      onFilterChange: (
        /*func*/
        ctx[19]
      ),
      fields: (
        /*$dataFrame*/
        ctx[6].fields
      )
    }
  });
  return {
    c() {
      create_component(colorfiltersettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(colorfiltersettings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const colorfiltersettings_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        colorfiltersettings_changes.filter = /*view*/
        (_b2 = (_a2 = ctx2[33]) == null ? void 0 : _a2.colors) != null ? _b2 : { conditions: [] };
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        colorfiltersettings_changes.onFilterChange = /*func*/
        ctx2[19];
      if (dirty[0] & /*$dataFrame*/
      64)
        colorfiltersettings_changes.fields = /*$dataFrame*/
        ctx2[6].fields;
      colorfiltersettings.$set(colorfiltersettings_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(colorfiltersettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(colorfiltersettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(colorfiltersettings, detaching);
    }
  };
}
function create_if_block14(ctx) {
  let flair;
  let current;
  flair = new Flair_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(flair.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flair, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const flair_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11 | dirty[1] & /*$$scope*/
      8) {
        flair_changes.$$scope = { dirty, ctx: ctx2 };
      }
      flair.$set(flair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flair, detaching);
    }
  };
}
function create_default_slot_28(ctx) {
  var _a;
  let t_value = (
    /*view*/
    ((_a = ctx[33]) == null ? void 0 : _a.filter.conditions.length) + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*projects, projectId, viewId*/
      11 && t_value !== (t_value = /*view*/
      ((_a2 = ctx2[33]) == null ? void 0 : _a2.filter.conditions.length) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_115(ctx) {
  var _a;
  let icon;
  let t3;
  let if_block_anchor;
  let current;
  icon = new Icon_default({ props: { name: "filter" } });
  let if_block = (
    /*view*/
    ((_a = ctx[33]) == null ? void 0 : _a.filter.conditions.length) && create_if_block14(ctx)
  );
  return {
    c() {
      create_component(icon.$$.fragment);
      t3 = text("\n      Filter\n      ");
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (
        /*view*/
        (_a2 = ctx2[33]) == null ? void 0 : _a2.filter.conditions.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*projects, projectId, viewId*/
          11) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t3);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot15(ctx) {
  var _a, _b;
  let filtersettings;
  let current;
  filtersettings = new FilterSettings_default({
    props: {
      filter: (
        /*view*/
        (_b = (_a = ctx[33]) == null ? void 0 : _a.filter) != null ? _b : { conditions: [] }
      ),
      onFilterChange: (
        /*func_2*/
        ctx[23]
      ),
      fields: (
        /*$dataFrame*/
        ctx[6].fields
      )
    }
  });
  return {
    c() {
      create_component(filtersettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filtersettings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const filtersettings_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        filtersettings_changes.filter = /*view*/
        (_b2 = (_a2 = ctx2[33]) == null ? void 0 : _a2.filter) != null ? _b2 : { conditions: [] };
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        filtersettings_changes.onFilterChange = /*func_2*/
        ctx2[23];
      if (dirty[0] & /*$dataFrame*/
      64)
        filtersettings_changes.fields = /*$dataFrame*/
        ctx2[6].fields;
      filtersettings.$set(filtersettings_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filtersettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filtersettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filtersettings, detaching);
    }
  };
}
function create_right_slot(ctx) {
  get_context(ctx);
  let button0;
  let updating_ref;
  let t0;
  let popover0;
  let t1;
  let button1;
  let updating_ref_1;
  let t22;
  let popover1;
  let current;
  function button0_ref_binding(value) {
    ctx[17](value);
  }
  let button0_props = {
    disabled: !/*view*/
    ctx[33],
    $$slots: { default: [create_default_slot_46] },
    $$scope: { ctx }
  };
  if (
    /*colorRef*/
    ctx[9] !== void 0
  ) {
    button0_props.ref = /*colorRef*/
    ctx[9];
  }
  button0 = new Button_default({ props: button0_props });
  binding_callbacks.push(() => bind6(button0, "ref", button0_ref_binding));
  button0.$on(
    "click",
    /*click_handler*/
    ctx[18]
  );
  popover0 = new Popover_default({
    props: {
      anchorEl: (
        /*colorRef*/
        ctx[9]
      ),
      open: (
        /*colorOpen*/
        ctx[10]
      ),
      onClose: (
        /*func_1*/
        ctx[20]
      ),
      placement: "auto",
      $$slots: { default: [create_default_slot_36] },
      $$scope: { ctx }
    }
  });
  function button1_ref_binding(value) {
    ctx[21](value);
  }
  let button1_props = {
    disabled: !/*view*/
    ctx[33],
    $$slots: { default: [create_default_slot_115] },
    $$scope: { ctx }
  };
  if (
    /*filterRef*/
    ctx[7] !== void 0
  ) {
    button1_props.ref = /*filterRef*/
    ctx[7];
  }
  button1 = new Button_default({ props: button1_props });
  binding_callbacks.push(() => bind6(button1, "ref", button1_ref_binding));
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[22]
  );
  popover1 = new Popover_default({
    props: {
      anchorEl: (
        /*filterRef*/
        ctx[7]
      ),
      open: (
        /*filterOpen*/
        ctx[8]
      ),
      onClose: (
        /*func_3*/
        ctx[24]
      ),
      placement: "auto",
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(popover0.$$.fragment);
      t1 = space();
      create_component(button1.$$.fragment);
      t22 = space();
      create_component(popover1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t0, anchor);
      mount_component(popover0, target, anchor);
      insert(target, t1, anchor);
      mount_component(button1, target, anchor);
      insert(target, t22, anchor);
      mount_component(popover1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_context(ctx2);
      const button0_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        button0_changes.disabled = !/*view*/
        ctx2[33];
      if (dirty[0] & /*projects, projectId, viewId*/
      11 | dirty[1] & /*$$scope*/
      8) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty[0] & /*colorRef*/
      512) {
        updating_ref = true;
        button0_changes.ref = /*colorRef*/
        ctx2[9];
        add_flush_callback(() => updating_ref = false);
      }
      button0.$set(button0_changes);
      const popover0_changes = {};
      if (dirty[0] & /*colorRef*/
      512)
        popover0_changes.anchorEl = /*colorRef*/
        ctx2[9];
      if (dirty[0] & /*colorOpen*/
      1024)
        popover0_changes.open = /*colorOpen*/
        ctx2[10];
      if (dirty[0] & /*colorOpen*/
      1024)
        popover0_changes.onClose = /*func_1*/
        ctx2[20];
      if (dirty[0] & /*projects, projectId, viewId, $dataFrame*/
      75 | dirty[1] & /*$$scope*/
      8) {
        popover0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover0.$set(popover0_changes);
      const button1_changes = {};
      if (dirty[0] & /*projects, projectId, viewId*/
      11)
        button1_changes.disabled = !/*view*/
        ctx2[33];
      if (dirty[0] & /*projects, projectId, viewId*/
      11 | dirty[1] & /*$$scope*/
      8) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_1 && dirty[0] & /*filterRef*/
      128) {
        updating_ref_1 = true;
        button1_changes.ref = /*filterRef*/
        ctx2[7];
        add_flush_callback(() => updating_ref_1 = false);
      }
      button1.$set(button1_changes);
      const popover1_changes = {};
      if (dirty[0] & /*filterRef*/
      128)
        popover1_changes.anchorEl = /*filterRef*/
        ctx2[7];
      if (dirty[0] & /*filterOpen*/
      256)
        popover1_changes.open = /*filterOpen*/
        ctx2[8];
      if (dirty[0] & /*filterOpen*/
      256)
        popover1_changes.onClose = /*func_3*/
        ctx2[24];
      if (dirty[0] & /*projects, projectId, viewId, $dataFrame*/
      75 | dirty[1] & /*$$scope*/
      8) {
        popover1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover1.$set(popover1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(popover0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(popover1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(popover0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(popover1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(popover0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(button1, detaching);
      if (detaching)
        detach(t22);
      destroy_component(popover1, detaching);
    }
  };
}
function create_fragment48(ctx) {
  let viewtoolbar;
  let current;
  viewtoolbar = new ViewToolbar_default({
    props: {
      variant: "primary",
      $$slots: {
        right: [create_right_slot],
        middle: [create_middle_slot],
        left: [create_left_slot],
        info: [create_info_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewtoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewtoolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewtoolbar_changes = {};
      if (dirty[0] & /*filterRef, filterOpen, projects, projectId, viewId, $dataFrame, colorRef, colorOpen, views, project, $app, onViewChange, $i18n, onProjectChange, errors*/
      32767 | dirty[1] & /*$$scope*/
      8) {
        viewtoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewtoolbar.$set(viewtoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewtoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewtoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewtoolbar, detaching);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let project;
  let views;
  let errors;
  let $dataFrame;
  let $app;
  let $i18n;
  component_subscribe($$self, dataFrame, ($$value) => $$invalidate(6, $dataFrame = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(13, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(14, $i18n = $$value));
  var _a, _b;
  let { projects } = $$props;
  let { projectId } = $$props;
  let { onProjectChange } = $$props;
  let { viewId } = $$props;
  let { onViewChange } = $$props;
  let filterRef;
  let filterOpen = false;
  let colorRef;
  let colorOpen = false;
  function button0_ref_binding(value) {
    colorRef = value;
    $$invalidate(9, colorRef);
  }
  const click_handler = () => {
    $$invalidate(10, colorOpen = !colorOpen);
  };
  const func8 = (filter3) => {
    var _a2, _b2;
    const view2 = (_b2 = (_a2 = projects.find((project2) => project2.id === projectId)) == null ? void 0 : _a2.views) == null ? void 0 : _b2.find((view3) => view3.id === viewId);
    if (projectId && view2) {
      settings.updateView(projectId, immer_esm_default(view2, (draft) => {
        draft.colors = filter3;
      }));
    }
  };
  const func_15 = () => {
    $$invalidate(10, colorOpen = false);
  };
  function button1_ref_binding(value) {
    filterRef = value;
    $$invalidate(7, filterRef);
  }
  const click_handler_1 = () => {
    $$invalidate(8, filterOpen = !filterOpen);
  };
  const func_2 = (filter3) => {
    var _a2, _b2;
    const view2 = (_b2 = (_a2 = projects.find((project2) => project2.id === projectId)) == null ? void 0 : _a2.views) == null ? void 0 : _b2.find((view3) => view3.id === viewId);
    if (projectId && view2) {
      settings.updateView(projectId, immer_esm_default(view2, (draft) => {
        draft.filter = filter3;
      }));
    }
  };
  const func_3 = () => {
    $$invalidate(8, filterOpen = false);
  };
  const func_6 = (name) => !!(project == null ? void 0 : project.views.find((view2) => view2.name === name));
  const func_7 = (viewIds) => {
    if (projectId) {
      settings.sortViews(projectId, viewIds);
    }
  };
  const func_8 = () => {
    if (project) {
      new AddViewModal(
        $app,
        project,
        (projectId2, view2) => {
          settings.addView(projectId2, view2);
          onViewChange(view2.id);
        }
      ).open();
    }
  };
  const func_9 = (viewId2, name) => {
    if (projectId) {
      settings.renameView(projectId, viewId2, name);
    }
  };
  const func_10 = (viewId2) => {
    if (projectId) {
      const id = settings.duplicateView(projectId, viewId2);
      onViewChange(id);
    }
  };
  const func_11 = (viewId2) => {
    new ConfirmDialogModal(
      $app,
      $i18n.t("modals.view.delete.title"),
      $i18n.t("modals.view.delete.message"),
      $i18n.t("modals.view.delete.cta"),
      () => {
        if (projectId) {
          settings.deleteView(projectId, viewId2);
        }
      }
    ).open();
  };
  const func_122 = () => new CreateProjectModal(
    $app,
    $i18n.t("modals.project.create.title"),
    $i18n.t("modals.project.create.cta"),
    (project2) => {
      settings.addProject(project2);
      $$invalidate(0, projectId = project2.id);
      onProjectChange(project2.id);
    },
    createProject()
  ).open();
  const click_handler_2 = () => {
    new InspectorModal($app, "Project inspector", errors).open();
  };
  $$self.$$set = ($$props2) => {
    if ("projects" in $$props2)
      $$invalidate(1, projects = $$props2.projects);
    if ("projectId" in $$props2)
      $$invalidate(0, projectId = $$props2.projectId);
    if ("onProjectChange" in $$props2)
      $$invalidate(2, onProjectChange = $$props2.onProjectChange);
    if ("viewId" in $$props2)
      $$invalidate(3, viewId = $$props2.viewId);
    if ("onViewChange" in $$props2)
      $$invalidate(4, onViewChange = $$props2.onViewChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*projects, projectId*/
    3) {
      $:
        $$invalidate(5, project = projects.find((project2) => project2.id === projectId));
    }
    if ($$self.$$.dirty[0] & /*project, _a*/
    32800) {
      $:
        $$invalidate(12, views = $$invalidate(15, _a = project === null || project === void 0 ? void 0 : project.views) !== null && _a !== void 0 ? _a : []);
    }
    if ($$self.$$.dirty[0] & /*$dataFrame, _b*/
    65600) {
      $:
        $$invalidate(11, errors = $$invalidate(16, _b = $dataFrame.errors) !== null && _b !== void 0 ? _b : []);
    }
  };
  return [
    projectId,
    projects,
    onProjectChange,
    viewId,
    onViewChange,
    project,
    $dataFrame,
    filterRef,
    filterOpen,
    colorRef,
    colorOpen,
    errors,
    views,
    $app,
    $i18n,
    _a,
    _b,
    button0_ref_binding,
    click_handler,
    func8,
    func_15,
    button1_ref_binding,
    click_handler_1,
    func_2,
    func_3,
    func_6,
    func_7,
    func_8,
    func_9,
    func_10,
    func_11,
    func_122,
    click_handler_2
  ];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        projects: 1,
        projectId: 0,
        onProjectChange: 2,
        viewId: 3,
        onViewChange: 4
      },
      null,
      [-1, -1]
    );
  }
};
var Toolbar_default = Toolbar;

// src/app/onboarding/demo-project.ts
var import_dayjs5 = __toESM(require_dayjs_min());
var import_obsidian28 = require("obsidian");
function createDemoProject(vault) {
  return __async(this, null, function* () {
    const demoFolder = "Projects - Demo Project";
    yield vault.createFolder(demoFolder);
    const startDate = (0, import_dayjs5.default)();
    const files = {
      "The Best Notes You'll Ever Make": {
        status: "Done",
        due: startDate.subtract(2, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 1,
        tags: ["note-taking"],
        image: "https://images.unsplash.com/photo-1455390582262-044cdead277a?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "The Easiest Way to Start Taking Notes": {
        status: "Done",
        due: startDate.subtract(1, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 2,
        tags: ["note-taking", "obsidian"],
        image: "https://images.unsplash.com/photo-1488190211105-8b0e65b80b4e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "Why You Should Be Taking More Notes": {
        status: "Doing",
        due: startDate.format("YYYY-MM-DD"),
        published: false,
        weight: 3,
        tags: ["note-taking", "pkm"],
        image: "https://images.unsplash.com/photo-1501504905252-473c47e087f8?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "What I Learned From Taking 15,000 Notes": {
        status: "Backlog",
        due: startDate.add(1, "weeks").format("YYYY-MM-DD"),
        published: false,
        weight: 4,
        tags: ["pkm", "obsidian"],
        image: "https://images.unsplash.com/photo-1550592704-6c76defa9985?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "5 Mistakes I Made When I Started Using Obsidian": {
        status: "Backlog",
        due: startDate.add(2, "weeks").format("YYYY-MM-DD"),
        published: false,
        tags: ["obsidian"],
        image: "https://images.unsplash.com/photo-1471107340929-a87cd0f5b5f3?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      }
    };
    for (const [linkText, data] of Object.entries(files)) {
      const content = "---\n" + (0, import_obsidian28.stringifyYaml)(data) + "---\n\n# " + linkText;
      yield vault.create(
        (0, import_obsidian28.normalizePath)(demoFolder + "/" + linkText + ".md"),
        content
      );
    }
    const tableConfig = {
      fieldConfig: {
        name: {
          width: 360
        },
        path: {
          hide: true
        }
      }
    };
    const boardConfig = {
      groupByField: "status",
      priorityField: "weight"
    };
    const calendarConfig = {
      interval: "month",
      dateField: "due",
      checkField: "published"
    };
    const galleryConfig = {
      coverField: "image"
    };
    settings.addProject(
      Object.assign({}, DEFAULT_PROJECT3, {
        name: "Demo project",
        id: v4_default(),
        path: demoFolder,
        dataSource: {
          kind: "folder",
          config: {
            path: demoFolder,
            recursive: false
          }
        },
        views: [
          Object.assign({}, DEFAULT_VIEW2, {
            name: "Table",
            id: v4_default(),
            type: "table",
            config: tableConfig
          }),
          Object.assign({}, DEFAULT_VIEW2, {
            name: "Board",
            id: v4_default(),
            type: "board",
            config: boardConfig
          }),
          Object.assign({}, DEFAULT_VIEW2, {
            name: "Calendar",
            id: v4_default(),
            type: "calendar",
            config: calendarConfig
          }),
          Object.assign({}, DEFAULT_VIEW2, {
            name: "Gallery",
            id: v4_default(),
            type: "gallery",
            config: galleryConfig
          })
        ]
      })
    );
  });
}

// src/app/onboarding/onboarding-modal.ts
var import_obsidian29 = require("obsidian");

// src/app/onboarding/TabContainer.svelte
function add_css25(target) {
  append_styles(target, "svelte-1es105s", ".nomargin.svelte-1es105s{margin:0;padding:8px}.header.svelte-1es105s{display:flex;gap:4px;margin-bottom:4px}");
}
var get_default_slot_changes = (dirty) => ({ selected: dirty & /*selected*/
2 });
var get_default_slot_context = (ctx) => ({ selected: (
  /*selected*/
  ctx[1]
) });
function get_each_context8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_each_block8(ctx) {
  let div;
  let t0_value = (
    /*option*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*option*/
        ctx[7]
      )
    );
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "clickable-icon");
      toggle_class(
        div,
        "is-active",
        /*option*/
        ctx[7] === /*selected*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t0);
      append4(div, t1);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[4]
          ),
          listen(div, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options*/
      1 && t0_value !== (t0_value = /*option*/
      ctx[7] + ""))
        set_data(t0, t0_value);
      if (dirty & /*options, selected*/
      3) {
        toggle_class(
          div,
          "is-active",
          /*option*/
          ctx[7] === /*selected*/
          ctx[1]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment49(ctx) {
  let div2;
  let div0;
  let t3;
  let div1;
  let current;
  let each_value = (
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block8(get_each_context8(ctx, each_value, i2));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_default_slot_context
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "header svelte-1es105s");
      attr(div1, "class", "card nomargin svelte-1es105s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append4(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append4(div2, t3);
      append4(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*options, selected*/
      3) {
        each_value = /*options*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, selected*/
        6)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a;
  let { options } = $$props;
  let selected = (_a = options[0]) !== null && _a !== void 0 ? _a : "";
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = (option2) => {
    $$invalidate(1, selected = option2);
  };
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [options, selected, $$scope, slots, keypress_handler, click_handler];
}
var TabContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance49, create_fragment49, safe_not_equal, { options: 0 }, add_css25);
  }
};
var TabContainer_default = TabContainer;

// src/app/onboarding/Onboarding.svelte
function add_css26(target) {
  append_styles(target, "svelte-a9juqy", "pre.svelte-a9juqy{background-color:var(--background-secondary);border-radius:var(--radius-s);padding:8px}ol.svelte-a9juqy{margin:0;padding:0 22px}");
}
function create_default_slot_66(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Get started with Projects");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_57(ctx) {
  let t0;
  let a2;
  let t22;
  return {
    c() {
      t0 = text("Projects lets you manage groups of related notes using\n    ");
      a2 = element("a");
      a2.textContent = "front matter";
      t22 = text(". For example, a folder with the blog posts you're working on.");
      attr(a2, "href", "https://help.obsidian.md/Advanced+topics/YAML+front+matter");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a2, anchor);
      insert(target, t22, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t22);
    }
  };
}
function create_default_slot_47(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Start from scratch, or explore a demo project \u{1F447}");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_37(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Create new project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_29(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Try a demo project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_116(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_37] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  button1 = new Button_default({
    props: {
      variant: "default",
      tooltip: "Creates a new folder at the root of your vault with example notes.",
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[3]
  );
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_else_block4(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>In the top-right corner of the <strong>Projects</strong>
          view, click
          <strong>New</strong>.</li> 
        <li>Click <strong>New project</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_18(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Open the <strong>Command palette</strong>.</li> 
        <li>Search for <strong>Create new project</strong></li> 
        <li>Press <strong>Enter</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block15(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Right-click a folder in <strong>File explorer</strong>.</li> 
        <li>Click <strong>Create project in folder</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_default_slot16(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[4] === "File explorer"
    )
      return create_if_block15;
    if (
      /*selected*/
      ctx2[4] === "Command palette"
    )
      return create_if_block_18;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment50(ctx) {
  let div;
  let typography0;
  let t0;
  let typography1;
  let t1;
  let pre;
  let t3;
  let typography2;
  let t4;
  let modalbuttongroup;
  let t5;
  let p2;
  let p_style_value;
  let t8;
  let tabcontainer;
  let current;
  typography0 = new Typography_default({
    props: {
      variant: "h1",
      $$slots: { default: [create_default_slot_66] },
      $$scope: { ctx }
    }
  });
  typography1 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_57] },
      $$scope: { ctx }
    }
  });
  typography2 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_47] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_116] },
      $$scope: { ctx }
    }
  });
  tabcontainer = new TabContainer_default({
    props: {
      options: ["Projects view", "Command palette", "File explorer"],
      $$slots: {
        default: [
          create_default_slot16,
          ({ selected }) => ({ 4: selected }),
          ({ selected }) => selected ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(typography0.$$.fragment);
      t0 = space();
      create_component(typography1.$$.fragment);
      t1 = space();
      pre = element("pre");
      pre.innerHTML = `<code>---
status: Backlog
due: 2023-01-01
published: false
---

# My blog post</code>`;
      t3 = space();
      create_component(typography2.$$.fragment);
      t4 = space();
      create_component(modalbuttongroup.$$.fragment);
      t5 = space();
      p2 = element("p");
      p2.innerHTML = `<strong>Psst! \u{1F44B}</strong> Next time you can create your projects using any of
    the following ways:`;
      t8 = space();
      create_component(tabcontainer.$$.fragment);
      attr(pre, "class", "svelte-a9juqy");
      attr(p2, "style", p_style_value = "color: var(--text-muted); margin-top: 45px; font-size: var(--font-ui-smaller);");
      attr(div, "class", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography0, div, null);
      append4(div, t0);
      mount_component(typography1, div, null);
      append4(div, t1);
      append4(div, pre);
      append4(div, t3);
      mount_component(typography2, div, null);
      append4(div, t4);
      mount_component(modalbuttongroup, div, null);
      append4(div, t5);
      append4(div, p2);
      append4(div, t8);
      mount_component(tabcontainer, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography0_changes = {};
      if (dirty & /*$$scope*/
      32) {
        typography0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography0.$set(typography0_changes);
      const typography1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        typography1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography1.$set(typography1_changes);
      const typography2_changes = {};
      if (dirty & /*$$scope*/
      32) {
        typography2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography2.$set(typography2_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onTry, onCreate*/
      35) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
      const tabcontainer_changes = {};
      if (dirty & /*$$scope, selected*/
      48) {
        tabcontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabcontainer.$set(tabcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography0.$$.fragment, local);
      transition_in(typography1.$$.fragment, local);
      transition_in(typography2.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      transition_in(tabcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography0.$$.fragment, local);
      transition_out(typography1.$$.fragment, local);
      transition_out(typography2.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      transition_out(tabcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography0);
      destroy_component(typography1);
      destroy_component(typography2);
      destroy_component(modalbuttongroup);
      destroy_component(tabcontainer);
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let { onCreate } = $$props;
  let { onTry } = $$props;
  const click_handler = () => onCreate();
  const click_handler_1 = () => onTry();
  $$self.$$set = ($$props2) => {
    if ("onCreate" in $$props2)
      $$invalidate(0, onCreate = $$props2.onCreate);
    if ("onTry" in $$props2)
      $$invalidate(1, onTry = $$props2.onTry);
  };
  return [onCreate, onTry, click_handler, click_handler_1];
}
var Onboarding = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance50, create_fragment50, safe_not_equal, { onCreate: 0, onTry: 1 }, add_css26);
  }
};
var Onboarding_default = Onboarding;

// src/app/onboarding/onboarding-modal.ts
var OnboardingModal = class extends import_obsidian29.Modal {
  constructor(app3, onCreate, onTry) {
    super(app3);
    this.app = app3;
    this.onCreate = onCreate;
    this.onTry = onTry;
  }
  onOpen() {
    this.component = new Onboarding_default({
      target: this.contentEl,
      props: {
        onCreate: () => {
          this.onCreate();
          this.close();
        },
        onTry: () => {
          this.onTry();
          this.close();
        }
      }
    });
  }
};

// src/app/filter-functions.ts
function matchesCondition(cond, record) {
  const { operator } = cond;
  const value = record.values[cond.field];
  if (operator === "is-empty" || operator === "is-not-empty") {
    return baseFns[operator](value);
  }
  switch (typeof value) {
    case "string":
      if (isStringFilterOperator(operator)) {
        return stringFns[operator](value, cond.value);
      }
      break;
    case "number":
      if (isNumberFilterOperator(operator)) {
        return numberFns[operator](
          value,
          cond.value ? parseFloat(cond.value) : void 0
        );
      }
      break;
    case "boolean":
      if (isBooleanFilterOperator(operator)) {
        return booleanFns[operator](value);
      }
  }
  return false;
}
function matchesFilterConditions(filter3, record) {
  const validConds = filter3.conditions.filter((cond) => {
    var _a;
    return (_a = cond == null ? void 0 : cond.enabled) != null ? _a : true;
  });
  return validConds.every((cond) => matchesCondition(cond, record));
}
function applyFilter(frame, filter3) {
  return immer_esm_default(frame, (draft) => {
    draft.records = draft.records.filter(
      (record) => (
        // @ts-ignore
        matchesFilterConditions(filter3, record)
      )
    );
  });
}
var baseFns = {
  "is-empty": (value) => value === void 0 || value === null,
  "is-not-empty": (value) => value !== void 0 && value !== null
};
var stringFns = {
  is: (left6, right6) => left6 === right6,
  "is-not": (left6, right6) => left6 !== right6,
  contains: (left6, right6) => left6.contains(right6 != null ? right6 : ""),
  "not-contains": (left6, right6) => !left6.contains(right6 != null ? right6 : "")
};
var numberFns = {
  eq: (left6, right6) => left6 === right6,
  neq: (left6, right6) => left6 !== right6,
  lt: (left6, right6) => right6 ? left6 < right6 : false,
  gt: (left6, right6) => right6 ? left6 > right6 : false,
  lte: (left6, right6) => right6 ? left6 <= right6 : false,
  gte: (left6, right6) => right6 ? left6 >= right6 : false
};
var booleanFns = {
  "is-checked": (value) => value === true,
  "is-not-checked": (value) => value === false
};

// src/app/useView.ts
function useView(node, props) {
  let viewId = props.view.id;
  const projectId = props.project.id;
  let projectView = get_store_value(customViews)[props.view.type];
  if (projectView) {
    projectView.onOpen({
      viewId: props.view.id,
      project: props.project,
      contentEl: node,
      config: props.config,
      saveConfig: props.onConfigChange,
      viewApi: props.viewApi,
      readonly: props.readonly,
      getRecordColor: props.getRecordColor
    });
    projectView.onData(props.dataProps);
  }
  return {
    update(newprops) {
      const dirty = newprops.view.id !== viewId || newprops.project.id !== projectId;
      if (dirty) {
        projectView == null ? void 0 : projectView.onClose();
        node.empty();
        projectView = get_store_value(customViews)[newprops.view.type];
        if (projectView) {
          projectView.onOpen({
            contentEl: node,
            viewId: newprops.view.id,
            project: newprops.project,
            viewApi: newprops.viewApi,
            readonly: newprops.readonly,
            config: newprops.config,
            saveConfig: newprops.onConfigChange,
            getRecordColor: newprops.getRecordColor
          });
          projectView.onData(newprops.dataProps);
        }
        viewId = newprops.view.id;
      } else {
        projectView == null ? void 0 : projectView.onData(newprops.dataProps);
      }
    },
    destroy() {
      projectView == null ? void 0 : projectView.onClose();
    }
  };
}

// src/app/View.svelte
function add_css27(target) {
  append_styles(target, "svelte-1kuj9kb", "div.svelte-1kuj9kb{width:100%;height:100%}");
}
function create_fragment51(ctx) {
  let div;
  let useView_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "svelte-1kuj9kb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useView_action = useView.call(null, div, {
          view: (
            /*view*/
            ctx[1]
          ),
          dataProps: { data: (
            /*filteredFrame*/
            ctx[4]
          ) },
          viewApi: (
            /*api*/
            ctx[3]
          ),
          project: (
            /*project*/
            ctx[0]
          ),
          readonly: (
            /*readonly*/
            ctx[2]
          ),
          config: (
            /*view*/
            ctx[1].config
          ),
          onConfigChange: (
            /*handleConfigChange*/
            ctx[5]
          ),
          getRecordColor: (
            /*getRecordColor*/
            ctx[6]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useView_action && is_function(useView_action.update) && dirty & /*view, filteredFrame, api, project, readonly*/
      31)
        useView_action.update.call(null, {
          view: (
            /*view*/
            ctx2[1]
          ),
          dataProps: { data: (
            /*filteredFrame*/
            ctx2[4]
          ) },
          viewApi: (
            /*api*/
            ctx2[3]
          ),
          project: (
            /*project*/
            ctx2[0]
          ),
          readonly: (
            /*readonly*/
            ctx2[2]
          ),
          config: (
            /*view*/
            ctx2[1].config
          ),
          onConfigChange: (
            /*handleConfigChange*/
            ctx2[5]
          ),
          getRecordColor: (
            /*getRecordColor*/
            ctx2[6]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let viewFilter;
  let filteredFrame;
  var _a;
  let { project } = $$props;
  let { view: view2 } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { onConfigChange } = $$props;
  function handleConfigChange(config) {
    onConfigChange(project.id, view2.id, config);
  }
  function getRecordColor(record) {
    var _a2, _b, _c;
    const colorFilter = (_a2 = view2.colors) !== null && _a2 !== void 0 ? _a2 : { conditions: [] };
    for (const cond of colorFilter.conditions) {
      if ((_c = (_b = cond.condition) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : true) {
        if (matchesCondition(cond.condition, record)) {
          return cond.color;
        }
      }
    }
    return null;
  }
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("view" in $$props2)
      $$invalidate(1, view2 = $$props2.view);
    if ("frame" in $$props2)
      $$invalidate(7, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(3, api2 = $$props2.api);
    if ("onConfigChange" in $$props2)
      $$invalidate(8, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*view, _a*/
    514) {
      $:
        $$invalidate(10, viewFilter = $$invalidate(9, _a = view2.filter) !== null && _a !== void 0 ? _a : { conditions: [] });
    }
    if ($$self.$$.dirty & /*frame, viewFilter, project, view*/
    1155) {
      $: {
        const fieldNames = frame.fields.map((field) => field.name);
        if (viewFilter.conditions.length !== viewFilter.conditions.filter((cond) => fieldNames.includes(cond.field)).length) {
          settings.updateView(project.id, Object.assign(Object.assign({}, view2), {
            filter: {
              conditions: viewFilter.conditions.filter((cond) => fieldNames.includes(cond.field))
            }
          }));
        }
      }
    }
    if ($$self.$$.dirty & /*frame, viewFilter*/
    1152) {
      $:
        $$invalidate(4, filteredFrame = applyFilter(frame, viewFilter));
    }
  };
  return [
    project,
    view2,
    readonly,
    api2,
    filteredFrame,
    handleConfigChange,
    getRecordColor,
    frame,
    onConfigChange,
    _a,
    viewFilter
  ];
}
var View = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance51,
      create_fragment51,
      safe_not_equal,
      {
        project: 0,
        view: 1,
        frame: 7,
        readonly: 2,
        api: 3,
        onConfigChange: 8
      },
      add_css27
    );
  }
};
var View_default = View;

// node_modules/tslib/tslib.es6.js
function __rest(s2, e) {
  var t3 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t3[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t3[p2[i2]] = s2[p2[i2]];
    }
  return t3;
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/app/DataFrameProvider.svelte
var import_obsidian_dataview2 = __toESM(require_lib());

// src/lib/datasources/folder/folder.ts
var import_obsidian30 = require("obsidian");

// src/lib/datasources/frontmatter/frontmatter-helpers.ts
function standardizeRecord(id, values) {
  return {
    id,
    values
  };
}

// src/lib/datasources/frontmatter/frontmatter.ts
var FrontMatterDataSource = class extends DataSource {
  constructor(fileSystem2, project, preferences) {
    super(project, preferences);
    this.fileSystem = fileSystem2;
  }
  queryOne(file, fields) {
    return __async(this, null, function* () {
      return this.queryFiles([file], fields);
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      const files = this.fileSystem.getAllFiles().filter(({ path }) => this.includes(path));
      if (files.length > this.preferences.projectSizeLimit) {
        throw new TooManyNotesError(
          files.length,
          this.preferences.projectSizeLimit
        );
      }
      return this.queryFiles(files);
    });
  }
  queryFiles(files, predefinedFields) {
    return __async(this, null, function* () {
      const standardizedRecords = yield standardizeRecords(files);
      const res = Array_exports.separate(standardizedRecords);
      let fields = this.sortFields(detectSchema2(res.right));
      for (const f2 in this.project.fieldConfig) {
        fields = fields.map(
          (field) => {
            var _a;
            return field.name !== f2 ? field : __spreadProps(__spreadValues({}, field), {
              typeConfig: __spreadValues(__spreadValues({}, (_a = this.project.fieldConfig) == null ? void 0 : _a[f2]), field.typeConfig)
            });
          }
        );
      }
      for (const predefinedField of predefinedFields != null ? predefinedFields : []) {
        fields = fields.map(
          (field) => field.name !== predefinedField.name ? field : __spreadProps(__spreadValues({}, field), { type: predefinedField.type })
        );
      }
      const records = parseRecords(res.right, fields);
      return { fields, records, errors: res.left };
    });
  }
  sortFields(fields) {
    return immer_esm_default(fields, (draft) => {
      draft.sort((a2, b2) => {
        if (a2.name === "name" || a2.name === "path") {
          return -1;
        }
        if (b2.name === "name" || b2.name === "path") {
          return 1;
        }
        return a2.name.localeCompare(b2.name);
      });
    });
  }
};
var RecordError = class extends Error {
  constructor(recordId, err) {
    super(err.message);
    this.recordId = recordId;
    this.err = err;
  }
};
function standardizeRecords(files) {
  return __async(this, null, function* () {
    return Promise.all(
      files.map((file) => __async(this, null, function* () {
        return function_exports.pipe(
          yield file.read(),
          decodeFrontMatter,
          Either_exports.mapLeft((e) => new RecordError(file.path, e)),
          Either_exports.map(filterUndefinedValues),
          Either_exports.map((values) => __spreadProps(__spreadValues({}, values), {
            path: file.path,
            name: `[[${file.path}|${file.basename}]]`
          })),
          Either_exports.map((values) => standardizeRecord(file.path, values))
        );
      }))
    );
  });
}
function filterUndefinedValues(val) {
  return Object.fromEntries(
    Object.entries(val).filter(([_key, value]) => notUndefined(value))
  );
}
function detectSchema2(records) {
  return detectFields(records).map(
    (field) => field.name === "name" ? immer_esm_default(field, (draft) => {
      var _a;
      draft.derived = true;
      draft.typeConfig = immer_esm_default((_a = field.typeConfig) != null ? _a : {}, (draft2) => {
        draft2.richText = true;
      });
    }) : field
  ).map(
    (field) => field.name === "path" ? immer_esm_default(field, (draft) => {
      draft.derived = true;
    }) : field
  );
}

// src/lib/datasources/folder/folder.ts
var FolderDataSource = class extends FrontMatterDataSource {
  constructor(fileSystem2, project, preferences) {
    super(fileSystem2, project, preferences);
    this.fileSystem = fileSystem2;
  }
  includes(path) {
    var _a;
    if (this.project.dataSource.kind !== "folder") {
      return false;
    }
    if ((_a = this.project.excludedNotes) == null ? void 0 : _a.includes(path)) {
      return false;
    }
    let projectPath = (0, import_obsidian30.normalizePath)(this.project.dataSource.config.path);
    if (projectPath === "/") {
      projectPath = "";
    }
    const normalizedPath = (0, import_obsidian30.normalizePath)(path);
    if (!normalizedPath.startsWith(projectPath)) {
      return false;
    }
    if (!this.project.dataSource.config.recursive) {
      return folderContainsPath(projectPath, normalizedPath);
    }
    return true;
  }
};
function folderContainsPath(folderPath, filePath) {
  const fileElements = filePath.split("/").slice(0, -1);
  const folderElement = folderPath.split("/").filter((el) => el);
  return fileElements.join("/") === folderElement.join("/");
}

// src/lib/datasources/tag/tag.ts
var TagDataSource = class extends FrontMatterDataSource {
  constructor(fileSystem2, project, preferences) {
    super(fileSystem2, project, preferences);
    this.fileSystem = fileSystem2;
  }
  includes(path) {
    var _a;
    if (this.project.dataSource.kind !== "tag") {
      return false;
    }
    if ((_a = this.project.excludedNotes) == null ? void 0 : _a.includes(path)) {
      return false;
    }
    const { tag } = this.project.dataSource.config;
    const file = this.fileSystem.getFile(path);
    if (file) {
      return file.readTags().has(tag);
    }
    return false;
  }
};

// src/app/DataFrameProvider.svelte
var get_default_slot_changes2 = (dirty) => ({
  frame: dirty & /*$dataFrame*/
  4,
  source: dirty & /*$dataSource*/
  1
});
var get_default_slot_context2 = (ctx) => ({
  frame: (
    /*$dataFrame*/
    ctx[2]
  ),
  source: (
    /*$dataSource*/
    ctx[0]
  )
});
function create_catch_block_1(ctx) {
  let div;
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: (
        /*error*/
        ctx[16].name
      ),
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(callout.$$.fragment);
      set_style(div, "padding", "var(--size-4-3)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(callout, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & /*querying*/
      2)
        callout_changes.title = /*error*/
        ctx2[16].name;
      if (dirty & /*$$scope, querying*/
      514) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(callout);
    }
  };
}
function create_default_slot_117(ctx) {
  let t_value = (
    /*error*/
    ctx[16].message + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*querying*/
      2 && t_value !== (t_value = /*error*/
      ctx2[16].message + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot17(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_117] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & /*$$scope, querying*/
      514) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_then_block_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context2
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $dataFrame, $dataSource*/
        517)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_pending_block(ctx) {
  let await_block_anchor;
  let promise2;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block,
    catch: create_catch_block,
    blocks: [, , ,]
  };
  handle_promise(promise2 = /*wait*/
  ctx[3](), info);
  return {
    c() {
      await_block_anchor = empty3();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let loading;
  let current;
  loading = new Loading_default({});
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment52(ctx) {
  let await_block_anchor;
  let promise2;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block_1,
    catch: create_catch_block_1,
    error: 16,
    blocks: [, , ,]
  };
  handle_promise(promise2 = /*querying*/
  ctx[1], info);
  return {
    c() {
      await_block_anchor = empty3();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*querying*/
      2 && promise2 !== (promise2 = /*querying*/
      ctx[1]) && handle_promise(promise2, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function reassemble(text2) {
  const res = JSON.parse(text2);
  return Object.assign(Object.assign({}, res), { views: [] });
}
function instance52($$self, $$props, $$invalidate) {
  let disassembedProject;
  let projectAsText;
  let reassembledProject;
  let $settings;
  let $fileSystem;
  let $app;
  let $dataSource;
  let $dataFrame;
  component_subscribe($$self, settings, ($$value) => $$invalidate(10, $settings = $$value));
  component_subscribe($$self, fileSystem, ($$value) => $$invalidate(11, $fileSystem = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(12, $app = $$value));
  component_subscribe($$self, dataSource, ($$value) => $$invalidate(0, $dataSource = $$value));
  component_subscribe($$self, dataFrame, ($$value) => $$invalidate(2, $dataFrame = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { project } = $$props;
  function disassemble(project2) {
    const { views: _24 } = project2, foo = __rest(project2, ["views"]);
    return foo;
  }
  let querying;
  function getDataviewAPI() {
    if ((0, import_obsidian_dataview2.isPluginEnabled)($app)) {
      return (0, import_obsidian_dataview2.getAPI)($app);
    } else {
      throw new UnsupportedCapability(get_store_value(i18n).t("errors.missingDataview.message"));
    }
  }
  function resolveDataSource(project2) {
    switch (project2.dataSource.kind) {
      case "dataview":
        const dataviewApi = getDataviewAPI();
        if (!dataviewApi) {
          throw new Error("Couldn't connect to Dataview. Is the Dataview plugin enabled?");
        }
        return new DataviewDataSource($fileSystem, project2, $settings.preferences, dataviewApi);
      case "tag":
        return new TagDataSource($fileSystem, project2, $settings.preferences);
      default:
        return new FolderDataSource($fileSystem, project2, $settings.preferences);
    }
  }
  const wait2 = () => new Promise((res) => setTimeout(res, 500));
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(4, project = $$props2.project);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*project*/
    16) {
      $:
        $$invalidate(7, disassembedProject = disassemble(project));
    }
    if ($$self.$$.dirty & /*disassembedProject*/
    128) {
      $:
        $$invalidate(6, projectAsText = JSON.stringify(disassembedProject));
    }
    if ($$self.$$.dirty & /*projectAsText*/
    64) {
      $:
        $$invalidate(5, reassembledProject = reassemble(projectAsText));
    }
    if ($$self.$$.dirty & /*reassembledProject*/
    32) {
      $:
        dataSource.set(resolveDataSource(reassembledProject));
    }
    if ($$self.$$.dirty & /*$dataSource*/
    1) {
      $: {
        $$invalidate(1, querying = (() => __awaiter2(void 0, void 0, void 0, function* () {
          if ($dataSource) {
            dataFrame.set(yield $dataSource.queryAll());
          }
        }))());
      }
    }
  };
  return [
    $dataSource,
    querying,
    $dataFrame,
    wait2,
    project,
    reassembledProject,
    projectAsText,
    disassembedProject,
    slots,
    $$scope
  ];
}
var DataFrameProvider = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance52, create_fragment52, safe_not_equal, { project: 4 });
  }
};
var DataFrameProvider_default = DataFrameProvider;

// src/app/App.svelte
function add_css28(target) {
  append_styles(target, "svelte-gr1f73", ".projects-container.svelte-gr1f73{display:flex;flex-direction:column;height:100%}.projects-main.svelte-gr1f73{flex:1;display:flex;flex-direction:column;min-height:0}");
}
var get_default_slot_changes3 = (dirty) => ({
  project: dirty & /*project*/
  16,
  view: dirty & /*view*/
  8,
  source: dirty & /*source*/
  65536,
  frame: dirty & /*frame*/
  32768
});
var get_default_slot_context3 = (ctx) => ({
  project: (
    /*project*/
    ctx[4]
  ),
  view: (
    /*view*/
    ctx[3]
  ),
  source: (
    /*source*/
    ctx[16]
  ),
  frame: (
    /*frame*/
    ctx[15]
  )
});
function create_if_block16(ctx) {
  let dataframeprovider;
  let current;
  dataframeprovider = new DataFrameProvider_default({
    props: {
      project: (
        /*project*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot18,
          ({ frame, source }) => ({ 15: frame, 16: source }),
          ({ frame, source }) => (frame ? 32768 : 0) | (source ? 65536 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dataframeprovider.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dataframeprovider, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dataframeprovider_changes = {};
      if (dirty & /*project*/
      16)
        dataframeprovider_changes.project = /*project*/
        ctx2[4];
      if (dirty & /*$$scope, project, view, source, frame, $api*/
      102456) {
        dataframeprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dataframeprovider.$set(dataframeprovider_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dataframeprovider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dataframeprovider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dataframeprovider, detaching);
    }
  };
}
function create_if_block_19(ctx) {
  let view_1;
  let current;
  view_1 = new View_default({
    props: {
      project: (
        /*project*/
        ctx[4]
      ),
      view: (
        /*view*/
        ctx[3]
      ),
      readonly: (
        /*source*/
        ctx[16].readonly()
      ),
      api: new ViewApi(
        /*source*/
        ctx[16],
        /*$api*/
        ctx[5]
      ),
      onConfigChange: settings.updateViewConfig,
      frame: (
        /*frame*/
        ctx[15]
      )
    }
  });
  return {
    c() {
      create_component(view_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_1_changes = {};
      if (dirty & /*project*/
      16)
        view_1_changes.project = /*project*/
        ctx2[4];
      if (dirty & /*view*/
      8)
        view_1_changes.view = /*view*/
        ctx2[3];
      if (dirty & /*source*/
      65536)
        view_1_changes.readonly = /*source*/
        ctx2[16].readonly();
      if (dirty & /*source, $api*/
      65568)
        view_1_changes.api = new ViewApi(
          /*source*/
          ctx2[16],
          /*$api*/
          ctx2[5]
        );
      if (dirty & /*frame*/
      32768)
        view_1_changes.frame = /*frame*/
        ctx2[15];
      view_1.$set(view_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(view_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view_1, detaching);
    }
  };
}
function create_default_slot18(ctx) {
  let t3;
  let current;
  let if_block = (
    /*project*/
    ctx[4] && /*view*/
    ctx[3] && /*source*/
    ctx[16] && create_if_block_19(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context3
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*project*/
        ctx2[4] && /*view*/
        ctx2[3] && /*source*/
        ctx2[16]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*project, view, source*/
          65560) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, project, view, source, frame*/
        102424)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment53(ctx) {
  var _a, _b;
  let div1;
  let toolbar;
  let t3;
  let div0;
  let current;
  toolbar = new Toolbar_default({
    props: {
      projects: (
        /*projects*/
        ctx[2]
      ),
      projectId: (
        /*project*/
        (_a = ctx[4]) == null ? void 0 : _a.id
      ),
      onProjectChange: (
        /*func*/
        ctx[10]
      ),
      viewId: (
        /*view*/
        (_b = ctx[3]) == null ? void 0 : _b.id
      ),
      onViewChange: (
        /*func_1*/
        ctx[11]
      )
    }
  });
  let if_block = (
    /*project*/
    ctx[4] && create_if_block16(ctx)
  );
  return {
    c() {
      div1 = element("div");
      create_component(toolbar.$$.fragment);
      t3 = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "projects-main svelte-gr1f73");
      attr(div1, "class", "projects-container svelte-gr1f73");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(toolbar, div1, null);
      append4(div1, t3);
      append4(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      const toolbar_changes = {};
      if (dirty & /*projects*/
      4)
        toolbar_changes.projects = /*projects*/
        ctx2[2];
      if (dirty & /*project*/
      16)
        toolbar_changes.projectId = /*project*/
        (_a2 = ctx2[4]) == null ? void 0 : _a2.id;
      if (dirty & /*projectId*/
      1)
        toolbar_changes.onProjectChange = /*func*/
        ctx2[10];
      if (dirty & /*view*/
      8)
        toolbar_changes.viewId = /*view*/
        (_b2 = ctx2[3]) == null ? void 0 : _b2.id;
      if (dirty & /*viewId*/
      2)
        toolbar_changes.onViewChange = /*func_1*/
        ctx2[11];
      toolbar.$set(toolbar_changes);
      if (
        /*project*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*project*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(toolbar);
      if (if_block)
        if_block.d();
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let projects;
  let defaultProject;
  let project;
  let views;
  let view2;
  let $app;
  let $i18n;
  let $settings;
  let $api;
  component_subscribe($$self, app2, ($$value) => $$invalidate(13, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(14, $i18n = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(8, $settings = $$value));
  component_subscribe($$self, api, ($$value) => $$invalidate(5, $api = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { projectId } = $$props;
  let { viewId } = $$props;
  onMount(() => {
    if (!projects.length) {
      new OnboardingModal(
        $app,
        // Create from scratch.
        () => {
          new CreateProjectModal($app, $i18n.t("modals.project.create.title"), $i18n.t("modals.project.create.cta"), settings.addProject, createProject()).open();
        },
        // Try demo project.
        () => {
          createDemoProject($app.vault);
        }
      ).open();
    }
  });
  const func8 = (id) => $$invalidate(0, projectId = id);
  const func_15 = (id) => $$invalidate(1, viewId = id);
  $$self.$$set = ($$props2) => {
    if ("projectId" in $$props2)
      $$invalidate(0, projectId = $$props2.projectId);
    if ("viewId" in $$props2)
      $$invalidate(1, viewId = $$props2.viewId);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$settings*/
    256) {
      $:
        $$invalidate(2, { projects } = $settings, projects);
    }
    if ($$self.$$.dirty & /*projects*/
    4) {
      $:
        $$invalidate(7, defaultProject = projects.find((project2) => project2.isDefault));
    }
    if ($$self.$$.dirty & /*projects, projectId, defaultProject*/
    133) {
      $:
        $$invalidate(4, project = projects.find((project2) => projectId === project2.id) || defaultProject || projects[0]);
    }
    if ($$self.$$.dirty & /*project*/
    16) {
      $:
        $$invalidate(6, views = (project === null || project === void 0 ? void 0 : project.views) || []);
    }
    if ($$self.$$.dirty & /*views, viewId*/
    66) {
      $:
        $$invalidate(3, view2 = views.find((view3) => viewId === view3.id) || views[0]);
    }
  };
  return [
    projectId,
    viewId,
    projects,
    view2,
    project,
    $api,
    views,
    defaultProject,
    $settings,
    slots,
    func8,
    func_15,
    $$scope
  ];
}
var App10 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance53, create_fragment53, safe_not_equal, { projectId: 0, viewId: 1 }, add_css28);
  }
};
var App_default = App10;

// src/custom-view-api.ts
var ProjectView = class {
  onData(result) {
    return __async(this, null, function* () {
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
    });
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/Field/Field.svelte
function add_css29(target) {
  append_styles(target, "svelte-gtpy0j", "div.svelte-gtpy0j{display:flex;align-items:center;justify-content:flex-end;gap:8px}");
}
function create_default_slot19(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t3,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment54(ctx) {
  let div;
  let typography;
  let t3;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      create_component(typography.$$.fragment);
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-gtpy0j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography, div, null);
      append4(div, t3);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & /*$$scope, name*/
      5) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, slots, $$scope];
}
var Field2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance54, create_fragment54, safe_not_equal, { name: 0 }, add_css29);
  }
};
var Field_default = Field2;

// src/components/Layout/ViewContent.svelte
function add_css30(target) {
  append_styles(target, "svelte-ldfkf", "div.svelte-ldfkf{flex:1;overflow:auto}");
}
function create_fragment55(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-ldfkf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ViewContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance55, create_fragment55, safe_not_equal, {}, add_css30);
  }
};
var ViewContent_default = ViewContent;

// src/components/Layout/ViewHeader.svelte
function create_fragment56(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ViewHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance56, create_fragment56, safe_not_equal, {});
  }
};
var ViewHeader_default = ViewHeader;

// src/components/Layout/ViewLayout.svelte
function add_css31(target) {
  append_styles(target, "svelte-vsdhnm", "div.svelte-vsdhnm{height:100%;display:flex;flex-direction:column}");
}
function create_fragment57(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-vsdhnm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ViewLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance57, create_fragment57, safe_not_equal, {}, add_css31);
  }
};
var ViewLayout_default = ViewLayout;

// src/modals/edit-note-modal.ts
var import_obsidian35 = require("obsidian");

// src/modals/input-dialog.ts
var import_obsidian33 = require("obsidian");

// src/modals/components/InputDialog.svelte
function add_css32(target) {
  append_styles(target, "svelte-gwqplq", "input.svelte-gwqplq{width:100%}");
}
function create_default_slot_48(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "svelte-gwqplq");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[7](input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_38(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*cta*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*cta*/
      4)
        set_data(
          t3,
          /*cta*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_210(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[6].t("modals.input.cancel") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      64 && t_value !== (t_value = /*$i18n*/
      ctx2[6].t("modals.input.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_118(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_38] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_210] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[11]
  );
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope, cta*/
      4100) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope, $i18n*/
      4160) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot20(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_48] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_118] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, ref, value*/
      4129) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onCancel, $i18n, onSubmit, value, cta*/
      4189) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment58(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*message*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*message*/
      2)
        modallayout_changes.title = /*message*/
        ctx2[1];
      if (dirty & /*$$scope, onCancel, $i18n, onSubmit, value, cta, ref*/
      4221) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance58($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  let { value } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let ref;
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const focus_handler = () => ref.select();
  const click_handler = () => {
    onSubmit(value);
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSubmit" in $$props2)
      $$invalidate(3, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    value,
    message,
    cta,
    onSubmit,
    onCancel,
    ref,
    $i18n,
    input_binding,
    input_input_handler,
    focus_handler,
    click_handler,
    click_handler_1
  ];
}
var InputDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance58,
      create_fragment58,
      safe_not_equal,
      {
        value: 0,
        message: 1,
        cta: 2,
        onSubmit: 3,
        onCancel: 4
      },
      add_css32
    );
  }
};
var InputDialog_default = InputDialog;

// src/modals/input-dialog.ts
var InputDialogModal = class extends import_obsidian33.Modal {
  constructor(app3, message, cta, onSubmit, value) {
    super(app3);
    this.message = message;
    this.cta = cta;
    this.onSubmit = onSubmit;
    this.value = value;
  }
  onOpen() {
    var _a;
    this.component = new InputDialog_default({
      target: this.contentEl,
      props: {
        message: this.message,
        cta: this.cta,
        value: (_a = this.value) != null ? _a : "",
        onSubmit: (value) => {
          this.onSubmit(value);
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/components/TagList/TagList.svelte
function add_css33(target) {
  append_styles(target, "svelte-8h9y9", "div.svelte-8h9y9{display:flex;align-items:center;gap:4px;overflow:hidden;padding:4px}.edit.svelte-8h9y9{flex-wrap:wrap}");
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function get_each_context9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function create_else_block5(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = (
    /*values*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*values*/
      1) {
        each_value_1 = /*values*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block17(ctx) {
  let t3;
  let iconbutton;
  let current;
  let each_value = (
    /*stringValues*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block9(get_each_context9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  iconbutton = new IconButton_default({
    props: {
      icon: "plus",
      nopadding: true,
      onClick: (
        /*func_1*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onChange, values, stringValues*/
      13) {
        each_value = /*stringValues*/
        ctx2[3];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const iconbutton_changes = {};
      if (dirty & /*$app, onChange, values*/
      21)
        iconbutton_changes.onClick = /*func_1*/
        ctx2[6];
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_119(ctx) {
  let t_value = (
    /*value*/
    ctx[7] + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*values*/
      1 && t_value !== (t_value = /*value*/
      ctx2[7] + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_1(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot_119] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & /*$$scope, values*/
      4097) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_default_slot21(ctx) {
  let t0_value = (
    /*value*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  let iconbutton;
  let current;
  function func8() {
    return (
      /*func*/
      ctx[5](
        /*i*/
        ctx[9]
      )
    );
  }
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      size: "xs",
      nopadding: true,
      onClick: func8
    }
  });
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*stringValues*/
      8) && t0_value !== (t0_value = /*value*/
      ctx[7] + ""))
        set_data(t0, t0_value);
      const iconbutton_changes = {};
      if (dirty & /*onChange, values*/
      5)
        iconbutton_changes.onClick = func8;
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block9(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & /*$$scope, onChange, values, stringValues*/
      4109) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_fragment59(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block17, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*edit*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "svelte-8h9y9");
      toggle_class(
        div,
        "edit",
        /*edit*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*edit*/
      2) {
        toggle_class(
          div,
          "edit",
          /*edit*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance59($$self, $$props, $$invalidate) {
  let stringValues;
  let $app;
  component_subscribe($$self, app2, ($$value) => $$invalidate(4, $app = $$value));
  let { values } = $$props;
  let { edit = false } = $$props;
  let { onChange = () => {
  } } = $$props;
  const func8 = (i2) => {
    onChange(values.filter((_24, j2) => i2 !== j2));
  };
  const func_15 = () => {
    new InputDialogModal(
      $app,
      "Add list item",
      "Add",
      (value) => {
        onChange([...values, value]);
      }
    ).open();
  };
  $$self.$$set = ($$props2) => {
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*values*/
    1) {
      $:
        $$invalidate(3, stringValues = values.filter(isString));
    }
  };
  return [values, edit, onChange, stringValues, $app, func8, func_15];
}
var TagList = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance59, create_fragment59, safe_not_equal, { values: 0, edit: 1, onChange: 2 }, add_css33);
  }
};
var TagList_default = TagList;

// src/components/FieldControl/FieldControl.svelte
function create_if_block_5(ctx) {
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: isDate(
        /*value*/
        ctx[1]
      ) ? (
        /*value*/
        ctx[1]
      ) : null
    }
  });
  dateinput.$on(
    "change",
    /*change_handler_1*/
    ctx[12]
  );
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dateinput_changes = {};
      if (dirty & /*value*/
      2)
        dateinput_changes.value = isDate(
          /*value*/
          ctx2[1]
        ) ? (
          /*value*/
          ctx2[1]
        ) : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      value: isNumber(
        /*value*/
        ctx[1]
      ) ? (
        /*value*/
        ctx[1]
      ) : null
    }
  });
  numberinput.$on(
    "input",
    /*input_handler_1*/
    ctx[11]
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*value*/
      2)
        numberinput_changes.value = isNumber(
          /*value*/
          ctx2[1]
        ) ? (
          /*value*/
          ctx2[1]
        ) : null;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_26(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_33, create_else_block6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*options*/
      ctx2[4].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_110(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      edit: true,
      values: (
        /*value*/
        (_a = ctx[1]) != null ? _a : []
      ),
      onChange: (
        /*onChange*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & /*value*/
      2)
        taglist_changes.values = /*value*/
        (_a2 = ctx2[1]) != null ? _a2 : [];
      if (dirty & /*onChange*/
      4)
        taglist_changes.onChange = /*onChange*/
        ctx2[2];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_if_block18(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: isBoolean(
        /*value*/
        ctx[1]
      ) ? (
        /*value*/
        ctx[1]
      ) : false
    }
  });
  switch_1.$on(
    "check",
    /*check_handler*/
    ctx[8]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & /*value*/
      2)
        switch_1_changes.checked = isBoolean(
          /*value*/
          ctx2[1]
        ) ? (
          /*value*/
          ctx2[1]
        ) : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_else_block6(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: isString(
        /*value*/
        ctx[1]
      ) ? (
        /*value*/
        ctx[1]
      ) : "",
      readonly: (
        /*readonly*/
        ctx[3]
      )
    }
  });
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[10]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*value*/
      2)
        textinput_changes.value = isString(
          /*value*/
          ctx2[1]
        ) ? (
          /*value*/
          ctx2[1]
        ) : "";
      if (dirty & /*readonly*/
      8)
        textinput_changes.readonly = /*readonly*/
        ctx2[3];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_33(ctx) {
  let autocomplete;
  let current;
  autocomplete = new Autocomplete_default({
    props: {
      value: isString(
        /*value*/
        ctx[1]
      ) ? (
        /*value*/
        ctx[1]
      ) : "",
      options: (
        /*options*/
        ctx[4]
      )
    }
  });
  autocomplete.$on(
    "change",
    /*change_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const autocomplete_changes = {};
      if (dirty & /*value*/
      2)
        autocomplete_changes.value = isString(
          /*value*/
          ctx2[1]
        ) ? (
          /*value*/
          ctx2[1]
        ) : "";
      if (dirty & /*options*/
      16)
        autocomplete_changes.options = /*options*/
        ctx2[4];
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function create_fragment60(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block18,
    create_if_block_110,
    create_if_block_26,
    create_if_block_42,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*field, value*/
    3)
      show_if = null;
    if (
      /*field*/
      ctx2[0].type === "boolean" /* Boolean */
    )
      return 0;
    if (show_if == null)
      show_if = !!/*field*/
      (ctx2[0].repeated && isOptionalList(
        /*value*/
        ctx2[1]
      ));
    if (show_if)
      return 1;
    if (
      /*field*/
      ctx2[0].type === "string" /* String */
    )
      return 2;
    if (
      /*field*/
      ctx2[0].type === "number" /* Number */
    )
      return 3;
    if (
      /*field*/
      ctx2[0].type === "date" /* Date */
    )
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance60($$self, $$props, $$invalidate) {
  let options;
  var _a, _b, _c;
  let { field } = $$props;
  let { value } = $$props;
  let { onChange } = $$props;
  let { readonly = false } = $$props;
  const check_handler = ({ detail }) => onChange(detail);
  const change_handler = ({ detail }) => onChange(detail);
  const input_handler = ({ detail: value2 }) => onChange(value2);
  const input_handler_1 = ({ detail: value2 }) => onChange(value2 !== null ? value2 : void 0);
  const change_handler_1 = ({ detail: value2 }) => onChange(value2 != null ? value2 : void 0);
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field, _a, _b, _c*/
    225) {
      $:
        $$invalidate(4, options = $$invalidate(7, _c = $$invalidate(6, _b = $$invalidate(5, _a = field.typeConfig) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.map((option2) => ({ label: option2, description: "" }))) !== null && _c !== void 0 ? _c : []);
    }
  };
  return [
    field,
    value,
    onChange,
    readonly,
    options,
    _a,
    _b,
    _c,
    check_handler,
    change_handler,
    input_handler,
    input_handler_1,
    change_handler_1
  ];
}
var FieldControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance60, create_fragment60, safe_not_equal, {
      field: 0,
      value: 1,
      onChange: 2,
      readonly: 3
    });
  }
};
var FieldControl_default = FieldControl;

// src/modals/components/EditNote.svelte
function get_each_context10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_if_block19(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: (
        /*$i18n*/
        ctx[3].t("modals.note.edit.no-editable-fields.title")
      ),
      icon: "info",
      variant: "info",
      $$slots: { default: [create_default_slot_58] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & /*$i18n*/
      8)
        callout_changes.title = /*$i18n*/
        ctx2[3].t("modals.note.edit.no-editable-fields.title");
      if (dirty & /*$$scope, $i18n*/
      1032) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_58(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[3].t("modals.note.edit.no-editable-fields.message") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      8 && t_value !== (t_value = /*$i18n*/
      ctx2[3].t("modals.note.edit.no-editable-fields.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_49(ctx) {
  let fieldcontrol;
  let t3;
  let current;
  function func8(...args) {
    return (
      /*func*/
      ctx[5](
        /*field*/
        ctx[7],
        ...args
      )
    );
  }
  fieldcontrol = new FieldControl_default({
    props: {
      field: (
        /*field*/
        ctx[7]
      ),
      value: (
        /*record*/
        ctx[0].values[
          /*field*/
          ctx[7].name
        ]
      ),
      onChange: func8
    }
  });
  return {
    c() {
      create_component(fieldcontrol.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(fieldcontrol, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fieldcontrol_changes = {};
      if (dirty & /*editableFields*/
      4)
        fieldcontrol_changes.field = /*field*/
        ctx[7];
      if (dirty & /*record, editableFields*/
      5)
        fieldcontrol_changes.value = /*record*/
        ctx[0].values[
          /*field*/
          ctx[7].name
        ];
      if (dirty & /*record, editableFields*/
      5)
        fieldcontrol_changes.onChange = func8;
      fieldcontrol.$set(fieldcontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldcontrol, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block10(key_1, ctx) {
  let first;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*field*/
        ctx[7].name
      ),
      $$slots: { default: [create_default_slot_49] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(settingitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const settingitem_changes = {};
      if (dirty & /*editableFields*/
      4)
        settingitem_changes.name = /*field*/
        ctx[7].name;
      if (dirty & /*$$scope, editableFields, record*/
      1029) {
        settingitem_changes.$$scope = { dirty, ctx };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_39(ctx) {
  let t3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block = !/*editableFields*/
  ctx[2].length && create_if_block19(ctx);
  let each_value = (
    /*editableFields*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*field*/
    ctx2[7].name
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block10(key, child_ctx));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*editableFields*/
      ctx2[2].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editableFields*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*editableFields, record, produce*/
      5) {
        each_value = /*editableFields*/
        ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block10, each_1_anchor, get_each_context10);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_211(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[3].t("modals.note.edit.save") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      8 && t_value !== (t_value = /*$i18n*/
      ctx2[3].t("modals.note.edit.save") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_120(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_211] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      1032) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot22(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_39] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_120] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, editableFields, record, $i18n*/
      1037) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onSave, record, $i18n*/
      1035) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment61(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*$i18n*/
        ctx[3].t("modals.note.edit.title")
      ),
      $$slots: { default: [create_default_slot22] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*$i18n*/
      8)
        modallayout_changes.title = /*$i18n*/
        ctx2[3].t("modals.note.edit.title");
      if (dirty & /*$$scope, onSave, record, $i18n, editableFields*/
      1039) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance61($$self, $$props, $$invalidate) {
  let editableFields;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { fields } = $$props;
  let { record } = $$props;
  let { onSave } = $$props;
  const func8 = (field, value) => {
    $$invalidate(0, record = immer_esm_default(record, (draft) => {
      draft.values[field.name] = value;
    }));
  };
  const click_handler = () => {
    onSave(record);
  };
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(4, fields = $$props2.fields);
    if ("record" in $$props2)
      $$invalidate(0, record = $$props2.record);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fields*/
    16) {
      $:
        $$invalidate(2, editableFields = fields.filter((field) => !field.derived));
    }
  };
  return [record, onSave, editableFields, $i18n, fields, func8, click_handler];
}
var EditNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance61, create_fragment61, safe_not_equal, { fields: 4, record: 0, onSave: 1 });
  }
};
var EditNote_default = EditNote;

// src/modals/edit-note-modal.ts
var EditNoteModal = class extends import_obsidian35.Modal {
  constructor(app3, fields, onSave, defaults2) {
    super(app3);
    this.fields = fields;
    this.onSave = onSave;
    this.defaults = defaults2;
  }
  onOpen() {
    this.component = new EditNote_default({
      target: this.contentEl,
      props: {
        record: this.defaults,
        fields: this.fields,
        onSave: (record) => {
          this.onSave(record);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/helpers.ts
function fieldToSelectableValue(field) {
  return {
    label: field.name,
    value: field.name
  };
}
var getRecordColorKey = Symbol();
function getRecordColorContext() {
  return getContext(getRecordColorKey);
}
function setRecordColorContext(fn3) {
  setContext(getRecordColorKey, fn3);
}

// src/views/Table/components/SwitchSelect/SwitchSelect.svelte
function add_css34(target) {
  append_styles(target, "svelte-zdcf2i", "div.svelte-zdcf2i{align-items:center;display:inline-flex;text-align:start}");
}
function get_each_context11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2].label;
  child_ctx[10] = list[i2].value;
  child_ctx[11] = list[i2].enabled;
  return child_ctx;
}
function create_each_block11(ctx) {
  let menuitem;
  let current;
  function check_handler(...args) {
    return (
      /*check_handler*/
      ctx[8](
        /*value*/
        ctx[10],
        ...args
      )
    );
  }
  menuitem = new MenuItem_default({
    props: {
      label: (
        /*label*/
        ctx[2]
      ),
      checked: (
        /*enabled*/
        ctx[11]
      )
    }
  });
  menuitem.$on("check", check_handler);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & /*items*/
      1)
        menuitem_changes.label = /*label*/
        ctx[2];
      if (dirty & /*items*/
      1)
        menuitem_changes.checked = /*enabled*/
        ctx[11];
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot23(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block11(get_each_context11(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items, onChange*/
      3) {
        each_value = /*items*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block11(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment62(ctx) {
  let div;
  let t0;
  let t1;
  let menu;
  let current;
  let mounted;
  let dispose;
  menu = new Menu_default({
    props: {
      anchorEl: (
        /*ref*/
        ctx[3]
      ),
      open: (
        /*isOpen*/
        ctx[4]
      ),
      onClose: (
        /*func*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot23] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      t0 = text(
        /*label*/
        ctx[2]
      );
      t1 = space();
      create_component(menu.$$.fragment);
      attr(div, "class", "dropdown svelte-zdcf2i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t0);
      ctx[6](div);
      insert(target, t1, anchor);
      mount_component(menu, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[5]
          ),
          listen(
            div,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*label*/
      4)
        set_data(
          t0,
          /*label*/
          ctx2[2]
        );
      const menu_changes = {};
      if (dirty & /*ref*/
      8)
        menu_changes.anchorEl = /*ref*/
        ctx2[3];
      if (dirty & /*isOpen*/
      16)
        menu_changes.open = /*isOpen*/
        ctx2[4];
      if (dirty & /*isOpen*/
      16)
        menu_changes.onClose = /*func*/
        ctx2[9];
      if (dirty & /*$$scope, items, onChange*/
      16387) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[6](null);
      if (detaching)
        detach(t1);
      destroy_component(menu, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance62($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { label } = $$props;
  let { onChange } = $$props;
  let ref;
  let isOpen = false;
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler = () => $$invalidate(4, isOpen = true);
  const check_handler = (value, { detail: checked }) => onChange(value, checked);
  const func8 = () => $$invalidate(4, isOpen = false);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
  };
  return [
    items,
    onChange,
    label,
    ref,
    isOpen,
    keypress_handler,
    div_binding,
    click_handler,
    check_handler,
    func8
  ];
}
var SwitchSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance62, create_fragment62, safe_not_equal, { items: 0, label: 2, onChange: 1 }, add_css34);
  }
};
var SwitchSelect_default = SwitchSelect;

// src/views/Board/board.ts
function unique(records, fieldName) {
  const keys = records.map((record) => record.values[fieldName]).map((value) => value && isNumber(value) ? value.toLocaleString() : value).map((value) => value && isString(value) ? value : null).filter(notEmpty);
  const set2 = new Set(keys);
  return [...set2];
}
function groupRecordsByField(records, fieldName) {
  var _a;
  const noStatus = get_store_value(i18n).t("views.board.no-status");
  if (!fieldName) {
    return { [noStatus]: records };
  }
  const keys = unique(records, fieldName);
  const res = {
    [noStatus]: []
  };
  for (const key of keys) {
    res[key] = [];
  }
  records.forEach((record) => {
    var _a2, _b, _c;
    const value = record.values[fieldName];
    if (value && isString(value)) {
      (_a2 = res[value]) == null ? void 0 : _a2.push(record);
    } else if (value && isNumber(value)) {
      (_b = res[value.toLocaleString()]) == null ? void 0 : _b.push(record);
    } else {
      (_c = res[noStatus]) == null ? void 0 : _c.push(record);
    }
  });
  if (!((_a = res[noStatus]) == null ? void 0 : _a.length)) {
    delete res[noStatus];
  }
  return res;
}

// node_modules/svelte-dnd-action/dist/index.mjs
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o2);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var FINALIZE_EVENT_NAME = "finalize";
var CONSIDER_EVENT_NAME = "consider";
function dispatchFinalizeEvent(el, items, info) {
  el.dispatchEvent(new CustomEvent(FINALIZE_EVENT_NAME, {
    detail: {
      items,
      info
    }
  }));
}
function dispatchConsiderEvent(el, items, info) {
  el.dispatchEvent(new CustomEvent(CONSIDER_EVENT_NAME, {
    detail: {
      items,
      info
    }
  }));
}
var DRAGGED_ENTERED_EVENT_NAME = "draggedEntered";
var DRAGGED_LEFT_EVENT_NAME = "draggedLeft";
var DRAGGED_OVER_INDEX_EVENT_NAME = "draggedOverIndex";
var DRAGGED_LEFT_DOCUMENT_EVENT_NAME = "draggedLeftDocument";
var DRAGGED_LEFT_TYPES = {
  LEFT_FOR_ANOTHER: "leftForAnother",
  OUTSIDE_OF_ANY: "outsideOfAny"
};
function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {
    detail: {
      indexObj,
      draggedEl: draggedEl2
    }
  }));
}
function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl2, theOtherDz) {
  containerEl.dispatchEvent(new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
    detail: {
      draggedEl: draggedEl2,
      type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER,
      theOtherDz
    }
  }));
}
function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl2) {
  containerEl.dispatchEvent(new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
    detail: {
      draggedEl: draggedEl2,
      type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY
    }
  }));
}
function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {
    detail: {
      indexObj,
      draggedEl: draggedEl2
    }
  }));
}
function dispatchDraggedLeftDocument(draggedEl2) {
  window.dispatchEvent(new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {
    detail: {
      draggedEl: draggedEl2
    }
  }));
}
var TRIGGERS = {
  DRAG_STARTED: "dragStarted",
  DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,
  DRAGGED_ENTERED_ANOTHER: "dragEnteredAnother",
  DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,
  DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,
  DRAGGED_LEFT_ALL: "draggedLeftAll",
  DROPPED_INTO_ZONE: "droppedIntoZone",
  DROPPED_INTO_ANOTHER: "droppedIntoAnother",
  DROPPED_OUTSIDE_OF_ANY: "droppedOutsideOfAny",
  DRAG_STOPPED: "dragStopped"
};
var SOURCES = {
  POINTER: "pointer",
  KEYBOARD: "keyboard"
};
var SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
var SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
var DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
var ITEM_ID_KEY = "id";
var activeDndZoneCount = 0;
function incrementActiveDropZoneCount() {
  activeDndZoneCount++;
}
function decrementActiveDropZoneCount() {
  if (activeDndZoneCount === 0) {
    throw new Error("Bug! trying to decrement when there are no dropzones");
  }
  activeDndZoneCount--;
}
var isOnServer = typeof window === "undefined";
var printDebug = function printDebug2() {
};
function getBoundingRectNoTransforms(el) {
  var ta;
  var rect = el.getBoundingClientRect();
  var style = getComputedStyle(el);
  var tx = style.transform;
  if (tx) {
    var sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return rect;
    }
    var to = style.transformOrigin;
    var x2 = rect.x - dx - (1 - sx) * parseFloat(to);
    var y2 = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    var w2 = sx ? rect.width / sx : el.offsetWidth;
    var h2 = sy ? rect.height / sy : el.offsetHeight;
    return {
      x: x2,
      y: y2,
      width: w2,
      height: h2,
      top: y2,
      right: x2 + w2,
      bottom: y2 + h2,
      left: x2
    };
  } else {
    return rect;
  }
}
function getAbsoluteRectNoTransforms(el) {
  var rect = getBoundingRectNoTransforms(el);
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function getAbsoluteRect(el) {
  var rect = el.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function findCenter(rect) {
  return {
    x: (rect.left + rect.right) / 2,
    y: (rect.top + rect.bottom) / 2
  };
}
function calcDistance(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
}
function isPointInsideRect(point, rect) {
  return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;
}
function findCenterOfElement(el) {
  return findCenter(getAbsoluteRect(el));
}
function isCenterOfAInsideB(elA, elB) {
  var centerOfA = findCenterOfElement(elA);
  var rectOfB = getAbsoluteRectNoTransforms(elB);
  return isPointInsideRect(centerOfA, rectOfB);
}
function calcDistanceBetweenCenters(elA, elB) {
  var centerOfA = findCenterOfElement(elA);
  var centerOfB = findCenterOfElement(elB);
  return calcDistance(centerOfA, centerOfB);
}
function isElementOffDocument(el) {
  var rect = getAbsoluteRect(el);
  return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
}
function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
  var rect = getAbsoluteRect(el);
  if (!isPointInsideRect(point, rect)) {
    return null;
  }
  return {
    top: point.y - rect.top,
    bottom: rect.bottom - point.y,
    left: point.x - rect.left,
    // TODO - figure out what is so special about right (why the rect is too big)
    right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
  };
}
var dzToShadowIndexToRect;
function resetIndexesCache() {
  printDebug(function() {
    return "resetting indexes cache";
  });
  dzToShadowIndexToRect = /* @__PURE__ */ new Map();
}
resetIndexesCache();
function resetIndexesCacheForDz(dz) {
  printDebug(function() {
    return "resetting indexes cache for dz";
  });
  dzToShadowIndexToRect["delete"](dz);
}
function cacheShadowRect(dz) {
  var shadowElIndex = Array.from(dz.children).findIndex(function(child) {
    return child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
  });
  if (shadowElIndex >= 0) {
    if (!dzToShadowIndexToRect.has(dz)) {
      dzToShadowIndexToRect.set(dz, /* @__PURE__ */ new Map());
    }
    dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));
    return shadowElIndex;
  }
  return void 0;
}
function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
  if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {
    return null;
  }
  var children2 = collectionBelowEl.children;
  if (children2.length === 0) {
    return {
      index: 0,
      isProximityBased: true
    };
  }
  var shadowElIndex = cacheShadowRect(collectionBelowEl);
  for (var i2 = 0; i2 < children2.length; i2++) {
    if (isCenterOfAInsideB(floatingAboveEl, children2[i2])) {
      var cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i2);
      if (cachedShadowRect) {
        if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {
          return {
            index: shadowElIndex,
            isProximityBased: false
          };
        }
      }
      return {
        index: i2,
        isProximityBased: false
      };
    }
  }
  var minDistanceSoFar = Number.MAX_VALUE;
  var indexOfMin = void 0;
  for (var _i = 0; _i < children2.length; _i++) {
    var distance = calcDistanceBetweenCenters(floatingAboveEl, children2[_i]);
    if (distance < minDistanceSoFar) {
      minDistanceSoFar = distance;
      indexOfMin = _i;
    }
  }
  return {
    index: indexOfMin,
    isProximityBased: true
  };
}
var SCROLL_ZONE_PX = 25;
function makeScroller() {
  var scrollingInfo;
  function resetScrolling2() {
    scrollingInfo = {
      directionObj: void 0,
      stepPx: 0
    };
  }
  resetScrolling2();
  function scrollContainer(containerEl) {
    var _scrollingInfo = scrollingInfo, directionObj = _scrollingInfo.directionObj, stepPx = _scrollingInfo.stepPx;
    if (directionObj) {
      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
      window.requestAnimationFrame(function() {
        return scrollContainer(containerEl);
      });
    }
  }
  function calcScrollStepPx(distancePx) {
    return SCROLL_ZONE_PX - distancePx;
  }
  function scrollIfNeeded2(pointer, elementToScroll) {
    if (!elementToScroll) {
      return false;
    }
    var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
    if (distances === null) {
      resetScrolling2();
      return false;
    }
    var isAlreadyScrolling = !!scrollingInfo.directionObj;
    var scrollingVertically = false, scrollingHorizontally = false;
    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
      if (distances.bottom < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = {
          x: 0,
          y: 1
        };
        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
      } else if (distances.top < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = {
          x: 0,
          y: -1
        };
        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
      }
      if (!isAlreadyScrolling && scrollingVertically) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
      if (distances.right < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = {
          x: 1,
          y: 0
        };
        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
      } else if (distances.left < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = {
          x: -1,
          y: 0
        };
        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
      }
      if (!isAlreadyScrolling && scrollingHorizontally) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    resetScrolling2();
    return false;
  }
  return {
    scrollIfNeeded: scrollIfNeeded2,
    resetScrolling: resetScrolling2
  };
}
function toString(object) {
  return JSON.stringify(object, null, 2);
}
function getDepth(node) {
  if (!node) {
    throw new Error("cannot get depth of a falsy node");
  }
  return _getDepth(node, 0);
}
function _getDepth(node) {
  var countSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!node.parentElement) {
    return countSoFar - 1;
  }
  return _getDepth(node.parentElement, countSoFar + 1);
}
function areObjectsShallowEqual(objA, objB) {
  if (Object.keys(objA).length !== Object.keys(objB).length) {
    return false;
  }
  for (var keyA in objA) {
    if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {
      return false;
    }
  }
  return true;
}
function areArraysShallowEqualSameOrder(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (var i2 = 0; i2 < arrA.length; i2++) {
    if (arrA[i2] !== arrB[i2]) {
      return false;
    }
  }
  return true;
}
var INTERVAL_MS = 200;
var TOLERANCE_PX = 10;
var _makeScroller = makeScroller();
var scrollIfNeeded = _makeScroller.scrollIfNeeded;
var resetScrolling = _makeScroller.resetScrolling;
var next;
function observe(draggedEl2, dropZones) {
  var intervalMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : INTERVAL_MS;
  var lastDropZoneFound;
  var lastIndexFound;
  var lastIsDraggedInADropZone = false;
  var lastCentrePositionOfDragged;
  var dropZonesFromDeepToShallow = Array.from(dropZones).sort(function(dz1, dz2) {
    return getDepth(dz2) - getDepth(dz1);
  });
  function andNow() {
    var currentCenterOfDragged = findCenterOfElement(draggedEl2);
    var scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);
    if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
      next = window.setTimeout(andNow, intervalMs);
      return;
    }
    if (isElementOffDocument(draggedEl2)) {
      printDebug(function() {
        return "off document";
      });
      dispatchDraggedLeftDocument(draggedEl2);
      return;
    }
    lastCentrePositionOfDragged = currentCenterOfDragged;
    var isDraggedInADropZone = false;
    var _iterator = _createForOfIteratorHelper(dropZonesFromDeepToShallow), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var dz = _step.value;
        if (scrolled)
          resetIndexesCacheForDz(lastDropZoneFound);
        var indexObj = findWouldBeIndex(draggedEl2, dz);
        if (indexObj === null) {
          continue;
        }
        var index2 = indexObj.index;
        isDraggedInADropZone = true;
        if (dz !== lastDropZoneFound) {
          lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl2, dz);
          dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl2);
          lastDropZoneFound = dz;
        } else if (index2 !== lastIndexFound) {
          dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl2);
          lastIndexFound = index2;
        }
        break;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {
      dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl2);
      lastDropZoneFound = void 0;
      lastIndexFound = void 0;
      lastIsDraggedInADropZone = false;
    } else {
      lastIsDraggedInADropZone = true;
    }
    next = window.setTimeout(andNow, intervalMs);
  }
  andNow();
}
function unobserve() {
  printDebug(function() {
    return "unobserving";
  });
  clearTimeout(next);
  resetScrolling();
  resetIndexesCache();
}
var INTERVAL_MS$1 = 300;
var mousePosition;
function updateMousePosition(e) {
  var c2 = e.touches ? e.touches[0] : e;
  mousePosition = {
    x: c2.clientX,
    y: c2.clientY
  };
}
var _makeScroller$1 = makeScroller();
var scrollIfNeeded$1 = _makeScroller$1.scrollIfNeeded;
var resetScrolling$1 = _makeScroller$1.resetScrolling;
var next$1;
function loop2() {
  if (mousePosition) {
    var scrolled = scrollIfNeeded$1(mousePosition, document.documentElement);
    if (scrolled)
      resetIndexesCache();
  }
  next$1 = window.setTimeout(loop2, INTERVAL_MS$1);
}
function armWindowScroller() {
  printDebug(function() {
    return "arming window scroller";
  });
  window.addEventListener("mousemove", updateMousePosition);
  window.addEventListener("touchmove", updateMousePosition);
  loop2();
}
function disarmWindowScroller() {
  printDebug(function() {
    return "disarming window scroller";
  });
  window.removeEventListener("mousemove", updateMousePosition);
  window.removeEventListener("touchmove", updateMousePosition);
  mousePosition = void 0;
  window.clearTimeout(next$1);
  resetScrolling$1();
}
function svelteNodeClone(el) {
  var cloned = el.cloneNode(true);
  var values = [];
  var elIsSelect = el.tagName === "SELECT";
  var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll("select"));
  var _iterator = _createForOfIteratorHelper(selects), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _select = _step.value;
      values.push(_select.value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (selects.length <= 0) {
    return cloned;
  }
  var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll("select"));
  for (var i2 = 0; i2 < clonedSelects.length; i2++) {
    var select = clonedSelects[i2];
    var value = values[i2];
    var optionEl = select.querySelector('option[value="'.concat(value, '"'));
    if (optionEl) {
      optionEl.setAttribute("selected", true);
    }
  }
  return cloned;
}
var TRANSITION_DURATION_SECONDS = 0.2;
function trs(property) {
  return "".concat(property, " ").concat(TRANSITION_DURATION_SECONDS, "s ease");
}
function createDraggedElementFrom(originalElement, positionCenterOnXY) {
  var rect = originalElement.getBoundingClientRect();
  var draggedEl2 = svelteNodeClone(originalElement);
  copyStylesFromTo(originalElement, draggedEl2);
  draggedEl2.id = DRAGGED_ELEMENT_ID;
  draggedEl2.style.position = "fixed";
  var elTopPx = rect.top;
  var elLeftPx = rect.left;
  draggedEl2.style.top = "".concat(elTopPx, "px");
  draggedEl2.style.left = "".concat(elLeftPx, "px");
  if (positionCenterOnXY) {
    var center = findCenter(rect);
    elTopPx -= center.y - positionCenterOnXY.y;
    elLeftPx -= center.x - positionCenterOnXY.x;
    window.setTimeout(function() {
      draggedEl2.style.top = "".concat(elTopPx, "px");
      draggedEl2.style.left = "".concat(elLeftPx, "px");
    }, 0);
  }
  draggedEl2.style.margin = "0";
  draggedEl2.style.boxSizing = "border-box";
  draggedEl2.style.height = "".concat(rect.height, "px");
  draggedEl2.style.width = "".concat(rect.width, "px");
  draggedEl2.style.transition = "".concat(trs("top"), ", ").concat(trs("left"), ", ").concat(trs("background-color"), ", ").concat(trs("opacity"), ", ").concat(trs("color"), " ");
  window.setTimeout(function() {
    return draggedEl2.style.transition += ", ".concat(trs("width"), ", ").concat(trs("height"));
  }, 0);
  draggedEl2.style.zIndex = "9999";
  draggedEl2.style.cursor = "grabbing";
  return draggedEl2;
}
function moveDraggedElementToWasDroppedState(draggedEl2) {
  draggedEl2.style.cursor = "grab";
}
function morphDraggedElementToBeLike(draggedEl2, copyFromEl, currentMouseX, currentMouseY) {
  copyStylesFromTo(copyFromEl, draggedEl2);
  var newRect = copyFromEl.getBoundingClientRect();
  var draggedElRect = draggedEl2.getBoundingClientRect();
  var widthChange = newRect.width - draggedElRect.width;
  var heightChange = newRect.height - draggedElRect.height;
  if (widthChange || heightChange) {
    var relativeDistanceOfMousePointerFromDraggedSides = {
      left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
      top: (currentMouseY - draggedElRect.top) / draggedElRect.height
    };
    draggedEl2.style.height = "".concat(newRect.height, "px");
    draggedEl2.style.width = "".concat(newRect.width, "px");
    draggedEl2.style.left = "".concat(parseFloat(draggedEl2.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange, "px");
    draggedEl2.style.top = "".concat(parseFloat(draggedEl2.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange, "px");
  }
}
function copyStylesFromTo(copyFromEl, copyToEl) {
  var computedStyle = window.getComputedStyle(copyFromEl);
  Array.from(computedStyle).filter(function(s2) {
    return s2.startsWith("background") || s2.startsWith("padding") || s2.startsWith("font") || s2.startsWith("text") || s2.startsWith("align") || s2.startsWith("justify") || s2.startsWith("display") || s2.startsWith("flex") || s2.startsWith("border") || s2 === "opacity" || s2 === "color" || s2 === "list-style-type";
  }).forEach(function(s2) {
    return copyToEl.style.setProperty(s2, computedStyle.getPropertyValue(s2), computedStyle.getPropertyPriority(s2));
  });
}
function styleDraggable(draggableEl, dragDisabled) {
  draggableEl.draggable = false;
  draggableEl.ondragstart = function() {
    return false;
  };
  if (!dragDisabled) {
    draggableEl.style.userSelect = "none";
    draggableEl.style.WebkitUserSelect = "none";
    draggableEl.style.cursor = "grab";
  } else {
    draggableEl.style.userSelect = "";
    draggableEl.style.WebkitUserSelect = "";
    draggableEl.style.cursor = "";
  }
}
function hideElement(dragTarget) {
  dragTarget.style.display = "none";
  dragTarget.style.position = "fixed";
  dragTarget.style.zIndex = "-5";
}
function decorateShadowEl(shadowEl) {
  shadowEl.style.visibility = "hidden";
  shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, "true");
}
function unDecorateShadowElement(shadowEl) {
  shadowEl.style.visibility = "";
  shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
}
function styleActiveDropZones(dropZones) {
  var getStyles = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
  };
  var getClasses = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    return [];
  };
  dropZones.forEach(function(dz) {
    var styles = getStyles(dz);
    Object.keys(styles).forEach(function(style) {
      dz.style[style] = styles[style];
    });
    getClasses(dz).forEach(function(c2) {
      return dz.classList.add(c2);
    });
  });
}
function styleInactiveDropZones(dropZones) {
  var getStyles = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
  };
  var getClasses = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    return [];
  };
  dropZones.forEach(function(dz) {
    var styles = getStyles(dz);
    Object.keys(styles).forEach(function(style) {
      dz.style[style] = "";
    });
    getClasses(dz).forEach(function(c2) {
      return dz.classList.contains(c2) && dz.classList.remove(c2);
    });
  });
}
function preventShrinking(el) {
  var originalMinHeight = el.style.minHeight;
  el.style.minHeight = window.getComputedStyle(el).getPropertyValue("height");
  var originalMinWidth = el.style.minWidth;
  el.style.minWidth = window.getComputedStyle(el).getPropertyValue("width");
  return function undo() {
    el.style.minHeight = originalMinHeight;
    el.style.minWidth = originalMinWidth;
  };
}
var DEFAULT_DROP_ZONE_TYPE = "--any--";
var MIN_OBSERVATION_INTERVAL_MS = 100;
var MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
var DEFAULT_DROP_TARGET_STYLE = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var originalDragTarget;
var draggedEl;
var draggedElData;
var draggedElType;
var originDropZone;
var originIndex;
var shadowElData;
var shadowElDropZone;
var dragStartMousePosition;
var currentMousePosition;
var isWorkingOnPreviousDrag = false;
var finalizingPreviousDrag = false;
var unlockOriginDzMinDimensions;
var isDraggedOutsideOfAnyDz = false;
var scheduledForRemovalAfterDrop = [];
var typeToDropZones = /* @__PURE__ */ new Map();
var dzToConfig = /* @__PURE__ */ new Map();
var elToMouseDownListener = /* @__PURE__ */ new WeakMap();
function registerDropZone(dropZoneEl, type) {
  printDebug(function() {
    return "registering drop-zone if absent";
  });
  if (!typeToDropZones.has(type)) {
    typeToDropZones.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones.get(type).has(dropZoneEl)) {
    typeToDropZones.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone(dropZoneEl, type) {
  typeToDropZones.get(type)["delete"](dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones.get(type).size === 0) {
    typeToDropZones["delete"](type);
  }
}
function watchDraggedElement() {
  printDebug(function() {
    return "watching dragged element";
  });
  armWindowScroller();
  var dropZones = typeToDropZones.get(draggedElType);
  var _iterator = _createForOfIteratorHelper(dropZones), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var dz = _step.value;
      dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
      dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
      dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  var observationIntervalMs = Math.max.apply(Math, [MIN_OBSERVATION_INTERVAL_MS].concat(_toConsumableArray(Array.from(dropZones.keys()).map(function(dz2) {
    return dzToConfig.get(dz2).dropAnimationDurationMs;
  }))));
  observe(draggedEl, dropZones, observationIntervalMs * 1.07);
}
function unWatchDraggedElement() {
  printDebug(function() {
    return "unwatching dragged element";
  });
  disarmWindowScroller();
  var dropZones = typeToDropZones.get(draggedElType);
  var _iterator2 = _createForOfIteratorHelper(dropZones), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var dz = _step2.value;
      dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
      dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
      dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  unobserve();
}
function findShadowPlaceHolderIdx(items) {
  return items.findIndex(function(item) {
    return item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID;
  });
}
function findShadowElementIdx(items) {
  return items.findIndex(function(item) {
    return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID;
  });
}
function handleDraggedEntered(e) {
  printDebug(function() {
    return ["dragged entered", e.currentTarget, e.detail];
  });
  var _dzToConfig$get = dzToConfig.get(e.currentTarget), items = _dzToConfig$get.items, dropFromOthersDisabled = _dzToConfig$get.dropFromOthersDisabled;
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(function() {
      return "ignoring dragged entered because drop is currently disabled";
    });
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  items = items.filter(function(item) {
    return item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY];
  });
  printDebug(function() {
    return "dragged entered items ".concat(toString(items));
  });
  if (originDropZone !== e.currentTarget) {
    var originZoneItems = dzToConfig.get(originDropZone).items;
    var newOriginZoneItems = originZoneItems.filter(function(item) {
      return !item[SHADOW_ITEM_MARKER_PROPERTY_NAME];
    });
    dispatchConsiderEvent(originDropZone, newOriginZoneItems, {
      trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  } else {
    var shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
    if (shadowPlaceHolderIdx !== -1) {
      printDebug(function() {
        return "removing placeholder item from origin dz";
      });
      items.splice(shadowPlaceHolderIdx, 1);
    }
  }
  var _e$detail$indexObj = e.detail.indexObj, index2 = _e$detail$indexObj.index, isProximityBased = _e$detail$indexObj.isProximityBased;
  var shadowElIdx = isProximityBased && index2 === e.currentTarget.children.length - 1 ? index2 + 1 : index2;
  shadowElDropZone = e.currentTarget;
  items.splice(shadowElIdx, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_ENTERED,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
function handleDraggedLeft(e) {
  if (!isWorkingOnPreviousDrag)
    return;
  printDebug(function() {
    return ["dragged left", e.currentTarget, e.detail];
  });
  var _dzToConfig$get2 = dzToConfig.get(e.currentTarget), items = _dzToConfig$get2.items, dropFromOthersDisabled = _dzToConfig$get2.dropFromOthersDisabled;
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
    printDebug(function() {
      return "drop is currently disabled";
    });
    return;
  }
  var shadowElIdx = findShadowElementIdx(items);
  var shadowItem = items.splice(shadowElIdx, 1)[0];
  shadowElDropZone = void 0;
  var _e$detail = e.detail, type = _e$detail.type, theOtherDz = _e$detail.theOtherDz;
  if (type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY || type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled) {
    printDebug(function() {
      return "dragged left all, putting shadow element back in the origin dz";
    });
    isDraggedOutsideOfAnyDz = true;
    shadowElDropZone = originDropZone;
    var originZoneItems = dzToConfig.get(originDropZone).items;
    originZoneItems.splice(originIndex, 0, shadowItem);
    dispatchConsiderEvent(originDropZone, originZoneItems, {
      trigger: TRIGGERS.DRAGGED_LEFT_ALL,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  }
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_LEFT,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
function handleDraggedIsOverIndex(e) {
  printDebug(function() {
    return ["dragged is over index", e.currentTarget, e.detail];
  });
  var _dzToConfig$get3 = dzToConfig.get(e.currentTarget), items = _dzToConfig$get3.items, dropFromOthersDisabled = _dzToConfig$get3.dropFromOthersDisabled;
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(function() {
      return "drop is currently disabled";
    });
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  var index2 = e.detail.indexObj.index;
  var shadowElIdx = findShadowElementIdx(items);
  items.splice(shadowElIdx, 1);
  items.splice(index2, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_OVER_INDEX,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
function handleMouseMove(e) {
  e.preventDefault();
  var c2 = e.touches ? e.touches[0] : e;
  currentMousePosition = {
    x: c2.clientX,
    y: c2.clientY
  };
  draggedEl.style.transform = "translate3d(".concat(currentMousePosition.x - dragStartMousePosition.x, "px, ").concat(currentMousePosition.y - dragStartMousePosition.y, "px, 0)");
}
function handleDrop() {
  printDebug(function() {
    return "dropped";
  });
  finalizingPreviousDrag = true;
  window.removeEventListener("mousemove", handleMouseMove);
  window.removeEventListener("touchmove", handleMouseMove);
  window.removeEventListener("mouseup", handleDrop);
  window.removeEventListener("touchend", handleDrop);
  unWatchDraggedElement();
  moveDraggedElementToWasDroppedState(draggedEl);
  if (!shadowElDropZone) {
    printDebug(function() {
      return "element was dropped right after it left origin but before entering somewhere else";
    });
    shadowElDropZone = originDropZone;
  }
  printDebug(function() {
    return ["dropped in dz", shadowElDropZone];
  });
  var _dzToConfig$get4 = dzToConfig.get(shadowElDropZone), items = _dzToConfig$get4.items, type = _dzToConfig$get4.type;
  styleInactiveDropZones(typeToDropZones.get(type), function(dz) {
    return dzToConfig.get(dz).dropTargetStyle;
  }, function(dz) {
    return dzToConfig.get(dz).dropTargetClasses;
  });
  var shadowElIdx = findShadowElementIdx(items);
  if (shadowElIdx === -1)
    shadowElIdx = originIndex;
  items = items.map(function(item) {
    return item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item;
  });
  function finalizeWithinZone() {
    unlockOriginDzMinDimensions();
    dispatchFinalizeEvent(shadowElDropZone, items, {
      trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
    if (shadowElDropZone !== originDropZone) {
      dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {
        trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
        id: draggedElData[ITEM_ID_KEY],
        source: SOURCES.POINTER
      });
    }
    unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
    cleanupPostDrop();
  }
  animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
}
function animateDraggedToFinalPosition(shadowElIdx, callback) {
  var shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
  var newTransform = {
    x: shadowElRect.left - parseFloat(draggedEl.style.left),
    y: shadowElRect.top - parseFloat(draggedEl.style.top)
  };
  var _dzToConfig$get5 = dzToConfig.get(shadowElDropZone), dropAnimationDurationMs = _dzToConfig$get5.dropAnimationDurationMs;
  var transition = "transform ".concat(dropAnimationDurationMs, "ms ease");
  draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
  draggedEl.style.transform = "translate3d(".concat(newTransform.x, "px, ").concat(newTransform.y, "px, 0)");
  window.setTimeout(callback, dropAnimationDurationMs);
}
function scheduleDZForRemovalAfterDrop(dz, destroy2) {
  scheduledForRemovalAfterDrop.push({
    dz,
    destroy: destroy2
  });
  window.requestAnimationFrame(function() {
    hideElement(dz);
    document.body.appendChild(dz);
  });
}
function cleanupPostDrop() {
  draggedEl.remove();
  originalDragTarget.remove();
  if (scheduledForRemovalAfterDrop.length) {
    printDebug(function() {
      return ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop];
    });
    scheduledForRemovalAfterDrop.forEach(function(_ref) {
      var dz = _ref.dz, destroy2 = _ref.destroy;
      destroy2();
      dz.remove();
    });
    scheduledForRemovalAfterDrop = [];
  }
  draggedEl = void 0;
  originalDragTarget = void 0;
  draggedElData = void 0;
  draggedElType = void 0;
  originDropZone = void 0;
  originIndex = void 0;
  shadowElData = void 0;
  shadowElDropZone = void 0;
  dragStartMousePosition = void 0;
  currentMousePosition = void 0;
  isWorkingOnPreviousDrag = false;
  finalizingPreviousDrag = false;
  unlockOriginDzMinDimensions = void 0;
  isDraggedOutsideOfAnyDz = false;
}
function dndzone(node, options) {
  var initialized = false;
  var config = {
    items: void 0,
    type: void 0,
    flipDurationMs: 0,
    dragDisabled: false,
    morphDisabled: false,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses: [],
    transformDraggedElement: function transformDraggedElement() {
    },
    centreDraggedOnCursor: false
  };
  printDebug(function() {
    return ["dndzone good to go options: ".concat(toString(options), ", config: ").concat(toString(config)), {
      node
    }];
  });
  var elToIdx = /* @__PURE__ */ new Map();
  function addMaybeListeners() {
    window.addEventListener("mousemove", handleMouseMoveMaybeDragStart, {
      passive: false
    });
    window.addEventListener("touchmove", handleMouseMoveMaybeDragStart, {
      passive: false,
      capture: false
    });
    window.addEventListener("mouseup", handleFalseAlarm, {
      passive: false
    });
    window.addEventListener("touchend", handleFalseAlarm, {
      passive: false
    });
  }
  function removeMaybeListeners() {
    window.removeEventListener("mousemove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("mouseup", handleFalseAlarm);
    window.removeEventListener("touchend", handleFalseAlarm);
  }
  function handleFalseAlarm() {
    removeMaybeListeners();
    originalDragTarget = void 0;
    dragStartMousePosition = void 0;
    currentMousePosition = void 0;
  }
  function handleMouseMoveMaybeDragStart(e) {
    e.preventDefault();
    var c2 = e.touches ? e.touches[0] : e;
    currentMousePosition = {
      x: c2.clientX,
      y: c2.clientY
    };
    if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
      removeMaybeListeners();
      handleDragStart();
    }
  }
  function handleMouseDown(e) {
    if (e.target !== e.currentTarget && (e.target.value !== void 0 || e.target.isContentEditable)) {
      printDebug(function() {
        return "won't initiate drag on a nested input element";
      });
      return;
    }
    if (e.button) {
      printDebug(function() {
        return "ignoring none left click button: ".concat(e.button);
      });
      return;
    }
    if (isWorkingOnPreviousDrag) {
      printDebug(function() {
        return "cannot start a new drag before finalizing previous one";
      });
      return;
    }
    e.stopPropagation();
    var c2 = e.touches ? e.touches[0] : e;
    dragStartMousePosition = {
      x: c2.clientX,
      y: c2.clientY
    };
    currentMousePosition = _objectSpread22({}, dragStartMousePosition);
    originalDragTarget = e.currentTarget;
    addMaybeListeners();
  }
  function handleDragStart() {
    printDebug(function() {
      return ["drag start config: ".concat(toString(config)), originalDragTarget];
    });
    isWorkingOnPreviousDrag = true;
    var currentIdx = elToIdx.get(originalDragTarget);
    originIndex = currentIdx;
    originDropZone = originalDragTarget.parentElement;
    var rootNode = originDropZone.getRootNode();
    var originDropZoneRoot = rootNode.body || rootNode;
    var items = config.items, type = config.type, centreDraggedOnCursor = config.centreDraggedOnCursor;
    draggedElData = _objectSpread22({}, items[currentIdx]);
    draggedElType = type;
    shadowElData = _objectSpread22(_objectSpread22({}, draggedElData), {}, _defineProperty3({}, SHADOW_ITEM_MARKER_PROPERTY_NAME, true));
    var placeHolderElData = _objectSpread22(_objectSpread22({}, shadowElData), {}, _defineProperty3({}, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID));
    draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
    function keepOriginalElementInDom() {
      if (!draggedEl.parentElement) {
        originDropZoneRoot.appendChild(draggedEl);
        draggedEl.focus();
        watchDraggedElement();
        hideElement(originalDragTarget);
        originDropZoneRoot.appendChild(originalDragTarget);
      } else {
        window.requestAnimationFrame(keepOriginalElementInDom);
      }
    }
    window.requestAnimationFrame(keepOriginalElementInDom);
    styleActiveDropZones(Array.from(typeToDropZones.get(config.type)).filter(function(dz) {
      return dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled;
    }), function(dz) {
      return dzToConfig.get(dz).dropTargetStyle;
    }, function(dz) {
      return dzToConfig.get(dz).dropTargetClasses;
    });
    items.splice(currentIdx, 1, placeHolderElData);
    unlockOriginDzMinDimensions = preventShrinking(originDropZone);
    dispatchConsiderEvent(originDropZone, items, {
      trigger: TRIGGERS.DRAG_STARTED,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
    window.addEventListener("mousemove", handleMouseMove, {
      passive: false
    });
    window.addEventListener("touchmove", handleMouseMove, {
      passive: false,
      capture: false
    });
    window.addEventListener("mouseup", handleDrop, {
      passive: false
    });
    window.addEventListener("touchend", handleDrop, {
      passive: false
    });
  }
  function configure(_ref2) {
    var _ref2$items = _ref2.items, items = _ref2$items === void 0 ? void 0 : _ref2$items, _ref2$flipDurationMs = _ref2.flipDurationMs, dropAnimationDurationMs = _ref2$flipDurationMs === void 0 ? 0 : _ref2$flipDurationMs, _ref2$type = _ref2.type, newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE : _ref2$type, _ref2$dragDisabled = _ref2.dragDisabled, dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled, _ref2$morphDisabled = _ref2.morphDisabled, morphDisabled = _ref2$morphDisabled === void 0 ? false : _ref2$morphDisabled, _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled, dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD, _ref2$dropTargetStyle = _ref2.dropTargetStyle, dropTargetStyle = _ref2$dropTargetStyle === void 0 ? DEFAULT_DROP_TARGET_STYLE : _ref2$dropTargetStyle, _ref2$dropTargetClass = _ref2.dropTargetClasses, dropTargetClasses = _ref2$dropTargetClass === void 0 ? [] : _ref2$dropTargetClass, _ref2$transformDragge = _ref2.transformDraggedElement, transformDraggedElement = _ref2$transformDragge === void 0 ? function() {
    } : _ref2$transformDragge, _ref2$centreDraggedOn = _ref2.centreDraggedOnCursor, centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn;
    config.dropAnimationDurationMs = dropAnimationDurationMs;
    if (config.type && newType !== config.type) {
      unregisterDropZone(node, config.type);
    }
    config.type = newType;
    registerDropZone(node, newType);
    config.items = _toConsumableArray(items);
    config.dragDisabled = dragDisabled;
    config.morphDisabled = morphDisabled;
    config.transformDraggedElement = transformDraggedElement;
    config.centreDraggedOnCursor = centreDraggedOnCursor;
    if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
      styleInactiveDropZones([node], function() {
        return config.dropTargetStyle;
      }, function() {
        return dropTargetClasses;
      });
      styleActiveDropZones([node], function() {
        return dropTargetStyle;
      }, function() {
        return dropTargetClasses;
      });
    }
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = _toConsumableArray(dropTargetClasses);
    function getConfigProp(dz, propName) {
      return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];
    }
    if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {
      if (dropFromOthersDisabled) {
        styleInactiveDropZones([node], function(dz) {
          return getConfigProp(dz, "dropTargetStyle");
        }, function(dz) {
          return getConfigProp(dz, "dropTargetClasses");
        });
      } else {
        styleActiveDropZones([node], function(dz) {
          return getConfigProp(dz, "dropTargetStyle");
        }, function(dz) {
          return getConfigProp(dz, "dropTargetClasses");
        });
      }
    }
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    dzToConfig.set(node, config);
    var shadowElIdx = findShadowElementIdx(config.items);
    for (var idx = 0; idx < node.children.length; idx++) {
      var draggableEl = node.children[idx];
      styleDraggable(draggableEl, dragDisabled);
      if (idx === shadowElIdx) {
        config.transformDraggedElement(draggedEl, draggedElData, idx);
        if (!morphDisabled) {
          morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
        }
        decorateShadowEl(draggableEl);
        continue;
      }
      draggableEl.removeEventListener("mousedown", elToMouseDownListener.get(draggableEl));
      draggableEl.removeEventListener("touchstart", elToMouseDownListener.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("mousedown", handleMouseDown);
        draggableEl.addEventListener("touchstart", handleMouseDown);
        elToMouseDownListener.set(draggableEl, handleMouseDown);
      }
      elToIdx.set(draggableEl, idx);
      if (!initialized) {
        initialized = true;
      }
    }
  }
  configure(options);
  return {
    update: function update2(newOptions) {
      printDebug(function() {
        return "pointer dndzone will update newOptions: ".concat(toString(newOptions));
      });
      configure(newOptions);
    },
    destroy: function destroy2() {
      function destroyDz() {
        printDebug(function() {
          return "pointer dndzone will destroy";
        });
        unregisterDropZone(node, dzToConfig.get(node).type);
        dzToConfig["delete"](node);
      }
      if (isWorkingOnPreviousDrag) {
        printDebug(function() {
          return "pointer dndzone will be scheduled for destruction";
        });
        scheduleDZForRemovalAfterDrop(node, destroyDz);
      } else {
        destroyDz();
      }
    }
  };
}
var _ID_TO_INSTRUCTION;
var INSTRUCTION_IDs = {
  DND_ZONE_ACTIVE: "dnd-zone-active",
  DND_ZONE_DRAG_DISABLED: "dnd-zone-drag-disabled"
};
var ID_TO_INSTRUCTION = (_ID_TO_INSTRUCTION = {}, _defineProperty3(_ID_TO_INSTRUCTION, INSTRUCTION_IDs.DND_ZONE_ACTIVE, "Tab to one the items and press space-bar or enter to start dragging it"), _defineProperty3(_ID_TO_INSTRUCTION, INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED, "This is a disabled drag and drop list"), _ID_TO_INSTRUCTION);
var ALERT_DIV_ID = "dnd-action-aria-alert";
var alertsDiv;
function initAriaOnBrowser() {
  if (alertsDiv) {
    return;
  }
  alertsDiv = document.createElement("div");
  (function initAlertsDiv() {
    alertsDiv.id = ALERT_DIV_ID;
    alertsDiv.style.position = "fixed";
    alertsDiv.style.bottom = "0";
    alertsDiv.style.left = "0";
    alertsDiv.style.zIndex = "-5";
    alertsDiv.style.opacity = "0";
    alertsDiv.style.height = "0";
    alertsDiv.style.width = "0";
    alertsDiv.setAttribute("role", "alert");
  })();
  document.body.prepend(alertsDiv);
  Object.entries(ID_TO_INSTRUCTION).forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], txt = _ref2[1];
    return document.body.prepend(instructionToHiddenDiv(id, txt));
  });
}
function initAria() {
  if (isOnServer)
    return null;
  if (document.readyState === "complete") {
    initAriaOnBrowser();
  } else {
    window.addEventListener("DOMContentLoaded", initAriaOnBrowser);
  }
  return _objectSpread22({}, INSTRUCTION_IDs);
}
function destroyAria() {
  if (isOnServer || !alertsDiv)
    return;
  Object.keys(ID_TO_INSTRUCTION).forEach(function(id) {
    var _document$getElementB;
    return (_document$getElementB = document.getElementById(id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
  });
  alertsDiv.remove();
  alertsDiv = void 0;
}
function instructionToHiddenDiv(id, txt) {
  var div = document.createElement("div");
  div.id = id;
  div.innerHTML = "<p>".concat(txt, "</p>");
  div.style.display = "none";
  div.style.position = "fixed";
  div.style.zIndex = "-5";
  return div;
}
function alertToScreenReader(txt) {
  if (isOnServer)
    return;
  if (!alertsDiv) {
    initAriaOnBrowser();
  }
  alertsDiv.innerHTML = "";
  var alertText = document.createTextNode(txt);
  alertsDiv.appendChild(alertText);
  alertsDiv.style.display = "none";
  alertsDiv.style.display = "inline";
}
var DEFAULT_DROP_ZONE_TYPE$1 = "--any--";
var DEFAULT_DROP_TARGET_STYLE$1 = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var isDragging = false;
var draggedItemType;
var focusedDz;
var focusedDzLabel = "";
var focusedItem;
var focusedItemId;
var focusedItemLabel = "";
var allDragTargets = /* @__PURE__ */ new WeakSet();
var elToKeyDownListeners = /* @__PURE__ */ new WeakMap();
var elToFocusListeners = /* @__PURE__ */ new WeakMap();
var dzToHandles = /* @__PURE__ */ new Map();
var dzToConfig$1 = /* @__PURE__ */ new Map();
var typeToDropZones$1 = /* @__PURE__ */ new Map();
var INSTRUCTION_IDs$1;
function registerDropZone$1(dropZoneEl, type) {
  printDebug(function() {
    return "registering drop-zone if absent";
  });
  if (typeToDropZones$1.size === 0) {
    printDebug(function() {
      return "adding global keydown and click handlers";
    });
    INSTRUCTION_IDs$1 = initAria();
    window.addEventListener("keydown", globalKeyDownHandler);
    window.addEventListener("click", globalClickHandler);
  }
  if (!typeToDropZones$1.has(type)) {
    typeToDropZones$1.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones$1.get(type).has(dropZoneEl)) {
    typeToDropZones$1.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone$1(dropZoneEl, type) {
  printDebug(function() {
    return "unregistering drop-zone";
  });
  if (focusedDz === dropZoneEl) {
    handleDrop$1();
  }
  typeToDropZones$1.get(type)["delete"](dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones$1.get(type).size === 0) {
    typeToDropZones$1["delete"](type);
  }
  if (typeToDropZones$1.size === 0) {
    printDebug(function() {
      return "removing global keydown and click handlers";
    });
    window.removeEventListener("keydown", globalKeyDownHandler);
    window.removeEventListener("click", globalClickHandler);
    INSTRUCTION_IDs$1 = void 0;
    destroyAria();
  }
}
function globalKeyDownHandler(e) {
  if (!isDragging)
    return;
  switch (e.key) {
    case "Escape": {
      handleDrop$1();
      break;
    }
  }
}
function globalClickHandler() {
  if (!isDragging)
    return;
  if (!allDragTargets.has(document.activeElement)) {
    printDebug(function() {
      return "clicked outside of any draggable";
    });
    handleDrop$1();
  }
}
function handleZoneFocus(e) {
  printDebug(function() {
    return "zone focus";
  });
  if (!isDragging)
    return;
  var newlyFocusedDz = e.currentTarget;
  if (newlyFocusedDz === focusedDz)
    return;
  focusedDzLabel = newlyFocusedDz.getAttribute("aria-label") || "";
  var _dzToConfig$get = dzToConfig$1.get(focusedDz), originItems = _dzToConfig$get.items;
  var originItem = originItems.find(function(item) {
    return item[ITEM_ID_KEY] === focusedItemId;
  });
  var originIdx = originItems.indexOf(originItem);
  var itemToMove = originItems.splice(originIdx, 1)[0];
  var _dzToConfig$get2 = dzToConfig$1.get(newlyFocusedDz), targetItems = _dzToConfig$get2.items, autoAriaDisabled = _dzToConfig$get2.autoAriaDisabled;
  if (newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top || newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left) {
    targetItems.push(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader("Moved item ".concat(focusedItemLabel, " to the end of the list ").concat(focusedDzLabel));
    }
  } else {
    targetItems.unshift(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader("Moved item ".concat(focusedItemLabel, " to the beginning of the list ").concat(focusedDzLabel));
    }
  }
  var dzFrom = focusedDz;
  dispatchFinalizeEvent(dzFrom, originItems, {
    trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
    id: focusedItemId,
    source: SOURCES.KEYBOARD
  });
  dispatchFinalizeEvent(newlyFocusedDz, targetItems, {
    trigger: TRIGGERS.DROPPED_INTO_ZONE,
    id: focusedItemId,
    source: SOURCES.KEYBOARD
  });
  focusedDz = newlyFocusedDz;
}
function triggerAllDzsUpdate() {
  dzToHandles.forEach(function(_ref, dz) {
    var update2 = _ref.update;
    return update2(dzToConfig$1.get(dz));
  });
}
function handleDrop$1() {
  var dispatchConsider = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  printDebug(function() {
    return "drop";
  });
  if (!dzToConfig$1.get(focusedDz).autoAriaDisabled) {
    alertToScreenReader("Stopped dragging item ".concat(focusedItemLabel));
  }
  if (allDragTargets.has(document.activeElement)) {
    document.activeElement.blur();
  }
  if (dispatchConsider) {
    dispatchConsiderEvent(focusedDz, dzToConfig$1.get(focusedDz).items, {
      trigger: TRIGGERS.DRAG_STOPPED,
      id: focusedItemId,
      source: SOURCES.KEYBOARD
    });
  }
  styleInactiveDropZones(typeToDropZones$1.get(draggedItemType), function(dz) {
    return dzToConfig$1.get(dz).dropTargetStyle;
  }, function(dz) {
    return dzToConfig$1.get(dz).dropTargetClasses;
  });
  focusedItem = null;
  focusedItemId = null;
  focusedItemLabel = "";
  draggedItemType = null;
  focusedDz = null;
  focusedDzLabel = "";
  isDragging = false;
  triggerAllDzsUpdate();
}
function dndzone$1(node, options) {
  var config = {
    items: void 0,
    type: void 0,
    dragDisabled: false,
    zoneTabIndex: 0,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,
    dropTargetClasses: [],
    autoAriaDisabled: false
  };
  function swap4(arr, i2, j2) {
    if (arr.length <= 1)
      return;
    arr.splice(j2, 1, arr.splice(i2, 1, arr[j2])[0]);
  }
  function handleKeyDown(e) {
    printDebug(function() {
      return ["handling key down", e.key];
    });
    switch (e.key) {
      case "Enter":
      case " ": {
        if ((e.target.disabled !== void 0 || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (isDragging) {
          handleDrop$1();
        } else {
          handleDragStart(e);
        }
        break;
      }
      case "ArrowDown":
      case "ArrowRight": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        var _dzToConfig$get3 = dzToConfig$1.get(node), items = _dzToConfig$get3.items;
        var children2 = Array.from(node.children);
        var idx = children2.indexOf(e.currentTarget);
        printDebug(function() {
          return ["arrow down", idx];
        });
        if (idx < children2.length - 1) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader("Moved item ".concat(focusedItemLabel, " to position ").concat(idx + 2, " in the list ").concat(focusedDzLabel));
          }
          swap4(items, idx, idx + 1);
          dispatchFinalizeEvent(node, items, {
            trigger: TRIGGERS.DROPPED_INTO_ZONE,
            id: focusedItemId,
            source: SOURCES.KEYBOARD
          });
        }
        break;
      }
      case "ArrowUp":
      case "ArrowLeft": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        var _dzToConfig$get4 = dzToConfig$1.get(node), _items = _dzToConfig$get4.items;
        var _children = Array.from(node.children);
        var _idx = _children.indexOf(e.currentTarget);
        printDebug(function() {
          return ["arrow up", _idx];
        });
        if (_idx > 0) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader("Moved item ".concat(focusedItemLabel, " to position ").concat(_idx, " in the list ").concat(focusedDzLabel));
          }
          swap4(_items, _idx, _idx - 1);
          dispatchFinalizeEvent(node, _items, {
            trigger: TRIGGERS.DROPPED_INTO_ZONE,
            id: focusedItemId,
            source: SOURCES.KEYBOARD
          });
        }
        break;
      }
    }
  }
  function handleDragStart(e) {
    printDebug(function() {
      return "drag start";
    });
    setCurrentFocusedItem(e.currentTarget);
    focusedDz = node;
    draggedItemType = config.type;
    isDragging = true;
    var dropTargets = Array.from(typeToDropZones$1.get(config.type)).filter(function(dz) {
      return dz === focusedDz || !dzToConfig$1.get(dz).dropFromOthersDisabled;
    });
    styleActiveDropZones(dropTargets, function(dz) {
      return dzToConfig$1.get(dz).dropTargetStyle;
    }, function(dz) {
      return dzToConfig$1.get(dz).dropTargetClasses;
    });
    if (!config.autoAriaDisabled) {
      var msg = "Started dragging item ".concat(focusedItemLabel, ". Use the arrow keys to move it within its list ").concat(focusedDzLabel);
      if (dropTargets.length > 1) {
        msg += ", or tab to another list in order to move the item into it";
      }
      alertToScreenReader(msg);
    }
    dispatchConsiderEvent(node, dzToConfig$1.get(node).items, {
      trigger: TRIGGERS.DRAG_STARTED,
      id: focusedItemId,
      source: SOURCES.KEYBOARD
    });
    triggerAllDzsUpdate();
  }
  function handleClick(e) {
    if (!isDragging)
      return;
    if (e.currentTarget === focusedItem)
      return;
    e.stopPropagation();
    handleDrop$1(false);
    handleDragStart(e);
  }
  function setCurrentFocusedItem(draggableEl) {
    var _dzToConfig$get5 = dzToConfig$1.get(node), items = _dzToConfig$get5.items;
    var children2 = Array.from(node.children);
    var focusedItemIdx = children2.indexOf(draggableEl);
    focusedItem = draggableEl;
    focusedItem.tabIndex = 0;
    focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
    focusedItemLabel = children2[focusedItemIdx].getAttribute("aria-label") || "";
  }
  function configure(_ref2) {
    var _ref2$items = _ref2.items, items = _ref2$items === void 0 ? [] : _ref2$items, _ref2$type = _ref2.type, newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE$1 : _ref2$type, _ref2$dragDisabled = _ref2.dragDisabled, dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled, _ref2$zoneTabIndex = _ref2.zoneTabIndex, zoneTabIndex = _ref2$zoneTabIndex === void 0 ? 0 : _ref2$zoneTabIndex, _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled, dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD, _ref2$dropTargetStyle = _ref2.dropTargetStyle, dropTargetStyle = _ref2$dropTargetStyle === void 0 ? DEFAULT_DROP_TARGET_STYLE$1 : _ref2$dropTargetStyle, _ref2$dropTargetClass = _ref2.dropTargetClasses, dropTargetClasses = _ref2$dropTargetClass === void 0 ? [] : _ref2$dropTargetClass, _ref2$autoAriaDisable = _ref2.autoAriaDisabled, autoAriaDisabled = _ref2$autoAriaDisable === void 0 ? false : _ref2$autoAriaDisable;
    config.items = _toConsumableArray(items);
    config.dragDisabled = dragDisabled;
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    config.zoneTabIndex = zoneTabIndex;
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = dropTargetClasses;
    config.autoAriaDisabled = autoAriaDisabled;
    if (config.type && newType !== config.type) {
      unregisterDropZone$1(node, config.type);
    }
    config.type = newType;
    registerDropZone$1(node, newType);
    if (!autoAriaDisabled) {
      node.setAttribute("aria-disabled", dragDisabled);
      node.setAttribute("role", "list");
      node.setAttribute("aria-describedby", dragDisabled ? INSTRUCTION_IDs$1.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs$1.DND_ZONE_ACTIVE);
    }
    dzToConfig$1.set(node, config);
    if (isDragging) {
      node.tabIndex = node === focusedDz || focusedItem.contains(node) || config.dropFromOthersDisabled || focusedDz && config.type !== dzToConfig$1.get(focusedDz).type ? -1 : 0;
    } else {
      node.tabIndex = config.zoneTabIndex;
    }
    node.addEventListener("focus", handleZoneFocus);
    var _loop = function _loop2(i3) {
      var draggableEl = node.children[i3];
      allDragTargets.add(draggableEl);
      draggableEl.tabIndex = isDragging ? -1 : 0;
      if (!autoAriaDisabled) {
        draggableEl.setAttribute("role", "listitem");
      }
      draggableEl.removeEventListener("keydown", elToKeyDownListeners.get(draggableEl));
      draggableEl.removeEventListener("click", elToFocusListeners.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("keydown", handleKeyDown);
        elToKeyDownListeners.set(draggableEl, handleKeyDown);
        draggableEl.addEventListener("click", handleClick);
        elToFocusListeners.set(draggableEl, handleClick);
      }
      if (isDragging && config.items[i3][ITEM_ID_KEY] === focusedItemId) {
        printDebug(function() {
          return ["focusing on", {
            i: i3,
            focusedItemId
          }];
        });
        focusedItem = draggableEl;
        focusedItem.tabIndex = 0;
        draggableEl.focus();
      }
    };
    for (var i2 = 0; i2 < node.children.length; i2++) {
      _loop(i2);
    }
  }
  configure(options);
  var handles = {
    update: function update2(newOptions) {
      printDebug(function() {
        return "keyboard dndzone will update newOptions: ".concat(toString(newOptions));
      });
      configure(newOptions);
    },
    destroy: function destroy2() {
      printDebug(function() {
        return "keyboard dndzone will destroy";
      });
      unregisterDropZone$1(node, config.type);
      dzToConfig$1["delete"](node);
      dzToHandles["delete"](node);
    }
  };
  dzToHandles.set(node, handles);
  return handles;
}
var _excluded2 = ["items", "flipDurationMs", "type", "dragDisabled", "morphDisabled", "dropFromOthersDisabled", "zoneTabIndex", "dropTargetStyle", "dropTargetClasses", "transformDraggedElement", "autoAriaDisabled", "centreDraggedOnCursor"];
function dndzone$2(node, options) {
  validateOptions(options);
  var pointerZone = dndzone(node, options);
  var keyboardZone = dndzone$1(node, options);
  return {
    update: function update2(newOptions) {
      validateOptions(newOptions);
      pointerZone.update(newOptions);
      keyboardZone.update(newOptions);
    },
    destroy: function destroy2() {
      pointerZone.destroy();
      keyboardZone.destroy();
    }
  };
}
function validateOptions(options) {
  var items = options.items, flipDurationMs5 = options.flipDurationMs, type = options.type, dragDisabled = options.dragDisabled, morphDisabled = options.morphDisabled, dropFromOthersDisabled = options.dropFromOthersDisabled, zoneTabIndex = options.zoneTabIndex, dropTargetStyle = options.dropTargetStyle, dropTargetClasses = options.dropTargetClasses, transformDraggedElement = options.transformDraggedElement, autoAriaDisabled = options.autoAriaDisabled, centreDraggedOnCursor = options.centreDraggedOnCursor, rest = _objectWithoutProperties2(options, _excluded2);
  if (Object.keys(rest).length > 0) {
    console.warn("dndzone will ignore unknown options", rest);
  }
  if (!items) {
    throw new Error("no 'items' key provided to dndzone");
  }
  var itemWithMissingId = items.find(function(item) {
    return !{}.hasOwnProperty.call(item, ITEM_ID_KEY);
  });
  if (itemWithMissingId) {
    throw new Error("missing '".concat(ITEM_ID_KEY, "' property for item ").concat(toString(itemWithMissingId)));
  }
  if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {
    throw new Error("dropTargetClasses should be an array but instead it is a ".concat(_typeof3(dropTargetClasses), ", ").concat(toString(dropTargetClasses)));
  }
  if (zoneTabIndex && !isInt(zoneTabIndex)) {
    throw new Error("zoneTabIndex should be a number but instead it is a ".concat(_typeof3(zoneTabIndex), ", ").concat(toString(zoneTabIndex)));
  }
}
function isInt(value) {
  return !isNaN(value) && function(x2) {
    return (x2 | 0) === x2;
  }(parseFloat(value));
}

// node_modules/svelte/animate/index.mjs
function flip3(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay: delay2 = 0, duration = (d2) => Math.sqrt(d2) * 120, easing = cubicOut } = params;
  return {
    delay: delay2,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t3, u2) => {
      const x2 = u2 * dx;
      const y2 = u2 * dy;
      const sx = t3 + u2 * from.width / to.width;
      const sy = t3 + u2 * from.height / to.height;
      return `transform: ${transform} translate(${x2}px, ${y2}px) scale(${sx}, ${sy});`;
    }
  };
}

// src/components/CardMetadata/Checkbox.svelte
function create_if_block20(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: (
        /*value*/
        ctx[0]
      ),
      disabled: true
    }
  });
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & /*value*/
      1)
        switch_1_changes.checked = /*value*/
        ctx2[0];
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment63(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*field*/
    ctx[1].type === "boolean" /* Boolean */ && !/*field*/
    ctx[1].repeated && typeof /*value*/
    ctx[0] === "boolean" && create_if_block20(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*field*/
        ctx2[1].type === "boolean" /* Boolean */ && !/*field*/
        ctx2[1].repeated && typeof /*value*/
        ctx2[0] === "boolean"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*field, value*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance63($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { field } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
  };
  return [value, field];
}
var Checkbox2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance63, create_fragment63, safe_not_equal, { value: 0, field: 1 });
  }
};
var Checkbox_default2 = Checkbox2;

// src/components/CardMetadata/Tags.svelte
function create_if_block21(ctx) {
  let taglist;
  let current;
  taglist = new TagList_default({
    props: { values: (
      /*value*/
      ctx[0] || []
    ) }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taglist_changes = {};
      if (dirty & /*value*/
      1)
        taglist_changes.values = /*value*/
        ctx2[0] || [];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_fragment64(ctx) {
  let show_if = (
    /*field*/
    ctx[1].type === "string" /* String */ && /*field*/
    ctx[1].repeated && Array.isArray(
      /*value*/
      ctx[0]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block21(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*field, value*/
      3)
        show_if = /*field*/
        ctx2[1].type === "string" /* String */ && /*field*/
        ctx2[1].repeated && Array.isArray(
          /*value*/
          ctx2[0]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*field, value*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance64($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { field } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
  };
  return [value, field];
}
var Tags = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance64, create_fragment64, safe_not_equal, { value: 0, field: 1 });
  }
};
var Tags_default = Tags;

// src/components/CardMetadata/Text.svelte
var import_obsidian36 = require("obsidian");
function add_css35(target) {
  append_styles(target, "svelte-1myw14o", "div.svelte-1myw14o{overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:4;line-clamp:4;-webkit-box-orient:vertical}div.svelte-1myw14o p:first-child{margin-top:0}div.svelte-1myw14o p:last-child{margin-bottom:0}");
}
function create_if_block_111(ctx) {
  let div;
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(
        /*value*/
        ctx[0]
      );
      attr(div, "class", "svelte-1myw14o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data(
          t3,
          /*value*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block22(ctx) {
  let div;
  let useMarkdown_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "svelte-1myw14o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useMarkdown_action = /*useMarkdown*/
          ctx[2].call(null, div)),
          listen(
            div,
            "click",
            /*handleClick*/
            ctx[3]
          ),
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment65(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    var _a;
    if (
      /*field*/
      (_a = ctx2[1].typeConfig) == null ? void 0 : _a.richText
    )
      return create_if_block22;
    if (typeof /*value*/
    ctx2[0] === "string")
      return create_if_block_111;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance65($$self, $$props, $$invalidate) {
  let $app;
  let $view;
  component_subscribe($$self, app2, ($$value) => $$invalidate(6, $app = $$value));
  component_subscribe($$self, view, ($$value) => $$invalidate(7, $view = $$value));
  let { value } = $$props;
  let { field } = $$props;
  let { sourcePath = "" } = $$props;
  function useMarkdown(node) {
    if (typeof value === "string") {
      import_obsidian36.MarkdownRenderer.renderMarkdown(value, node, sourcePath, $view);
    }
  }
  function handleClick(event) {
    const targetEl = event.target;
    const closestAnchor = targetEl.tagName === "A" ? targetEl : targetEl.closest("a");
    if (!closestAnchor) {
      return;
    }
    event.stopPropagation();
    if (closestAnchor.hasClass("internal-link")) {
      event.preventDefault();
      const href = closestAnchor.getAttr("href");
      const newLeaf = event.button === 1 || event.ctrlKey || event.metaKey;
      if (href) {
        $app.workspace.openLinkText(href, sourcePath, newLeaf);
      }
    }
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("sourcePath" in $$props2)
      $$invalidate(4, sourcePath = $$props2.sourcePath);
  };
  return [value, field, useMarkdown, handleClick, sourcePath, keypress_handler];
}
var Text = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance65, create_fragment65, safe_not_equal, { value: 0, field: 1, sourcePath: 4 }, add_css35);
  }
};
var Text_default = Text;

// src/components/CardMetadata/Date.svelte
function create_if_block23(ctx) {
  let t_value = Intl.DateTimeFormat().format(
    /*value*/
    ctx[0]
  ) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1 && t_value !== (t_value = Intl.DateTimeFormat().format(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment66(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[1].type === "date" /* Date */ && !/*field*/
    ctx[1].repeated && /*value*/
    ctx[0] instanceof Date && create_if_block23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*field*/
        ctx2[1].type === "date" /* Date */ && !/*field*/
        ctx2[1].repeated && /*value*/
        ctx2[0] instanceof Date
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance66($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { field } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
  };
  return [value, field];
}
var Date_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance66, create_fragment66, safe_not_equal, { value: 0, field: 1 });
  }
};
var Date_default = Date_1;

// src/components/CardMetadata/Number.svelte
function create_if_block24(ctx) {
  let t_value = Intl.NumberFormat().format(
    /*value*/
    ctx[0]
  ) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1 && t_value !== (t_value = Intl.NumberFormat().format(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment67(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[1].type === "number" /* Number */ && !/*field*/
    ctx[1].repeated && typeof /*value*/
    ctx[0] === "number" && create_if_block24(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*field*/
        ctx2[1].type === "number" /* Number */ && !/*field*/
        ctx2[1].repeated && typeof /*value*/
        ctx2[0] === "number"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance67($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { field } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
  };
  return [value, field];
}
var Number2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance67, create_fragment67, safe_not_equal, { value: 0, field: 1 });
  }
};
var Number_default = Number2;

// src/components/CardMetadata/CardMetadata.svelte
function add_css36(target) {
  append_styles(target, "svelte-zmcwo8", ".field-label.svelte-zmcwo8{margin-bottom:8px}.field-label.svelte-zmcwo8:last-child{margin-bottom:0}");
}
function get_each_context12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  const constants_0 = (
    /*record*/
    child_ctx[1].values[
      /*field*/
      child_ctx[2].name
    ]
  );
  child_ctx[3] = constants_0;
  return child_ctx;
}
function create_if_block25(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*field*/
    ctx[2].name + ""
  );
  let t0;
  let t1;
  let current_block_type_index;
  let if_block;
  let t22;
  let current;
  const if_block_creators = [
    create_if_block_112,
    create_if_block_34,
    create_if_block_43,
    create_if_block_52,
    create_if_block_6,
    create_else_block7
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*field*/
      ctx2[2].repeated
    )
      return 0;
    if (
      /*field*/
      ctx2[2].type === "boolean" /* Boolean */
    )
      return 1;
    if (
      /*field*/
      ctx2[2].type === "string" /* String */
    )
      return 2;
    if (
      /*field*/
      ctx2[2].type === "number" /* Number */
    )
      return 3;
    if (
      /*field*/
      ctx2[2].type === "date" /* Date */
    )
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      t22 = space();
      attr(div0, "class", "setting-item-description");
      set_style(div0, "margin-bottom", "4px");
      attr(div1, "class", "field-label svelte-zmcwo8");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append4(div1, div0);
      append4(div0, t0);
      append4(div1, t1);
      if_blocks[current_block_type_index].m(div1, null);
      append4(div1, t22);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*fields*/
      1) && t0_value !== (t0_value = /*field*/
      ctx2[2].name + ""))
        set_data(t0, t0_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t22);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block7(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "slash" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let date;
  let current;
  date = new Date_default({
    props: {
      value: (
        /*value*/
        ctx[3]
      ),
      field: (
        /*field*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(date.$$.fragment);
    },
    m(target, anchor) {
      mount_component(date, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const date_changes = {};
      if (dirty & /*record, fields*/
      3)
        date_changes.value = /*value*/
        ctx2[3];
      if (dirty & /*fields*/
      1)
        date_changes.field = /*field*/
        ctx2[2];
      date.$set(date_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(date.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(date.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(date, detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let number;
  let current;
  number = new Number_default({
    props: {
      field: (
        /*field*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(number.$$.fragment);
    },
    m(target, anchor) {
      mount_component(number, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const number_changes = {};
      if (dirty & /*fields*/
      1)
        number_changes.field = /*field*/
        ctx2[2];
      if (dirty & /*record, fields*/
      3)
        number_changes.value = /*value*/
        ctx2[3];
      number.$set(number_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(number.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(number.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(number, detaching);
    }
  };
}
function create_if_block_43(ctx) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      field: (
        /*field*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(text_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const text_1_changes = {};
      if (dirty & /*fields*/
      1)
        text_1_changes.field = /*field*/
        ctx2[2];
      if (dirty & /*record, fields*/
      3)
        text_1_changes.value = /*value*/
        ctx2[3];
      text_1.$set(text_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(text_1, detaching);
    }
  };
}
function create_if_block_34(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox_default2({
    props: {
      field: (
        /*field*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*fields*/
      1)
        checkbox_changes.field = /*field*/
        ctx2[2];
      if (dirty & /*record, fields*/
      3)
        checkbox_changes.value = /*value*/
        ctx2[3];
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_if_block_112(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*field*/
    ctx[2].type === "string" /* String */ && create_if_block_27(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*field*/
        ctx2[2].type === "string" /* String */
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*fields*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_27(ctx) {
  let tags;
  let current;
  tags = new Tags_default({
    props: {
      field: (
        /*field*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(tags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tags_changes = {};
      if (dirty & /*fields*/
      1)
        tags_changes.field = /*field*/
        ctx2[2];
      if (dirty & /*record, fields*/
      3)
        tags_changes.value = /*value*/
        ctx2[3];
      tags.$set(tags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tags, detaching);
    }
  };
}
function create_each_block12(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*value*/
    ctx[3] !== void 0 && /*value*/
    ctx[3] !== null && create_if_block25(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*value*/
        ctx[3] !== void 0 && /*value*/
        ctx[3] !== null
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*record, fields*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block25(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment68(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = (
    /*fields*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*field*/
    ctx2[2].name
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context12(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block12(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*fields, record, DataFieldType, undefined*/
      3) {
        each_value = /*fields*/
        ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block12, each_1_anchor, get_each_context12);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance68($$self, $$props, $$invalidate) {
  let { fields } = $$props;
  let { record } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(0, fields = $$props2.fields);
    if ("record" in $$props2)
      $$invalidate(1, record = $$props2.record);
  };
  return [fields, record];
}
var CardMetadata = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance68, create_fragment68, safe_not_equal, { fields: 0, record: 1 }, add_css36);
  }
};
var CardMetadata_default = CardMetadata;

// src/components/ColorItem/ColorItem.svelte
function add_css37(target) {
  append_styles(target, "svelte-7vepl5", ".color-item.svelte-7vepl5{display:flex}.card-layout.svelte-7vepl5{overflow:hidden;flex:1}.card-header.svelte-7vepl5{font-size:16px;margin-bottom:8px}.card-header.svelte-7vepl5:last-child{margin-bottom:0}");
}
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_if_block26(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "margin-right", "8px");
      set_style(
        span,
        "background-color",
        /*color*/
        ctx[0]
      );
      set_style(span, "min-width", "5px");
      set_style(span, "border-radius", "9999px");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*color*/
      1) {
        set_style(
          span,
          "background-color",
          /*color*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment69(ctx) {
  let div2;
  let t0;
  let div1;
  let div0;
  let t1;
  let current;
  let if_block = (
    /*color*/
    ctx[0] && create_if_block26(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[2].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_header_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (header_slot)
        header_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "card-header svelte-7vepl5");
      attr(div1, "class", "card-layout svelte-7vepl5");
      attr(div2, "class", "color-item svelte-7vepl5");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append4(div2, t0);
      append4(div2, div1);
      append4(div1, div0);
      if (header_slot) {
        header_slot.m(div0, null);
      }
      append4(div1, t1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*color*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          if_block.m(div2, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      if (header_slot)
        header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance69($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { color } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [color, $$scope, slots];
}
var ColorItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance69, create_fragment69, safe_not_equal, { color: 0 }, add_css37);
  }
};
var ColorItem_default = ColorItem;

// src/views/Board/components/Board/CardGroup.svelte
function add_css38(target) {
  append_styles(target, "svelte-15c4oy3", ".lst.svelte-15c4oy3{display:flex;flex-direction:column;gap:var(--size-4-2);min-height:35px;transition:all 150ms ease-in-out}.crd.svelte-15c4oy3{background-color:var(--background-primary);border-radius:var(--radius-s);border:1px solid var(--background-modifier-border);padding:var(--size-4-2)}.crd.svelte-15c4oy3:hover{border:1px solid var(--background-modifier-border-hover)}");
}
function get_each_context13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  const constants_0 = (
    /*getRecordColor*/
    child_ctx[7](
      /*item*/
      child_ctx[12]
    )
  );
  child_ctx[13] = constants_0;
  return child_ctx;
}
function create_default_slot_121(ctx) {
  let cardmetadata;
  let current;
  cardmetadata = new CardMetadata_default({
    props: {
      fields: (
        /*fields*/
        ctx[3]
      ),
      record: (
        /*item*/
        ctx[12]
      )
    }
  });
  return {
    c() {
      create_component(cardmetadata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cardmetadata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cardmetadata_changes = {};
      if (dirty & /*fields*/
      8)
        cardmetadata_changes.fields = /*fields*/
        ctx2[3];
      if (dirty & /*items*/
      1)
        cardmetadata_changes.record = /*item*/
        ctx2[12];
      cardmetadata.$set(cardmetadata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardmetadata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardmetadata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cardmetadata, detaching);
    }
  };
}
function create_default_slot24(ctx) {
  let t_value = getDisplayName(
    /*item*/
    ctx[12].id
  ) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      1 && t_value !== (t_value = getDisplayName(
        /*item*/
        ctx2[12].id
      ) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_header_slot3(ctx) {
  let internallink;
  let current;
  function open_handler(...args) {
    return (
      /*open_handler*/
      ctx[10](
        /*item*/
        ctx[12],
        ...args
      )
    );
  }
  internallink = new InternalLink_default({
    props: {
      slot: "header",
      linkText: (
        /*item*/
        ctx[12].id
      ),
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot24] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & /*items*/
      1)
        internallink_changes.linkText = /*item*/
        ctx[12].id;
      if (dirty & /*$$scope, items*/
      65537) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
    }
  };
}
function create_each_block13(key_1, ctx) {
  let div;
  let coloritem;
  let t3;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  coloritem = new ColorItem_default({
    props: {
      color: (
        /*color*/
        ctx[13]
      ),
      $$slots: {
        header: [create_header_slot3],
        default: [create_default_slot_121]
      },
      $$scope: { ctx }
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[11](
        /*item*/
        ctx[12]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(coloritem.$$.fragment);
      t3 = space();
      attr(div, "class", "crd svelte-15c4oy3");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(coloritem, div, null);
      append4(div, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[9]
          ),
          listen(div, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const coloritem_changes = {};
      if (dirty & /*items*/
      1)
        coloritem_changes.color = /*color*/
        ctx[13];
      if (dirty & /*$$scope, items, $app, onRecordClick, fields*/
      65563) {
        coloritem_changes.$$scope = { dirty, ctx };
      }
      coloritem.$set(coloritem_changes);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip3, { duration: flipDurationMs });
    },
    i(local) {
      if (current)
        return;
      transition_in(coloritem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(coloritem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(coloritem);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment70(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*items*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[12].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context13(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block13(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "lst svelte-15c4oy3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone$2.call(null, div, {
            type: "card",
            items: (
              /*items*/
              ctx[0]
            ),
            flipDurationMs,
            dropTargetStyle: {
              outline: "none",
              borderRadius: "5px",
              background: "hsla(var(--interactive-accent-hsl), 0.3)",
              transition: "all 150ms easy-in-out"
            },
            dragDisabled: (
              /*dragDisabled*/
              ctx[2]
            )
          })),
          listen(
            div,
            "consider",
            /*handleDndConsider*/
            ctx[5]
          ),
          listen(
            div,
            "finalize",
            /*handleDndFinalize*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*onRecordClick, items, getRecordColor, $app, getDisplayName, fields*/
      155) {
        each_value = /*items*/
        ctx2[0];
        group_outros();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block13, null, get_each_context13);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].a();
        check_outros();
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & /*items, dragDisabled*/
      5)
        dndzone_action.update.call(null, {
          type: "card",
          items: (
            /*items*/
            ctx2[0]
          ),
          flipDurationMs,
          dropTargetStyle: {
            outline: "none",
            borderRadius: "5px",
            background: "hsla(var(--interactive-accent-hsl), 0.3)",
            transition: "all 150ms easy-in-out"
          },
          dragDisabled: (
            /*dragDisabled*/
            ctx2[2]
          )
        });
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
var flipDurationMs = 200;
function instance70($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app2, ($$value) => $$invalidate(4, $app = $$value));
  let { items } = $$props;
  let { onRecordClick } = $$props;
  let { onDrop = () => {
  } } = $$props;
  let { dragDisabled = false } = $$props;
  let { fields } = $$props;
  function handleDndConsider(e) {
    $$invalidate(0, items = e.detail.items);
  }
  function handleDndFinalize(e) {
    $$invalidate(0, items = e.detail.items);
    if (onDrop) {
      onDrop(e.detail.items);
    }
  }
  const getRecordColor = getRecordColorContext();
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const open_handler = (item, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(item);
    }
  };
  const click_handler = (item) => onRecordClick(item);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("onRecordClick" in $$props2)
      $$invalidate(1, onRecordClick = $$props2.onRecordClick);
    if ("onDrop" in $$props2)
      $$invalidate(8, onDrop = $$props2.onDrop);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
    if ("fields" in $$props2)
      $$invalidate(3, fields = $$props2.fields);
  };
  return [
    items,
    onRecordClick,
    dragDisabled,
    fields,
    $app,
    handleDndConsider,
    handleDndFinalize,
    getRecordColor,
    onDrop,
    keypress_handler,
    open_handler,
    click_handler
  ];
}
var CardGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance70,
      create_fragment70,
      safe_not_equal,
      {
        items: 0,
        onRecordClick: 1,
        onDrop: 8,
        dragDisabled: 2,
        fields: 3
      },
      add_css38
    );
  }
};
var CardGroup_default = CardGroup;

// src/views/Board/components/Board/BoardColumn.svelte
function add_css39(target) {
  append_styles(target, "svelte-epk499", ".column.svelte-epk499{border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);background-color:var(--background-secondary);display:flex;flex-direction:column}.column-section.svelte-epk499{padding:var(--size-4-2);display:flex;flex-direction:column}.unprio.svelte-epk499{border-top:1px solid var(--background-modifier-border)}p.svelte-epk499{font-weight:500;margin:0;margin-bottom:4px;color:var(--text-faint);font-size:var(--font-smaller)}");
}
function create_default_slot_122(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*name*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t3,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block8(ctx) {
  let div;
  let cardgroup;
  let current;
  cardgroup = new CardGroup_default({
    props: {
      items: (
        /*records*/
        ctx[1]
      ),
      onRecordClick: (
        /*onRecordClick*/
        ctx[6]
      ),
      dragDisabled: true,
      fields: (
        /*fields*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(cardgroup.$$.fragment);
      attr(div, "class", "column-section svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(cardgroup, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardgroup_changes = {};
      if (dirty & /*records*/
      2)
        cardgroup_changes.items = /*records*/
        ctx2[1];
      if (dirty & /*onRecordClick*/
      64)
        cardgroup_changes.onRecordClick = /*onRecordClick*/
        ctx2[6];
      if (dirty & /*fields*/
      32)
        cardgroup_changes.fields = /*fields*/
        ctx2[5];
      cardgroup.$set(cardgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardgroup);
    }
  };
}
function create_if_block_113(ctx) {
  let div0;
  let cardgroup0;
  let t0;
  let div1;
  let p2;
  let t1_value = (
    /*$i18n*/
    ctx[10].t("views.board.unprioritized") + ""
  );
  let t1;
  let t22;
  let cardgroup1;
  let current;
  cardgroup0 = new CardGroup_default({
    props: {
      items: (
        /*prioritized*/
        ctx[9]
      ),
      onRecordClick: (
        /*onRecordClick*/
        ctx[6]
      ),
      onDrop: (
        /*handleDropPrioritized*/
        ctx[11]
      ),
      dragDisabled: (
        /*dragDisabled*/
        ctx[4]
      ),
      fields: (
        /*fields*/
        ctx[5]
      )
    }
  });
  cardgroup1 = new CardGroup_default({
    props: {
      items: (
        /*unprioritized*/
        ctx[8]
      ),
      onRecordClick: (
        /*onRecordClick*/
        ctx[6]
      ),
      onDrop: (
        /*handleDropUnprioritized*/
        ctx[12]
      ),
      dragDisabled: (
        /*dragDisabled*/
        ctx[4]
      ),
      fields: (
        /*fields*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(cardgroup0.$$.fragment);
      t0 = space();
      div1 = element("div");
      p2 = element("p");
      t1 = text(t1_value);
      t22 = space();
      create_component(cardgroup1.$$.fragment);
      attr(div0, "class", "column-section svelte-epk499");
      attr(p2, "class", "svelte-epk499");
      attr(div1, "class", "column-section unprio svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(cardgroup0, div0, null);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append4(div1, p2);
      append4(p2, t1);
      append4(div1, t22);
      mount_component(cardgroup1, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardgroup0_changes = {};
      if (dirty & /*prioritized*/
      512)
        cardgroup0_changes.items = /*prioritized*/
        ctx2[9];
      if (dirty & /*onRecordClick*/
      64)
        cardgroup0_changes.onRecordClick = /*onRecordClick*/
        ctx2[6];
      if (dirty & /*dragDisabled*/
      16)
        cardgroup0_changes.dragDisabled = /*dragDisabled*/
        ctx2[4];
      if (dirty & /*fields*/
      32)
        cardgroup0_changes.fields = /*fields*/
        ctx2[5];
      cardgroup0.$set(cardgroup0_changes);
      if ((!current || dirty & /*$i18n*/
      1024) && t1_value !== (t1_value = /*$i18n*/
      ctx2[10].t("views.board.unprioritized") + ""))
        set_data(t1, t1_value);
      const cardgroup1_changes = {};
      if (dirty & /*unprioritized*/
      256)
        cardgroup1_changes.items = /*unprioritized*/
        ctx2[8];
      if (dirty & /*onRecordClick*/
      64)
        cardgroup1_changes.onRecordClick = /*onRecordClick*/
        ctx2[6];
      if (dirty & /*dragDisabled*/
      16)
        cardgroup1_changes.dragDisabled = /*dragDisabled*/
        ctx2[4];
      if (dirty & /*fields*/
      32)
        cardgroup1_changes.fields = /*fields*/
        ctx2[5];
      cardgroup1.$set(cardgroup1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardgroup0.$$.fragment, local);
      transition_in(cardgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardgroup0.$$.fragment, local);
      transition_out(cardgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(cardgroup0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      destroy_component(cardgroup1);
    }
  };
}
function create_if_block27(ctx) {
  let div;
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot25] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[14]
  );
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "column-section svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      33792) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button);
    }
  };
}
function create_default_slot25(ctx) {
  let icon;
  let t0;
  let t1_value = (
    /*$i18n*/
    ctx[10].t("views.board.note.add") + ""
  );
  let t1;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$i18n*/
      1024) && t1_value !== (t1_value = /*$i18n*/
      ctx2[10].t("views.board.note.add") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment71(ctx) {
  let div1;
  let div0;
  let typography;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot_122] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_113, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*groupByPriority*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !/*readonly*/
  ctx[3] && create_if_block27(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(typography.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "column-section svelte-epk499");
      attr(
        div1,
        "data-id",
        /*name*/
        ctx[0]
      );
      attr(div1, "class", "column svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append4(div1, div0);
      mount_component(typography, div0, null);
      append4(div1, t0);
      if_blocks[current_block_type_index].m(div1, null);
      append4(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & /*$$scope, name*/
      32769) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div1, t1);
      }
      if (!/*readonly*/
      ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*readonly*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block27(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*name*/
      1) {
        attr(
          div1,
          "data-id",
          /*name*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(typography);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance71($$self, $$props, $$invalidate) {
  let prioritized;
  let unprioritized;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(10, $i18n = $$value));
  let { name } = $$props;
  let { records } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { dragDisabled = false } = $$props;
  let { onRecordUpdate } = $$props;
  let { fields } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordAdd } = $$props;
  function handleDropPrioritized(items) {
    items.forEach((item, i2) => {
      if (groupByPriority) {
        if (groupByPriority.type === "number" /* Number */) {
          onRecordUpdate(Object.assign(Object.assign({}, item), {
            values: Object.assign(Object.assign({}, item.values), { [groupByPriority.name]: i2 + 1 })
          }));
        } else if (groupByPriority.type === "date" /* Date */) {
          onRecordUpdate(item);
        }
      }
    });
  }
  function handleDropUnprioritized(items) {
    items.forEach((item) => {
      if (groupByPriority) {
        onRecordUpdate(Object.assign(Object.assign({}, item), {
          values: Object.assign(Object.assign({}, item.values), { [groupByPriority.name]: void 0 })
        }));
      }
    });
  }
  const click_handler = () => onRecordAdd();
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("records" in $$props2)
      $$invalidate(1, records = $$props2.records);
    if ("groupByPriority" in $$props2)
      $$invalidate(2, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("dragDisabled" in $$props2)
      $$invalidate(4, dragDisabled = $$props2.dragDisabled);
    if ("onRecordUpdate" in $$props2)
      $$invalidate(13, onRecordUpdate = $$props2.onRecordUpdate);
    if ("fields" in $$props2)
      $$invalidate(5, fields = $$props2.fields);
    if ("onRecordClick" in $$props2)
      $$invalidate(6, onRecordClick = $$props2.onRecordClick);
    if ("onRecordAdd" in $$props2)
      $$invalidate(7, onRecordAdd = $$props2.onRecordAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*records, groupByPriority*/
    6) {
      $:
        $$invalidate(9, prioritized = getPrioritizedRecords(records, groupByPriority));
    }
    if ($$self.$$.dirty & /*records, groupByPriority*/
    6) {
      $:
        $$invalidate(8, unprioritized = getUnprioritizedRecords(records, groupByPriority));
    }
  };
  return [
    name,
    records,
    groupByPriority,
    readonly,
    dragDisabled,
    fields,
    onRecordClick,
    onRecordAdd,
    unprioritized,
    prioritized,
    $i18n,
    handleDropPrioritized,
    handleDropUnprioritized,
    onRecordUpdate,
    click_handler
  ];
}
var BoardColumn = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance71,
      create_fragment71,
      safe_not_equal,
      {
        name: 0,
        records: 1,
        groupByPriority: 2,
        readonly: 3,
        dragDisabled: 4,
        onRecordUpdate: 13,
        fields: 5,
        onRecordClick: 6,
        onRecordAdd: 7
      },
      add_css39
    );
  }
};
var BoardColumn_default = BoardColumn;

// src/views/Board/components/Board/Board.svelte
function add_css40(target) {
  append_styles(target, "svelte-pei0r2", "div.svelte-pei0r2{display:grid;column-gap:8px;align-items:flex-start}");
}
function get_each_context14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_each_block14(key_1, ctx) {
  let first;
  let boardcolumn;
  let current;
  function func8() {
    return (
      /*func*/
      ctx[12](
        /*column*/
        ctx[14]
      )
    );
  }
  function func_15(...args) {
    return (
      /*func_1*/
      ctx[13](
        /*column*/
        ctx[14],
        ...args
      )
    );
  }
  boardcolumn = new BoardColumn_default({
    props: {
      readonly: (
        /*readonly*/
        ctx[2]
      ),
      name: (
        /*column*/
        ctx[14].id
      ),
      records: (
        /*column*/
        ctx[14].records
      ),
      groupByPriority: (
        /*groupByPriority*/
        ctx[1]
      ),
      onRecordClick: (
        /*onRecordClick*/
        ctx[3]
      ),
      onRecordAdd: func8,
      dragDisabled: (
        /*dragDisabled*/
        ctx[7]
      ),
      onRecordUpdate: func_15,
      fields: (
        /*fields*/
        ctx[8]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(boardcolumn.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(boardcolumn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const boardcolumn_changes = {};
      if (dirty & /*readonly*/
      4)
        boardcolumn_changes.readonly = /*readonly*/
        ctx[2];
      if (dirty & /*columns*/
      1)
        boardcolumn_changes.name = /*column*/
        ctx[14].id;
      if (dirty & /*columns*/
      1)
        boardcolumn_changes.records = /*column*/
        ctx[14].records;
      if (dirty & /*groupByPriority*/
      2)
        boardcolumn_changes.groupByPriority = /*groupByPriority*/
        ctx[1];
      if (dirty & /*onRecordClick*/
      8)
        boardcolumn_changes.onRecordClick = /*onRecordClick*/
        ctx[3];
      if (dirty & /*onRecordAdd, columns*/
      33)
        boardcolumn_changes.onRecordAdd = func8;
      if (dirty & /*dragDisabled*/
      128)
        boardcolumn_changes.dragDisabled = /*dragDisabled*/
        ctx[7];
      if (dirty & /*onRecordUpdate, columns*/
      17)
        boardcolumn_changes.onRecordUpdate = func_15;
      if (dirty & /*fields*/
      256)
        boardcolumn_changes.fields = /*fields*/
        ctx[8];
      boardcolumn.$set(boardcolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(boardcolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(boardcolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(boardcolumn, detaching);
    }
  };
}
function create_fragment72(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_style_value;
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*columns*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[14].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context14(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block14(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "style", div_style_value = `grid-template-columns: repeat(${/*columns*/
      ctx[0].length}, ${/*columnWidth*/
      ctx[6]}px);`);
      attr(div, "class", "svelte-pei0r2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone$2.call(null, div, {
            type: "columns",
            items: (
              /*columns*/
              ctx[0]
            ),
            flipDurationMs: flipDurationMs2,
            dropTargetStyle: { outline: "none" }
          })),
          listen(
            div,
            "consider",
            /*handleDndConsider*/
            ctx[9]
          ),
          listen(
            div,
            "finalize",
            /*handleDndFinalize*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*readonly, columns, groupByPriority, onRecordClick, onRecordAdd, dragDisabled, onRecordUpdate, fields*/
      447) {
        each_value = /*columns*/
        ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block14, null, get_each_context14);
        check_outros();
      }
      if (!current || dirty & /*columns, columnWidth*/
      65 && div_style_value !== (div_style_value = `grid-template-columns: repeat(${/*columns*/
      ctx2[0].length}, ${/*columnWidth*/
      ctx2[6]}px);`)) {
        attr(div, "style", div_style_value);
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & /*columns*/
      1)
        dndzone_action.update.call(null, {
          type: "columns",
          items: (
            /*columns*/
            ctx2[0]
          ),
          flipDurationMs: flipDurationMs2,
          dropTargetStyle: { outline: "none" }
        });
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
var flipDurationMs2 = 200;
function instance72($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordUpdate } = $$props;
  let { onRecordAdd } = $$props;
  let { columnWidth } = $$props;
  let { onSortColumns } = $$props;
  let { dragDisabled } = $$props;
  let { fields } = $$props;
  function handleDndConsider(e) {
    $$invalidate(0, columns = e.detail.items);
  }
  function handleDndFinalize(e) {
    $$invalidate(0, columns = e.detail.items);
    onSortColumns(columns.map((col) => col.id));
  }
  const func8 = (column) => onRecordAdd(column.id);
  const func_15 = (column, record) => onRecordUpdate(column.id, record);
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("groupByPriority" in $$props2)
      $$invalidate(1, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("onRecordClick" in $$props2)
      $$invalidate(3, onRecordClick = $$props2.onRecordClick);
    if ("onRecordUpdate" in $$props2)
      $$invalidate(4, onRecordUpdate = $$props2.onRecordUpdate);
    if ("onRecordAdd" in $$props2)
      $$invalidate(5, onRecordAdd = $$props2.onRecordAdd);
    if ("columnWidth" in $$props2)
      $$invalidate(6, columnWidth = $$props2.columnWidth);
    if ("onSortColumns" in $$props2)
      $$invalidate(11, onSortColumns = $$props2.onSortColumns);
    if ("dragDisabled" in $$props2)
      $$invalidate(7, dragDisabled = $$props2.dragDisabled);
    if ("fields" in $$props2)
      $$invalidate(8, fields = $$props2.fields);
  };
  return [
    columns,
    groupByPriority,
    readonly,
    onRecordClick,
    onRecordUpdate,
    onRecordAdd,
    columnWidth,
    dragDisabled,
    fields,
    handleDndConsider,
    handleDndFinalize,
    onSortColumns,
    func8,
    func_15
  ];
}
var Board = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance72,
      create_fragment72,
      safe_not_equal,
      {
        columns: 0,
        groupByPriority: 1,
        readonly: 2,
        onRecordClick: 3,
        onRecordUpdate: 4,
        onRecordAdd: 5,
        columnWidth: 6,
        onSortColumns: 11,
        dragDisabled: 7,
        fields: 8
      },
      add_css40
    );
  }
};
var Board_default = Board;

// src/views/Board/settings/settings-modal.ts
var import_obsidian39 = require("obsidian");

// src/views/Board/settings/BoardSettings.svelte
function create_default_slot_212(ctx) {
  let numberinput;
  let updating_value;
  let current;
  function numberinput_value_binding(value) {
    ctx[3](value);
  }
  let numberinput_props = { placeholder: "270" };
  if (
    /*columnWidthValue*/
    ctx[2] !== void 0
  ) {
    numberinput_props.value = /*columnWidthValue*/
    ctx[2];
  }
  numberinput = new NumberInput_default({ props: numberinput_props });
  binding_callbacks.push(() => bind6(numberinput, "value", numberinput_value_binding));
  numberinput.$on(
    "blur",
    /*blur_handler*/
    ctx[4]
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (!updating_value && dirty & /*columnWidthValue*/
      4) {
        updating_value = true;
        numberinput_changes.value = /*columnWidthValue*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_default_slot_123(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Column width",
      description: "Width of each column in pixels.",
      $$slots: { default: [create_default_slot_212] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, columnWidthValue, onSave, config*/
      71) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot26(ctx) {
  let modalcontent;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_123] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, columnWidthValue, onSave, config*/
      71) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
    }
  };
}
function create_fragment73(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: "Board settings",
      $$slots: { default: [create_default_slot26] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*$$scope, columnWidthValue, onSave, config*/
      71) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance73($$self, $$props, $$invalidate) {
  var _a;
  let { config } = $$props;
  let { onSave } = $$props;
  let columnWidthValue = (_a = config.columnWidth) !== null && _a !== void 0 ? _a : null;
  function numberinput_value_binding(value) {
    columnWidthValue = value;
    $$invalidate(2, columnWidthValue);
  }
  const blur_handler = () => onSave(immer_esm_default(config, (draft) => {
    const _a2 = draft, { columnWidth } = _a2, rest = __objRest(_a2, ["columnWidth"]);
    if (!columnWidthValue) {
      return rest;
    }
    return __spreadProps(__spreadValues({}, rest), { columnWidth: columnWidthValue });
  }));
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  return [config, onSave, columnWidthValue, numberinput_value_binding, blur_handler];
}
var BoardSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance73, create_fragment73, safe_not_equal, { config: 0, onSave: 1 });
  }
};
var BoardSettings_default = BoardSettings;

// src/views/Board/settings/settings-modal.ts
var BoardSettingsModal = class extends import_obsidian39.Modal {
  constructor(app3, config, onSave) {
    super(app3);
    this.config = config;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new BoardSettings_default({
      target: contentEl,
      props: {
        config: this.config,
        onSave: (config) => {
          this.onSave(config);
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/Board/BoardView.svelte
function add_css41(target) {
  append_styles(target, "svelte-kq39qk", "div.svelte-kq39qk{background-color:var(--background-primary);padding:8px}");
}
function create_default_slot_410(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*groupByField*/
        (_b = (_a = ctx[2]) == null ? void 0 : _a.name) != null ? _b : ""
      ),
      options: (
        /*textFields*/
        ctx[7].map(fieldToSelectableValue)
      ),
      placeholder: (
        /*$i18n*/
        (_c = ctx[8].t("views.board.fields.none")) != null ? _c : ""
      ),
      allowEmpty: true
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[22]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & /*groupByField*/
      4)
        select_changes.value = /*groupByField*/
        (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & /*textFields*/
      128)
        select_changes.options = /*textFields*/
        ctx2[7].map(fieldToSelectableValue);
      if (dirty & /*$i18n*/
      256)
        select_changes.placeholder = /*$i18n*/
        (_c2 = ctx2[8].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_310(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*priorityField*/
        (_b = (_a = ctx[5]) == null ? void 0 : _a.name) != null ? _b : ""
      ),
      options: (
        /*priorityFields*/
        ctx[6].map(fieldToSelectableValue)
      ),
      placeholder: (
        /*$i18n*/
        (_c = ctx[8].t("views.board.fields.none")) != null ? _c : ""
      ),
      allowEmpty: true
    }
  });
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[23]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & /*priorityField*/
      32)
        select_changes.value = /*priorityField*/
        (_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & /*priorityFields*/
      64)
        select_changes.options = /*priorityFields*/
        ctx2[6].map(fieldToSelectableValue);
      if (dirty & /*$i18n*/
      256)
        select_changes.placeholder = /*$i18n*/
        (_c2 = ctx2[8].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block28(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      name: "info",
      tooltip: "Date fields can't be reprioritized using drag and drop."
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_right_slot2(ctx) {
  var _a;
  let field0;
  let t0;
  let field1;
  let t1;
  let t22;
  let switchselect;
  let t3;
  let iconbutton;
  let current;
  field0 = new Field_default({
    props: {
      name: (
        /*$i18n*/
        ctx[8].t("views.board.fields.status")
      ),
      $$slots: { default: [create_default_slot_410] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: (
        /*$i18n*/
        ctx[8].t("views.board.fields.priority")
      ),
      $$slots: { default: [create_default_slot_310] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*priorityField*/
    ((_a = ctx[5]) == null ? void 0 : _a.type) === "date" /* Date */ && create_if_block28(ctx)
  );
  switchselect = new SwitchSelect_default({
    props: {
      label: "Include fields",
      items: (
        /*fields*/
        ctx[3].map(
          /*func*/
          ctx[24]
        )
      ),
      onChange: (
        /*handleIncludeFieldChange*/
        ctx[15]
      )
    }
  });
  iconbutton = new IconButton_default({
    props: {
      icon: "settings",
      onClick: (
        /*func_1*/
        ctx[25]
      )
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      t22 = space();
      create_component(switchselect.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t22, anchor);
      mount_component(switchselect, target, anchor);
      insert(target, t3, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const field0_changes = {};
      if (dirty & /*$i18n*/
      256)
        field0_changes.name = /*$i18n*/
        ctx2[8].t("views.board.fields.status");
      if (dirty & /*$$scope, groupByField, textFields, $i18n, config*/
      268435845) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & /*$i18n*/
      256)
        field1_changes.name = /*$i18n*/
        ctx2[8].t("views.board.fields.priority");
      if (dirty & /*$$scope, priorityField, priorityFields, $i18n, config*/
      268435809) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      if (
        /*priorityField*/
        ((_a2 = ctx2[5]) == null ? void 0 : _a2.type) === "date" /* Date */
      ) {
        if (if_block) {
          if (dirty & /*priorityField*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t22.parentNode, t22);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const switchselect_changes = {};
      if (dirty & /*fields, config*/
      9)
        switchselect_changes.items = /*fields*/
        ctx2[3].map(
          /*func*/
          ctx2[24]
        );
      switchselect.$set(switchselect_changes);
      const iconbutton_changes = {};
      if (dirty & /*$app, config*/
      513)
        iconbutton_changes.onClick = /*func_1*/
        ctx2[25];
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(if_block);
      transition_in(switchselect.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(if_block);
      transition_out(switchselect.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t22);
      destroy_component(switchselect, detaching);
      if (detaching)
        detach(t3);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_213(ctx) {
  let viewtoolbar;
  let current;
  viewtoolbar = new ViewToolbar_default({
    props: {
      variant: "secondary",
      $$slots: { right: [create_right_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewtoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewtoolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewtoolbar_changes = {};
      if (dirty & /*$$scope, $app, config, fields, priorityField, $i18n, priorityFields, groupByField, textFields*/
      268436461) {
        viewtoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewtoolbar.$set(viewtoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewtoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewtoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewtoolbar, detaching);
    }
  };
}
function create_default_slot_124(ctx) {
  var _a, _b;
  let div;
  let board;
  let current;
  board = new Board_default({
    props: {
      onRecordUpdate: (
        /*handleRecordUpdate*/
        ctx[13]
      ),
      dragDisabled: !/*priorityField*/
      ctx[5],
      onSortColumns: (
        /*func_2*/
        ctx[26]
      ),
      readonly: (
        /*readonly*/
        ctx[1]
      ),
      columns: (
        /*getColumns*/
        ctx[11](
          /*groupedRecords*/
          ctx[4]
        )
      ),
      groupByPriority: (
        /*priorityField*/
        ctx[5]
      ),
      onRecordClick: (
        /*handleRecordClick*/
        ctx[12]
      ),
      onRecordAdd: (
        /*handleRecordAdd*/
        ctx[14]
      ),
      columnWidth: (
        /*config*/
        (_b = (_a = ctx[0]) == null ? void 0 : _a.columnWidth) != null ? _b : 270
      ),
      fields: (
        /*fields*/
        ctx[3].filter(
          /*func_3*/
          ctx[27]
        )
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(board.$$.fragment);
      attr(div, "class", "svelte-kq39qk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(board, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const board_changes = {};
      if (dirty & /*priorityField*/
      32)
        board_changes.dragDisabled = !/*priorityField*/
        ctx2[5];
      if (dirty & /*config*/
      1)
        board_changes.onSortColumns = /*func_2*/
        ctx2[26];
      if (dirty & /*readonly*/
      2)
        board_changes.readonly = /*readonly*/
        ctx2[1];
      if (dirty & /*groupedRecords*/
      16)
        board_changes.columns = /*getColumns*/
        ctx2[11](
          /*groupedRecords*/
          ctx2[4]
        );
      if (dirty & /*priorityField*/
      32)
        board_changes.groupByPriority = /*priorityField*/
        ctx2[5];
      if (dirty & /*config*/
      1)
        board_changes.columnWidth = /*config*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.columnWidth) != null ? _b2 : 270;
      if (dirty & /*fields, config*/
      9)
        board_changes.fields = /*fields*/
        ctx2[3].filter(
          /*func_3*/
          ctx2[27]
        );
      board.$set(board_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(board.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(board.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(board);
    }
  };
}
function create_default_slot27(ctx) {
  let viewheader;
  let t3;
  let viewcontent;
  let current;
  viewheader = new ViewHeader_default({
    props: {
      $$slots: { default: [create_default_slot_213] },
      $$scope: { ctx }
    }
  });
  viewcontent = new ViewContent_default({
    props: {
      $$slots: { default: [create_default_slot_124] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewheader.$$.fragment);
      t3 = space();
      create_component(viewcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewheader, target, anchor);
      insert(target, t3, anchor);
      mount_component(viewcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewheader_changes = {};
      if (dirty & /*$$scope, $app, config, fields, priorityField, $i18n, priorityFields, groupByField, textFields*/
      268436461) {
        viewheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewheader.$set(viewheader_changes);
      const viewcontent_changes = {};
      if (dirty & /*$$scope, priorityField, config, readonly, groupedRecords, fields*/
      268435515) {
        viewcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewcontent.$set(viewcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewheader.$$.fragment, local);
      transition_in(viewcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewheader.$$.fragment, local);
      transition_out(viewcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewheader, detaching);
      if (detaching)
        detach(t3);
      destroy_component(viewcontent, detaching);
    }
  };
}
function create_fragment74(ctx) {
  let viewlayout;
  let current;
  viewlayout = new ViewLayout_default({
    props: {
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const viewlayout_changes = {};
      if (dirty & /*$$scope, priorityField, config, readonly, groupedRecords, fields, $app, $i18n, priorityFields, groupByField, textFields*/
      268436479) {
        viewlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewlayout.$set(viewlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewlayout, detaching);
    }
  };
}
function instance74($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let textFields;
  let groupByField;
  let priorityFields;
  let priorityField;
  let groupedRecords;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(8, $i18n = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(9, $app = $$value));
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { getRecordColor } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function saveConfig(cfg) {
    $$invalidate(0, config = cfg);
    onConfigChange(cfg);
  }
  function getColumns(records2) {
    var _a, _b;
    const columns = new Set(Object.entries(records2).map((entry) => entry[0]));
    if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.type) === "string" /* String */) {
      for (const option2 of (_b = (_a = groupByField === null || groupByField === void 0 ? void 0 : groupByField.typeConfig) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : []) {
        columns.add(option2);
      }
    }
    return [...columns].sort((a2, b2) => {
      var _a2, _b2, _c, _d, _e, _f;
      const aweight = (_c = (_b2 = (_a2 = config === null || config === void 0 ? void 0 : config.columns) === null || _a2 === void 0 ? void 0 : _a2[a2]) === null || _b2 === void 0 ? void 0 : _b2.weight) !== null && _c !== void 0 ? _c : 0;
      const bweight = (_f = (_e = (_d = config === null || config === void 0 ? void 0 : config.columns) === null || _d === void 0 ? void 0 : _d[b2]) === null || _e === void 0 ? void 0 : _e.weight) !== null && _f !== void 0 ? _f : 0;
      if (aweight < bweight) {
        return -1;
      } else if (aweight > bweight) {
        return 1;
      } else {
        return 0;
      }
    }).map((column) => {
      var _a2;
      return {
        id: column,
        records: (_a2 = groupedRecords[column]) !== null && _a2 !== void 0 ? _a2 : []
      };
    });
  }
  function handleRecordClick(record) {
    new EditNoteModal($app, fields, (record2) => api2.updateRecord(record2, fields), record).open();
  }
  function handleRecordUpdate(column, record) {
    if (groupByField) {
      api2.updateRecord(
        Object.assign(Object.assign({}, record), {
          values: Object.assign(Object.assign({}, record.values), { [groupByField.name]: column })
        }),
        fields
      );
    }
  }
  function handleRecordAdd(column) {
    new CreateNoteModal(
      $app,
      project,
      (name, templatePath) => {
        api2.addRecord(
          createDataRecord(name, project, groupByField ? {
            [groupByField.name]: column !== $i18n.t("views.board.no-status") ? column : void 0
          } : {}),
          templatePath
        );
      }
    ).open();
  }
  function handleIncludeFieldChange(field, enabled) {
    const includedFields = new Set(config === null || config === void 0 ? void 0 : config.includeFields);
    if (enabled) {
      includedFields.add(field);
    } else {
      includedFields.delete(field);
    }
    saveConfig(Object.assign(Object.assign({}, config), { includeFields: [...includedFields] }));
  }
  setRecordColorContext(getRecordColor);
  const change_handler = ({ detail: value }) => saveConfig(__spreadProps(__spreadValues({}, config), { groupByField: value }));
  const change_handler_1 = ({ detail: value }) => {
    saveConfig(__spreadProps(__spreadValues({}, config), { priorityField: value }));
  };
  const func8 = (field) => {
    var _a;
    return {
      label: field.name,
      value: field.name,
      enabled: !!((_a = config == null ? void 0 : config.includeFields) == null ? void 0 : _a.includes(field.name))
    };
  };
  const func_15 = () => {
    new BoardSettingsModal(
      $app,
      config != null ? config : {},
      (value) => {
        saveConfig(value);
      }
    ).open();
  };
  const func_2 = (names) => {
    saveConfig(__spreadProps(__spreadValues({}, config), {
      columns: Object.fromEntries(names.map((name, i2) => {
        return [name, { weight: i2 }];
      }))
    }));
  };
  const func_3 = (field) => {
    var _a;
    return !!((_a = config == null ? void 0 : config.includeFields) == null ? void 0 : _a.includes(field.name));
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(16, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(17, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(18, api2 = $$props2.api);
    if ("getRecordColor" in $$props2)
      $$invalidate(19, getRecordColor = $$props2.getRecordColor);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(20, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*frame*/
    131072) {
      $:
        $$invalidate(3, { fields, records } = frame, fields, ($$invalidate(21, records), $$invalidate(17, frame)));
    }
    if ($$self.$$.dirty & /*fields*/
    8) {
      $:
        $$invalidate(7, textFields = fields.filter((field) => !field.repeated).filter((field) => field.type === "string" /* String */ || field.type === "number" /* Number */));
    }
    if ($$self.$$.dirty & /*fields, config*/
    9) {
      $:
        $$invalidate(2, groupByField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.groupByField) === field.name));
    }
    if ($$self.$$.dirty & /*fields*/
    8) {
      $:
        $$invalidate(6, priorityFields = fields.filter((field) => !field.repeated).filter((field) => field.type === "number" /* Number */ || field.type === "date" /* Date */));
    }
    if ($$self.$$.dirty & /*fields, config*/
    9) {
      $:
        $$invalidate(5, priorityField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.priorityField) === field.name));
    }
    if ($$self.$$.dirty & /*records, groupByField*/
    2097156) {
      $:
        $$invalidate(4, groupedRecords = groupRecordsByField(records, groupByField === null || groupByField === void 0 ? void 0 : groupByField.name));
    }
  };
  return [
    config,
    readonly,
    groupByField,
    fields,
    groupedRecords,
    priorityField,
    priorityFields,
    textFields,
    $i18n,
    $app,
    saveConfig,
    getColumns,
    handleRecordClick,
    handleRecordUpdate,
    handleRecordAdd,
    handleIncludeFieldChange,
    project,
    frame,
    api2,
    getRecordColor,
    onConfigChange,
    records,
    change_handler,
    change_handler_1,
    func8,
    func_15,
    func_2,
    func_3
  ];
}
var BoardView = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance74,
      create_fragment74,
      safe_not_equal,
      {
        project: 16,
        frame: 17,
        readonly: 1,
        api: 18,
        getRecordColor: 19,
        config: 0,
        onConfigChange: 20
      },
      add_css41
    );
  }
};
var BoardView_default = BoardView;

// src/views/Board/board-view.ts
var BoardView2 = class extends ProjectView {
  getViewType() {
    return "board";
  }
  getDisplayName() {
    return "Board";
  }
  getIcon() {
    return "columns";
  }
  onData(_0) {
    return __async(this, arguments, function* ({ data }) {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$set({ frame: data });
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.view = new BoardView_default({
        target: props.contentEl,
        props: {
          frame: { fields: [], records: [] },
          api: props.viewApi,
          project: props.project,
          readonly: props.readonly,
          config: props.config,
          onConfigChange: props.saveConfig,
          getRecordColor: props.getRecordColor
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/views/Calendar/CalendarView.svelte
var import_dayjs8 = __toESM(require_dayjs_min());

// src/views/Calendar/calendar.ts
var import_dayjs6 = __toESM(require_dayjs_min());
function isCalendarInterval(value) {
  switch (value) {
    case "month":
    case "2weeks":
    case "week":
    case "3days":
    case "day":
      return true;
    default:
      return false;
  }
}
function addInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.add(1, "month");
    case "2weeks":
      return date.add(2, "week");
    case "week":
      return date.add(1, "week");
    case "3days":
      return date.add(1, "day");
    case "day":
      return date.add(1, "day");
  }
}
function subtractInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.subtract(1, "month");
    case "2weeks":
      return date.subtract(2, "week");
    case "week":
      return date.subtract(1, "week");
    case "3days":
      return date.subtract(1, "day");
    case "day":
      return date.subtract(1, "day");
  }
}
function groupRecordsByField2(records, field) {
  const res = {};
  records.forEach((record) => {
    var _a;
    const dateValue = record.values[field];
    const start2 = dateValue ? isDate(dateValue) ? (0, import_dayjs6.default)(dateValue) : null : null;
    if (start2) {
      const dateStr = start2.format("YYYY-MM-DD");
      if (!(dateStr in res)) {
        res[dateStr] = [];
      }
      (_a = res[dateStr]) == null ? void 0 : _a.push(record);
    }
  });
  return res;
}
function computeDateInterval(anchor, interval) {
  switch (interval) {
    case "month":
      return [
        anchor.startOf("month").startOf("isoWeek"),
        anchor.endOf("month").endOf("isoWeek")
      ];
    case "2weeks":
      return [
        anchor.startOf("isoWeek"),
        anchor.add(1, "week").endOf("isoWeek")
      ];
    case "week":
      return [anchor.startOf("isoWeek"), anchor.endOf("isoWeek")];
    case "3days":
      return [anchor, anchor.add(2, "days")];
    case "day":
      return [anchor, anchor];
  }
}
function generateTitle(dateInterval) {
  if (dateInterval[0].startOf("day").isSame(dateInterval[1].startOf("day"))) {
    return get_store_value(i18n).t("views.calendar.date", {
      value: dateInterval[0],
      formatParams: {
        value: { year: "numeric", month: "long", day: "numeric" }
      }
    });
  }
  return get_store_value(i18n).t("views.calendar.interval", {
    from: dateInterval[0],
    to: dateInterval[1],
    formatParams: {
      from: { month: "short", day: "numeric" },
      to: { year: "numeric", month: "short", day: "numeric" }
    }
  });
}
function generateDates(dateInterval) {
  const dates = [];
  const numDays = dateInterval[1].diff(dateInterval[0], "days");
  for (let i2 = 0; i2 <= numDays; i2++) {
    dates.push(dateInterval[0].add(i2, "day"));
  }
  return dates;
}
function chunkDates(dates, chunks) {
  const chunkedDates = [];
  let rest = dates;
  while (rest.length) {
    const chunked = take(rest, chunks);
    chunkedDates.push(chunked);
    rest = rest.slice(chunked.length);
  }
  return chunkedDates;
}
function take(arr, num) {
  const buffer = [];
  for (let i2 = 0; i2 < num && i2 < arr.length; i2++) {
    const el = arr[i2];
    if (el) {
      buffer.push(el);
    }
  }
  return buffer;
}

// src/views/Calendar/components/Calendar/Week.svelte
function add_css42(target) {
  append_styles(target, "svelte-15iqrr1", "div.svelte-15iqrr1{display:flex;border-bottom:1px solid var(--background-modifier-border);min-height:100px}div.svelte-15iqrr1:last-child{border-bottom:0}");
}
function create_fragment75(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-15iqrr1");
      set_style(
        div,
        "height",
        /*height*/
        ctx[0] + "%"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (dirty & /*height*/
      1) {
        set_style(
          div,
          "height",
          /*height*/
          ctx2[0] + "%"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance75($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { height } = $$props;
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [height, $$scope, slots];
}
var Week = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance75, create_fragment75, safe_not_equal, { height: 0 }, add_css42);
  }
};
var Week_default = Week;

// src/views/Calendar/components/Calendar/Calendar.svelte
function add_css43(target) {
  append_styles(target, "svelte-rkq8la", "div.svelte-rkq8la{display:flex;flex-direction:column;height:100%}");
}
function create_fragment76(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-rkq8la");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance76($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Calendar = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance76, create_fragment76, safe_not_equal, {}, add_css43);
  }
};
var Calendar_default = Calendar;

// src/views/Calendar/components/Calendar/Day.svelte
var import_dayjs7 = __toESM(require_dayjs_min());
var import_obsidian42 = require("obsidian");

// src/views/Calendar/components/Calendar/Date.svelte
function add_css44(target) {
  append_styles(target, "svelte-19rown3", "span.svelte-19rown3{height:24px;line-height:24px;font-size:12px;font-weight:500;border-radius:50px;width:max-content;min-width:24px;text-align:center;display:inline-block;align-self:center}.today.svelte-19rown3{background:var(--interactive-accent);color:var(--text-on-accent)}");
}
function create_fragment77(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "class", "svelte-19rown3");
      toggle_class(
        span,
        "today",
        /*today*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*today*/
      1) {
        toggle_class(
          span,
          "today",
          /*today*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance77($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { today = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("today" in $$props2)
      $$invalidate(0, today = $$props2.today);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [today, $$scope, slots];
}
var Date2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance77, create_fragment77, safe_not_equal, { today: 0 }, add_css44);
  }
};
var Date_default2 = Date2;

// src/views/Calendar/components/Calendar/ColorPill.svelte
function create_fragment78(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "height", `100%`);
      set_style(span, "border-radius", `9999px`);
      set_style(
        span,
        "background-color",
        /*color*/
        ctx[0]
      );
      set_style(
        span,
        "width",
        /*width*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*color*/
      1) {
        set_style(
          span,
          "background-color",
          /*color*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      2) {
        set_style(
          span,
          "width",
          /*width*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance78($$self, $$props, $$invalidate) {
  let { color } = $$props;
  let { width = "5px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
  };
  return [color, width];
}
var ColorPill = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance78, create_fragment78, safe_not_equal, { color: 0, width: 1 });
  }
};
var ColorPill_default = ColorPill;

// src/views/Calendar/components/Calendar/Ellipsis.svelte
function add_css45(target) {
  append_styles(target, "svelte-16vy86e", "span.svelte-16vy86e{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}");
}
function create_fragment79(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "class", "svelte-16vy86e");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Ellipsis = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance79, create_fragment79, safe_not_equal, {}, add_css45);
  }
};
var Ellipsis_default = Ellipsis;

// src/views/Calendar/components/Calendar/Event.svelte
function add_css46(target) {
  append_styles(target, "svelte-opw0t4", 'div.svelte-opw0t4{display:flex;gap:4px;align-items:center;padding:0.2em 0.4em;font-size:var(--font-ui-smaller);border:1px solid var(--background-modifier-border);background-color:var(--background-primary);border-radius:var(--radius-s)}div.svelte-opw0t4 input[type="checkbox"]{margin:0}');
}
function create_if_block_28(ctx) {
  let colorpill;
  let current;
  colorpill = new ColorPill_default({ props: { color: (
    /*color*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(colorpill.$$.fragment);
    },
    m(target, anchor) {
      mount_component(colorpill, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const colorpill_changes = {};
      if (dirty & /*color*/
      2)
        colorpill_changes.color = /*color*/
        ctx2[1];
      colorpill.$set(colorpill_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(colorpill.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(colorpill.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(colorpill, detaching);
    }
  };
}
function create_if_block_114(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox_default({ props: { checked: false } });
  checkbox.$on(
    "check",
    /*check_handler_1*/
    ctx[6]
  );
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_if_block29(ctx) {
  let checkbox;
  let updating_checked;
  let current;
  function checkbox_checked_binding(value) {
    ctx[4](value);
  }
  let checkbox_props = {};
  if (
    /*checked*/
    ctx[0] !== void 0
  ) {
    checkbox_props.checked = /*checked*/
    ctx[0];
  }
  checkbox = new Checkbox_default({ props: checkbox_props });
  binding_callbacks.push(() => bind6(checkbox, "checked", checkbox_checked_binding));
  checkbox.$on(
    "check",
    /*check_handler*/
    ctx[5]
  );
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (!updating_checked && dirty & /*checked*/
      1) {
        updating_checked = true;
        checkbox_changes.checked = /*checked*/
        ctx2[0];
        add_flush_callback(() => updating_checked = false);
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment80(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let ellipsis;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*color*/
    ctx[1] && create_if_block_28(ctx)
  );
  const if_block_creators = [create_if_block29, create_if_block_114];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*checked*/
      ctx2[0] !== void 0 && /*checked*/
      ctx2[0] !== null
    )
      return 0;
    if (
      /*checked*/
      ctx2[0] === null && /*hover*/
      ctx2[2]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  ellipsis = new Ellipsis_default({
    props: {
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(ellipsis.$$.fragment);
      attr(div, "class", "svelte-opw0t4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append4(div, t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append4(div, t1);
      mount_component(ellipsis, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[7]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*color*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*color*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_28(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        } else {
          if_block1 = null;
        }
      }
      const ellipsis_changes = {};
      if (dirty & /*$$scope*/
      512) {
        ellipsis_changes.$$scope = { dirty, ctx: ctx2 };
      }
      ellipsis.$set(ellipsis_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(ellipsis.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(ellipsis.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(ellipsis);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance80($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { color = null } = $$props;
  let { checked = void 0 } = $$props;
  let hover = false;
  function checkbox_checked_binding(value) {
    checked = value;
    $$invalidate(0, checked);
  }
  function check_handler(event) {
    bubble.call(this, $$self, event);
  }
  function check_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  const mouseenter_handler = () => $$invalidate(2, hover = true);
  const mouseleave_handler = () => $$invalidate(2, hover = false);
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    checked,
    color,
    hover,
    slots,
    checkbox_checked_binding,
    check_handler,
    check_handler_1,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var Event = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance80, create_fragment80, safe_not_equal, { color: 1, checked: 0 }, add_css46);
  }
};
var Event_default = Event;

// src/views/Calendar/components/Calendar/EventList.svelte
function add_css47(target) {
  append_styles(target, "svelte-49q3js", "div.svelte-49q3js{display:flex;flex-direction:column;gap:2px;height:100%;width:100%;overflow-y:auto}");
}
function get_each_context15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_if_block30(ctx) {
  let event;
  let current;
  function check_handler(...args) {
    return (
      /*check_handler*/
      ctx[9](
        /*record*/
        ctx[11],
        ...args
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*record*/
        ctx[11]
      )
    );
  }
  event = new Event_default({
    props: {
      color: (
        /*getRecordColor*/
        ctx[7](
          /*record*/
          ctx[11]
        )
      ),
      checked: (
        /*checkField*/
        ctx[1] !== void 0 ? asOptionalBoolean(
          /*record*/
          ctx[11].values[
            /*checkField*/
            ctx[1]
          ]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot29] },
      $$scope: { ctx }
    }
  });
  event.$on("check", check_handler);
  event.$on("click", click_handler);
  return {
    c() {
      create_component(event.$$.fragment);
    },
    m(target, anchor) {
      mount_component(event, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty & /*records*/
      1)
        event_changes.color = /*getRecordColor*/
        ctx[7](
          /*record*/
          ctx[11]
        );
      if (dirty & /*checkField, records*/
      3)
        event_changes.checked = /*checkField*/
        ctx[1] !== void 0 ? asOptionalBoolean(
          /*record*/
          ctx[11].values[
            /*checkField*/
            ctx[1]
          ]
        ) : void 0;
      if (dirty & /*$$scope, records, $app, onRecordClick*/
      16405) {
        event_changes.$$scope = { dirty, ctx };
      }
      event.$set(event_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(event, detaching);
    }
  };
}
function create_default_slot_125(ctx) {
  let t_value = getDisplayName(
    /*record*/
    ctx[11].id
  ) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*records*/
      1 && t_value !== (t_value = getDisplayName(
        /*record*/
        ctx2[11].id
      ) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot29(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler(...args) {
    return (
      /*open_handler*/
      ctx[8](
        /*record*/
        ctx[11],
        ...args
      )
    );
  }
  internallink = new InternalLink_default({
    props: {
      linkText: (
        /*record*/
        ctx[11].id
      ),
      sourcePath: "",
      resolved: true,
      tooltip: getDisplayName(
        /*record*/
        ctx[11].id
      ),
      $$slots: { default: [create_default_slot_125] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & /*records*/
      1)
        internallink_changes.linkText = /*record*/
        ctx[11].id;
      if (dirty & /*records*/
      1)
        internallink_changes.tooltip = getDisplayName(
          /*record*/
          ctx[11].id
        );
      if (dirty & /*$$scope, records*/
      16385) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block15(key_1, ctx) {
  let first;
  let show_if = getDisplayName(
    /*record*/
    ctx[11].id
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block30(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*records*/
      1)
        show_if = getDisplayName(
          /*record*/
          ctx[11].id
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*records*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block30(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment81(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*records*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*record*/
    ctx2[11].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context15(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block15(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "svelte-49q3js");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone$2.call(null, div, {
            type: "entries",
            items: (
              /*records*/
              ctx[0]
            ),
            flipDurationMs: flipDurationMs3,
            dropTargetStyle: {
              outline: "none",
              borderRadius: "5px",
              background: "hsla(var(--interactive-accent-hsl), 0.3)"
            }
          })),
          listen(
            div,
            "consider",
            /*handleDndConsider*/
            ctx[5]
          ),
          listen(
            div,
            "finalize",
            /*handleDndFinalize*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*getRecordColor, records, checkField, undefined, asOptionalBoolean, onRecordChange, onRecordClick, getDisplayName, $app*/
      159) {
        each_value = /*records*/
        ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block15, null, get_each_context15);
        check_outros();
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & /*records*/
      1)
        dndzone_action.update.call(null, {
          type: "entries",
          items: (
            /*records*/
            ctx2[0]
          ),
          flipDurationMs: flipDurationMs3,
          dropTargetStyle: {
            outline: "none",
            borderRadius: "5px",
            background: "hsla(var(--interactive-accent-hsl), 0.3)"
          }
        });
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
var flipDurationMs3 = 200;
function asOptionalBoolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return null;
}
function instance81($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app2, ($$value) => $$invalidate(4, $app = $$value));
  let { records } = $$props;
  let { checkField } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordChange } = $$props;
  function handleDndConsider(e) {
    $$invalidate(0, records = e.detail.items);
  }
  function handleDndFinalize(e) {
    $$invalidate(0, records = e.detail.items);
    records.forEach(onRecordChange);
  }
  const getRecordColor = getRecordColorContext();
  const open_handler = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const check_handler = (record, { detail: checked }) => {
    if (checkField) {
      onRecordChange(__spreadProps(__spreadValues({}, record), {
        values: __spreadProps(__spreadValues({}, record.values), { [checkField]: checked })
      }));
    }
  };
  const click_handler = (record) => {
    onRecordClick(record);
  };
  $$self.$$set = ($$props2) => {
    if ("records" in $$props2)
      $$invalidate(0, records = $$props2.records);
    if ("checkField" in $$props2)
      $$invalidate(1, checkField = $$props2.checkField);
    if ("onRecordClick" in $$props2)
      $$invalidate(2, onRecordClick = $$props2.onRecordClick);
    if ("onRecordChange" in $$props2)
      $$invalidate(3, onRecordChange = $$props2.onRecordChange);
  };
  return [
    records,
    checkField,
    onRecordClick,
    onRecordChange,
    $app,
    handleDndConsider,
    handleDndFinalize,
    getRecordColor,
    open_handler,
    check_handler,
    click_handler
  ];
}
var EventList = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance81,
      create_fragment81,
      safe_not_equal,
      {
        records: 0,
        checkField: 1,
        onRecordClick: 2,
        onRecordChange: 3
      },
      add_css47
    );
  }
};
var EventList_default = EventList;

// src/views/Calendar/components/Calendar/Day.svelte
function add_css48(target) {
  append_styles(target, "svelte-y223yt", "div.svelte-y223yt{border-right:1px solid var(--background-modifier-border);padding:4px;font-size:var(--font-ui-small);display:flex;flex-direction:column;gap:4px}div.svelte-y223yt:last-child{border-right:0}.weekend.svelte-y223yt{background-color:var(--background-secondary)}");
}
function create_default_slot30(ctx) {
  let t_value = (
    /*date*/
    ctx[0].date() + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*date*/
      1 && t_value !== (t_value = /*date*/
      ctx2[0].date() + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment82(ctx) {
  let div;
  let date_1;
  let t3;
  let eventlist;
  let current;
  let mounted;
  let dispose;
  date_1 = new Date_default2({
    props: {
      today: (
        /*today*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot30] },
      $$scope: { ctx }
    }
  });
  eventlist = new EventList_default({
    props: {
      checkField: (
        /*checkField*/
        ctx[3]
      ),
      records: (
        /*records*/
        ctx[2]
      ),
      onRecordClick: (
        /*onRecordClick*/
        ctx[4]
      ),
      onRecordChange: (
        /*onRecordChange*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(date_1.$$.fragment);
      t3 = space();
      create_component(eventlist.$$.fragment);
      attr(div, "class", "svelte-y223yt");
      toggle_class(
        div,
        "weekend",
        /*weekend*/
        ctx[7]
      );
      set_style(
        div,
        "width",
        /*width*/
        ctx[1] + "%"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(date_1, div, null);
      append4(div, t3);
      mount_component(eventlist, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "dblclick",
            /*handleDblClick*/
            ctx[8]
          ),
          listen(
            div,
            "mousedown",
            /*handleMouseDown*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const date_1_changes = {};
      if (dirty & /*today*/
      64)
        date_1_changes.today = /*today*/
        ctx2[6];
      if (dirty & /*$$scope, date*/
      4097) {
        date_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      date_1.$set(date_1_changes);
      const eventlist_changes = {};
      if (dirty & /*checkField*/
      8)
        eventlist_changes.checkField = /*checkField*/
        ctx2[3];
      if (dirty & /*records*/
      4)
        eventlist_changes.records = /*records*/
        ctx2[2];
      if (dirty & /*onRecordClick*/
      16)
        eventlist_changes.onRecordClick = /*onRecordClick*/
        ctx2[4];
      if (dirty & /*onRecordChange*/
      32)
        eventlist_changes.onRecordChange = /*onRecordChange*/
        ctx2[5];
      eventlist.$set(eventlist_changes);
      if (!current || dirty & /*weekend*/
      128) {
        toggle_class(
          div,
          "weekend",
          /*weekend*/
          ctx2[7]
        );
      }
      if (dirty & /*width*/
      2) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[1] + "%"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(date_1.$$.fragment, local);
      transition_in(eventlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(date_1.$$.fragment, local);
      transition_out(eventlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(date_1);
      destroy_component(eventlist);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance82($$self, $$props, $$invalidate) {
  let weekend;
  let today;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(11, $i18n = $$value));
  let { date } = $$props;
  let { width } = $$props;
  let { records } = $$props;
  let { checkField } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordChange } = $$props;
  let { onRecordAdd } = $$props;
  function handleDblClick(event) {
    onRecordAdd();
  }
  function handleMouseDown(event) {
    if (event.button === 2) {
      new import_obsidian42.Menu().addItem((item) => {
        item.setTitle($i18n.t("views.calendar.new-note")).setIcon("file-plus").onClick(() => onRecordAdd());
      }).showAtMouseEvent(event);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("records" in $$props2)
      $$invalidate(2, records = $$props2.records);
    if ("checkField" in $$props2)
      $$invalidate(3, checkField = $$props2.checkField);
    if ("onRecordClick" in $$props2)
      $$invalidate(4, onRecordClick = $$props2.onRecordClick);
    if ("onRecordChange" in $$props2)
      $$invalidate(5, onRecordChange = $$props2.onRecordChange);
    if ("onRecordAdd" in $$props2)
      $$invalidate(10, onRecordAdd = $$props2.onRecordAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*date*/
    1) {
      $:
        $$invalidate(7, weekend = date.day() === 0 || date.day() === 6);
    }
    if ($$self.$$.dirty & /*date*/
    1) {
      $:
        $$invalidate(6, today = date.startOf("day").isSame((0, import_dayjs7.default)().startOf("day")));
    }
  };
  return [
    date,
    width,
    records,
    checkField,
    onRecordClick,
    onRecordChange,
    today,
    weekend,
    handleDblClick,
    handleMouseDown,
    onRecordAdd
  ];
}
var Day = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance82,
      create_fragment82,
      safe_not_equal,
      {
        date: 0,
        width: 1,
        records: 2,
        checkField: 3,
        onRecordClick: 4,
        onRecordChange: 5,
        onRecordAdd: 10
      },
      add_css48
    );
  }
};
var Day_default = Day;

// src/views/Calendar/components/Calendar/Weekday.svelte
function add_css49(target) {
  append_styles(target, "svelte-16ljls7", "div.svelte-16ljls7{width:calc(100% / 7);border-right:1px solid var(--background-modifier-border);padding:4px;padding-bottom:0;text-align:center;font-size:var(--font-ui-small);font-weight:500;color:var(--text-muted)}.weekend.svelte-16ljls7{background-color:var(--background-secondary)}");
}
function create_fragment83(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-16ljls7");
      toggle_class(
        div,
        "weekend",
        /*weekend*/
        ctx[0]
      );
      set_style(
        div,
        "width",
        /*width*/
        ctx[1] + "%"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*weekend*/
      1) {
        toggle_class(
          div,
          "weekend",
          /*weekend*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      2) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[1] + "%"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance83($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { weekend = false } = $$props;
  let { width } = $$props;
  $$self.$$set = ($$props2) => {
    if ("weekend" in $$props2)
      $$invalidate(0, weekend = $$props2.weekend);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [weekend, width, $$scope, slots];
}
var Weekday = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance83, create_fragment83, safe_not_equal, { weekend: 0, width: 1 }, add_css49);
  }
};
var Weekday_default = Weekday;

// src/views/Calendar/components/Calendar/WeekHeader.svelte
function add_css50(target) {
  append_styles(target, "svelte-1yrjn1q", "div.svelte-1yrjn1q{display:flex}");
}
function create_fragment84(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1yrjn1q");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance84($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var WeekHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance84, create_fragment84, safe_not_equal, {}, add_css50);
  }
};
var WeekHeader_default = WeekHeader;

// src/views/Calendar/components/Navigation/Navigation.svelte
function add_css51(target) {
  append_styles(target, "svelte-1u5a4vj", "div.svelte-1u5a4vj{display:flex;gap:4px;align-items:center}");
}
function create_default_slot31(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[3].t("views.calendar.today") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      8 && t_value !== (t_value = /*$i18n*/
      ctx2[3].t("views.calendar.today") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment85(ctx) {
  let div;
  let iconbutton0;
  let t0;
  let button;
  let t1;
  let iconbutton1;
  let current;
  iconbutton0 = new IconButton_default({
    props: {
      icon: "chevron-left",
      onClick: (
        /*onPrevious*/
        ctx[1]
      )
    }
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot31] },
      $$scope: { ctx }
    }
  });
  button.$on("click", function() {
    if (is_function(
      /*onToday*/
      ctx[2]
    ))
      ctx[2].apply(this, arguments);
  });
  iconbutton1 = new IconButton_default({
    props: {
      icon: "chevron-right",
      onClick: (
        /*onNext*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(iconbutton0.$$.fragment);
      t0 = space();
      create_component(button.$$.fragment);
      t1 = space();
      create_component(iconbutton1.$$.fragment);
      attr(div, "class", "svelte-1u5a4vj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(iconbutton0, div, null);
      append4(div, t0);
      mount_component(button, div, null);
      append4(div, t1);
      mount_component(iconbutton1, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const iconbutton0_changes = {};
      if (dirty & /*onPrevious*/
      2)
        iconbutton0_changes.onClick = /*onPrevious*/
        ctx[1];
      iconbutton0.$set(iconbutton0_changes);
      const button_changes = {};
      if (dirty & /*$$scope, $i18n*/
      24) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
      const iconbutton1_changes = {};
      if (dirty & /*onNext*/
      1)
        iconbutton1_changes.onClick = /*onNext*/
        ctx[0];
      iconbutton1.$set(iconbutton1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton0.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      transition_in(iconbutton1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton0.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      transition_out(iconbutton1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(iconbutton0);
      destroy_component(button);
      destroy_component(iconbutton1);
    }
  };
}
function instance85($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { onNext } = $$props;
  let { onPrevious } = $$props;
  let { onToday } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onNext" in $$props2)
      $$invalidate(0, onNext = $$props2.onNext);
    if ("onPrevious" in $$props2)
      $$invalidate(1, onPrevious = $$props2.onPrevious);
    if ("onToday" in $$props2)
      $$invalidate(2, onToday = $$props2.onToday);
  };
  return [onNext, onPrevious, onToday, $i18n];
}
var Navigation = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance85, create_fragment85, safe_not_equal, { onNext: 0, onPrevious: 1, onToday: 2 }, add_css51);
  }
};
var Navigation_default = Navigation;

// src/views/Calendar/CalendarView.svelte
var import_obsidian44 = require("obsidian");
function get_each_context16(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i2];
  return child_ctx;
}
function get_each_context_12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i2];
  return child_ctx;
}
function create_left_slot2(ctx) {
  let navigation;
  let current;
  navigation = new Navigation_default({
    props: {
      slot: "left",
      onNext: (
        /*func*/
        ctx[34]
      ),
      onPrevious: (
        /*func_1*/
        ctx[35]
      ),
      onToday: (
        /*func_2*/
        ctx[36]
      )
    }
  });
  return {
    c() {
      create_component(navigation.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navigation, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navigation_changes = {};
      if (dirty[0] & /*anchorDate, interval*/
      10)
        navigation_changes.onNext = /*func*/
        ctx2[34];
      if (dirty[0] & /*anchorDate, interval*/
      10)
        navigation_changes.onPrevious = /*func_1*/
        ctx2[35];
      if (dirty[0] & /*anchorDate*/
      2)
        navigation_changes.onToday = /*func_2*/
        ctx2[36];
      navigation.$set(navigation_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navigation, detaching);
    }
  };
}
function create_default_slot_92(ctx) {
  let t3;
  return {
    c() {
      t3 = text(
        /*title*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*title*/
      128)
        set_data(
          t3,
          /*title*/
          ctx2[7]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_middle_slot2(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      slot: "middle",
      variant: "h2",
      nomargin: true,
      $$slots: { default: [create_default_slot_92] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty[0] & /*title*/
      128 | dirty[1] & /*$$scope*/
      524288) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_default_slot_82(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (
        /*dateField*/
        (_b = (_a = ctx[2]) == null ? void 0 : _a.name) != null ? _b : ""
      ),
      options: (
        /*dateFields*/
        ctx[4].map(fieldToSelectableValue)
      ),
      placeholder: (
        /*$i18n*/
        (_c = ctx[11].t("views.calendar.fields.none")) != null ? _c : ""
      )
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[31]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & /*dateField*/
      4)
        select_changes.value = /*dateField*/
        (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & /*dateFields*/
      16)
        select_changes.options = /*dateFields*/
        ctx2[4].map(fieldToSelectableValue);
      if (dirty[0] & /*$i18n*/
      2048)
        select_changes.placeholder = /*$i18n*/
        (_c2 = ctx2[11].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_72(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      allowEmpty: true,
      value: (
        /*booleanField*/
        (_b = (_a = ctx[9]) == null ? void 0 : _a.name) != null ? _b : ""
      ),
      options: (
        /*booleanFields*/
        ctx[10].map(fieldToSelectableValue)
      ),
      placeholder: (
        /*$i18n*/
        (_c = ctx[11].t("views.calendar.fields.none")) != null ? _c : ""
      )
    }
  });
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[32]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & /*booleanField*/
      512)
        select_changes.value = /*booleanField*/
        (_b2 = (_a2 = ctx2[9]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & /*booleanFields*/
      1024)
        select_changes.options = /*booleanFields*/
        ctx2[10].map(fieldToSelectableValue);
      if (dirty[0] & /*$i18n*/
      2048)
        select_changes.placeholder = /*$i18n*/
        (_c2 = ctx2[11].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_right_slot3(ctx) {
  var _a, _b;
  let field0;
  let t0;
  let field1;
  let t1;
  let select;
  let current;
  field0 = new Field_default({
    props: {
      name: (
        /*$i18n*/
        ctx[11].t("views.calendar.fields.date")
      ),
      $$slots: { default: [create_default_slot_82] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: (
        /*$i18n*/
        ctx[11].t("views.calendar.fields.check")
      ),
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    }
  });
  select = new Select_default({
    props: {
      value: (
        /*config*/
        (_b = (_a = ctx[0]) == null ? void 0 : _a.interval) != null ? _b : "week"
      ),
      options: [
        {
          label: (
            /*$i18n*/
            ctx[11].t("views.calendar.intervals.month", { count: 1 })
          ),
          value: "month"
        },
        {
          label: (
            /*$i18n*/
            ctx[11].t("views.calendar.intervals.weekWithCount", { count: 2 })
          ),
          value: "2weeks"
        },
        {
          label: (
            /*$i18n*/
            ctx[11].t("views.calendar.intervals.week", { count: 1 })
          ),
          value: "week"
        },
        {
          label: (
            /*$i18n*/
            ctx[11].t("views.calendar.intervals.dayWithCount", { count: 3 })
          ),
          value: "3days"
        },
        {
          label: (
            /*$i18n*/
            ctx[11].t("views.calendar.intervals.day", { count: 1 })
          ),
          value: "day"
        }
      ]
    }
  });
  select.$on(
    "change",
    /*change_handler_2*/
    ctx[33]
  );
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const field0_changes = {};
      if (dirty[0] & /*$i18n*/
      2048)
        field0_changes.name = /*$i18n*/
        ctx2[11].t("views.calendar.fields.date");
      if (dirty[0] & /*dateField, dateFields, $i18n*/
      2068 | dirty[1] & /*$$scope*/
      524288) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & /*$i18n*/
      2048)
        field1_changes.name = /*$i18n*/
        ctx2[11].t("views.calendar.fields.check");
      if (dirty[0] & /*booleanField, booleanFields, $i18n*/
      3584 | dirty[1] & /*$$scope*/
      524288) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const select_changes = {};
      if (dirty[0] & /*config*/
      1)
        select_changes.value = /*config*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.interval) != null ? _b2 : "week";
      if (dirty[0] & /*$i18n*/
      2048)
        select_changes.options = [
          {
            label: (
              /*$i18n*/
              ctx2[11].t("views.calendar.intervals.month", { count: 1 })
            ),
            value: "month"
          },
          {
            label: (
              /*$i18n*/
              ctx2[11].t("views.calendar.intervals.weekWithCount", { count: 2 })
            ),
            value: "2weeks"
          },
          {
            label: (
              /*$i18n*/
              ctx2[11].t("views.calendar.intervals.week", { count: 1 })
            ),
            value: "week"
          },
          {
            label: (
              /*$i18n*/
              ctx2[11].t("views.calendar.intervals.dayWithCount", { count: 3 })
            ),
            value: "3days"
          },
          {
            label: (
              /*$i18n*/
              ctx2[11].t("views.calendar.intervals.day", { count: 1 })
            ),
            value: "day"
          }
        ];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_67(ctx) {
  let viewtoolbar;
  let current;
  viewtoolbar = new ViewToolbar_default({
    props: {
      variant: "secondary",
      $$slots: {
        right: [create_right_slot3],
        middle: [create_middle_slot2],
        left: [create_left_slot2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewtoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewtoolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewtoolbar_changes = {};
      if (dirty[0] & /*config, $i18n, booleanField, booleanFields, dateField, dateFields, title, anchorDate, interval*/
      3743 | dirty[1] & /*$$scope*/
      524288) {
        viewtoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewtoolbar.$set(viewtoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewtoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewtoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewtoolbar, detaching);
    }
  };
}
function create_default_slot_59(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[11].t("views.calendar.weekday", {
      value: (
        /*weekDay*/
        ctx[47].toDate()
      ),
      formatParams: { value: { weekday: "short" } }
    }) + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$i18n, weekDays*/
      2080 && t_value !== (t_value = /*$i18n*/
      ctx2[11].t("views.calendar.weekday", {
        value: (
          /*weekDay*/
          ctx2[47].toDate()
        ),
        formatParams: { value: { weekday: "short" } }
      }) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_2(ctx) {
  let weekday;
  let current;
  weekday = new Weekday_default({
    props: {
      width: 100 / /*weekDays*/
      ctx[5].length,
      weekend: (
        /*weekDay*/
        ctx[47].day() === 0 || /*weekDay*/
        ctx[47].day() === 6
      ),
      $$slots: { default: [create_default_slot_59] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(weekday.$$.fragment);
    },
    m(target, anchor) {
      mount_component(weekday, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const weekday_changes = {};
      if (dirty[0] & /*weekDays*/
      32)
        weekday_changes.width = 100 / /*weekDays*/
        ctx2[5].length;
      if (dirty[0] & /*weekDays*/
      32)
        weekday_changes.weekend = /*weekDay*/
        ctx2[47].day() === 0 || /*weekDay*/
        ctx2[47].day() === 6;
      if (dirty[0] & /*$i18n, weekDays*/
      2080 | dirty[1] & /*$$scope*/
      524288) {
        weekday_changes.$$scope = { dirty, ctx: ctx2 };
      }
      weekday.$set(weekday_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(weekday.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(weekday.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(weekday, detaching);
    }
  };
}
function create_default_slot_411(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = (
    /*weekDays*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*weekDays, $i18n*/
      2080) {
        each_value_2 = /*weekDays*/
        ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_12(ctx) {
  var _a;
  let day;
  let current;
  function func_3(...args) {
    return (
      /*func_3*/
      ctx[37](
        /*date*/
        ctx[44],
        ...args
      )
    );
  }
  function func_4() {
    return (
      /*func_4*/
      ctx[38](
        /*date*/
        ctx[44]
      )
    );
  }
  day = new Day_default({
    props: {
      width: 100 / /*week*/
      ctx[41].length,
      date: (
        /*date*/
        ctx[44]
      ),
      checkField: (
        /*booleanField*/
        (_a = ctx[9]) == null ? void 0 : _a.name
      ),
      records: (
        /*groupedRecords*/
        ctx[8][
          /*date*/
          ctx[44].format("YYYY-MM-DD")
        ] || []
      ),
      onRecordClick: (
        /*handleRecordClick*/
        ctx[16]
      ),
      onRecordChange: func_3,
      onRecordAdd: func_4
    }
  });
  return {
    c() {
      create_component(day.$$.fragment);
    },
    m(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const day_changes = {};
      if (dirty[0] & /*weeks*/
      64)
        day_changes.width = 100 / /*week*/
        ctx[41].length;
      if (dirty[0] & /*weeks*/
      64)
        day_changes.date = /*date*/
        ctx[44];
      if (dirty[0] & /*booleanField*/
      512)
        day_changes.checkField = /*booleanField*/
        (_a2 = ctx[9]) == null ? void 0 : _a2.name;
      if (dirty[0] & /*groupedRecords, weeks*/
      320)
        day_changes.records = /*groupedRecords*/
        ctx[8][
          /*date*/
          ctx[44].format("YYYY-MM-DD")
        ] || [];
      if (dirty[0] & /*weeks*/
      64)
        day_changes.onRecordChange = func_3;
      if (dirty[0] & /*weeks*/
      64)
        day_changes.onRecordAdd = func_4;
      day.$set(day_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(day, detaching);
    }
  };
}
function create_default_slot_311(ctx) {
  let t3;
  let current;
  let each_value_1 = (
    /*week*/
    ctx[41]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_12(get_each_context_12(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*weeks, booleanField, groupedRecords, handleRecordClick, handleRecordChange, handleRecordAdd*/
      230208) {
        each_value_1 = /*week*/
        ctx2[41];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_12(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block16(ctx) {
  let week;
  let current;
  week = new Week_default({
    props: {
      height: 100 / /*weeks*/
      ctx[6].length,
      $$slots: { default: [create_default_slot_311] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(week.$$.fragment);
    },
    m(target, anchor) {
      mount_component(week, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const week_changes = {};
      if (dirty[0] & /*weeks*/
      64)
        week_changes.height = 100 / /*weeks*/
        ctx2[6].length;
      if (dirty[0] & /*weeks, booleanField, groupedRecords*/
      832 | dirty[1] & /*$$scope*/
      524288) {
        week_changes.$$scope = { dirty, ctx: ctx2 };
      }
      week.$set(week_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(week.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(week.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(week, detaching);
    }
  };
}
function create_default_slot_214(ctx) {
  let weekheader;
  let t3;
  let each_1_anchor;
  let current;
  weekheader = new WeekHeader_default({
    props: {
      $$slots: { default: [create_default_slot_411] },
      $$scope: { ctx }
    }
  });
  let each_value = (
    /*weeks*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block16(get_each_context16(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(weekheader.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(weekheader, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const weekheader_changes = {};
      if (dirty[0] & /*weekDays, $i18n*/
      2080 | dirty[1] & /*$$scope*/
      524288) {
        weekheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      weekheader.$set(weekheader_changes);
      if (dirty[0] & /*weeks, booleanField, groupedRecords, handleRecordClick, handleRecordChange, handleRecordAdd*/
      230208) {
        each_value = /*weeks*/
        ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context16(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block16(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(weekheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(weekheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(weekheader, detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_126(ctx) {
  let calendar;
  let current;
  calendar = new Calendar_default({
    props: {
      $$slots: { default: [create_default_slot_214] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(calendar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(calendar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const calendar_changes = {};
      if (dirty[0] & /*weeks, booleanField, groupedRecords, weekDays, $i18n*/
      2912 | dirty[1] & /*$$scope*/
      524288) {
        calendar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      calendar.$set(calendar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(calendar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(calendar, detaching);
    }
  };
}
function create_default_slot32(ctx) {
  let viewheader;
  let t3;
  let viewcontent;
  let current;
  viewheader = new ViewHeader_default({
    props: {
      $$slots: { default: [create_default_slot_67] },
      $$scope: { ctx }
    }
  });
  viewcontent = new ViewContent_default({
    props: {
      $$slots: { default: [create_default_slot_126] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewheader.$$.fragment);
      t3 = space();
      create_component(viewcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewheader, target, anchor);
      insert(target, t3, anchor);
      mount_component(viewcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewheader_changes = {};
      if (dirty[0] & /*config, $i18n, booleanField, booleanFields, dateField, dateFields, title, anchorDate, interval*/
      3743 | dirty[1] & /*$$scope*/
      524288) {
        viewheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewheader.$set(viewheader_changes);
      const viewcontent_changes = {};
      if (dirty[0] & /*weeks, booleanField, groupedRecords, weekDays, $i18n*/
      2912 | dirty[1] & /*$$scope*/
      524288) {
        viewcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewcontent.$set(viewcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewheader.$$.fragment, local);
      transition_in(viewcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewheader.$$.fragment, local);
      transition_out(viewcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewheader, detaching);
      if (detaching)
        detach(t3);
      destroy_component(viewcontent, detaching);
    }
  };
}
function create_fragment86(ctx) {
  let viewlayout;
  let current;
  viewlayout = new ViewLayout_default({
    props: {
      $$slots: { default: [create_default_slot32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewlayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewlayout_changes = {};
      if (dirty[0] & /*weeks, booleanField, groupedRecords, weekDays, $i18n, config, booleanFields, dateField, dateFields, title, anchorDate, interval*/
      4095 | dirty[1] & /*$$scope*/
      524288) {
        viewlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewlayout.$set(viewlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewlayout, detaching);
    }
  };
}
function instance86($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let dateFields;
  let dateField;
  let booleanFields;
  let booleanField;
  let interval;
  let dateInterval;
  let groupedRecords;
  let title;
  let dates;
  let numColumns;
  let weeks;
  let weekDays;
  let $app;
  let $i18n;
  component_subscribe($$self, app2, ($$value) => $$invalidate(39, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(11, $i18n = $$value));
  var _a, _b;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { getRecordColor } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function saveConfig(cfg) {
    $$invalidate(0, config = cfg);
    onConfigChange(cfg);
  }
  let anchorDate = (0, import_dayjs8.default)();
  function handleIntervalChange(interval2) {
    if (isCalendarInterval(interval2)) {
      saveConfig(Object.assign(Object.assign({}, config), { interval: interval2 }));
    }
  }
  function handleDateFieldChange(dateField2) {
    saveConfig(Object.assign(Object.assign({}, config), { dateField: dateField2 }));
  }
  function handleCheckFieldChange(checkField) {
    saveConfig(Object.assign(Object.assign({}, config), { checkField }));
  }
  function handleRecordChange(date, record) {
    if (dateField) {
      api2.updateRecord(
        Object.assign(Object.assign({}, record), {
          values: Object.assign(Object.assign({}, record.values), {
            [dateField.name]: date.format("YYYY-MM-DD")
          })
        }),
        fields
      );
    }
  }
  function handleRecordClick(entry) {
    if (entry) {
      new EditNoteModal(
        get_store_value(app2),
        fields,
        (record) => {
          api2.updateRecord(record, fields);
        },
        entry
      ).open();
    }
  }
  function handleRecordAdd(date) {
    if (!dateField) {
      new import_obsidian44.Notice("Select a Date field to create calendar events.");
      return;
    }
    if (readonly) {
      new import_obsidian44.Notice("Can't create calendar events in read-only projects.");
      return;
    }
    new CreateNoteModal(
      $app,
      project,
      (name, templatePath) => {
        if (dateField) {
          api2.addRecord(createDataRecord(name, project, { [dateField.name]: date.toDate() }), templatePath);
        }
      }
    ).open();
  }
  setRecordColorContext(getRecordColor);
  const change_handler = ({ detail }) => handleDateFieldChange(detail);
  const change_handler_1 = ({ detail }) => handleCheckFieldChange(detail);
  const change_handler_2 = ({ detail }) => handleIntervalChange(detail);
  const func8 = () => $$invalidate(1, anchorDate = addInterval(anchorDate, interval));
  const func_15 = () => $$invalidate(1, anchorDate = subtractInterval(anchorDate, interval));
  const func_2 = () => $$invalidate(1, anchorDate = (0, import_dayjs8.default)());
  const func_3 = (date, record) => {
    handleRecordChange(date, record);
  };
  const func_4 = (date) => {
    handleRecordAdd(date);
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(18, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(19, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(20, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(21, api2 = $$props2.api);
    if ("getRecordColor" in $$props2)
      $$invalidate(22, getRecordColor = $$props2.getRecordColor);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(23, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*frame*/
    524288) {
      $:
        $$invalidate(26, { fields, records } = frame, fields, ($$invalidate(30, records), $$invalidate(19, frame)));
    }
    if ($$self.$$.dirty[0] & /*fields*/
    67108864) {
      $:
        $$invalidate(4, dateFields = fields.filter((field) => !field.repeated).filter((field) => field.type === "date" /* Date */));
    }
    if ($$self.$$.dirty[0] & /*dateFields, config, _a*/
    16777233) {
      $:
        $$invalidate(2, dateField = $$invalidate(24, _a = dateFields.find((field) => (config === null || config === void 0 ? void 0 : config.dateField) === field.name)) !== null && _a !== void 0 ? _a : dateFields[0]);
    }
    if ($$self.$$.dirty[0] & /*fields*/
    67108864) {
      $:
        $$invalidate(10, booleanFields = fields.filter((field) => !field.repeated).filter((field) => field.type === "boolean" /* Boolean */));
    }
    if ($$self.$$.dirty[0] & /*fields, config*/
    67108865) {
      $:
        $$invalidate(9, booleanField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.checkField) === field.name));
    }
    if ($$self.$$.dirty[0] & /*config, _b*/
    33554433) {
      $:
        $$invalidate(3, interval = $$invalidate(25, _b = config === null || config === void 0 ? void 0 : config.interval) !== null && _b !== void 0 ? _b : "week");
    }
    if ($$self.$$.dirty[0] & /*anchorDate, interval*/
    10) {
      $:
        $$invalidate(29, dateInterval = computeDateInterval(anchorDate, interval));
    }
    if ($$self.$$.dirty[0] & /*dateField, records*/
    1073741828) {
      $:
        $$invalidate(8, groupedRecords = dateField ? groupRecordsByField2(records, dateField.name) : {});
    }
    if ($$self.$$.dirty[0] & /*dateInterval*/
    536870912) {
      $:
        $$invalidate(7, title = dateInterval ? generateTitle(dateInterval) : "");
    }
    if ($$self.$$.dirty[0] & /*dateInterval*/
    536870912) {
      $:
        $$invalidate(28, dates = dateInterval ? generateDates(dateInterval) : []);
    }
    if ($$self.$$.dirty[0] & /*dates*/
    268435456) {
      $:
        $$invalidate(27, numColumns = Math.min(dates.length, 7));
    }
    if ($$self.$$.dirty[0] & /*dates, numColumns*/
    402653184) {
      $:
        $$invalidate(6, weeks = chunkDates(dates, numColumns));
    }
    if ($$self.$$.dirty[0] & /*dates, numColumns*/
    402653184) {
      $:
        $$invalidate(5, weekDays = dates.slice(0, numColumns));
    }
  };
  return [
    config,
    anchorDate,
    dateField,
    interval,
    dateFields,
    weekDays,
    weeks,
    title,
    groupedRecords,
    booleanField,
    booleanFields,
    $i18n,
    handleIntervalChange,
    handleDateFieldChange,
    handleCheckFieldChange,
    handleRecordChange,
    handleRecordClick,
    handleRecordAdd,
    project,
    frame,
    readonly,
    api2,
    getRecordColor,
    onConfigChange,
    _a,
    _b,
    fields,
    numColumns,
    dates,
    dateInterval,
    records,
    change_handler,
    change_handler_1,
    change_handler_2,
    func8,
    func_15,
    func_2,
    func_3,
    func_4
  ];
}
var CalendarView = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance86,
      create_fragment86,
      safe_not_equal,
      {
        project: 18,
        frame: 19,
        readonly: 20,
        api: 21,
        getRecordColor: 22,
        config: 0,
        onConfigChange: 23
      },
      null,
      [-1, -1]
    );
  }
};
var CalendarView_default = CalendarView;

// src/views/Calendar/calendar-view.ts
var CalendarView2 = class extends ProjectView {
  getViewType() {
    return "calendar";
  }
  getDisplayName() {
    return "Calendar";
  }
  getIcon() {
    return "calendar";
  }
  onData(_0) {
    return __async(this, arguments, function* ({ data }) {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$set({ frame: data });
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.view = new CalendarView_default({
        target: props.contentEl,
        props: {
          frame: { fields: [], records: [] },
          api: props.viewApi,
          project: props.project,
          readonly: props.readonly,
          config: props.config,
          onConfigChange: props.saveConfig,
          getRecordColor: props.getRecordColor
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/modals/components/CenterBox.svelte
function add_css52(target) {
  append_styles(target, "svelte-8ezeao", "div.svelte-8ezeao{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex:1}");
}
function create_fragment87(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-8ezeao");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CenterBox = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance87, create_fragment87, safe_not_equal, {}, add_css52);
  }
};
var CenterBox_default = CenterBox;

// src/views/Gallery/components/Card/Card.svelte
function add_css53(target) {
  append_styles(target, "svelte-xq218h", "div.svelte-xq218h{background-color:var(--background-secondary);border-radius:var(--radius-s);border:1px solid var(--background-modifier-border);padding:0;margin:0}div.svelte-xq218h:hover{border:1px solid var(--background-modifier-border-hover)}");
}
function create_fragment88(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-xq218h");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance88($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance88, create_fragment88, safe_not_equal, {}, add_css53);
  }
};
var Card_default2 = Card;

// src/views/Gallery/components/Card/CardContent.svelte
function add_css54(target) {
  append_styles(target, "svelte-1rhoaa0", "div.svelte-1rhoaa0{padding:8px}");
}
function create_fragment89(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1rhoaa0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance89($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CardContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance89, create_fragment89, safe_not_equal, {}, add_css54);
  }
};
var CardContent_default = CardContent;

// src/views/Gallery/components/Card/CardMedia.svelte
function add_css55(target) {
  append_styles(target, "svelte-1ur9trs", "div.svelte-1ur9trs{height:180px;border-top-left-radius:4px;border-top-right-radius:4px;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--background-modifier-border)}");
}
function create_fragment90(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1ur9trs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[2]
          ),
          listen(
            div,
            "click",
            /*click_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance90($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots, keypress_handler, click_handler];
}
var CardMedia = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance90, create_fragment90, safe_not_equal, {}, add_css55);
  }
};
var CardMedia_default = CardMedia;

// src/views/Gallery/components/Grid/Grid.svelte
function add_css56(target) {
  append_styles(target, "svelte-1eu9z5i", "div.svelte-1eu9z5i{display:grid;gap:24px}");
}
function create_fragment91(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "style", div_style_value = `grid-template-columns: repeat(auto-fill, minmax(${/*cardWidth*/
      ctx[0]}px, 1fr));`);
      attr(div, "class", "svelte-1eu9z5i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cardWidth*/
      1 && div_style_value !== (div_style_value = `grid-template-columns: repeat(auto-fill, minmax(${/*cardWidth*/
      ctx2[0]}px, 1fr));`)) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance91($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cardWidth } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cardWidth" in $$props2)
      $$invalidate(0, cardWidth = $$props2.cardWidth);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [cardWidth, $$scope, slots];
}
var Grid = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance91, create_fragment91, safe_not_equal, { cardWidth: 0 }, add_css56);
  }
};
var Grid_default = Grid;

// src/views/Gallery/components/Image/Image.svelte
function add_css57(target) {
  append_styles(target, "svelte-ol6m5s", "img.svelte-ol6m5s{width:100%;height:100%;border-top-left-radius:4px;border-top-right-radius:4px}");
}
function create_fragment92(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(
        img,
        "alt",
        /*alt*/
        ctx[0]
      );
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-ol6m5s");
      set_style(
        img,
        "object-fit",
        /*fit*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*alt*/
      1) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[0]
        );
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*fit*/
      4) {
        set_style(
          img,
          "object-fit",
          /*fit*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function instance92($$self, $$props, $$invalidate) {
  let { alt: alt5 } = $$props;
  let { src } = $$props;
  let { fit } = $$props;
  $$self.$$set = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt5 = $$props2.alt);
    if ("src" in $$props2)
      $$invalidate(1, src = $$props2.src);
    if ("fit" in $$props2)
      $$invalidate(2, fit = $$props2.fit);
  };
  return [alt5, src, fit];
}
var Image = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance92, create_fragment92, safe_not_equal, { alt: 0, src: 1, fit: 2 }, add_css57);
  }
};
var Image_default = Image;

// src/views/Gallery/helpers.ts
var obsidianLinkRegExp = /^\[\[(.*?)(\|(.*?))?\]\]$/;
function parseObsidianLink(link) {
  const match6 = link.match(obsidianLinkRegExp);
  return match6 ? {
    linkText: match6[1] || "",
    displayName: match6[3] || ""
  } : null;
}

// src/views/Gallery/settings/settings-modal.ts
var import_obsidian45 = require("obsidian");

// src/views/Gallery/settings/GallerySettings.svelte
function create_default_slot_215(ctx) {
  let numberinput;
  let updating_value;
  let current;
  function numberinput_value_binding(value) {
    ctx[3](value);
  }
  let numberinput_props = { placeholder: "300" };
  if (
    /*cardWidthValue*/
    ctx[2] !== void 0
  ) {
    numberinput_props.value = /*cardWidthValue*/
    ctx[2];
  }
  numberinput = new NumberInput_default({ props: numberinput_props });
  binding_callbacks.push(() => bind6(numberinput, "value", numberinput_value_binding));
  numberinput.$on(
    "blur",
    /*blur_handler*/
    ctx[4]
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (!updating_value && dirty & /*cardWidthValue*/
      4) {
        updating_value = true;
        numberinput_changes.value = /*cardWidthValue*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_default_slot_127(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Card width",
      description: "Width of each card in pixels.",
      $$slots: { default: [create_default_slot_215] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, cardWidthValue, onSave, config*/
      71) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot33(ctx) {
  let modalcontent;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_127] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, cardWidthValue, onSave, config*/
      71) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
    }
  };
}
function create_fragment93(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: "Gallery settings",
      $$slots: { default: [create_default_slot33] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*$$scope, cardWidthValue, onSave, config*/
      71) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance93($$self, $$props, $$invalidate) {
  var _a;
  let { config } = $$props;
  let { onSave } = $$props;
  let cardWidthValue = (_a = config.cardWidth) !== null && _a !== void 0 ? _a : null;
  function numberinput_value_binding(value) {
    cardWidthValue = value;
    $$invalidate(2, cardWidthValue);
  }
  const blur_handler = () => onSave(immer_esm_default(config, (draft) => {
    const _a2 = draft, { cardWidth } = _a2, rest = __objRest(_a2, ["cardWidth"]);
    if (!cardWidthValue) {
      return rest;
    }
    return __spreadProps(__spreadValues({}, rest), { cardWidth: cardWidthValue });
  }));
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  return [config, onSave, cardWidthValue, numberinput_value_binding, blur_handler];
}
var GallerySettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance93, create_fragment93, safe_not_equal, { config: 0, onSave: 1 });
  }
};
var GallerySettings_default = GallerySettings;

// src/views/Gallery/settings/settings-modal.ts
var GallerySettingsModal = class extends import_obsidian45.Modal {
  constructor(app3, config, onSave) {
    super(app3);
    this.config = config;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new GallerySettings_default({
      target: contentEl,
      props: {
        config: this.config,
        onSave: (config) => {
          this.onSave(config);
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/Gallery/GalleryView.svelte
function add_css58(target) {
  append_styles(target, "svelte-mbfvt8", ".padding.svelte-mbfvt8{padding:24px}");
}
function get_each_context17(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  const constants_0 = (
    /*getRecordColor*/
    child_ctx[3](
      /*record*/
      child_ctx[29]
    )
  );
  child_ctx[30] = constants_0;
  return child_ctx;
}
function get_context2(ctx) {
  const constants_0 = (
    /*getCoverRealPath*/
    ctx[12](
      /*record*/
      ctx[29]
    )
  );
  ctx[33] = constants_0;
}
function create_default_slot_1110(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      allowEmpty: true,
      value: (
        /*coverField*/
        (_b = (_a = ctx[6]) == null ? void 0 : _a.name) != null ? _b : ""
      ),
      options: (
        /*textFields*/
        ctx[5].map(fieldToSelectableValue)
      ),
      placeholder: (
        /*$i18n*/
        (_c = ctx[10].t("views.gallery.fields.none")) != null ? _c : ""
      )
    }
  });
  select.$on(
    "change",
    /*change_handler*/
    ctx[20]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & /*coverField*/
      64)
        select_changes.value = /*coverField*/
        (_b2 = (_a2 = ctx2[6]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & /*textFields*/
      32)
        select_changes.options = /*textFields*/
        ctx2[5].map(fieldToSelectableValue);
      if (dirty[0] & /*$i18n*/
      1024)
        select_changes.placeholder = /*$i18n*/
        (_c2 = ctx2[10].t("views.gallery.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_right_slot4(ctx) {
  var _a, _b;
  let field;
  let t0;
  let select;
  let t1;
  let switchselect;
  let t22;
  let iconbutton;
  let current;
  field = new Field_default({
    props: {
      name: (
        /*$i18n*/
        ctx[10].t("views.gallery.fields.cover")
      ),
      $$slots: { default: [create_default_slot_1110] },
      $$scope: { ctx }
    }
  });
  select = new Select_default({
    props: {
      value: (
        /*config*/
        (_b = (_a = ctx[0]) == null ? void 0 : _a.fitStyle) != null ? _b : "cover"
      ),
      options: [
        { label: "Fill image", value: "cover" },
        { label: "Fit image", value: "contain" }
      ]
    }
  });
  select.$on(
    "change",
    /*change_handler_1*/
    ctx[21]
  );
  switchselect = new SwitchSelect_default({
    props: {
      label: "Include fields",
      items: (
        /*fields*/
        ctx[4].map(
          /*func*/
          ctx[22]
        )
      ),
      onChange: (
        /*handleIncludeFieldChange*/
        ctx[15]
      )
    }
  });
  iconbutton = new IconButton_default({
    props: {
      icon: "settings",
      onClick: (
        /*func_1*/
        ctx[23]
      )
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
      t0 = space();
      create_component(select.$$.fragment);
      t1 = space();
      create_component(switchselect.$$.fragment);
      t22 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      insert(target, t0, anchor);
      mount_component(select, target, anchor);
      insert(target, t1, anchor);
      mount_component(switchselect, target, anchor);
      insert(target, t22, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const field_changes = {};
      if (dirty[0] & /*$i18n*/
      1024)
        field_changes.name = /*$i18n*/
        ctx2[10].t("views.gallery.fields.cover");
      if (dirty[0] & /*coverField, textFields, $i18n*/
      1120 | dirty[1] & /*$$scope*/
      8) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      const select_changes = {};
      if (dirty[0] & /*config*/
      1)
        select_changes.value = /*config*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.fitStyle) != null ? _b2 : "cover";
      select.$set(select_changes);
      const switchselect_changes = {};
      if (dirty[0] & /*fields, config*/
      17)
        switchselect_changes.items = /*fields*/
        ctx2[4].map(
          /*func*/
          ctx2[22]
        );
      switchselect.$set(switchselect_changes);
      const iconbutton_changes = {};
      if (dirty[0] & /*$app, config*/
      513)
        iconbutton_changes.onClick = /*func_1*/
        ctx2[23];
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      transition_in(switchselect.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      transition_out(switchselect.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
      if (detaching)
        detach(t0);
      destroy_component(select, detaching);
      if (detaching)
        detach(t1);
      destroy_component(switchselect, detaching);
      if (detaching)
        detach(t22);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_102(ctx) {
  let viewtoolbar;
  let current;
  viewtoolbar = new ViewToolbar_default({
    props: {
      variant: "secondary",
      $$slots: { right: [create_right_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewtoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewtoolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewtoolbar_changes = {};
      if (dirty[0] & /*$app, config, fields, $i18n, coverField, textFields*/
      1649 | dirty[1] & /*$$scope*/
      8) {
        viewtoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewtoolbar.$set(viewtoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewtoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewtoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewtoolbar, detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let centerbox;
  let current;
  centerbox = new CenterBox_default({
    props: {
      $$slots: { default: [create_default_slot_83] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(centerbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(centerbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const centerbox_changes = {};
      if (dirty[0] & /*$i18n*/
      1024 | dirty[1] & /*$$scope*/
      8) {
        centerbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      centerbox.$set(centerbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(centerbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(centerbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(centerbox, detaching);
    }
  };
}
function create_if_block31(ctx) {
  var _a, _b;
  let div;
  let grid;
  let current;
  grid = new Grid_default({
    props: {
      cardWidth: (
        /*config*/
        (_b = (_a = ctx[0]) == null ? void 0 : _a.cardWidth) != null ? _b : 300
      ),
      $$slots: { default: [create_default_slot_216] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(grid.$$.fragment);
      attr(div, "class", "padding svelte-mbfvt8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(grid, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const grid_changes = {};
      if (dirty[0] & /*config*/
      1)
        grid_changes.cardWidth = /*config*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.cardWidth) != null ? _b2 : 300;
      if (dirty[0] & /*$app, project, api, records, getRecordColor, fields, config, fitStyle*/
      927 | dirty[1] & /*$$scope*/
      8) {
        grid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid.$set(grid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(grid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(grid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(grid);
    }
  };
}
function create_default_slot_93(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[10].t("views.gallery.empty") + ""
  );
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$i18n*/
      1024 && t_value !== (t_value = /*$i18n*/
      ctx2[10].t("views.gallery.empty") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_83(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h5",
      $$slots: { default: [create_default_slot_93] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty[0] & /*$i18n*/
      1024 | dirty[1] & /*$$scope*/
      8) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_else_block9(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "image", size: "lg" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_115(ctx) {
  let image;
  let current;
  image = new Image_default({
    props: {
      alt: "Title",
      src: (
        /*coverPath*/
        ctx[33]
      ),
      fit: (
        /*fitStyle*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(image.$$.fragment);
    },
    m(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const image_changes = {};
      if (dirty[0] & /*records*/
      256)
        image_changes.src = /*coverPath*/
        ctx2[33];
      if (dirty[0] & /*fitStyle*/
      128)
        image_changes.fit = /*fitStyle*/
        ctx2[7];
      image.$set(image_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(image, detaching);
    }
  };
}
function create_default_slot_73(ctx) {
  get_context2(ctx);
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_115, create_else_block9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*coverPath*/
      ctx2[33]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_context2(ctx2);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_68(ctx) {
  let cardmetadata;
  let current;
  cardmetadata = new CardMetadata_default({
    props: {
      fields: (
        /*fields*/
        ctx[4].filter(
          /*func_2*/
          ctx[26]
        )
      ),
      record: (
        /*record*/
        ctx[29]
      )
    }
  });
  return {
    c() {
      create_component(cardmetadata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cardmetadata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cardmetadata_changes = {};
      if (dirty[0] & /*fields, config*/
      17)
        cardmetadata_changes.fields = /*fields*/
        ctx2[4].filter(
          /*func_2*/
          ctx2[26]
        );
      if (dirty[0] & /*records*/
      256)
        cardmetadata_changes.record = /*record*/
        ctx2[29];
      cardmetadata.$set(cardmetadata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardmetadata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardmetadata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cardmetadata, detaching);
    }
  };
}
function create_default_slot_510(ctx) {
  let t_value = getDisplayName(
    /*record*/
    ctx[29].id
  ) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*records*/
      256 && t_value !== (t_value = getDisplayName(
        /*record*/
        ctx2[29].id
      ) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_header_slot4(ctx) {
  let internallink;
  let current;
  function open_handler(...args) {
    return (
      /*open_handler*/
      ctx[25](
        /*record*/
        ctx[29],
        ...args
      )
    );
  }
  internallink = new InternalLink_default({
    props: {
      slot: "header",
      linkText: (
        /*record*/
        ctx[29].id
      ),
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_510] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty[0] & /*records*/
      256)
        internallink_changes.linkText = /*record*/
        ctx[29].id;
      if (dirty[0] & /*records*/
      256 | dirty[1] & /*$$scope*/
      8) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
    }
  };
}
function create_default_slot_412(ctx) {
  let coloritem;
  let current;
  coloritem = new ColorItem_default({
    props: {
      color: (
        /*color*/
        ctx[30]
      ),
      $$slots: {
        header: [create_header_slot4],
        default: [create_default_slot_68]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(coloritem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(coloritem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const coloritem_changes = {};
      if (dirty[0] & /*getRecordColor, records*/
      264)
        coloritem_changes.color = /*color*/
        ctx2[30];
      if (dirty[0] & /*records, $app, fields, config*/
      785 | dirty[1] & /*$$scope*/
      8) {
        coloritem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      coloritem.$set(coloritem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(coloritem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(coloritem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(coloritem, detaching);
    }
  };
}
function create_default_slot_312(ctx) {
  let cardmedia;
  let t3;
  let cardcontent;
  let current;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[24](
        /*record*/
        ctx[29],
        ...args
      )
    );
  }
  cardmedia = new CardMedia_default({
    props: {
      $$slots: { default: [create_default_slot_73] },
      $$scope: { ctx }
    }
  });
  cardmedia.$on("click", click_handler);
  cardcontent = new CardContent_default({
    props: {
      $$slots: { default: [create_default_slot_412] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(cardmedia.$$.fragment);
      t3 = space();
      create_component(cardcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cardmedia, target, anchor);
      insert(target, t3, anchor);
      mount_component(cardcontent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const cardmedia_changes = {};
      if (dirty[0] & /*records, fitStyle*/
      384 | dirty[1] & /*$$scope*/
      8) {
        cardmedia_changes.$$scope = { dirty, ctx };
      }
      cardmedia.$set(cardmedia_changes);
      const cardcontent_changes = {};
      if (dirty[0] & /*getRecordColor, records, $app, fields, config*/
      793 | dirty[1] & /*$$scope*/
      8) {
        cardcontent_changes.$$scope = { dirty, ctx };
      }
      cardcontent.$set(cardcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardmedia.$$.fragment, local);
      transition_in(cardcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardmedia.$$.fragment, local);
      transition_out(cardcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cardmedia, detaching);
      if (detaching)
        detach(t3);
      destroy_component(cardcontent, detaching);
    }
  };
}
function create_each_block17(key_1, ctx) {
  let first;
  let card;
  let current;
  card = new Card_default2({
    props: {
      $$slots: { default: [create_default_slot_312] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(card.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty[0] & /*getRecordColor, records, $app, fields, config, fitStyle*/
      921 | dirty[1] & /*$$scope*/
      8) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_216(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t3;
  let iconbutton;
  let current;
  let each_value = (
    /*records*/
    ctx[8]
  );
  const get_key = (ctx2) => (
    /*record*/
    ctx2[29].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context17(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block17(key, child_ctx));
  }
  iconbutton = new IconButton_default({
    props: {
      icon: "plus",
      size: "lg",
      onClick: (
        /*func_3*/
        ctx[27]
      )
    }
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*getRecordColor, records, $app, handleRecordClick, fields, config, getCoverRealPath, fitStyle*/
      70553) {
        each_value = /*records*/
        ctx2[8];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t3.parentNode, outro_and_destroy_block, create_each_block17, t3, get_each_context17);
        check_outros();
      }
      const iconbutton_changes = {};
      if (dirty[0] & /*$app, project, api*/
      518)
        iconbutton_changes.onClick = /*func_3*/
        ctx2[27];
      iconbutton.$set(iconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(t3);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_128(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*records*/
      ctx2[8].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot34(ctx) {
  let viewheader;
  let t3;
  let viewcontent;
  let current;
  viewheader = new ViewHeader_default({
    props: {
      $$slots: { default: [create_default_slot_102] },
      $$scope: { ctx }
    }
  });
  viewcontent = new ViewContent_default({
    props: {
      $$slots: { default: [create_default_slot_128] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewheader.$$.fragment);
      t3 = space();
      create_component(viewcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewheader, target, anchor);
      insert(target, t3, anchor);
      mount_component(viewcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewheader_changes = {};
      if (dirty[0] & /*$app, config, fields, $i18n, coverField, textFields*/
      1649 | dirty[1] & /*$$scope*/
      8) {
        viewheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewheader.$set(viewheader_changes);
      const viewcontent_changes = {};
      if (dirty[0] & /*config, $app, project, api, records, getRecordColor, fields, fitStyle, $i18n*/
      1951 | dirty[1] & /*$$scope*/
      8) {
        viewcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewcontent.$set(viewcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewheader.$$.fragment, local);
      transition_in(viewcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewheader.$$.fragment, local);
      transition_out(viewcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewheader, detaching);
      if (detaching)
        detach(t3);
      destroy_component(viewcontent, detaching);
    }
  };
}
function create_fragment94(ctx) {
  let viewlayout;
  let current;
  viewlayout = new ViewLayout_default({
    props: {
      $$slots: { default: [create_default_slot34] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewlayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewlayout_changes = {};
      if (dirty[0] & /*config, $app, project, api, records, getRecordColor, fields, fitStyle, $i18n, coverField, textFields*/
      2047 | dirty[1] & /*$$scope*/
      8) {
        viewlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewlayout.$set(viewlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewlayout, detaching);
    }
  };
}
function instance94($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let textFields;
  let coverField;
  let fitStyle;
  let $app;
  let $i18n;
  component_subscribe($$self, app2, ($$value) => $$invalidate(9, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(10, $i18n = $$value));
  var _a;
  let { project } = $$props;
  let { frame } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  let { api: api2 } = $$props;
  let { getRecordColor } = $$props;
  function saveConfig(cfg) {
    $$invalidate(0, config = cfg);
    onConfigChange(cfg);
  }
  function getCoverRealPath(record) {
    if (!coverField) {
      return null;
    }
    const coverPath = record.values[coverField.name];
    if (!coverPath) {
      return null;
    }
    if (isString(coverPath)) {
      if (coverPath.startsWith("http://") || coverPath.startsWith("https://")) {
        return coverPath;
      }
      return getResourcePathFromLinkText(coverPath);
    }
    return null;
  }
  function getResourcePathFromLinkText(text2) {
    var _a2;
    const linkText = ((_a2 = parseObsidianLink(text2)) === null || _a2 === void 0 ? void 0 : _a2.linkText) || text2;
    const file = $app.metadataCache.getFirstLinkpathDest(linkText, "");
    if (file) {
      if (["png", "jpg", "jpeg", "gif", "bmp", "svg"].includes(file.extension)) {
        return $app.vault.getResourcePath(file);
      }
    }
    return null;
  }
  function handleCoverFieldChange(coverField2) {
    saveConfig(Object.assign(Object.assign({}, config), { coverField: coverField2 }));
  }
  function handleFitStyleChange(fitStyle2) {
    saveConfig(Object.assign(Object.assign({}, config), { fitStyle: fitStyle2 }));
  }
  function handleIncludeFieldChange(field, enabled) {
    const includedFields = new Set(config === null || config === void 0 ? void 0 : config.includeFields);
    if (enabled) {
      includedFields.add(field);
    } else {
      includedFields.delete(field);
    }
    saveConfig(Object.assign(Object.assign({}, config), { includeFields: [...includedFields] }));
  }
  function handleRecordClick(record) {
    new EditNoteModal($app, fields, (record2) => api2.updateRecord(record2, fields), record).open();
  }
  const change_handler = ({ detail }) => handleCoverFieldChange(detail);
  const change_handler_1 = ({ detail }) => handleFitStyleChange(detail);
  const func8 = (field) => {
    var _a2;
    return {
      label: field.name,
      value: field.name,
      enabled: !!((_a2 = config == null ? void 0 : config.includeFields) == null ? void 0 : _a2.includes(field.name))
    };
  };
  const func_15 = () => {
    new GallerySettingsModal(
      $app,
      config != null ? config : {},
      (value) => {
        saveConfig(value);
      }
    ).open();
  };
  const click_handler = (record, event) => {
    if (event.metaKey || event.ctrlKey) {
      $app.workspace.openLinkText(record.id, "", true);
    } else {
      handleRecordClick(record);
    }
  };
  const open_handler = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      handleRecordClick(record);
    }
  };
  const func_2 = (field) => {
    var _a2;
    return !!((_a2 = config == null ? void 0 : config.includeFields) == null ? void 0 : _a2.includes(field.name));
  };
  const func_3 = () => {
    new CreateNoteModal(
      $app,
      project,
      (name, templatePath, project2) => {
        api2.addRecord(createDataRecord(name, project2), templatePath);
      }
    ).open();
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(17, frame = $$props2.frame);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(18, onConfigChange = $$props2.onConfigChange);
    if ("api" in $$props2)
      $$invalidate(2, api2 = $$props2.api);
    if ("getRecordColor" in $$props2)
      $$invalidate(3, getRecordColor = $$props2.getRecordColor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*frame*/
    131072) {
      $:
        $$invalidate(4, { fields, records } = frame, fields, ($$invalidate(8, records), $$invalidate(17, frame)));
    }
    if ($$self.$$.dirty[0] & /*fields*/
    16) {
      $:
        $$invalidate(5, textFields = fields.filter((field) => !field.repeated).filter((field) => field.type === "string" /* String */));
    }
    if ($$self.$$.dirty[0] & /*textFields, config*/
    33) {
      $:
        $$invalidate(6, coverField = textFields.find((field) => (config === null || config === void 0 ? void 0 : config.coverField) === field.name));
    }
    if ($$self.$$.dirty[0] & /*config, _a*/
    524289) {
      $:
        $$invalidate(7, fitStyle = $$invalidate(19, _a = config === null || config === void 0 ? void 0 : config.fitStyle) !== null && _a !== void 0 ? _a : "cover");
    }
  };
  return [
    config,
    project,
    api2,
    getRecordColor,
    fields,
    textFields,
    coverField,
    fitStyle,
    records,
    $app,
    $i18n,
    saveConfig,
    getCoverRealPath,
    handleCoverFieldChange,
    handleFitStyleChange,
    handleIncludeFieldChange,
    handleRecordClick,
    frame,
    onConfigChange,
    _a,
    change_handler,
    change_handler_1,
    func8,
    func_15,
    click_handler,
    open_handler,
    func_2,
    func_3
  ];
}
var GalleryView = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance94,
      create_fragment94,
      safe_not_equal,
      {
        project: 1,
        frame: 17,
        config: 0,
        onConfigChange: 18,
        api: 2,
        getRecordColor: 3
      },
      add_css58,
      [-1, -1]
    );
  }
};
var GalleryView_default = GalleryView;

// src/views/Gallery/gallery-view.ts
var GalleryView2 = class extends ProjectView {
  getViewType() {
    return "gallery";
  }
  getDisplayName() {
    return "Gallery";
  }
  getIcon() {
    return "layout-grid";
  }
  onData(_0) {
    return __async(this, arguments, function* ({ data }) {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$set({ frame: data });
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.view = new GalleryView_default({
        target: props.contentEl,
        props: {
          frame: { fields: [], records: [] },
          api: props.viewApi,
          project: props.project,
          config: props.config,
          onConfigChange: props.saveConfig,
          getRecordColor: props.getRecordColor
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/views/Table/components/DataGrid/DataGrid.svelte
var import_obsidian51 = require("obsidian");

// src/views/Table/components/DataGrid/GridRow.svelte
var import_obsidian49 = require("obsidian");

// src/views/Table/components/DataGrid/GridCell/Resizer.svelte
function add_css59(target) {
  append_styles(target, "svelte-1ixawe6", ".handle.svelte-1ixawe6{position:absolute;right:-3px;width:6px;min-width:6px;height:100%;border-radius:1px;z-index:1}.handle.svelte-1ixawe6:hover{background-color:var(--interactive-accent);cursor:ew-resize}.visible.svelte-1ixawe6{background-color:var(--interactive-accent);cursor:ew-resize}");
}
function create_fragment95(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "handle svelte-1ixawe6");
      toggle_class(
        span,
        "visible",
        /*start*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mouseup",
            /*stopResize*/
            ctx[2]
          ),
          listen(
            window,
            "mousemove",
            /*resize*/
            ctx[3]
          ),
          listen(
            span,
            "mousedown",
            /*startResize*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*start*/
      1) {
        toggle_class(
          span,
          "visible",
          /*start*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance95($$self, $$props, $$invalidate) {
  let { width } = $$props;
  let { onChange } = $$props;
  let { onFinalize } = $$props;
  let { min: min3 } = $$props;
  let start2;
  let initial;
  function startResize(event) {
    event.stopPropagation();
    $$invalidate(0, start2 = event.pageX);
    initial = width;
  }
  function stopResize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min3) {
        onFinalize(width);
      }
    }
    $$invalidate(0, start2 = null);
    initial = null;
  }
  function resize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min3) {
        onChange(newWidth);
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("onChange" in $$props2)
      $$invalidate(5, onChange = $$props2.onChange);
    if ("onFinalize" in $$props2)
      $$invalidate(6, onFinalize = $$props2.onFinalize);
    if ("min" in $$props2)
      $$invalidate(7, min3 = $$props2.min);
  };
  return [start2, startResize, stopResize, resize, width, onChange, onFinalize, min3];
}
var Resizer = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance95,
      create_fragment95,
      safe_not_equal,
      {
        width: 4,
        onChange: 5,
        onFinalize: 6,
        min: 7
      },
      add_css59
    );
  }
};
var Resizer_default = Resizer;

// src/views/Table/components/DataGrid/GridCell/GridCell.svelte
function add_css60(target) {
  append_styles(target, "svelte-uwn3nn", "div.svelte-uwn3nn{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:var(--background-primary);border-right:1px solid var(--background-modifier-border);border-left-color:var(--background-modifier-border);border-bottom:1px solid var(--background-modifier-border);width:100%;min-height:30px}.selected.svelte-uwn3nn{box-shadow:0 0 0 3px var(--interactive-accent);z-index:4;padding:0}.columnHeader.svelte-uwn3nn{background-color:var(--background-secondary);font-weight:500;text-align:center;justify-content:space-between;padding:0 4px}.header.svelte-uwn3nn{background-color:var(--background-secondary);position:sticky;left:60px}.rowHeader.svelte-uwn3nn{left:0px;justify-content:center;z-index:5;background-color:var(--background-secondary);font-weight:500;padding:3px;gap:4px;position:sticky}");
}
var get_read_slot_changes_2 = (dirty) => ({});
var get_read_slot_context_2 = (ctx) => ({});
var get_hover_slot_changes_1 = (dirty) => ({});
var get_hover_slot_context_1 = (ctx) => ({});
var get_selected_slot_changes = (dirty) => ({});
var get_selected_slot_context = (ctx) => ({});
var get_read_slot_changes_1 = (dirty) => ({});
var get_read_slot_context_1 = (ctx) => ({});
var get_edit_slot_changes = (dirty) => ({});
var get_edit_slot_context = (ctx) => ({});
var get_read_slot_changes = (dirty) => ({});
var get_read_slot_context = (ctx) => ({});
var get_hover_slot_changes = (dirty) => ({});
var get_hover_slot_context = (ctx) => ({});
function create_else_block_12(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t3;
  let div_role_value;
  let div_aria_selected_value;
  let div_style_value;
  let div_tabindex_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_35, create_if_block_53, create_if_block_62, create_else_block_3];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[18].edit && /*edit*/
      ctx2[1]
    )
      return 0;
    if (
      /*$$slots*/
      ctx2[18].selected && /*selected*/
      ctx2[0]
    )
      return 1;
    if (
      /*$$slots*/
      ctx2[18].hover && /*hover*/
      ctx2[12]
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*resizable*/
    ctx[2] && create_if_block_29(ctx)
  );
  return {
    c() {
      div = element("div");
      if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "role", div_role_value = /*role*/
      ctx[17]());
      attr(div, "aria-selected", div_aria_selected_value = /*rowHeader*/
      ctx[8] || /*columnHeader*/
      ctx[7] ? void 0 : (
        /*selected*/
        ctx[0]
      ));
      attr(
        div,
        "aria-colindex",
        /*colindex*/
        ctx[6]
      );
      attr(div, "style", div_style_value = `width: ${/*column*/
      ctx[5].width}px`);
      attr(div, "tabindex", div_tabindex_value = !/*columnHeader*/
      ctx[7] && !/*rowHeader*/
      ctx[8] ? 1 : void 0);
      attr(div, "class", "svelte-uwn3nn");
      toggle_class(
        div,
        "header",
        /*column*/
        ctx[5].header
      );
      toggle_class(
        div,
        "selected",
        /*selected*/
        ctx[0]
      );
      toggle_class(
        div,
        "rowHeader",
        /*rowHeader*/
        ctx[8]
      );
      toggle_class(
        div,
        "columnHeader",
        /*columnHeader*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append4(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      ctx[30](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*handleClick*/
            ctx[13]
          ),
          listen(
            div,
            "dblclick",
            /*handleDoubleClick*/
            ctx[14]
          ),
          listen(
            div,
            "mousedown",
            /*mousedown_handler_1*/
            ctx[26]
          ),
          listen(
            div,
            "mouseenter",
            /*mouseenter_handler_1*/
            ctx[31]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave_handler_1*/
            ctx[32]
          ),
          listen(
            div,
            "focus",
            /*focus_handler*/
            ctx[33]
          ),
          listen(
            div,
            "blur",
            /*handleBlur*/
            ctx[16]
          ),
          listen(
            div,
            "keydown",
            /*handleKeyDown*/
            ctx[15]
          ),
          action_destroyer(useClickOutside_action = useClickOutside2.call(
            null,
            div,
            /*useClickOutside_function*/
            ctx[34]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t3);
      }
      if (
        /*resizable*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*resizable*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_29(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*rowHeader, columnHeader, selected*/
      385 && div_aria_selected_value !== (div_aria_selected_value = /*rowHeader*/
      ctx2[8] || /*columnHeader*/
      ctx2[7] ? void 0 : (
        /*selected*/
        ctx2[0]
      ))) {
        attr(div, "aria-selected", div_aria_selected_value);
      }
      if (!current || dirty[0] & /*colindex*/
      64) {
        attr(
          div,
          "aria-colindex",
          /*colindex*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*column*/
      32 && div_style_value !== (div_style_value = `width: ${/*column*/
      ctx2[5].width}px`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty[0] & /*columnHeader, rowHeader*/
      384 && div_tabindex_value !== (div_tabindex_value = !/*columnHeader*/
      ctx2[7] && !/*rowHeader*/
      ctx2[8] ? 1 : void 0)) {
        attr(div, "tabindex", div_tabindex_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty[0] & /*onEditChange, selected*/
      513)
        useClickOutside_action.update.call(
          null,
          /*useClickOutside_function*/
          ctx2[34]
        );
      if (!current || dirty[0] & /*column*/
      32) {
        toggle_class(
          div,
          "header",
          /*column*/
          ctx2[5].header
        );
      }
      if (!current || dirty[0] & /*selected*/
      1) {
        toggle_class(
          div,
          "selected",
          /*selected*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*rowHeader*/
      256) {
        toggle_class(
          div,
          "rowHeader",
          /*rowHeader*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*columnHeader*/
      128) {
        toggle_class(
          div,
          "columnHeader",
          /*columnHeader*/
          ctx2[7]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[30](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block32(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t3;
  let span;
  let div_role_value;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_116, create_else_block10];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[18].hover && /*hover*/
      ctx2[12]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      t3 = space();
      span = element("span");
      set_style(
        span,
        "background-color",
        /*color*/
        ctx[10] ? (
          /*color*/
          ctx[10]
        ) : "transparent"
      );
      set_style(span, "width", "5px");
      set_style(span, "border-radius", "9999px");
      set_style(span, "position", "absolute");
      set_style(span, "right", "4px");
      set_style(span, "height", "calc(100% - 8px)");
      attr(div, "role", div_role_value = /*role*/
      ctx[17]());
      attr(div, "style", div_style_value = `width: ${/*column*/
      ctx[5].width}px`);
      attr(div, "class", "svelte-uwn3nn");
      toggle_class(
        div,
        "rowHeader",
        /*rowHeader*/
        ctx[8]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append4(div, t3);
      append4(div, span);
      ctx[27](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[28]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[29]
          ),
          listen(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t3);
      }
      if (!current || dirty[0] & /*color*/
      1024) {
        set_style(
          span,
          "background-color",
          /*color*/
          ctx2[10] ? (
            /*color*/
            ctx2[10]
          ) : "transparent"
        );
      }
      if (!current || dirty[0] & /*column*/
      32 && div_style_value !== (div_style_value = `width: ${/*column*/
      ctx2[5].width}px`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty[0] & /*rowHeader*/
      256) {
        toggle_class(
          div,
          "rowHeader",
          /*rowHeader*/
          ctx2[8]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_3(ctx) {
  let current;
  const read_slot_template = (
    /*#slots*/
    ctx[24].read
  );
  const read_slot = create_slot(
    read_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_read_slot_context_2
  );
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            read_slot,
            read_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              read_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_read_slot_changes_2
            ),
            get_read_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_62(ctx) {
  let current;
  const hover_slot_template = (
    /*#slots*/
    ctx[24].hover
  );
  const hover_slot = create_slot(
    hover_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_hover_slot_context_1
  );
  return {
    c() {
      if (hover_slot)
        hover_slot.c();
    },
    m(target, anchor) {
      if (hover_slot) {
        hover_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (hover_slot) {
        if (hover_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            hover_slot,
            hover_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              hover_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_hover_slot_changes_1
            ),
            get_hover_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hover_slot, local);
      current = true;
    },
    o(local) {
      transition_out(hover_slot, local);
      current = false;
    },
    d(detaching) {
      if (hover_slot)
        hover_slot.d(detaching);
    }
  };
}
function create_if_block_53(ctx) {
  let current;
  const selected_slot_template = (
    /*#slots*/
    ctx[24].selected
  );
  const selected_slot = create_slot(
    selected_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_selected_slot_context
  );
  return {
    c() {
      if (selected_slot)
        selected_slot.c();
    },
    m(target, anchor) {
      if (selected_slot) {
        selected_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (selected_slot) {
        if (selected_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            selected_slot,
            selected_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              selected_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_selected_slot_changes
            ),
            get_selected_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selected_slot, local);
      current = true;
    },
    o(local) {
      transition_out(selected_slot, local);
      current = false;
    },
    d(detaching) {
      if (selected_slot)
        selected_slot.d(detaching);
    }
  };
}
function create_if_block_35(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_44, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*column*/
      ctx2[5].editable
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_2(ctx) {
  let current;
  const read_slot_template = (
    /*#slots*/
    ctx[24].read
  );
  const read_slot = create_slot(
    read_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_read_slot_context_1
  );
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            read_slot,
            read_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              read_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_read_slot_changes_1
            ),
            get_read_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_44(ctx) {
  let current;
  const edit_slot_template = (
    /*#slots*/
    ctx[24].edit
  );
  const edit_slot = create_slot(
    edit_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_edit_slot_context
  );
  return {
    c() {
      if (edit_slot)
        edit_slot.c();
    },
    m(target, anchor) {
      if (edit_slot) {
        edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (edit_slot) {
        if (edit_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            edit_slot,
            edit_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              edit_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_edit_slot_changes
            ),
            get_edit_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (edit_slot)
        edit_slot.d(detaching);
    }
  };
}
function create_if_block_29(ctx) {
  var _a;
  let resizer;
  let current;
  resizer = new Resizer_default({
    props: {
      width: (
        /*column*/
        (_a = ctx[5].width) != null ? _a : 180
      ),
      min: 100,
      onChange: (
        /*onResize*/
        ctx[3]
      ),
      onFinalize: (
        /*onFinalizeResize*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(resizer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(resizer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const resizer_changes = {};
      if (dirty[0] & /*column*/
      32)
        resizer_changes.width = /*column*/
        (_a2 = ctx2[5].width) != null ? _a2 : 180;
      if (dirty[0] & /*onResize*/
      8)
        resizer_changes.onChange = /*onResize*/
        ctx2[3];
      if (dirty[0] & /*onFinalizeResize*/
      16)
        resizer_changes.onFinalize = /*onFinalizeResize*/
        ctx2[4];
      resizer.$set(resizer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(resizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(resizer, detaching);
    }
  };
}
function create_else_block10(ctx) {
  let current;
  const read_slot_template = (
    /*#slots*/
    ctx[24].read
  );
  const read_slot = create_slot(
    read_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_read_slot_context
  );
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            read_slot,
            read_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              read_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_read_slot_changes
            ),
            get_read_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_116(ctx) {
  let current;
  const hover_slot_template = (
    /*#slots*/
    ctx[24].hover
  );
  const hover_slot = create_slot(
    hover_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_hover_slot_context
  );
  return {
    c() {
      if (hover_slot)
        hover_slot.c();
    },
    m(target, anchor) {
      if (hover_slot) {
        hover_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (hover_slot) {
        if (hover_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            hover_slot,
            hover_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              hover_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_hover_slot_changes
            ),
            get_hover_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hover_slot, local);
      current = true;
    },
    o(local) {
      transition_out(hover_slot, local);
      current = false;
    },
    d(detaching) {
      if (hover_slot)
        hover_slot.d(detaching);
    }
  };
}
function create_fragment96(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block32, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rowHeader*/
      ctx2[8]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance96($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { edit = false } = $$props;
  let { resizable = false } = $$props;
  let { onResize = () => {
  } } = $$props;
  let { onFinalizeResize = () => {
  } } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { columnHeader = false } = $$props;
  let { rowHeader = false } = $$props;
  let { onEditChange = (value) => {
    $$invalidate(1, edit = value);
  } } = $$props;
  let { color = null } = $$props;
  let { onCopy = () => {
  } } = $$props;
  let { onCut = () => {
  } } = $$props;
  let { onPaste = () => {
  } } = $$props;
  const dispatch2 = createEventDispatcher();
  let hover = false;
  let ref;
  function handleClick() {
    if (!column.header && !columnHeader && !rowHeader) {
      $$invalidate(0, selected = true);
    }
  }
  function handleDoubleClick() {
    if (!column.header && !columnHeader && !rowHeader && column.editable) {
      onEditChange(true);
    }
  }
  function handleKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      switch (event.key) {
        case "c":
          onCopy();
          break;
        case "x":
          onCut();
          break;
        case "v":
          onPaste();
          break;
      }
    }
    switch (event.key) {
      case "Enter":
        if (edit) {
          onEditChange(false);
          ref.focus();
        } else {
          onEditChange(true);
        }
        break;
      case "Escape":
        onEditChange(false);
        ref.focus();
        break;
      case "ArrowLeft":
        if (!edit) {
          dispatch2("navigate", [colindex - 1, rowindex]);
          event.preventDefault();
        }
        break;
      case "ArrowRight":
        if (!edit) {
          dispatch2("navigate", [colindex + 1, rowindex]);
          event.preventDefault();
        }
        break;
      case "ArrowUp":
        if (!edit) {
          dispatch2("navigate", [colindex, rowindex - 1]);
          event.preventDefault();
        }
        break;
      case "ArrowDown":
        if (!edit) {
          dispatch2("navigate", [colindex, rowindex + 1]);
          event.preventDefault();
        }
        break;
      case "Tab":
        if (event.shiftKey) {
          dispatch2("navigate", [colindex - 1, rowindex, true]);
        } else {
          dispatch2("navigate", [colindex + 1, rowindex, true]);
        }
        event.preventDefault();
        break;
    }
  }
  function handleBlur(event) {
    $$invalidate(12, hover = false);
    if (event.currentTarget instanceof HTMLDivElement && event.relatedTarget instanceof HTMLElement && !event.currentTarget.contains(event.relatedTarget)) {
      $$invalidate(0, selected = false);
      onEditChange(false);
    }
  }
  function role() {
    if (columnHeader) {
      return "columnheader";
    } else if (rowHeader) {
      return "rowheader";
    } else {
      return "gridcell";
    }
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(11, ref);
    });
  }
  const mouseenter_handler = () => $$invalidate(12, hover = true);
  const mouseleave_handler = () => $$invalidate(12, hover = false);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(11, ref);
    });
  }
  const mouseenter_handler_1 = () => $$invalidate(12, hover = true);
  const mouseleave_handler_1 = () => $$invalidate(12, hover = false);
  const focus_handler = () => {
    $$invalidate(12, hover = true);
    $$invalidate(0, selected = true);
  };
  const useClickOutside_function = () => {
    onEditChange(false);
    $$invalidate(0, selected = false);
  };
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("resizable" in $$props2)
      $$invalidate(2, resizable = $$props2.resizable);
    if ("onResize" in $$props2)
      $$invalidate(3, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(4, onFinalizeResize = $$props2.onFinalizeResize);
    if ("column" in $$props2)
      $$invalidate(5, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(19, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(6, colindex = $$props2.colindex);
    if ("columnHeader" in $$props2)
      $$invalidate(7, columnHeader = $$props2.columnHeader);
    if ("rowHeader" in $$props2)
      $$invalidate(8, rowHeader = $$props2.rowHeader);
    if ("onEditChange" in $$props2)
      $$invalidate(9, onEditChange = $$props2.onEditChange);
    if ("color" in $$props2)
      $$invalidate(10, color = $$props2.color);
    if ("onCopy" in $$props2)
      $$invalidate(20, onCopy = $$props2.onCopy);
    if ("onCut" in $$props2)
      $$invalidate(21, onCut = $$props2.onCut);
    if ("onPaste" in $$props2)
      $$invalidate(22, onPaste = $$props2.onPaste);
    if ("$$scope" in $$props2)
      $$invalidate(23, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*selected, ref*/
    2049) {
      $:
        if (selected && ref) {
          ref.focus();
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
    }
  };
  return [
    selected,
    edit,
    resizable,
    onResize,
    onFinalizeResize,
    column,
    colindex,
    columnHeader,
    rowHeader,
    onEditChange,
    color,
    ref,
    hover,
    handleClick,
    handleDoubleClick,
    handleKeyDown,
    handleBlur,
    role,
    $$slots,
    rowindex,
    onCopy,
    onCut,
    onPaste,
    $$scope,
    slots,
    mousedown_handler,
    mousedown_handler_1,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    div_binding_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    focus_handler,
    useClickOutside_function
  ];
}
var GridCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance96,
      create_fragment96,
      safe_not_equal,
      {
        selected: 0,
        edit: 1,
        resizable: 2,
        onResize: 3,
        onFinalizeResize: 4,
        column: 5,
        rowindex: 19,
        colindex: 6,
        columnHeader: 7,
        rowHeader: 8,
        onEditChange: 9,
        color: 10,
        onCopy: 20,
        onCut: 21,
        onPaste: 22
      },
      add_css60,
      [-1, -1]
    );
  }
};
var GridCell_default = GridCell;

// src/views/Table/components/DataGrid/GridCell/GridBooleanCell/GridBooleanCell.svelte
function create_if_block33(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: (
        /*value*/
        ctx[0]
      ),
      disabled: !/*column*/
      ctx[2].editable
    }
  });
  switch_1.$on(
    "check",
    /*check_handler_1*/
    ctx[7]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & /*value*/
      1)
        switch_1_changes.checked = /*value*/
        ctx2[0];
      if (dirty & /*column*/
      4)
        switch_1_changes.disabled = !/*column*/
        ctx2[2].editable;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_read_slot(ctx) {
  let show_if = isBoolean(
    /*value*/
    ctx[0]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block33(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        show_if = isBoolean(
          /*value*/
          ctx2[0]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block33(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot(ctx) {
  var _a;
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      slot: "edit",
      checked: (
        /*value*/
        (_a = ctx[0]) != null ? _a : false
      )
    }
  });
  switch_1.$on(
    "check",
    /*check_handler*/
    ctx[6]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const switch_1_changes = {};
      if (dirty & /*value*/
      1)
        switch_1_changes.checked = /*value*/
        (_a2 = ctx2[0]) != null ? _a2 : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment97(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      column: (
        /*column*/
        ctx[2]
      ),
      $$slots: {
        edit: [create_edit_slot],
        read: [create_read_slot]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[8]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & /*selected*/
      32)
        gridcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*column*/
      4)
        gridcell_changes.column = /*column*/
        ctx2[2];
      if (dirty & /*$$scope, value, onChange, column*/
      1031) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance97($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  const check_handler = ({ detail: checked }) => onChange(checked);
  const check_handler_1 = ({ detail: checked }) => onChange(checked);
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    check_handler,
    check_handler_1,
    mousedown_handler,
    navigate_handler
  ];
}
var GridBooleanCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance97, create_fragment97, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridBooleanCell_default = GridBooleanCell;

// src/views/Table/components/DataGrid/GridCell/GridDateCell/GridDateCell.svelte
function create_if_block34(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      value: new Intl.DateTimeFormat().format(
        /*value*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & /*value*/
      1)
        textlabel_changes.value = new Intl.DateTimeFormat().format(
          /*value*/
          ctx2[0]
        );
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_read_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*value*/
    ctx[0] && create_if_block34(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*value*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block34(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot2(ctx) {
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: (
        /*value*/
        ctx[0] != void 0 ? (
          /*value*/
          ctx[0]
        ) : null
      ),
      embed: true
    }
  });
  dateinput.$on(
    "change",
    /*change_handler*/
    ctx[7]
  );
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dateinput_changes = {};
      if (dirty & /*value*/
      1)
        dateinput_changes.value = /*value*/
        ctx2[0] != void 0 ? (
          /*value*/
          ctx2[0]
        ) : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_fragment98(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      edit: (
        /*edit*/
        ctx[6]
      ),
      onEditChange: (
        /*func*/
        ctx[8]
      ),
      column: (
        /*column*/
        ctx[2]
      ),
      onCopy: (
        /*func_1*/
        ctx[9]
      ),
      $$slots: {
        edit: [create_edit_slot2],
        read: [create_read_slot2]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[10]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[11]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & /*selected*/
      32)
        gridcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*edit*/
      64)
        gridcell_changes.edit = /*edit*/
        ctx2[6];
      if (dirty & /*edit*/
      64)
        gridcell_changes.onEditChange = /*func*/
        ctx2[8];
      if (dirty & /*column*/
      4)
        gridcell_changes.column = /*column*/
        ctx2[2];
      if (dirty & /*value*/
      1)
        gridcell_changes.onCopy = /*func_1*/
        ctx2[9];
      if (dirty & /*$$scope, value, edit, onChange*/
      4163) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance98($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const change_handler = ({ detail: value2 }) => {
    $$invalidate(6, edit = false);
    onChange(value2 != null ? value2 : void 0);
  };
  const func8 = (mode) => {
    $$invalidate(6, edit = mode);
  };
  const func_15 = () => {
    if (value) {
      navigator.clipboard.writeText(new Intl.DateTimeFormat().format(value));
    }
  };
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    edit,
    change_handler,
    func8,
    func_15,
    mousedown_handler,
    navigate_handler
  ];
}
var GridDateCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance98, create_fragment98, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridDateCell_default = GridDateCell;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberLabel.svelte
function add_css61(target) {
  append_styles(target, "svelte-1636x3v", "div.svelte-1636x3v{width:100%;padding:6px;text-align:right}");
}
function create_fragment99(ctx) {
  let div;
  let t_value = new Intl.NumberFormat().format(
    /*value*/
    ctx[0]
  ) + "";
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(t_value);
      attr(div, "class", "svelte-1636x3v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && t_value !== (t_value = new Intl.NumberFormat().format(
        /*value*/
        ctx2[0]
      ) + ""))
        set_data(t3, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance99($$self, $$props, $$invalidate) {
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value];
}
var NumberLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance99, create_fragment99, safe_not_equal, { value: 0 }, add_css61);
  }
};
var NumberLabel_default = NumberLabel;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberInput.svelte
function add_css62(target) {
  append_styles(target, "svelte-1uq2i75", "input.svelte-1uq2i75{all:unset;background-color:var(--background-primary);box-sizing:border-box;width:100%;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal);text-align:right}input.svelte-1uq2i75:focus{box-shadow:none !important}input.svelte-1uq2i75:hover{background-color:transparent}");
}
function create_fragment100(ctx) {
  let input;
  let input_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "tabindex", input_tabindex_value = -1);
      attr(input, "type", "number");
      input.value = /*value*/
      ctx[0];
      attr(input, "class", "svelte-1uq2i75");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[6](input);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*handleInput*/
            ctx[2]
          ),
          listen(
            input,
            "keypress",
            /*handleKeyup*/
            ctx[3]
          ),
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        input.value = /*value*/
        ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance100($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let ref;
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
      onChange(value);
    }
  }
  function handleKeyup(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  onMount(() => {
    ref.focus();
  });
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(4, onChange = $$props2.onChange);
  };
  return [value, ref, handleInput, handleKeyup, onChange, blur_handler, input_binding];
}
var NumberInput2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance100, create_fragment100, safe_not_equal, { value: 0, onChange: 4 }, add_css62);
  }
};
var NumberInput_default2 = NumberInput2;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/GridNumberCell.svelte
function create_if_block35(ctx) {
  let numberlabel;
  let current;
  numberlabel = new NumberLabel_default({ props: { value: (
    /*value*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(numberlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberlabel_changes = {};
      if (dirty & /*value*/
      2)
        numberlabel_changes.value = /*value*/
        ctx2[1];
      numberlabel.$set(numberlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberlabel, detaching);
    }
  };
}
function create_read_slot3(ctx) {
  let show_if = isNumber(
    /*value*/
    ctx[1]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block35(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      2)
        show_if = isNumber(
          /*value*/
          ctx2[1]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot3(ctx) {
  var _a;
  let numberinput;
  let current;
  numberinput = new NumberInput_default2({
    props: {
      slot: "edit",
      value: (
        /*value*/
        (_a = ctx[1]) != null ? _a : 0
      ),
      onChange: (
        /*func*/
        ctx[7]
      )
    }
  });
  numberinput.$on(
    "blur",
    /*blur_handler*/
    ctx[8]
  );
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const numberinput_changes = {};
      if (dirty & /*value*/
      2)
        numberinput_changes.value = /*value*/
        (_a2 = ctx2[1]) != null ? _a2 : 0;
      if (dirty & /*onChange*/
      4)
        numberinput_changes.onChange = /*func*/
        ctx2[7];
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_fragment101(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[12](value);
  }
  function gridcell_selected_binding(value) {
    ctx[13](value);
  }
  let gridcell_props = {
    column: (
      /*column*/
      ctx[3]
    ),
    rowindex: (
      /*rowindex*/
      ctx[4]
    ),
    colindex: (
      /*colindex*/
      ctx[5]
    ),
    onCopy: (
      /*func_1*/
      ctx[9]
    ),
    onCut: (
      /*func_2*/
      ctx[10]
    ),
    onPaste: (
      /*func_3*/
      ctx[11]
    ),
    $$slots: {
      edit: [create_edit_slot3],
      read: [create_read_slot3]
    },
    $$scope: { ctx }
  };
  if (
    /*edit*/
    ctx[6] !== void 0
  ) {
    gridcell_props.edit = /*edit*/
    ctx[6];
  }
  if (
    /*selected*/
    ctx[0] !== void 0
  ) {
    gridcell_props.selected = /*selected*/
    ctx[0];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind6(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind6(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[14]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[15]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & /*column*/
      8)
        gridcell_changes.column = /*column*/
        ctx2[3];
      if (dirty & /*rowindex*/
      16)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[4];
      if (dirty & /*colindex*/
      32)
        gridcell_changes.colindex = /*colindex*/
        ctx2[5];
      if (dirty & /*value*/
      2)
        gridcell_changes.onCopy = /*func_1*/
        ctx2[9];
      if (dirty & /*value, onChange*/
      6)
        gridcell_changes.onCut = /*func_2*/
        ctx2[10];
      if (dirty & /*onChange*/
      4)
        gridcell_changes.onPaste = /*func_3*/
        ctx2[11];
      if (dirty & /*$$scope, value, onChange, selected, edit*/
      65607) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & /*edit*/
      64) {
        updating_edit = true;
        gridcell_changes.edit = /*edit*/
        ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & /*selected*/
      1) {
        updating_selected = true;
        gridcell_changes.selected = /*selected*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance101($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const func8 = (value2) => {
    onChange(value2);
  };
  const blur_handler = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(0, selected = false);
      $$invalidate(6, edit = false);
    }
  };
  const func_15 = () => {
    navigator.clipboard.writeText((value == null ? void 0 : value.toString()) || "");
  };
  const func_2 = () => {
    navigator.clipboard.writeText((value == null ? void 0 : value.toString()) || "");
    onChange(void 0);
  };
  const func_3 = () => __async(this, null, function* () {
    onChange(parseFloat(yield navigator.clipboard.readText()));
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(0, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  return [
    selected,
    value,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    func8,
    blur_handler,
    func_15,
    func_2,
    func_3,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridNumberCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance101, create_fragment101, safe_not_equal, {
      value: 1,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 0
    });
  }
};
var GridNumberCell_default = GridNumberCell;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/TextLabel.svelte
var import_obsidian47 = require("obsidian");
function add_css63(target) {
  append_styles(target, "svelte-6n2r4e", "div.svelte-6n2r4e{padding:6px;width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}div.svelte-6n2r4e p:first-child{margin-top:0}div.svelte-6n2r4e p:last-child{margin-bottom:0}");
}
function create_else_block11(ctx) {
  let div;
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(
        /*value*/
        ctx[0]
      );
      attr(div, "class", "svelte-6n2r4e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1)
        set_data(
          t3,
          /*value*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block36(ctx) {
  let div;
  let useMarkdown_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "svelte-6n2r4e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useMarkdown_action = /*useMarkdown*/
          ctx[2].call(
            null,
            div,
            /*value*/
            ctx[0]
          )),
          listen(
            div,
            "click",
            /*handleClick*/
            ctx[3]
          ),
          listen(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (useMarkdown_action && is_function(useMarkdown_action.update) && dirty & /*value*/
      1)
        useMarkdown_action.update.call(
          null,
          /*value*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment102(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*richText*/
      ctx2[1]
    )
      return create_if_block36;
    return create_else_block11;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance102($$self, $$props, $$invalidate) {
  let $app;
  let $view;
  component_subscribe($$self, app2, ($$value) => $$invalidate(6, $app = $$value));
  component_subscribe($$self, view, ($$value) => $$invalidate(7, $view = $$value));
  var _a;
  let { value } = $$props;
  let { richText = false } = $$props;
  const sourcePath = (_a = getContext("sourcePath")) !== null && _a !== void 0 ? _a : "";
  function useMarkdown(node, value2) {
    import_obsidian47.MarkdownRenderer.renderMarkdown(value2, node, sourcePath, $view);
    return {
      update(newValue) {
        node.empty();
        import_obsidian47.MarkdownRenderer.renderMarkdown(newValue, node, sourcePath, $view);
      }
    };
  }
  function handleClick(event) {
    const targetEl = event.target;
    const closestAnchor = targetEl.tagName === "A" ? targetEl : targetEl.closest("a");
    if (!closestAnchor) {
      return;
    }
    if (closestAnchor.hasClass("internal-link")) {
      event.preventDefault();
      const href = closestAnchor.getAttr("href");
      const newLeaf = event.button === 1 || event.ctrlKey || event.metaKey;
      if (href) {
        $app.workspace.openLinkText(href, sourcePath, newLeaf);
      }
    }
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("richText" in $$props2)
      $$invalidate(1, richText = $$props2.richText);
  };
  return [value, richText, useMarkdown, handleClick, keypress_handler];
}
var TextLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance102, create_fragment102, safe_not_equal, { value: 0, richText: 1 }, add_css63);
  }
};
var TextLabel_default = TextLabel;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/GridTextCell.svelte
function create_read_slot4(ctx) {
  var _a, _b;
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      slot: "read",
      richText: (
        /*column*/
        (_b = (_a = ctx[3].typeConfig) == null ? void 0 : _a.richText) != null ? _b : false
      ),
      value: (
        /*value*/
        ctx[0] || ""
      )
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const textlabel_changes = {};
      if (dirty & /*column*/
      8)
        textlabel_changes.richText = /*column*/
        (_b2 = (_a2 = ctx2[3].typeConfig) == null ? void 0 : _a2.richText) != null ? _b2 : false;
      if (dirty & /*value*/
      1)
        textlabel_changes.value = /*value*/
        ctx2[0] || "";
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_else_block12(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      autoFocus: true,
      value: (
        /*value*/
        ctx[0] || ""
      ),
      embed: true,
      width: "100%"
    }
  });
  textinput.$on(
    "input",
    /*input_handler*/
    ctx[13]
  );
  textinput.$on(
    "blur",
    /*blur_handler_1*/
    ctx[14]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*value*/
      1)
        textinput_changes.value = /*value*/
        ctx2[0] || "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block37(ctx) {
  let autocomplete;
  let current;
  autocomplete = new Autocomplete_default({
    props: {
      value: (
        /*value*/
        ctx[0] || ""
      ),
      options: (
        /*options*/
        ctx[7]
      ),
      embed: true,
      autoFocus: true
    }
  });
  autocomplete.$on(
    "change",
    /*change_handler*/
    ctx[11]
  );
  autocomplete.$on(
    "blur",
    /*blur_handler*/
    ctx[12]
  );
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const autocomplete_changes = {};
      if (dirty & /*value*/
      1)
        autocomplete_changes.value = /*value*/
        ctx2[0] || "";
      if (dirty & /*options*/
      128)
        autocomplete_changes.options = /*options*/
        ctx2[7];
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function create_edit_slot4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block37, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*options*/
      ctx2[7].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment103(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[18](value);
  }
  function gridcell_selected_binding(value) {
    ctx[19](value);
  }
  let gridcell_props = {
    column: (
      /*column*/
      ctx[3]
    ),
    rowindex: (
      /*rowindex*/
      ctx[4]
    ),
    colindex: (
      /*colindex*/
      ctx[5]
    ),
    onCopy: (
      /*func*/
      ctx[15]
    ),
    onCut: (
      /*func_1*/
      ctx[16]
    ),
    onPaste: (
      /*func_2*/
      ctx[17]
    ),
    $$slots: {
      edit: [create_edit_slot4],
      read: [create_read_slot4]
    },
    $$scope: { ctx }
  };
  if (
    /*edit*/
    ctx[6] !== void 0
  ) {
    gridcell_props.edit = /*edit*/
    ctx[6];
  }
  if (
    /*selected*/
    ctx[1] !== void 0
  ) {
    gridcell_props.selected = /*selected*/
    ctx[1];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind6(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind6(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[20]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[21]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & /*column*/
      8)
        gridcell_changes.column = /*column*/
        ctx2[3];
      if (dirty & /*rowindex*/
      16)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[4];
      if (dirty & /*colindex*/
      32)
        gridcell_changes.colindex = /*colindex*/
        ctx2[5];
      if (dirty & /*value*/
      1)
        gridcell_changes.onCopy = /*func*/
        ctx2[15];
      if (dirty & /*value, onChange*/
      5)
        gridcell_changes.onCut = /*func_1*/
        ctx2[16];
      if (dirty & /*onChange*/
      4)
        gridcell_changes.onPaste = /*func_2*/
        ctx2[17];
      if (dirty & /*$$scope, value, options, selected, edit, onChange, column*/
      4194511) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & /*edit*/
      64) {
        updating_edit = true;
        gridcell_changes.edit = /*edit*/
        ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & /*selected*/
      2) {
        updating_selected = true;
        gridcell_changes.selected = /*selected*/
        ctx2[1];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance103($$self, $$props, $$invalidate) {
  let options;
  var _a, _b, _c;
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const change_handler = ({ detail }) => $$invalidate(0, value = detail);
  const blur_handler = ({ detail: event }) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(1, selected = false);
      $$invalidate(6, edit = false);
    }
    onChange(value);
  };
  const input_handler = ({ detail }) => $$invalidate(0, value = detail);
  const blur_handler_1 = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(1, selected = false);
      $$invalidate(6, edit = false);
    }
    onChange(value);
  };
  const func8 = () => {
    navigator.clipboard.writeText((value == null ? void 0 : value.toString()) || "");
  };
  const func_15 = () => {
    navigator.clipboard.writeText((value == null ? void 0 : value.toString()) || "");
    onChange(void 0);
  };
  const func_2 = () => __async(this, null, function* () {
    onChange(yield navigator.clipboard.readText());
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(1, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*column, _a, _b, _c*/
    1800) {
      $:
        $$invalidate(7, options = $$invalidate(10, _c = $$invalidate(9, _b = $$invalidate(8, _a = column.typeConfig) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.map((option2) => ({ label: option2, description: "" }))) !== null && _c !== void 0 ? _c : []);
    }
  };
  return [
    value,
    selected,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    options,
    _a,
    _b,
    _c,
    change_handler,
    blur_handler,
    input_handler,
    blur_handler_1,
    func8,
    func_15,
    func_2,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridTextCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance103, create_fragment103, safe_not_equal, {
      value: 0,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 1
    });
  }
};
var GridTextCell_default = GridTextCell;

// src/views/Table/components/DataGrid/GridCell/GridListCell/GridListCell.svelte
function create_read_slot5(ctx) {
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "read",
      edit: false,
      values: (
        /*value*/
        ctx[0] || []
      )
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taglist_changes = {};
      if (dirty & /*value*/
      1)
        taglist_changes.values = /*value*/
        ctx2[0] || [];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_edit_slot5(ctx) {
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "edit",
      edit: true,
      values: (
        /*value*/
        ctx[0] || []
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taglist_changes = {};
      if (dirty & /*value*/
      1)
        taglist_changes.values = /*value*/
        ctx2[0] || [];
      if (dirty & /*onChange*/
      2)
        taglist_changes.onChange = /*onChange*/
        ctx2[1];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_fragment104(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      column: (
        /*column*/
        ctx[2]
      ),
      $$slots: {
        edit: [create_edit_slot5],
        read: [create_read_slot5]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[6]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[7]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & /*selected*/
      32)
        gridcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*column*/
      4)
        gridcell_changes.column = /*column*/
        ctx2[2];
      if (dirty & /*$$scope, value, onChange*/
      259) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance104($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler
  ];
}
var GridListCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance104, create_fragment104, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridListCell_default = GridListCell;

// src/views/Table/components/DataGrid/GridCell/GridTypedCell.svelte
function create_else_block13(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      selected: (
        /*selected*/
        ctx[5]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  gridcell.$on(
    "mousedown",
    /*mousedown_handler_5*/
    ctx[16]
  );
  gridcell.$on(
    "navigate",
    /*navigate_handler_5*/
    ctx[17]
  );
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & /*rowindex*/
      8)
        gridcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*selected*/
      32)
        gridcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*colindex*/
      16)
        gridcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*column*/
      4)
        gridcell_changes.column = /*column*/
        ctx2[2];
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function create_if_block_45(ctx) {
  let griddatecell;
  let current;
  griddatecell = new GridDateCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  griddatecell.$on(
    "mousedown",
    /*mousedown_handler_4*/
    ctx[14]
  );
  griddatecell.$on(
    "navigate",
    /*navigate_handler_4*/
    ctx[15]
  );
  return {
    c() {
      create_component(griddatecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(griddatecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const griddatecell_changes = {};
      if (dirty & /*selected*/
      32)
        griddatecell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        griddatecell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        griddatecell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*value*/
      1)
        griddatecell_changes.value = /*value*/
        ctx2[0];
      if (dirty & /*onChange*/
      2)
        griddatecell_changes.onChange = /*onChange*/
        ctx2[1];
      if (dirty & /*column*/
      4)
        griddatecell_changes.column = /*column*/
        ctx2[2];
      griddatecell.$set(griddatecell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(griddatecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(griddatecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(griddatecell, detaching);
    }
  };
}
function create_if_block_36(ctx) {
  let gridnumbercell;
  let current;
  gridnumbercell = new GridNumberCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  gridnumbercell.$on(
    "mousedown",
    /*mousedown_handler_3*/
    ctx[12]
  );
  gridnumbercell.$on(
    "navigate",
    /*navigate_handler_3*/
    ctx[13]
  );
  return {
    c() {
      create_component(gridnumbercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridnumbercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridnumbercell_changes = {};
      if (dirty & /*selected*/
      32)
        gridnumbercell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridnumbercell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridnumbercell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*value*/
      1)
        gridnumbercell_changes.value = /*value*/
        ctx2[0];
      if (dirty & /*onChange*/
      2)
        gridnumbercell_changes.onChange = /*onChange*/
        ctx2[1];
      if (dirty & /*column*/
      4)
        gridnumbercell_changes.column = /*column*/
        ctx2[2];
      gridnumbercell.$set(gridnumbercell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridnumbercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridnumbercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridnumbercell, detaching);
    }
  };
}
function create_if_block_210(ctx) {
  let gridbooleancell;
  let current;
  gridbooleancell = new GridBooleanCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  gridbooleancell.$on(
    "mousedown",
    /*mousedown_handler_2*/
    ctx[10]
  );
  gridbooleancell.$on(
    "navigate",
    /*navigate_handler_2*/
    ctx[11]
  );
  return {
    c() {
      create_component(gridbooleancell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridbooleancell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridbooleancell_changes = {};
      if (dirty & /*selected*/
      32)
        gridbooleancell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridbooleancell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridbooleancell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*value*/
      1)
        gridbooleancell_changes.value = /*value*/
        ctx2[0];
      if (dirty & /*onChange*/
      2)
        gridbooleancell_changes.onChange = /*onChange*/
        ctx2[1];
      if (dirty & /*column*/
      4)
        gridbooleancell_changes.column = /*column*/
        ctx2[2];
      gridbooleancell.$set(gridbooleancell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridbooleancell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridbooleancell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridbooleancell, detaching);
    }
  };
}
function create_if_block_117(ctx) {
  let gridtextcell;
  let current;
  gridtextcell = new GridTextCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  gridtextcell.$on(
    "mousedown",
    /*mousedown_handler_1*/
    ctx[8]
  );
  gridtextcell.$on(
    "navigate",
    /*navigate_handler_1*/
    ctx[9]
  );
  return {
    c() {
      create_component(gridtextcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridtextcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridtextcell_changes = {};
      if (dirty & /*selected*/
      32)
        gridtextcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridtextcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridtextcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*value*/
      1)
        gridtextcell_changes.value = /*value*/
        ctx2[0];
      if (dirty & /*onChange*/
      2)
        gridtextcell_changes.onChange = /*onChange*/
        ctx2[1];
      if (dirty & /*column*/
      4)
        gridtextcell_changes.column = /*column*/
        ctx2[2];
      gridtextcell.$set(gridtextcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtextcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtextcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridtextcell, detaching);
    }
  };
}
function create_if_block38(ctx) {
  let gridlistcell;
  let current;
  gridlistcell = new GridListCell_default({
    props: {
      selected: (
        /*selected*/
        ctx[5]
      ),
      rowindex: (
        /*rowindex*/
        ctx[3]
      ),
      colindex: (
        /*colindex*/
        ctx[4]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      onChange: (
        /*onChange*/
        ctx[1]
      ),
      column: (
        /*column*/
        ctx[2]
      )
    }
  });
  gridlistcell.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[6]
  );
  gridlistcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[7]
  );
  return {
    c() {
      create_component(gridlistcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridlistcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridlistcell_changes = {};
      if (dirty & /*selected*/
      32)
        gridlistcell_changes.selected = /*selected*/
        ctx2[5];
      if (dirty & /*rowindex*/
      8)
        gridlistcell_changes.rowindex = /*rowindex*/
        ctx2[3];
      if (dirty & /*colindex*/
      16)
        gridlistcell_changes.colindex = /*colindex*/
        ctx2[4];
      if (dirty & /*value*/
      1)
        gridlistcell_changes.value = /*value*/
        ctx2[0];
      if (dirty & /*onChange*/
      2)
        gridlistcell_changes.onChange = /*onChange*/
        ctx2[1];
      if (dirty & /*column*/
      4)
        gridlistcell_changes.column = /*column*/
        ctx2[2];
      gridlistcell.$set(gridlistcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridlistcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridlistcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridlistcell, detaching);
    }
  };
}
function create_fragment105(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block38,
    create_if_block_117,
    create_if_block_210,
    create_if_block_36,
    create_if_block_45,
    create_else_block13
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*column, value*/
    5)
      show_if = null;
    if (dirty & /*column, value*/
    5)
      show_if_1 = null;
    if (dirty & /*column, value*/
    5)
      show_if_2 = null;
    if (dirty & /*column, value*/
    5)
      show_if_3 = null;
    if (dirty & /*column, value*/
    5)
      show_if_4 = null;
    if (show_if == null)
      show_if = !!/*column*/
      (ctx2[2].repeated && isOptionalList(
        /*value*/
        ctx2[0]
      ));
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!/*column*/
      (ctx2[2].type === "string" && isOptionalString(
        /*value*/
        ctx2[0]
      ));
    if (show_if_1)
      return 1;
    if (show_if_2 == null)
      show_if_2 = !!/*column*/
      (ctx2[2].type === "boolean" && isOptionalBoolean(
        /*value*/
        ctx2[0]
      ));
    if (show_if_2)
      return 2;
    if (show_if_3 == null)
      show_if_3 = !!/*column*/
      (ctx2[2].type === "number" && isOptionalNumber(
        /*value*/
        ctx2[0]
      ));
    if (show_if_3)
      return 3;
    if (show_if_4 == null)
      show_if_4 = !!/*column*/
      (ctx2[2].type === "date" && isOptionalDate(
        /*value*/
        ctx2[0]
      ));
    if (show_if_4)
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance105($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler,
    mousedown_handler_1,
    navigate_handler_1,
    mousedown_handler_2,
    navigate_handler_2,
    mousedown_handler_3,
    navigate_handler_3,
    mousedown_handler_4,
    navigate_handler_4,
    mousedown_handler_5,
    navigate_handler_5
  ];
}
var GridTypedCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance105, create_fragment105, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridTypedCell_default = GridTypedCell;

// src/views/Table/components/DataGrid/GridCellGroup.svelte
function add_css64(target) {
  append_styles(target, "svelte-1jrmech", "div.svelte-1jrmech{display:flex}.header.svelte-1jrmech{position:sticky;top:0;z-index:10}");
}
function create_fragment106(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "role", "row");
      attr(
        div,
        "aria-rowindex",
        /*index*/
        ctx[0]
      );
      attr(div, "class", "svelte-1jrmech");
      toggle_class(
        div,
        "header",
        /*header*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[4]
          ),
          listen(
            div,
            "focus",
            /*focus_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*index*/
      1) {
        attr(
          div,
          "aria-rowindex",
          /*index*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*header*/
      2) {
        toggle_class(
          div,
          "header",
          /*header*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance106($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { index: index2 } = $$props;
  let { header = false } = $$props;
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(0, index2 = $$props2.index);
    if ("header" in $$props2)
      $$invalidate(1, header = $$props2.header);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [index2, header, $$scope, slots, mouseover_handler, focus_handler];
}
var GridCellGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance106, create_fragment106, safe_not_equal, { index: 0, header: 1 }, add_css64);
  }
};
var GridCellGroup_default = GridCellGroup;

// src/views/Table/components/DataGrid/data-grid.ts
function fieldIcon(field) {
  switch (field) {
    case "string" /* String */:
      return "text";
    case "number" /* Number */:
      return "hash";
    case "boolean" /* Boolean */:
      return "check";
    case "date" /* Date */:
      return "calendar-days";
  }
  return "alert-triangle";
}
function sortRows(rows, sortModel) {
  return rows.sort((a2, b2) => {
    let aval = a2.row[sortModel.field];
    let bval = b2.row[sortModel.field];
    const isAsc = sortModel.sort === "asc";
    if (!aval && bval)
      return isAsc ? 1 : -1;
    if (aval && !bval)
      return isAsc ? -1 : 1;
    if (!aval && !bval)
      return 0;
    if (isNumber(aval) && isNumber(bval)) {
      if (aval < bval) {
        return isAsc ? -1 : 1;
      } else if (aval > bval) {
        return isAsc ? 1 : -1;
      } else {
        return 0;
      }
    }
    if (isDate(aval) && isDate(bval)) {
      if (aval.getTime() < bval.getTime())
        return isAsc ? -1 : 1;
      if (aval.getTime() > bval.getTime())
        return isAsc ? 1 : -1;
      return 0;
    }
    aval = aval.toString().toLocaleLowerCase();
    bval = bval.toString().toLocaleLowerCase();
    if (aval < bval) {
      return isAsc ? -1 : 1;
    } else if (aval > bval) {
      return isAsc ? 1 : -1;
    } else {
      return 0;
    }
  });
}
function menuOnContextMenu(event, menu) {
  const contextMenuFunc = (event2) => {
    window.removeEventListener("contextmenu", contextMenuFunc);
    event2.preventDefault();
    event2.stopPropagation();
    menu.showAtMouseEvent(event2);
  };
  window.addEventListener("contextmenu", contextMenuFunc, false);
}

// src/views/Table/components/DataGrid/GridRow.svelte
function get_each_context18(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[17] = i2;
  return child_ctx;
}
function create_read_slot6(ctx) {
  let div;
  let t_value = (
    /*index*/
    (ctx[1] - 1).toString() + ""
  );
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(t_value);
      attr(div, "slot", "read");
      set_style(div, "text-align", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append4(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*index*/
      2 && t_value !== (t_value = /*index*/
      (ctx2[1] - 1).toString() + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block18(key_1, ctx) {
  let first;
  let gridtypedcell;
  let current;
  function func8(...args) {
    return (
      /*func*/
      ctx[12](
        /*column*/
        ctx[15],
        ...args
      )
    );
  }
  gridtypedcell = new GridTypedCell_default({
    props: {
      selected: (
        /*activeCell*/
        ctx[4][0] === /*i*/
        ctx[17] + 2 && /*activeCell*/
        ctx[4][1] === /*index*/
        ctx[1] + 2
      ),
      rowindex: (
        /*index*/
        ctx[1] + 2
      ),
      colindex: (
        /*i*/
        ctx[17] + 2
      ),
      value: (
        /*row*/
        ctx[2][
          /*column*/
          ctx[15].field
        ]
      ),
      column: (
        /*column*/
        ctx[15]
      ),
      onChange: func8
    }
  });
  gridtypedcell.$on("mousedown", function() {
    if (is_function(
      /*handleCellClick*/
      ctx[8](
        /*column*/
        ctx[15],
        /*row*/
        ctx[2][
          /*column*/
          ctx[15].field
        ]
      )
    ))
      ctx[8](
        /*column*/
        ctx[15],
        /*row*/
        ctx[2][
          /*column*/
          ctx[15].field
        ]
      ).apply(this, arguments);
  });
  gridtypedcell.$on(
    "navigate",
    /*navigate_handler*/
    ctx[13]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(gridtypedcell.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(gridtypedcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridtypedcell_changes = {};
      if (dirty & /*activeCell, columns, index*/
      26)
        gridtypedcell_changes.selected = /*activeCell*/
        ctx[4][0] === /*i*/
        ctx[17] + 2 && /*activeCell*/
        ctx[4][1] === /*index*/
        ctx[1] + 2;
      if (dirty & /*index*/
      2)
        gridtypedcell_changes.rowindex = /*index*/
        ctx[1] + 2;
      if (dirty & /*columns*/
      8)
        gridtypedcell_changes.colindex = /*i*/
        ctx[17] + 2;
      if (dirty & /*row, columns*/
      12)
        gridtypedcell_changes.value = /*row*/
        ctx[2][
          /*column*/
          ctx[15].field
        ];
      if (dirty & /*columns*/
      8)
        gridtypedcell_changes.column = /*column*/
        ctx[15];
      if (dirty & /*onRowChange, rowId, row, columns*/
      77)
        gridtypedcell_changes.onChange = func8;
      gridtypedcell.$set(gridtypedcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtypedcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtypedcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(gridtypedcell, detaching);
    }
  };
}
function create_default_slot35(ctx) {
  let gridcell;
  let t3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: 1,
      colindex: 1,
      column: {
        field: "",
        header: true,
        width: 60,
        editable: false
      },
      rowHeader: true,
      color: (
        /*color*/
        ctx[5]
      ),
      $$slots: { read: [create_read_slot6] },
      $$scope: { ctx }
    }
  });
  gridcell.$on(
    "mousedown",
    /*handleHeaderClick*/
    ctx[7]()
  );
  let each_value = (
    /*columns*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[15].field
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context18(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block18(key, child_ctx));
  }
  return {
    c() {
      create_component(gridcell.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & /*color*/
      32)
        gridcell_changes.color = /*color*/
        ctx2[5];
      if (dirty & /*$$scope, index*/
      262146) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
      if (dirty & /*activeCell, columns, index, row, onRowChange, rowId, produce, handleCellClick*/
      351) {
        each_value = /*columns*/
        ctx2[3];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block18, each_1_anchor, get_each_context18);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
      if (detaching)
        detach(t3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment107(ctx) {
  let gridcellgroup;
  let current;
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: (
        /*index*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot35] },
      $$scope: { ctx }
    }
  });
  gridcellgroup.$on(
    "mouseover",
    /*handleHoverLink*/
    ctx[9]
  );
  return {
    c() {
      create_component(gridcellgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcellgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcellgroup_changes = {};
      if (dirty & /*index*/
      2)
        gridcellgroup_changes.index = /*index*/
        ctx2[1];
      if (dirty & /*$$scope, columns, activeCell, index, row, onRowChange, rowId, color*/
      262271) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcellgroup, detaching);
    }
  };
}
function instance107($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app2, ($$value) => $$invalidate(14, $app = $$value));
  let { rowId } = $$props;
  let { index: index2 } = $$props;
  let { row } = $$props;
  let { columns } = $$props;
  let { activeCell } = $$props;
  let { color } = $$props;
  setContext("sourcePath", row["path"]);
  let { onRowChange } = $$props;
  let { onRowMenu } = $$props;
  let { onCellMenu } = $$props;
  function handleHeaderClick() {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onRowMenu(rowId, row));
      }
    };
  }
  function handleCellClick(column, value) {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onCellMenu(rowId, column, value));
      }
      if (event.target instanceof HTMLTableCellElement) {
        if (event.target.firstChild instanceof HTMLInputElement) {
          event.target.firstChild.focus();
          event.preventDefault();
        }
      }
    };
  }
  function handleHoverLink(event) {
    if (!event.ctrlKey && !event.metaKey) {
      return;
    }
    const targetEl = event.target;
    if (targetEl instanceof HTMLDivElement) {
      const file = $app.vault.getAbstractFileByPath(rowId);
      if (file instanceof import_obsidian49.TFile) {
        $app.workspace.trigger("hover-link", {
          event,
          source: "obsidian-projects-table-view",
          hoverParent: targetEl.parentElement,
          targetEl,
          linktext: file.name,
          sourcePath: file.path
        });
      }
    }
  }
  const func8 = (column, value) => {
    onRowChange(rowId, immer_esm_default(row, (draft) => {
      draft[column.field] = value;
      return draft;
    }));
  };
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rowId" in $$props2)
      $$invalidate(0, rowId = $$props2.rowId);
    if ("index" in $$props2)
      $$invalidate(1, index2 = $$props2.index);
    if ("row" in $$props2)
      $$invalidate(2, row = $$props2.row);
    if ("columns" in $$props2)
      $$invalidate(3, columns = $$props2.columns);
    if ("activeCell" in $$props2)
      $$invalidate(4, activeCell = $$props2.activeCell);
    if ("color" in $$props2)
      $$invalidate(5, color = $$props2.color);
    if ("onRowChange" in $$props2)
      $$invalidate(6, onRowChange = $$props2.onRowChange);
    if ("onRowMenu" in $$props2)
      $$invalidate(10, onRowMenu = $$props2.onRowMenu);
    if ("onCellMenu" in $$props2)
      $$invalidate(11, onCellMenu = $$props2.onCellMenu);
  };
  return [
    rowId,
    index2,
    row,
    columns,
    activeCell,
    color,
    onRowChange,
    handleHeaderClick,
    handleCellClick,
    handleHoverLink,
    onRowMenu,
    onCellMenu,
    func8,
    navigate_handler
  ];
}
var GridRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance107, create_fragment107, safe_not_equal, {
      rowId: 0,
      index: 1,
      row: 2,
      columns: 3,
      activeCell: 4,
      color: 5,
      onRowChange: 6,
      onRowMenu: 10,
      onCellMenu: 11
    });
  }
};
var GridRow_default = GridRow;

// src/views/Table/components/DataGrid/GridHeader/GridColumnHeader.svelte
function add_css65(target) {
  append_styles(target, "svelte-1wnlez2", "div.svelte-1wnlez2{position:sticky;display:flex;align-items:center;justify-content:space-between;text-align:center;background-color:var(--background-secondary);border-right:1px solid var(--background-modifier-border);border-left-color:var(--background-modifier-border);border-bottom:1px solid var(--background-modifier-border);width:100%;min-height:30px;font-weight:500;padding:0 4px;cursor:default}");
}
function create_else_block14(ctx) {
  var _a, _b;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      name: fieldIcon(
        /*column*/
        (_a = ctx[0].type) != null ? _a : "unknown" /* Unknown */
      ),
      tooltip: (_b = get_store_value(i18n).t(`data-types.${/*column*/
      ctx[0].type}`)) != null ? _b : ""
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const icon_changes = {};
      if (dirty & /*column*/
      1)
        icon_changes.name = fieldIcon(
          /*column*/
          (_a2 = ctx2[0].type) != null ? _a2 : "unknown" /* Unknown */
        );
      if (dirty & /*column*/
      1)
        icon_changes.tooltip = (_b2 = get_store_value(i18n).t(`data-types.${/*column*/
        ctx2[0].type}`)) != null ? _b2 : "";
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block39(ctx) {
  var _a;
  let icon;
  let current;
  icon = new Icon_default({
    props: {
      name: "list",
      tooltip: (_a = get_store_value(i18n).t(`data-types.repeated`)) != null ? _a : ""
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment108(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t0;
  let textlabel;
  let t1;
  let iconbutton;
  let current;
  const if_block_creators = [create_if_block39, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*column*/
      ctx2[0].repeated
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  textlabel = new TextLabel_default({
    props: { value: (
      /*column*/
      ctx[0].field
    ) }
  });
  iconbutton = new IconButton_default({
    props: {
      size: "sm",
      icon: "vertical-three-dots",
      onClick: (
        /*handleFieldClick*/
        ctx[2](
          /*column*/
          ctx[0]
        )
      )
    }
  });
  return {
    c() {
      div = element("div");
      if_block.c();
      t0 = space();
      create_component(textlabel.$$.fragment);
      t1 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "role", "columnheader");
      attr(
        div,
        "aria-colindex",
        /*colindex*/
        ctx[1]
      );
      attr(div, "class", "svelte-1wnlez2");
      set_style(div, "width", `${/*column*/
      ctx[0].width}px`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append4(div, t0);
      mount_component(textlabel, div, null);
      append4(div, t1);
      mount_component(iconbutton, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t0);
      }
      const textlabel_changes = {};
      if (dirty & /*column*/
      1)
        textlabel_changes.value = /*column*/
        ctx2[0].field;
      textlabel.$set(textlabel_changes);
      const iconbutton_changes = {};
      if (dirty & /*column*/
      1)
        iconbutton_changes.onClick = /*handleFieldClick*/
        ctx2[2](
          /*column*/
          ctx2[0]
        );
      iconbutton.$set(iconbutton_changes);
      if (!current || dirty & /*colindex*/
      2) {
        attr(
          div,
          "aria-colindex",
          /*colindex*/
          ctx2[1]
        );
      }
      if (dirty & /*column*/
      1) {
        set_style(div, "width", `${/*column*/
        ctx2[0].width}px`);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(textlabel.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(textlabel.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      destroy_component(textlabel);
      destroy_component(iconbutton);
    }
  };
}
function instance108($$self, $$props, $$invalidate) {
  let { column } = $$props;
  let { colindex } = $$props;
  let { onColumnMenu } = $$props;
  function handleFieldClick(column2) {
    return (event) => {
      onColumnMenu(column2).showAtMouseEvent(event);
    };
  }
  $$self.$$set = ($$props2) => {
    if ("column" in $$props2)
      $$invalidate(0, column = $$props2.column);
    if ("colindex" in $$props2)
      $$invalidate(1, colindex = $$props2.colindex);
    if ("onColumnMenu" in $$props2)
      $$invalidate(3, onColumnMenu = $$props2.onColumnMenu);
  };
  return [column, colindex, handleFieldClick, onColumnMenu];
}
var GridColumnHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance108, create_fragment108, safe_not_equal, { column: 0, colindex: 1, onColumnMenu: 3 }, add_css65);
  }
};
var GridColumnHeader_default = GridColumnHeader;

// src/views/Table/components/DataGrid/GridHeader/GridHeader.svelte
function add_css66(target) {
  append_styles(target, "svelte-1yntd5r", "div.container.svelte-1yntd5r{position:sticky;top:0;z-index:6}div.flex.svelte-1yntd5r{display:flex}div.relative.svelte-1yntd5r{position:relative}span.svelte-1yntd5r{background-color:var(--background-secondary);border-right:1px solid var(--background-modifier-border);border-left-color:var(--background-modifier-border);border-bottom:1px solid var(--background-modifier-border);min-height:30px;width:60px;z-index:50;position:sticky;left:0px;top:0px}");
}
function get_each_context19(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_each_block19(key_1, ctx) {
  var _a;
  let div;
  let gridcolumnheader;
  let t0;
  let resizer;
  let t1;
  let div_class_value;
  let rect;
  let stop_animation = noop;
  let current;
  gridcolumnheader = new GridColumnHeader_default({
    props: {
      column: (
        /*column*/
        ctx[9]
      ),
      onColumnMenu: (
        /*onColumnMenu*/
        ctx[3]
      ),
      colindex: (
        /*columnIdx*/
        ctx[11]
      )
    }
  });
  function func8(...args) {
    return (
      /*func*/
      ctx[7](
        /*column*/
        ctx[9],
        ...args
      )
    );
  }
  function func_15(...args) {
    return (
      /*func_1*/
      ctx[8](
        /*column*/
        ctx[9],
        ...args
      )
    );
  }
  resizer = new Resizer_default({
    props: {
      width: (
        /*column*/
        (_a = ctx[9].width) != null ? _a : 180
      ),
      min: 100,
      onChange: func8,
      onFinalize: func_15
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(gridcolumnheader.$$.fragment);
      t0 = space();
      create_component(resizer.$$.fragment);
      t1 = space();
      attr(div, "class", div_class_value = null_to_empty(`flex relative`) + " svelte-1yntd5r");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(gridcolumnheader, div, null);
      append4(div, t0);
      mount_component(resizer, div, null);
      append4(div, t1);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const gridcolumnheader_changes = {};
      if (dirty & /*columns*/
      1)
        gridcolumnheader_changes.column = /*column*/
        ctx[9];
      if (dirty & /*onColumnMenu*/
      8)
        gridcolumnheader_changes.onColumnMenu = /*onColumnMenu*/
        ctx[3];
      if (dirty & /*columns*/
      1)
        gridcolumnheader_changes.colindex = /*columnIdx*/
        ctx[11];
      gridcolumnheader.$set(gridcolumnheader_changes);
      const resizer_changes = {};
      if (dirty & /*columns*/
      1)
        resizer_changes.width = /*column*/
        (_a2 = ctx[9].width) != null ? _a2 : 180;
      if (dirty & /*onResize, columns*/
      3)
        resizer_changes.onChange = func8;
      if (dirty & /*onFinalizeResize, columns*/
      5)
        resizer_changes.onFinalize = func_15;
      resizer.$set(resizer_changes);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip3, { duration: flipDurationMs4 });
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcolumnheader.$$.fragment, local);
      transition_in(resizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcolumnheader.$$.fragment, local);
      transition_out(resizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(gridcolumnheader);
      destroy_component(resizer);
    }
  };
}
function create_fragment109(ctx) {
  let div1;
  let span;
  let t3;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*columns*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[9].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context19(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block19(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t3 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "svelte-1yntd5r");
      attr(div0, "class", "flex svelte-1yntd5r");
      attr(div1, "class", "flex container svelte-1yntd5r");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append4(div1, span);
      append4(div1, t3);
      append4(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone$2.call(null, div0, {
            items: (
              /*columns*/
              ctx[0]
            ),
            flipDurationMs: flipDurationMs4,
            dropTargetStyle: {
              outline: "none",
              background: "hsla(var(--interactive-accent-hsl), 0.3)"
            }
          })),
          listen(
            div0,
            "consider",
            /*handleDndConsider*/
            ctx[4]
          ),
          listen(
            div0,
            "finalize",
            /*handleDndFinalize*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*columns, onResize, onFinalizeResize, onColumnMenu*/
      15) {
        each_value = /*columns*/
        ctx2[0];
        group_outros();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, fix_and_outro_and_destroy_block, create_each_block19, null, get_each_context19);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].a();
        check_outros();
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & /*columns*/
      1)
        dndzone_action.update.call(null, {
          items: (
            /*columns*/
            ctx2[0]
          ),
          flipDurationMs: flipDurationMs4,
          dropTargetStyle: {
            outline: "none",
            background: "hsla(var(--interactive-accent-hsl), 0.3)"
          }
        });
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
var flipDurationMs4 = 200;
function instance109($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { onResize } = $$props;
  let { onFinalizeResize } = $$props;
  let { onColumnMenu } = $$props;
  let { onColumnOrder } = $$props;
  function handleDndConsider(e) {
    $$invalidate(0, columns = e.detail.items);
  }
  function handleDndFinalize(e) {
    $$invalidate(0, columns = e.detail.items);
    onColumnOrder(columns);
  }
  const func8 = (column, width) => {
    onResize(column.field, width);
  };
  const func_15 = (column, width) => {
    onFinalizeResize(column.field, width);
  };
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("onResize" in $$props2)
      $$invalidate(1, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(2, onFinalizeResize = $$props2.onFinalizeResize);
    if ("onColumnMenu" in $$props2)
      $$invalidate(3, onColumnMenu = $$props2.onColumnMenu);
    if ("onColumnOrder" in $$props2)
      $$invalidate(6, onColumnOrder = $$props2.onColumnOrder);
  };
  return [
    columns,
    onResize,
    onFinalizeResize,
    onColumnMenu,
    handleDndConsider,
    handleDndFinalize,
    onColumnOrder,
    func8,
    func_15
  ];
}
var GridHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance109,
      create_fragment109,
      safe_not_equal,
      {
        columns: 0,
        onResize: 1,
        onFinalizeResize: 2,
        onColumnMenu: 3,
        onColumnOrder: 6
      },
      add_css66
    );
  }
};
var GridHeader_default = GridHeader;

// src/views/Table/components/DataGrid/DataGrid.svelte
function add_css67(target) {
  append_styles(target, "svelte-8irtc3", "div.svelte-8irtc3{display:inline-block}span.svelte-8irtc3{padding:4px;position:sticky;left:0}");
}
function get_each_context20(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i2].rowId;
  child_ctx[34] = list[i2].row;
  child_ctx[36] = i2;
  return child_ctx;
}
function create_each_block20(key_1, ctx) {
  let first;
  let gridrow;
  let current;
  function func_6(...args) {
    return (
      /*func_6*/
      ctx[30](
        /*row*/
        ctx[34],
        ...args
      )
    );
  }
  gridrow = new GridRow_default({
    props: {
      columns: (
        /*sortedColumns*/
        ctx[8]
      ),
      index: (
        /*i*/
        ctx[36] + 2
      ),
      rowId: (
        /*rowId*/
        ctx[33]
      ),
      row: (
        /*row*/
        ctx[34]
      ),
      activeCell: (
        /*activeCell*/
        ctx[5]
      ),
      onRowChange: (
        /*onRowChange*/
        ctx[4]
      ),
      color: (
        /*colorModel*/
        ctx[1](
          /*rowId*/
          ctx[33]
        )
      ),
      onRowMenu: (
        /*func_5*/
        ctx[29]
      ),
      onCellMenu: func_6
    }
  });
  gridrow.$on(
    "navigate",
    /*navigate_handler*/
    ctx[31]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty3();
      create_component(gridrow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(gridrow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridrow_changes = {};
      if (dirty[0] & /*sortedColumns*/
      256)
        gridrow_changes.columns = /*sortedColumns*/
        ctx[8];
      if (dirty[0] & /*sortedRows*/
      128)
        gridrow_changes.index = /*i*/
        ctx[36] + 2;
      if (dirty[0] & /*sortedRows*/
      128)
        gridrow_changes.rowId = /*rowId*/
        ctx[33];
      if (dirty[0] & /*sortedRows*/
      128)
        gridrow_changes.row = /*row*/
        ctx[34];
      if (dirty[0] & /*activeCell*/
      32)
        gridrow_changes.activeCell = /*activeCell*/
        ctx[5];
      if (dirty[0] & /*onRowChange*/
      16)
        gridrow_changes.onRowChange = /*onRowChange*/
        ctx[4];
      if (dirty[0] & /*colorModel, sortedRows*/
      130)
        gridrow_changes.color = /*colorModel*/
        ctx[1](
          /*rowId*/
          ctx[33]
        );
      if (dirty[0] & /*sortedRows*/
      128)
        gridrow_changes.onCellMenu = func_6;
      gridrow.$set(gridrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(gridrow, detaching);
    }
  };
}
function create_default_slot_129(ctx) {
  let icon;
  let t0;
  let t1_value = (
    /*t*/
    ctx[6]("components.data-grid.row.add") + ""
  );
  let t1;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*t*/
      64) && t1_value !== (t1_value = /*t*/
      ctx2[6]("components.data-grid.row.add") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot36(ctx) {
  let span;
  let button;
  let span_style_value;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_129] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[32]
  );
  return {
    c() {
      var _a, _b;
      span = element("span");
      create_component(button.$$.fragment);
      attr(span, "style", span_style_value = `width: ${60 + /*sortedColumns*/
      ((_b = (_a = ctx[8][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`);
      attr(span, "class", "svelte-8irtc3");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(button, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a, _b;
      const button_changes = {};
      if (dirty[0] & /*t*/
      64 | dirty[1] & /*$$scope*/
      64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (!current || dirty[0] & /*sortedColumns*/
      256 && span_style_value !== (span_style_value = `width: ${60 + /*sortedColumns*/
      ((_b = (_a = ctx2[8][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`)) {
        attr(span, "style", span_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(button);
    }
  };
}
function create_fragment110(ctx) {
  let div;
  let gridheader;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let gridcellgroup;
  let div_aria_colcount_value;
  let div_aria_rowcount_value;
  let current;
  gridheader = new GridHeader_default({
    props: {
      columns: (
        /*sortedColumns*/
        ctx[8].filter(func6).map(func_14)
      ),
      onResize: (
        /*func_2*/
        ctx[26]
      ),
      onFinalizeResize: (
        /*func_3*/
        ctx[27]
      ),
      onColumnMenu: (
        /*func_4*/
        ctx[28]
      ),
      onColumnOrder: (
        /*handleColumnOrder*/
        ctx[12]
      )
    }
  });
  let each_value = (
    /*sortedRows*/
    ctx[7]
  );
  const get_key = (ctx2) => (
    /*rowId*/
    ctx2[33]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context20(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block20(key, child_ctx));
  }
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: (
        /*sortedRows*/
        ctx[7].length + 2
      ),
      $$slots: { default: [create_default_slot36] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(gridheader.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(gridcellgroup.$$.fragment);
      attr(div, "role", "grid");
      attr(div, "aria-colcount", div_aria_colcount_value = /*sortedColumns*/
      ctx[8].length + 1);
      attr(div, "aria-rowcount", div_aria_rowcount_value = /*sortedRows*/
      ctx[7].length + 2);
      attr(div, "class", "svelte-8irtc3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(gridheader, div, null);
      append4(div, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append4(div, t1);
      mount_component(gridcellgroup, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const gridheader_changes = {};
      if (dirty[0] & /*sortedColumns*/
      256)
        gridheader_changes.columns = /*sortedColumns*/
        ctx2[8].filter(func6).map(func_14);
      if (dirty[0] & /*columns*/
      1)
        gridheader_changes.onResize = /*func_2*/
        ctx2[26];
      if (dirty[0] & /*onColumnResize*/
      4)
        gridheader_changes.onFinalizeResize = /*func_3*/
        ctx2[27];
      gridheader.$set(gridheader_changes);
      if (dirty[0] & /*sortedColumns, sortedRows, activeCell, onRowChange, colorModel, createRowMenu, createCellMenu, clamp*/
      11698) {
        each_value = /*sortedRows*/
        ctx2[7];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block20, t1, get_each_context20);
        check_outros();
      }
      const gridcellgroup_changes = {};
      if (dirty[0] & /*sortedRows*/
      128)
        gridcellgroup_changes.index = /*sortedRows*/
        ctx2[7].length + 2;
      if (dirty[0] & /*sortedColumns, onRowAdd, t*/
      328 | dirty[1] & /*$$scope*/
      64) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
      if (!current || dirty[0] & /*sortedColumns*/
      256 && div_aria_colcount_value !== (div_aria_colcount_value = /*sortedColumns*/
      ctx2[8].length + 1)) {
        attr(div, "aria-colcount", div_aria_colcount_value);
      }
      if (!current || dirty[0] & /*sortedRows*/
      128 && div_aria_rowcount_value !== (div_aria_rowcount_value = /*sortedRows*/
      ctx2[7].length + 2)) {
        attr(div, "aria-rowcount", div_aria_rowcount_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(gridheader);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      destroy_component(gridcellgroup);
    }
  };
}
var func6 = (col) => !col.hide;
var func_14 = (col) => __spreadProps(__spreadValues({}, col), { id: col.field });
function instance110($$self, $$props, $$invalidate) {
  let t3;
  let visibleColumns;
  let sortedColumns;
  let sortedRows;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(25, $i18n = $$value));
  let { columns } = $$props;
  let { rows } = $$props;
  let { sortModel } = $$props;
  let { colorModel } = $$props;
  let { readonly } = $$props;
  let { onSortModelChange } = $$props;
  let { onColumnResize } = $$props;
  let { onColumnSort } = $$props;
  let { onRowAdd } = $$props;
  let { onRowChange } = $$props;
  let { onColumnConfigure } = $$props;
  let { onColumnDelete } = $$props;
  let { onColumnHide } = $$props;
  let { onRowDelete } = $$props;
  let { onRowEdit } = $$props;
  let activeCell = [3, 3];
  function createColumnMenu(column) {
    const editable = !!column.editable && !readonly;
    const menu = new import_obsidian51.Menu();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.column.configure")).setIcon("settings").onClick(() => onColumnConfigure(column, editable));
    });
    if (editable) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.column.delete")).setIcon("trash").onClick(() => onColumnDelete(column.field));
      });
      menu.addSeparator();
    }
    let isDateCol = column.type === "date" /* Date */;
    menu.addItem((item) => {
      item.setTitle(t3(isDateCol ? "components.data-grid.sortDate.asc" : "components.data-grid.sort.asc")).setIcon("sort-asc").onClick(() => onSortModelChange(column.field, "asc"));
    });
    menu.addItem((item) => {
      item.setTitle(t3(isDateCol ? "components.data-grid.sortDate.desc" : "components.data-grid.sort.desc")).setIcon("sort-desc").onClick(() => onSortModelChange(column.field, "desc"));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.column.hide")).setIcon("eye-off").onClick(() => {
        onColumnHide(column);
      });
    });
    return menu;
  }
  function createRowMenu(rowId, row) {
    const menu = new import_obsidian51.Menu();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.row.edit")).setIcon("edit").onClick(() => onRowEdit(rowId, row));
    });
    if (!readonly) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.row.delete")).setIcon("trash").onClick(() => onRowDelete(rowId));
      });
    }
    return menu;
  }
  function createCellMenu(rowId, row, column) {
    const menu = new import_obsidian51.Menu();
    if (column.editable) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.cell.clear")).setIcon("x").onClick(() => {
          onRowChange(rowId, immer_esm_default(row, (draft) => {
            draft[column.field] = void 0;
            return draft;
          }));
        });
      });
    }
    return menu;
  }
  function handleColumnOrder(columns2) {
    onColumnSort(columns2.map((col) => col.field));
  }
  const clamp = (num, min3, max3) => Math.min(Math.max(num, min3), max3);
  const func_2 = (name, width) => {
    $$invalidate(0, columns = columns.map((column) => column.field === name ? __spreadProps(__spreadValues({}, column), { width }) : column));
  };
  const func_3 = (name, width) => {
    onColumnResize(name, width);
  };
  const func_4 = (field) => createColumnMenu(field);
  const func_5 = (rowId, row) => createRowMenu(rowId, row);
  const func_6 = (row, rowId, column) => createCellMenu(rowId, row, column);
  const navigate_handler = ({ detail: navinfo }) => {
    const colOffset = 1;
    const rowOffset = 3;
    const minColIdx = 1 + colOffset;
    const maxColIdx = sortedColumns.length + colOffset;
    const minRowIdx = 1 + rowOffset;
    const maxRowIdx = sortedRows.length + rowOffset;
    const [colIdx, rowIdx, wrap] = navinfo;
    const wrapPrev = wrap && colIdx < minColIdx && !(rowIdx - 1 < minRowIdx);
    const wrapNext = wrap && colIdx > maxColIdx && !(rowIdx + 1 > maxRowIdx);
    if (wrapPrev) {
      $$invalidate(5, activeCell = [maxColIdx, rowIdx - 1]);
    } else if (wrapNext) {
      $$invalidate(5, activeCell = [minColIdx, rowIdx + 1]);
    } else {
      $$invalidate(5, activeCell = [clamp(colIdx, minColIdx, maxColIdx), clamp(rowIdx, minRowIdx, maxRowIdx)]);
    }
  };
  const click_handler = () => onRowAdd();
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("rows" in $$props2)
      $$invalidate(14, rows = $$props2.rows);
    if ("sortModel" in $$props2)
      $$invalidate(15, sortModel = $$props2.sortModel);
    if ("colorModel" in $$props2)
      $$invalidate(1, colorModel = $$props2.colorModel);
    if ("readonly" in $$props2)
      $$invalidate(16, readonly = $$props2.readonly);
    if ("onSortModelChange" in $$props2)
      $$invalidate(17, onSortModelChange = $$props2.onSortModelChange);
    if ("onColumnResize" in $$props2)
      $$invalidate(2, onColumnResize = $$props2.onColumnResize);
    if ("onColumnSort" in $$props2)
      $$invalidate(18, onColumnSort = $$props2.onColumnSort);
    if ("onRowAdd" in $$props2)
      $$invalidate(3, onRowAdd = $$props2.onRowAdd);
    if ("onRowChange" in $$props2)
      $$invalidate(4, onRowChange = $$props2.onRowChange);
    if ("onColumnConfigure" in $$props2)
      $$invalidate(19, onColumnConfigure = $$props2.onColumnConfigure);
    if ("onColumnDelete" in $$props2)
      $$invalidate(20, onColumnDelete = $$props2.onColumnDelete);
    if ("onColumnHide" in $$props2)
      $$invalidate(21, onColumnHide = $$props2.onColumnHide);
    if ("onRowDelete" in $$props2)
      $$invalidate(22, onRowDelete = $$props2.onRowDelete);
    if ("onRowEdit" in $$props2)
      $$invalidate(23, onRowEdit = $$props2.onRowEdit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$i18n*/
    33554432) {
      $:
        $$invalidate(6, t3 = $i18n.t);
    }
    if ($$self.$$.dirty[0] & /*columns*/
    1) {
      $:
        $$invalidate(24, visibleColumns = columns.filter((column) => !column.hide));
    }
    if ($$self.$$.dirty[0] & /*visibleColumns*/
    16777216) {
      $:
        $$invalidate(8, sortedColumns = visibleColumns);
    }
    if ($$self.$$.dirty[0] & /*rows, sortModel*/
    49152) {
      $:
        $$invalidate(7, sortedRows = sortRows(rows, sortModel));
    }
  };
  return [
    columns,
    colorModel,
    onColumnResize,
    onRowAdd,
    onRowChange,
    activeCell,
    t3,
    sortedRows,
    sortedColumns,
    createColumnMenu,
    createRowMenu,
    createCellMenu,
    handleColumnOrder,
    clamp,
    rows,
    sortModel,
    readonly,
    onSortModelChange,
    onColumnSort,
    onColumnConfigure,
    onColumnDelete,
    onColumnHide,
    onRowDelete,
    onRowEdit,
    visibleColumns,
    $i18n,
    func_2,
    func_3,
    func_4,
    func_5,
    func_6,
    navigate_handler,
    click_handler
  ];
}
var DataGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(
      this,
      options,
      instance110,
      create_fragment110,
      safe_not_equal,
      {
        columns: 0,
        rows: 14,
        sortModel: 15,
        colorModel: 1,
        readonly: 16,
        onSortModelChange: 17,
        onColumnResize: 2,
        onColumnSort: 18,
        onRowAdd: 3,
        onRowChange: 4,
        onColumnConfigure: 19,
        onColumnDelete: 20,
        onColumnHide: 21,
        onRowDelete: 22,
        onRowEdit: 23
      },
      add_css67,
      [-1, -1]
    );
  }
};
var DataGrid_default = DataGrid;

// src/modals/configure-field.ts
var import_obsidian52 = require("obsidian");

// src/components/MultiTextInput/MultiTextInput.svelte
function add_css68(target) {
  append_styles(target, "svelte-9r99fn", "div.svelte-9r99fn{display:flex;flex-direction:column;gap:4px;width:100%}span.svelte-9r99fn{display:flex;gap:4px}");
}
function get_each_context21(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_each_block21(ctx) {
  let span;
  let textinput;
  let t3;
  let iconbutton;
  let current;
  textinput = new TextInput_default({
    props: { width: "100%", value: (
      /*option*/
      ctx[5]
    ) }
  });
  textinput.$on(
    "blur",
    /*handleOptionChange*/
    ctx[3](
      /*i*/
      ctx[7]
    )
  );
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      onClick: (
        /*handleOptionRemove*/
        ctx[2](
          /*i*/
          ctx[7]
        )
      )
    }
  });
  return {
    c() {
      span = element("span");
      create_component(textinput.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
      attr(span, "class", "svelte-9r99fn");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(textinput, span, null);
      append4(span, t3);
      mount_component(iconbutton, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*options*/
      1)
        textinput_changes.value = /*option*/
        ctx2[5];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(textinput);
      destroy_component(iconbutton);
    }
  };
}
function create_default_slot37(ctx) {
  let icon;
  let t3;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t3 = text("Add an option");
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment111(ctx) {
  let div;
  let t3;
  let button;
  let current;
  let each_value = (
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block21(get_each_context21(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot37] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*handleOptionAdd*/
    ctx[1]
  );
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(button.$$.fragment);
      attr(div, "class", "svelte-9r99fn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append4(div, t3);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*handleOptionRemove, options, handleOptionChange*/
      13) {
        each_value = /*options*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context21(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block21(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      destroy_component(button);
    }
  };
}
function instance111($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { onChange } = $$props;
  function handleOptionAdd() {
    onChange(immer_esm_default(options, (draft) => {
      draft.push("");
    }));
  }
  function handleOptionRemove(i2) {
    return () => {
      onChange(immer_esm_default(options, (draft) => {
        draft.splice(i2, 1);
      }));
    };
  }
  function handleOptionChange(i2) {
    return (event) => {
      if (event.currentTarget instanceof HTMLInputElement) {
        onChange(immer_esm_default(options, (draft) => {
          if (event.currentTarget instanceof HTMLInputElement) {
            draft.splice(i2, 1, event.currentTarget.value);
          }
        }));
      }
    };
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("onChange" in $$props2)
      $$invalidate(4, onChange = $$props2.onChange);
  };
  return [options, handleOptionAdd, handleOptionRemove, handleOptionChange, onChange];
}
var MultiTextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance111, create_fragment111, safe_not_equal, { options: 0, onChange: 4 }, add_css68);
  }
};
var MultiTextInput_default = MultiTextInput;

// src/modals/components/ConfigureField.svelte
function create_default_slot_74(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      readonly: !/*editable*/
      ctx[2],
      value: (
        /*field*/
        ctx[0].name
      )
    }
  });
  textinput.$on(
    "input",
    /*handleNameChange*/
    ctx[5]
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*editable*/
      4)
        textinput_changes.readonly = !/*editable*/
        ctx2[2];
      if (dirty & /*field*/
      1)
        textinput_changes.value = /*field*/
        ctx2[0].name;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_69(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      disabled: true,
      value: (
        /*field*/
        ctx[0].type
      ),
      options: (
        /*options*/
        ctx[4]
      )
    }
  });
  select.$on(
    "change",
    /*handleTypeChange*/
    ctx[6]
  );
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*field*/
      1)
        select_changes.value = /*field*/
        ctx2[0].type;
      if (dirty & /*options*/
      16)
        select_changes.options = /*options*/
        ctx2[4];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block40(ctx) {
  let settingitem0;
  let t3;
  let settingitem1;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Options",
      description: "Allows you to auto-complete using predefined values for the field.",
      vertical: true,
      $$slots: { default: [create_default_slot_511] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Enable rich text formatting",
      description: "For fields with Markdown content.",
      $$slots: { default: [create_default_slot_413] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem0_changes = {};
      if (dirty & /*$$scope, field*/
      1025) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, field*/
      1025) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_default_slot_511(ctx) {
  var _a, _b;
  let multitextinput;
  let current;
  multitextinput = new MultiTextInput_default({
    props: {
      options: (
        /*field*/
        (_b = (_a = ctx[0].typeConfig) == null ? void 0 : _a.options) != null ? _b : []
      ),
      onChange: (
        /*handleOptionsChange*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(multitextinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multitextinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const multitextinput_changes = {};
      if (dirty & /*field*/
      1)
        multitextinput_changes.options = /*field*/
        (_b2 = (_a2 = ctx2[0].typeConfig) == null ? void 0 : _a2.options) != null ? _b2 : [];
      multitextinput.$set(multitextinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multitextinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multitextinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multitextinput, detaching);
    }
  };
}
function create_default_slot_413(ctx) {
  var _a, _b;
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: (
        /*field*/
        (_b = (_a = ctx[0].typeConfig) == null ? void 0 : _a.richText) != null ? _b : false
      )
    }
  });
  switch_1.$on(
    "check",
    /*handleRichTextChange*/
    ctx[8]
  );
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const switch_1_changes = {};
      if (dirty & /*field*/
      1)
        switch_1_changes.checked = /*field*/
        (_b2 = (_a2 = ctx2[0].typeConfig) == null ? void 0 : _a2.richText) != null ? _b2 : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_default_slot_313(ctx) {
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let if_block_anchor;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Name",
      $$slots: { default: [create_default_slot_74] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Type",
      description: "Changing type isn't supported yet.",
      $$slots: { default: [create_default_slot_69] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*field*/
    ctx[0].type === "string" /* String */ && !/*field*/
    ctx[0].repeated && !/*field*/
    ctx[0].identifier && create_if_block40(ctx)
  );
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem0_changes = {};
      if (dirty & /*$$scope, editable, field*/
      1029) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & /*$$scope, field, options*/
      1041) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if (
        /*field*/
        ctx2[0].type === "string" /* String */ && !/*field*/
        ctx2[0].repeated && !/*field*/
        ctx2[0].identifier
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*field*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block40(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_217(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Save");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_130(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_217] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot38(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_313] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_130] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & /*$$scope, field, options, editable*/
      1045) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & /*$$scope, onSave, field*/
      1033) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment112(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: (
        /*title*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot38] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & /*title*/
      2)
        modallayout_changes.title = /*title*/
        ctx2[1];
      if (dirty & /*$$scope, onSave, field, options, editable*/
      1053) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance112($$self, $$props, $$invalidate) {
  let options;
  let { title } = $$props;
  let { field } = $$props;
  let { editable } = $$props;
  let { onSave } = $$props;
  function handleNameChange(value) {
    $$invalidate(0, field = Object.assign(Object.assign({}, field), { name: value.detail }));
  }
  function handleTypeChange(value) {
    $$invalidate(0, field = Object.assign(Object.assign({}, field), { type: value.detail }));
  }
  function handleOptionsChange(options2) {
    $$invalidate(0, field = Object.assign(Object.assign({}, field), {
      typeConfig: Object.assign(Object.assign({}, field.typeConfig), { options: options2 })
    }));
  }
  function handleRichTextChange({ detail: richText }) {
    $$invalidate(0, field = Object.assign(Object.assign({}, field), {
      typeConfig: Object.assign(Object.assign({}, field.typeConfig), { richText })
    }));
  }
  const click_handler = () => {
    onSave(field);
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("editable" in $$props2)
      $$invalidate(2, editable = $$props2.editable);
    if ("onSave" in $$props2)
      $$invalidate(3, onSave = $$props2.onSave);
  };
  $:
    $$invalidate(4, options = [
      {
        label: "Text",
        value: "string" /* String */
      },
      {
        label: "Number",
        value: "number" /* Number */
      },
      {
        label: "Checkbox",
        value: "boolean" /* Boolean */
      },
      { label: "Date", value: "date" /* Date */ },
      {
        label: "Unknown",
        value: "unknown" /* Unknown */
      }
    ]);
  return [
    field,
    title,
    editable,
    onSave,
    options,
    handleNameChange,
    handleTypeChange,
    handleOptionsChange,
    handleRichTextChange,
    click_handler
  ];
}
var ConfigureField = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance112, create_fragment112, safe_not_equal, {
      title: 1,
      field: 0,
      editable: 2,
      onSave: 3
    });
  }
};
var ConfigureField_default = ConfigureField;

// src/modals/configure-field.ts
var ConfigureFieldModal = class extends import_obsidian52.Modal {
  constructor(app3, title, field, editable, onSave) {
    super(app3);
    this.title = title;
    this.field = field;
    this.editable = editable;
    this.onSave = onSave;
  }
  onOpen() {
    this.component = new ConfigureField_default({
      target: this.contentEl,
      props: {
        title: this.title,
        field: this.field,
        editable: this.editable,
        onSave: (field) => {
          this.onSave(field);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/Table/helpers.ts
function sortFields(fields, order2) {
  if (!order2.length) {
    return fields;
  }
  const test = immer_esm_default(fields, (draft) => {
    draft.sort((left6, right6) => {
      if (!order2.includes(left6.name)) {
        return 1;
      }
      if (!order2.includes(right6.name)) {
        return -1;
      }
      return order2.indexOf(left6.name) - order2.indexOf(right6.name);
    });
  });
  return test;
}

// src/views/Table/TableView.svelte
function create_right_slot5(ctx) {
  let switchselect;
  let current;
  switchselect = new SwitchSelect_default({
    props: {
      label: (
        /*$i18n*/
        ctx[9].t("views.table.hide-fields")
      ),
      items: (
        /*columns*/
        ctx[8].map(func7)
      ),
      onChange: (
        /*handleVisibilityChange*/
        ctx[12]
      )
    }
  });
  return {
    c() {
      create_component(switchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switchselect_changes = {};
      if (dirty & /*$i18n*/
      512)
        switchselect_changes.label = /*$i18n*/
        ctx2[9].t("views.table.hide-fields");
      if (dirty & /*columns*/
      256)
        switchselect_changes.items = /*columns*/
        ctx2[8].map(func7);
      switchselect.$set(switchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switchselect, detaching);
    }
  };
}
function create_default_slot_218(ctx) {
  let viewtoolbar;
  let current;
  viewtoolbar = new ViewToolbar_default({
    props: {
      variant: "secondary",
      $$slots: { right: [create_right_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewtoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewtoolbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewtoolbar_changes = {};
      if (dirty & /*$$scope, $i18n, columns*/
      536871680) {
        viewtoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewtoolbar.$set(viewtoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewtoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewtoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewtoolbar, detaching);
    }
  };
}
function create_default_slot_131(ctx) {
  var _a, _b, _c;
  let datagrid;
  let current;
  datagrid = new DataGrid_default({
    props: {
      columns: (
        /*columns*/
        ctx[8]
      ),
      rows: (
        /*rows*/
        ctx[7]
      ),
      readonly: (
        /*readonly*/
        ctx[3]
      ),
      colorModel: (
        /*func_1*/
        ctx[19]
      ),
      onRowAdd: (
        /*func_2*/
        ctx[20]
      ),
      onRowEdit: (
        /*func_3*/
        ctx[21]
      ),
      onRowDelete: (
        /*func_4*/
        ctx[22]
      ),
      onColumnHide: (
        /*func_5*/
        ctx[23]
      ),
      onColumnConfigure: (
        /*func_6*/
        ctx[24]
      ),
      onColumnDelete: (
        /*func_7*/
        ctx[25]
      ),
      onRowChange: (
        /*func_8*/
        ctx[26]
      ),
      onColumnResize: (
        /*handleWidthChange*/
        ctx[13]
      ),
      sortModel: {
        field: (
          /*config*/
          (_b = (_a = ctx[0]) == null ? void 0 : _a.sortField) != null ? _b : "name"
        ),
        sort: (
          /*config*/
          ((_c = ctx[0]) == null ? void 0 : _c.sortAsc) ? "asc" : "desc"
        )
      },
      onSortModelChange: (
        /*func_9*/
        ctx[27]
      ),
      onColumnSort: (
        /*func_10*/
        ctx[28]
      )
    }
  });
  return {
    c() {
      create_component(datagrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(datagrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const datagrid_changes = {};
      if (dirty & /*columns*/
      256)
        datagrid_changes.columns = /*columns*/
        ctx2[8];
      if (dirty & /*rows*/
      128)
        datagrid_changes.rows = /*rows*/
        ctx2[7];
      if (dirty & /*readonly*/
      8)
        datagrid_changes.readonly = /*readonly*/
        ctx2[3];
      if (dirty & /*frame, getRecordColor*/
      36)
        datagrid_changes.colorModel = /*func_1*/
        ctx2[19];
      if (dirty & /*$app, project, api*/
      1042)
        datagrid_changes.onRowAdd = /*func_2*/
        ctx2[20];
      if (dirty & /*$app, fields, api*/
      1104)
        datagrid_changes.onRowEdit = /*func_3*/
        ctx2[21];
      if (dirty & /*api*/
      16)
        datagrid_changes.onRowDelete = /*func_4*/
        ctx2[22];
      if (dirty & /*fields, $app, api, project*/
      1106)
        datagrid_changes.onColumnConfigure = /*func_6*/
        ctx2[24];
      if (dirty & /*api*/
      16)
        datagrid_changes.onColumnDelete = /*func_7*/
        ctx2[25];
      if (dirty & /*api, fields*/
      80)
        datagrid_changes.onRowChange = /*func_8*/
        ctx2[26];
      if (dirty & /*config*/
      1)
        datagrid_changes.sortModel = {
          field: (
            /*config*/
            (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.sortField) != null ? _b2 : "name"
          ),
          sort: (
            /*config*/
            ((_c2 = ctx2[0]) == null ? void 0 : _c2.sortAsc) ? "asc" : "desc"
          )
        };
      if (dirty & /*config*/
      1)
        datagrid_changes.onSortModelChange = /*func_9*/
        ctx2[27];
      if (dirty & /*config*/
      1)
        datagrid_changes.onColumnSort = /*func_10*/
        ctx2[28];
      datagrid.$set(datagrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(datagrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(datagrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(datagrid, detaching);
    }
  };
}
function create_default_slot39(ctx) {
  let viewheader;
  let t3;
  let viewcontent;
  let current;
  viewheader = new ViewHeader_default({
    props: {
      $$slots: { default: [create_default_slot_218] },
      $$scope: { ctx }
    }
  });
  viewcontent = new ViewContent_default({
    props: {
      $$slots: { default: [create_default_slot_131] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewheader.$$.fragment);
      t3 = space();
      create_component(viewcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewheader, target, anchor);
      insert(target, t3, anchor);
      mount_component(viewcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewheader_changes = {};
      if (dirty & /*$$scope, $i18n, columns*/
      536871680) {
        viewheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewheader.$set(viewheader_changes);
      const viewcontent_changes = {};
      if (dirty & /*$$scope, columns, rows, readonly, frame, getRecordColor, $app, project, api, fields, config*/
      536872447) {
        viewcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewcontent.$set(viewcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewheader.$$.fragment, local);
      transition_in(viewcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewheader.$$.fragment, local);
      transition_out(viewcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewheader, detaching);
      if (detaching)
        detach(t3);
      destroy_component(viewcontent, detaching);
    }
  };
}
function create_fragment113(ctx) {
  let viewlayout;
  let current;
  viewlayout = new ViewLayout_default({
    props: {
      $$slots: { default: [create_default_slot39] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const viewlayout_changes = {};
      if (dirty & /*$$scope, columns, rows, readonly, frame, getRecordColor, $app, project, api, fields, config, $i18n*/
      536872959) {
        viewlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewlayout.$set(viewlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewlayout, detaching);
    }
  };
}
var func7 = (column) => ({
  label: column.field,
  value: column.field,
  enabled: !column.hide
});
function instance113($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let fieldConfig;
  let columns;
  let rows;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  component_subscribe($$self, app2, ($$value) => $$invalidate(10, $app = $$value));
  var _a, _b;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { getRecordColor } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function saveConfig(cfg) {
    $$invalidate(0, config = cfg);
    onConfigChange(cfg);
  }
  function handleVisibilityChange(field, enabled) {
    saveConfig(Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { hide: !enabled })
      })
    }));
  }
  function handleWidthChange(field, width) {
    saveConfig(Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { width })
      })
    }));
  }
  const func_15 = (rowId) => {
    const record = frame.records.find((record2) => record2.id === rowId);
    if (record) {
      return getRecordColor(record);
    }
    return null;
  };
  const func_2 = () => {
    new CreateNoteModal(
      $app,
      project,
      (name, templatePath, project2) => {
        api2.addRecord(createDataRecord(name, project2), templatePath);
      }
    ).open();
  };
  const func_3 = (id, values) => {
    new EditNoteModal(
      $app,
      fields,
      (record) => {
        api2.updateRecord(record, fields);
      },
      { id, values }
    ).open();
  };
  const func_4 = (id) => api2.deleteRecord(id);
  const func_5 = (column) => handleVisibilityChange(column.field, false);
  const func_6 = (column, editable) => {
    const field = fields.find((field2) => field2.name === column.field);
    if (field) {
      new ConfigureFieldModal(
        $app,
        "Configure field",
        field,
        editable,
        (field2) => {
          var _a2;
          if (editable) {
            if (field2.name !== column.field) {
              api2.updateField(field2, column.field);
            } else {
              api2.updateField(field2);
            }
          }
          const projectFields = Object.fromEntries(Object.entries((_a2 = project.fieldConfig) != null ? _a2 : {}).filter(([key, _24]) => fields.find((field3) => field3.name === key)));
          if (field2.typeConfig) {
            settings.updateProject(__spreadProps(__spreadValues({}, project), {
              fieldConfig: __spreadProps(__spreadValues({}, projectFields), {
                [field2.name]: field2.typeConfig
              })
            }));
          }
        }
      ).open();
    }
  };
  const func_7 = (field) => api2.deleteField(field);
  const func_8 = (rowId, row) => {
    api2.updateRecord({ id: rowId, values: row }, fields);
  };
  const func_9 = (field, sort4) => {
    saveConfig(__spreadProps(__spreadValues({}, config), {
      sortField: field,
      sortAsc: sort4 === "asc"
    }));
  };
  const func_10 = (fields2) => {
    saveConfig(__spreadProps(__spreadValues({}, config), { orderFields: fields2 }));
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(2, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(4, api2 = $$props2.api);
    if ("getRecordColor" in $$props2)
      $$invalidate(5, getRecordColor = $$props2.getRecordColor);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(14, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*frame*/
    4) {
      $:
        $$invalidate(6, { fields, records } = frame, fields, ($$invalidate(18, records), $$invalidate(2, frame)));
    }
    if ($$self.$$.dirty & /*fields, config, _a*/
    32833) {
      $: {
        $$invalidate(6, fields = sortFields(fields, $$invalidate(15, _a = config === null || config === void 0 ? void 0 : config.orderFields) !== null && _a !== void 0 ? _a : []));
      }
    }
    if ($$self.$$.dirty & /*config, _b*/
    65537) {
      $:
        $$invalidate(17, fieldConfig = $$invalidate(16, _b = config === null || config === void 0 ? void 0 : config.fieldConfig) !== null && _b !== void 0 ? _b : {});
    }
    if ($$self.$$.dirty & /*fields, fieldConfig*/
    131136) {
      $:
        $$invalidate(8, columns = fields.filter((field) => {
          if (field.repeated) {
            return field.type === "string" /* String */;
          }
          return true;
        }).map((field) => {
          var _a2, _b2, _c, _d;
          const colDef = Object.assign(Object.assign({}, field), {
            field: field.name,
            width: (_b2 = (_a2 = fieldConfig[field.name]) === null || _a2 === void 0 ? void 0 : _a2.width) !== null && _b2 !== void 0 ? _b2 : 180,
            hide: (_d = (_c = fieldConfig[field.name]) === null || _c === void 0 ? void 0 : _c.hide) !== null && _d !== void 0 ? _d : false,
            editable: !field.derived
          });
          return colDef;
        }));
    }
    if ($$self.$$.dirty & /*records*/
    262144) {
      $:
        $$invalidate(7, rows = records.map(({ id, values }) => ({ rowId: id, row: values })));
    }
  };
  return [
    config,
    project,
    frame,
    readonly,
    api2,
    getRecordColor,
    fields,
    rows,
    columns,
    $i18n,
    $app,
    saveConfig,
    handleVisibilityChange,
    handleWidthChange,
    onConfigChange,
    _a,
    _b,
    fieldConfig,
    records,
    func_15,
    func_2,
    func_3,
    func_4,
    func_5,
    func_6,
    func_7,
    func_8,
    func_9,
    func_10
  ];
}
var TableView = class extends SvelteComponent {
  constructor(options) {
    super();
    init4(this, options, instance113, create_fragment113, safe_not_equal, {
      project: 1,
      frame: 2,
      readonly: 3,
      api: 4,
      getRecordColor: 5,
      config: 0,
      onConfigChange: 14
    });
  }
};
var TableView_default = TableView;

// src/views/Table/table-view.ts
var TableView2 = class extends ProjectView {
  getViewType() {
    return "table";
  }
  getDisplayName() {
    return "Table";
  }
  getIcon() {
    return "table";
  }
  onData(_0) {
    return __async(this, arguments, function* ({ data }) {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$set({ frame: data });
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.view = new TableView_default({
        target: props.contentEl,
        props: {
          frame: { fields: [], records: [] },
          api: props.viewApi,
          project: props.project,
          readonly: props.readonly,
          config: props.config,
          onConfigChange: props.saveConfig,
          getRecordColor: props.getRecordColor
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/view.ts
var VIEW_TYPE_PROJECTS = "obsidian-projects";
var ProjectsView = class extends import_obsidian54.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.navigation = true;
  }
  getViewType() {
    return VIEW_TYPE_PROJECTS;
  }
  getDisplayText() {
    return "Projects";
  }
  getIcon() {
    return "layout";
  }
  onload() {
    return __async(this, null, function* () {
      view.set(this);
    });
  }
  setState(state, result) {
    return __async(this, null, function* () {
      if (this.component) {
        this.component.$set({
          projectId: state.projectId,
          viewId: state.viewId
        });
      }
      __superGet(ProjectsView.prototype, this, "setState").call(this, state, result);
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      const views = this.getViews();
      customViews.set(views);
      this.component = new App_default({
        target: this.contentEl
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      if (this.component) {
        this.component.$destroy();
      }
    });
  }
  getViews() {
    const views = {};
    this.getEnabledPlugins().forEach((plugin2) => {
      const registerView = plugin2.onRegisterProjectView;
      if (registerView) {
        const create = registerView.bind(plugin2);
        const instance114 = create();
        views[instance114.getViewType()] = instance114;
      }
    });
    views["table"] = new TableView2();
    views["board"] = new BoardView2();
    views["calendar"] = new CalendarView2();
    views["gallery"] = new GalleryView2();
    return views;
  }
  getEnabledPlugins() {
    const res = [];
    for (const pluginId in this.app.plugins.plugins) {
      const plugin2 = this.app.plugins.getPlugin(pluginId);
      if (plugin2) {
        res.push(plugin2);
      }
    }
    return res;
  }
};

// src/main.ts
import_dayjs9.default.extend(import_isoWeek.default);
import_dayjs9.default.extend(import_localizedFormat.default);
var PROJECTS_PLUGIN_ID = "obsidian-projects";
var ProjectsPlugin = class extends import_obsidian56.Plugin {
  /**
   * onload runs when the plugin is enabled.
   */
  onload() {
    return __async(this, null, function* () {
      const t3 = get_store_value(i18n).t;
      this.addSettingTab(new ProjectsSettingTab(this.app, this));
      this.registerView(
        VIEW_TYPE_PROJECTS,
        (leaf) => new ProjectsView(leaf, this)
      );
      this.registerEvent(
        this.app.workspace.on("file-menu", (menu, file) => {
          if (file instanceof import_obsidian56.TFolder) {
            menu.addItem((item) => {
              item.setTitle(t3("menus.project.create.title")).setIcon("folder-plus").onClick(() => __async(this, null, function* () {
                const project = createProject();
                new CreateProjectModal(
                  this.app,
                  t3("modals.project.create.title"),
                  t3("modals.project.create.cta"),
                  settings.addProject,
                  __spreadProps(__spreadValues({}, project), {
                    name: file.name,
                    dataSource: {
                      kind: "folder",
                      config: {
                        path: file.path,
                        recursive: false
                      }
                    }
                  })
                ).open();
              }));
            });
          }
        })
      );
      this.addCommand({
        id: "show-projects",
        name: t3("commands.show-projects.name"),
        callback: () => {
          this.activateView();
        }
      });
      this.addCommand({
        id: "create-project",
        name: t3("commands.create-project.name"),
        callback: () => {
          new CreateProjectModal(
            this.app,
            t3("modals.project.create.title"),
            t3("modals.project.create.cta"),
            settings.addProject,
            createProject()
          ).open();
        }
      });
      this.addCommand({
        id: "create-note",
        name: t3("commands.create-note.name"),
        // checkCallback because we don't want to create notes if there are no
        // projects.
        checkCallback: (checking) => {
          const project = get_store_value(settings).projects[0];
          if (project) {
            if (!checking) {
              new CreateNoteModal(
                this.app,
                project,
                (name, templatePath, project2) => __async(this, null, function* () {
                  const record = createDataRecord(name, project2);
                  yield get_store_value(api).createNote(record, templatePath);
                  const file = this.app.vault.getAbstractFileByPath(record.id);
                  if (file instanceof import_obsidian56.TFile) {
                    this.app.workspace.getLeaf(true).openFile(file);
                  }
                })
              ).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addRibbonIcon("layout", "Open projects", () => {
        this.activateView();
      });
      (0, import_obsidian56.addIcon)(
        "text",
        `<g transform="matrix(1,0,0,1,2,2)"><path d="M20,32L28,32L28,24L41.008,24L30.72,72L20,72L20,80L52,80L52,72L42.992,72L53.28,24L68,24L68,32L76,32L76,16L20,16L20,32Z" /></g>`
      );
      app2.set(this.app);
      plugin.set(this);
      yield this.loadSettings();
      this.unsubscribeSettings = settings.subscribe((value) => {
        this.ensureCommands(value.preferences.commands, value.projects);
        this.saveData(value);
      });
      const watcher = new ObsidianFileSystemWatcher(this);
      registerFileEvents(watcher);
    });
  }
  /**
   * onunload runs when the plugin is disabled. Use it to clean up any resources
   * you've allocated in the onload method.
   */
  onunload() {
    return __async(this, null, function* () {
      var _a;
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_PROJECTS);
      (_a = this.unsubscribeSettings) == null ? void 0 : _a.call(this);
    });
  }
  /**
   * loadSettings loads settings from disk, migrates it to the latest version,
   * and updates the Svelte store for settings.
   */
  loadSettings() {
    return __async(this, null, function* () {
      return (0, import_function14.pipe)(
        TaskEither_exports.tryCatch(() => this.loadData(), Either_exports.toError),
        TaskEither_exports.map(migrateSettings),
        TaskEither_exports.chain(TaskEither_exports.fromEither),
        Task_exports.map(
          Either_exports.fold(
            (err) => {
              throw err;
            },
            (value) => {
              settings.set(value);
            }
          )
        )
      )();
    });
  }
  /**
   * activateView opens the main Projects view in a new workspace leaf.
   * */
  activateView(projectId, viewId) {
    return __async(this, null, function* () {
      const leaf = yield this.getOrCreateLeaf();
      leaf.setViewState({
        type: VIEW_TYPE_PROJECTS,
        state: {
          projectId,
          viewId
        }
      });
      this.app.workspace.revealLeaf(leaf);
    });
  }
  /**
   * getOrCreateLeaf returns a new leaf, or returns an existing leaf if
   * Projects is already open.
   */
  getOrCreateLeaf() {
    return __async(this, null, function* () {
      const existingLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_PROJECTS);
      if (existingLeaves[0]) {
        return existingLeaves[0];
      }
      return this.app.workspace.getLeaf(true);
    });
  }
  /**
   * ensureCommands syncs enabled and registered show commands.
   */
  ensureCommands(enabledCommands, projects) {
    const registeredCommandIds = new Set(
      Object.keys(this.app.commands.commands).filter(
        (id) => id.startsWith(`${PROJECTS_PLUGIN_ID}:show:`)
      )
    );
    this.removeMissingCommands(enabledCommands, projects, registeredCommandIds);
    this.addMissingCommands(enabledCommands, projects, registeredCommandIds);
  }
  /**
   * removeMissingCommands cleans up registered show commands that have either
   * been disabled from the settings, or where the project or view has been
   * deleted.
   */
  removeMissingCommands(enabledCommands, projects, registeredCommandIds) {
    registeredCommandIds.forEach((id) => {
      const enabledCommand = enabledCommands.find(
        (command) => id === getShowCommandId(command, true)
      );
      if (!enabledCommand) {
        this.app.commands.removeCommand(id);
        return;
      }
      const project = projects.find((project2) => {
        if (enabledCommand.view) {
          return project2.id === enabledCommand.project && project2.views.find((view2) => view2.id === enabledCommand.view);
        } else {
          return project2.id === enabledCommand.project;
        }
      });
      if (!project) {
        this.app.commands.removeCommand(id);
      }
    });
  }
  /**
   * addMissingCommands registers show commands that have been enabled but not
   * registered.
   */
  addMissingCommands(enabledCommands, projects, registeredCommandIds) {
    enabledCommands.forEach((command) => {
      const globalId = getShowCommandId(command, true);
      const localId = getShowCommandId(command, false);
      if (registeredCommandIds.has(globalId)) {
        return;
      }
      const project = projects.find(
        (project2) => project2.id === command.project
      );
      if (project) {
        if (command.view) {
          const view2 = project == null ? void 0 : project.views.find((view3) => view3.id === command.view);
          if (view2) {
            this.addCommand({
              id: localId,
              name: `Show ${project.name} > ${view2.name}`,
              callback: () => {
                this.activateView(project.id, view2.id);
              }
            });
          }
        } else {
          this.addCommand({
            id: localId,
            name: `Show ${project.name}`,
            callback: () => {
              this.activateView(project.id);
            }
          });
        }
      }
    });
  }
};
function getShowCommandId(cmd, global2) {
  const res = [];
  if (global2) {
    res.push(PROJECTS_PLUGIN_ID);
  }
  res.push("show");
  if (cmd.project) {
    res.push(cmd.project);
  }
  if (cmd.view) {
    res.push(cmd.view);
  }
  return res.join(":");
}
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
